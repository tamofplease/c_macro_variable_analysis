<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f103ve/libraries/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_adc.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f1xx_hal_adc.c
  * @author  MCD Application Team
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Analog to Digital Convertor (ADC)
  *          peripheral:
  *           + Initialization and de-initialization functions
  *             ++ Initialization and Configuration of ADC
  *           + Operation functions
  *             ++ Start, stop, get result of conversions of regular
  *                group, using 3 possible modes: polling, interruption or DMA.
  *           + Control functions
  *             ++ Channels configuration on regular group
  *             ++ Channels configuration on injected group
  *             ++ Analog Watchdog configuration
  *           + State functions
  *             ++ ADC state machine management
  *             ++ Interrupts and flags management
  *          Other functions (extended functions) are available in file 
  *          "stm32f1xx_hal_adc_ex.c".
  *
  @verbatim
  ==============================================================================
                     ##### ADC peripheral features #####
  ==============================================================================
  [..]
  (+) 12-bit resolution

  (+) Interrupt generation at the end of regular conversion, end of injected
      conversion, and in case of analog watchdog or overrun events.
  
  (+) Single and continuous conversion modes.
  
  (+) Scan mode for conversion of several channels sequentially.
  
  (+) Data alignment with in-built data coherency.
  
  (+) Programmable sampling time (channel wise)
  
  (+) ADC conversion of regular group and injected group.

  (+) External trigger (timer or EXTI) 
      for both regular and injected groups.

  (+) DMA request generation for transfer of conversions data of regular group.

  (+) Multimode Dual mode (available on devices with 2 ADCs or more).
  
  (+) Configurable DMA data storage in Multimode Dual mode (available on devices
      with 2 DCs or more).
  
  (+) Configurable delay between conversions in Dual interleaved mode (available 
      on devices with 2 DCs or more).
  
  (+) ADC calibration

  (+) ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at 
      slower speed.
  
  (+) ADC input range: from Vref- (connected to Vssa) to Vref+ (connected to 
      Vdda or to an external voltage reference).


                     ##### How to use this driver #####
  ==============================================================================
    [..]

     *** Configuration of top level parameters related to ADC ***
     ============================================================
     [..]

    (#) Enable the ADC interface
      (++) As prerequisite, ADC clock must be configured at RCC top level.
           Caution: On STM32F1, ADC clock frequency max is 14MHz (refer
                    to device datasheet).
                    Therefore, ADC clock prescaler must be configured in 
                    function of ADC clock source frequency to remain below
                    this maximum frequency.
        (++) One clock setting is mandatory:
             ADC clock (core clock, also possibly conversion clock).
             (+++) Example:
                   Into HAL_ADC_MspInit() (recommended code location) or with
                   other device clock parameters configuration:
               (+++) RCC_PeriphCLKInitTypeDef  PeriphClkInit;
               (+++) __ADC1_CLK_ENABLE();
               (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
               (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
               (+++) HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit);

    (#) ADC pins configuration
         (++) Enable the clock for the ADC GPIOs
              using macro __HAL_RCC_GPIOx_CLK_ENABLE()
         (++) Configure these ADC pins in analog mode
              using function HAL_GPIO_Init()

    (#) Optionally, in case of usage of ADC with interruptions:
         (++) Configure the NVIC for ADC
              using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
         (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
              into the function of corresponding ADC interruption vector 
              ADCx_IRQHandler().

    (#) Optionally, in case of usage of DMA:
         (++) Configure the DMA (DMA channel, mode normal or circular, ...)
              using function HAL_DMA_Init().
         (++) Configure the NVIC for DMA
              using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
         (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
              into the function of corresponding DMA interruption vector 
              DMAx_Channelx_IRQHandler().

     *** Configuration of ADC, groups regular/injected, channels parameters ***
     ==========================================================================
     [..]

    (#) Configure the ADC parameters (resolution, data alignment, ...)
        and regular group parameters (conversion trigger, sequencer, ...)
        using function HAL_ADC_Init().

    (#) Configure the channels for regular group parameters (channel number, 
        channel rank into sequencer, ..., into regular group)
        using function HAL_ADC_ConfigChannel().

    (#) Optionally, configure the injected group parameters (conversion trigger, 
        sequencer, ..., of injected group)
        and the channels for injected group parameters (channel number, 
        channel rank into sequencer, ..., into injected group)
        using function HAL_ADCEx_InjectedConfigChannel().

    (#) Optionally, configure the analog watchdog parameters (channels
        monitored, thresholds, ...)
        using function HAL_ADC_AnalogWDGConfig().

    (#) Optionally, for devices with several ADC instances: configure the 
        multimode parameters
        using function HAL_ADCEx_MultiModeConfigChannel().

     *** Execution of ADC conversions ***
     ====================================
     [..]

    (#) Optionally, perform an automatic ADC calibration to improve the
        conversion accuracy
        using function HAL_ADCEx_Calibration_Start().

    (#) ADC driver can be used among three modes: polling, interruption,
        transfer by DMA.

        (++) ADC conversion by polling:
          (+++) Activate the ADC peripheral and start conversions
                using function HAL_ADC_Start()
          (+++) Wait for ADC conversion completion 
                using function HAL_ADC_PollForConversion()
                (or for injected group: HAL_ADCEx_InjectedPollForConversion() )
          (+++) Retrieve conversion results 
                using function HAL_ADC_GetValue()
                (or for injected group: HAL_ADCEx_InjectedGetValue() )
          (+++) Stop conversion and disable the ADC peripheral 
                using function HAL_ADC_Stop()

        (++) ADC conversion by interruption: 
          (+++) Activate the ADC peripheral and start conversions
                using function HAL_ADC_Start_IT()
          (+++) Wait for ADC conversion completion by call of function
                HAL_ADC_ConvCpltCallback()
                (this function must be implemented in user program)
                (or for injected group: HAL_ADCEx_InjectedConvCpltCallback() )
          (+++) Retrieve conversion results 
                using function HAL_ADC_GetValue()
                (or for injected group: HAL_ADCEx_InjectedGetValue() )
          (+++) Stop conversion and disable the ADC peripheral 
                using function HAL_ADC_Stop_IT()

        (++) ADC conversion with transfer by DMA:
          (+++) Activate the ADC peripheral and start conversions
                using function HAL_ADC_Start_DMA()
          (+++) Wait for ADC conversion completion by call of function
                HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
                (these functions must be implemented in user program)
          (+++) Conversion results are automatically transferred by DMA into
                destination variable address.
          (+++) Stop conversion and disable the ADC peripheral 
                using function HAL_ADC_Stop_DMA()

        (++) For devices with several ADCs: ADC multimode conversion 
             with transfer by DMA:
          (+++) Activate the ADC peripheral (slave) and start conversions
                using function HAL_ADC_Start()
          (+++) Activate the ADC peripheral (master) and start conversions
                using function HAL_ADCEx_MultiModeStart_DMA()
          (+++) Wait for ADC conversion completion by call of function
                HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
                (these functions must be implemented in user program)
          (+++) Conversion results are automatically transferred by DMA into
                destination variable address.
          (+++) Stop conversion and disable the ADC peripheral (master)
                using function HAL_ADCEx_MultiModeStop_DMA()
          (+++) Stop conversion and disable the ADC peripheral (slave)
                using function HAL_ADC_Stop_IT()

     [..]

    (@) Callback functions must be implemented in user program:
      (+@) HAL_ADC_ErrorCallback()
      (+@) HAL_ADC_LevelOutOfWindowCallback() (callback of analog watchdog)
      (+@) HAL_ADC_ConvCpltCallback()
      (+@) HAL_ADC_ConvHalfCpltCallback
      (+@) HAL_ADCEx_InjectedConvCpltCallback()

     *** Deinitialization of ADC ***
     ============================================================
     [..]

    (#) Disable the ADC interface
      (++) ADC clock can be hard reset and disabled at RCC top level.
        (++) Hard reset of ADC peripherals
             using macro __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET().
        (++) ADC clock disable
             using the equivalent macro/functions as configuration step.
             (+++) Example:
                   Into HAL_ADC_MspDeInit() (recommended code location) or with
                   other device clock parameters configuration:
               (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC
               (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPLLCLK2_OFF
               (+++) HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit)

    (#) ADC pins configuration
         (++) Disable the clock for the ADC GPIOs
              using macro __HAL_RCC_GPIOx_CLK_DISABLE()

    (#) Optionally, in case of usage of ADC with interruptions:
         (++) Disable the NVIC for ADC
              using function HAL_NVIC_EnableIRQ(ADCx_IRQn)

    (#) Optionally, in case of usage of DMA:
         (++) Deinitialize the DMA
              using function HAL_DMA_Init().
         (++) Disable the NVIC for DMA
              using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)

    [..]
    
    *** Callback registration ***
    =============================================
    [..]

     The compilation flag USE_HAL_ADC_REGISTER_CALLBACKS, when set to 1,
     allows the user to configure dynamically the driver callbacks.
     Use Functions @ref HAL_ADC_RegisterCallback()
     to register an interrupt callback.
    [..]

     Function @ref HAL_ADC_RegisterCallback() allows to register following callbacks:
       (+) ConvCpltCallback               : ADC conversion complete callback
       (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
       (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
       (+) ErrorCallback                  : ADC error callback
       (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
       (+) MspInitCallback                : ADC Msp Init callback
       (+) MspDeInitCallback              : ADC Msp DeInit callback
     This function takes as parameters the HAL peripheral handle, the Callback ID
     and a pointer to the user callback function.
    [..]

     Use function @ref HAL_ADC_UnRegisterCallback to reset a callback to the default
     weak function.
    [..]

     @ref HAL_ADC_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) ConvCpltCallback               : ADC conversion complete callback
       (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
       (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
       (+) ErrorCallback                  : ADC error callback
       (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
       (+) MspInitCallback                : ADC Msp Init callback
       (+) MspDeInitCallback              : ADC Msp DeInit callback
     [..]

     By default, after the @ref HAL_ADC_Init() and when the state is @ref HAL_ADC_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_ADC_ConvCpltCallback(), @ref HAL_ADC_ErrorCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit() only when
     these callbacks are null (not registered beforehand).
    [..]

     If MspInit or MspDeInit are not null, the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
     [..]

     Callbacks can be registered/unregistered in @ref HAL_ADC_STATE_READY state only.
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_ADC_STATE_READY or @ref HAL_ADC_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    [..]

     Then, the user first registers the MspInit/MspDeInit user callbacks
     using @ref HAL_ADC_RegisterCallback() before calling @ref HAL_ADC_DeInit()
     or @ref HAL_ADC_Init() function.
     [..]

     When the compilation flag USE_HAL_ADC_REGISTER_CALLBACKS is set to 0 or
     not defined, the callback registration feature is not available and all callbacks
     are set to the corresponding weak functions.
  
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f1xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F1xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADC ADC
  * @brief ADC HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_ADC_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup ADC_Private_Constants ADC Private Constants
  * @{
  */</comment>

  <comment type="block">/* Timeout values for ADC enable and disable settling time.                 */</comment>
  <comment type="block">/* Values defined to be higher than worst cases: low clocks freq,           */</comment>
  <comment type="block">/* maximum prescaler.                                                       */</comment>
  <comment type="block">/* Ex of profile low frequency : Clock source at 0.1 MHz, ADC clock         */</comment>
  <comment type="block">/* prescaler 4, sampling time 12.5 ADC clock cycles, resolution 12 bits.    */</comment>
  <comment type="block">/* Unit: ms                                                                 */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADC_ENABLE_TIMEOUT</name></cpp:macro>              <cpp:value>2U</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADC_DISABLE_TIMEOUT</name></cpp:macro>             <cpp:value>2U</cpp:value></cpp:define>

  <comment type="block">/* Delay for ADC stabilization time.                                        */</comment>
  <comment type="block">/* Maximum delay is 1us (refer to device datasheet, parameter tSTAB).       */</comment>
  <comment type="block">/* Unit: us                                                                 */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADC_STAB_DELAY_US</name></cpp:macro>               <cpp:value>1U</cpp:value></cpp:define>

  <comment type="block">/* Delay for temperature sensor stabilization time.                         */</comment>
  <comment type="block">/* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */</comment>
  <comment type="block">/* Unit: us                                                                 */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADC_TEMPSENSOR_DELAY_US</name></cpp:macro>         <cpp:value>10U</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup ADC_Private_Functions ADC Private Functions
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup ADC_Exported_Functions ADC Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADC_Exported_Functions_Group1 Initialization/de-initialization functions 
  * @brief    Initialization and Configuration functions
  *
@verbatim    
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the ADC. 
      (+) De-initialize the ADC.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the ADC peripheral and regular group according to  
  *         parameters specified in structure "ADC_InitTypeDef".
  * @note   As prerequisite, ADC clock must be configured at RCC top level
  *         (clock source APB2).
  *         See commented example code below that can be copied and uncommented 
  *         into HAL_ADC_MspInit().
  * @note   Possibility to update parameters on the fly:
  *         This function initializes the ADC MSP (HAL_ADC_MspInit()) only when
  *         coming from ADC state reset. Following calls to this function can
  *         be used to reconfigure some parameters of ADC_InitTypeDef  
  *         structure on the fly, without modifying MSP configuration. If ADC  
  *         MSP has to be modified again, HAL_ADC_DeInit() must be called
  *         before HAL_ADC_Init().
  *         The setting of these parameters is conditioned to ADC state.
  *         For parameters constraints, see comments of structure 
  *         "ADC_InitTypeDef".
  * @note   This function configures the ADC within 2 scopes: scope of entire 
  *         ADC and scope of regular group. For parameters details, see comments 
  *         of structure "ADC_InitTypeDef".
  * @param  hadc: ADC handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_Init</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_cr1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_cr2</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_sqr1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check ADC handle */</comment>
  <if_stmt><if>if<condition>(<expr><name>hadc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_DATA_ALIGN</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataAlign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_SCAN_MODE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ScanConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_EXTTRIG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ExternalTrigConv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ScanConvMode</name></name> <operator>!=</operator> <name>ADC_SCAN_DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_REGULAR_NB_CONV</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NbrOfConversion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DiscontinuousConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DiscontinuousConvMode</name></name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_REGULAR_DISCONT_NUMBER</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NbrOfDiscConversion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */</comment>
  <comment type="block">/* at RCC top level.                                                        */</comment>
  <comment type="block">/* Refer to header of this file for more details on clock enabling          */</comment>
  <comment type="block">/* procedure.                                                               */</comment>

  <comment type="block">/* Actions performed only if ADC is coming from state reset:                */</comment>
  <comment type="block">/* - Initialization of ADC MSP                                              */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ADC_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Initialize ADC error code */</comment>
    <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Init the ADC Callback settings */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ConvCpltCallback</name></name>              <operator>=</operator> <name>HAL_ADC_ConvCpltCallback</name></expr>;</expr_stmt>                 <comment type="block">/* Legacy weak callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ConvHalfCpltCallback</name></name>          <operator>=</operator> <name>HAL_ADC_ConvHalfCpltCallback</name></expr>;</expr_stmt>             <comment type="block">/* Legacy weak callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>LevelOutOfWindowCallback</name></name>      <operator>=</operator> <name>HAL_ADC_LevelOutOfWindowCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCallback</name></name>                 <operator>=</operator> <name>HAL_ADC_ErrorCallback</name></expr>;</expr_stmt>                    <comment type="block">/* Legacy weak callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>InjectedConvCpltCallback</name></name>      <operator>=</operator> <name>HAL_ADCEx_InjectedConvCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak callback */</comment>
    
    <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_ADC_MspInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspInit  */</comment>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name>HAL_ADC_MspInit</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
  <comment type="block">/* Disable ADC peripheral */</comment>
  <comment type="block">/* Note: In case of ADC already enabled, precaution to not launch an        */</comment>
  <comment type="block">/*       unwanted conversion while modifying register CR2 by writing 1 to   */</comment>
  <comment type="block">/*       bit ADON.                                                          */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  
  <comment type="block">/* Configuration of ADC parameters if previous preliminary actions are      */</comment> 
  <comment type="block">/* correctly completed.                                                     */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>(</operator><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name><operator>)</operator></expr>                                  )</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set ADC parameters */</comment>
    
    <comment type="block">/* Configuration of ADC:                                                  */</comment>
    <comment type="block">/*  - data alignment                                                      */</comment>
    <comment type="block">/*  - external trigger to start conversion                                */</comment>
    <comment type="block">/*  - external trigger polarity (always set to 1, because needed for all  */</comment>
    <comment type="block">/*    triggers: external trigger of SW start)                             */</comment>
    <comment type="block">/*  - continuous conversion mode                                          */</comment>
    <comment type="block">/* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */</comment>
    <comment type="block">/*       HAL_ADC_Start_xxx functions because if set in this function,     */</comment>
    <comment type="block">/*       a conversion on injected group would start a conversion also on  */</comment>
    <comment type="block">/*       regular group after ADC enabling.                                */</comment>
    <expr_stmt><expr><name>tmp_cr2</name> <operator>|=</operator> <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataAlign</name></name>                                          <operator>|</operator>
                <call><name>ADC_CFGR_EXTSEL</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ExternalTrigConv</name></name></expr></argument>)</argument_list></call>            <operator>|</operator>
                <call><name>ADC_CR2_CONTINUOUS</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name></expr></argument>)</argument_list></call>   <operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Configuration of ADC:                                                  */</comment>
    <comment type="block">/*  - scan mode                                                           */</comment>
    <comment type="block">/*  - discontinuous mode disable/enable                                   */</comment>
    <comment type="block">/*  - discontinuous mode number of conversions                            */</comment>
    <expr_stmt><expr><name>tmp_cr1</name> <operator>|=</operator> <operator>(</operator><call><name>ADC_CR1_SCAN_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ScanConvMode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Enable discontinuous mode only if continuous mode is disabled */</comment>
    <comment type="block">/* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */</comment>
    <comment type="block">/*       discontinuous is set anyway, but will have no effect on ADC HW.  */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DiscontinuousConvMode</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable the selected ADC regular discontinuous mode */</comment>
        <comment type="block">/* Set the number of channels to be converted in discontinuous mode */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>tmp_cr1</name></expr></argument>, <argument><expr><name>ADC_CR1_DISCEN</name>                                            <operator>|</operator>
                         <call><name>ADC_CR1_DISCONTINUOUS_NUM</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NbrOfDiscConversion</name></name></expr></argument>)</argument_list></call></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* ADC regular group settings continuous and sequencer discontinuous*/</comment>
        <comment type="block">/* cannot be enabled simultaneously.                                */</comment>
        
        <comment type="block">/* Update ADC state machine to error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Set ADC error code to ADC IP internal error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_ADC_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Update ADC configuration register CR1 with previous settings */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>,
                 <argument><expr><name>ADC_CR1_SCAN</name>    <operator>|</operator>
                 <name>ADC_CR1_DISCEN</name>  <operator>|</operator>
                 <name>ADC_CR1_DISCNUM</name></expr></argument>    ,
                 <argument><expr><name>tmp_cr1</name></expr></argument>             )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Update ADC configuration register CR2 with previous settings */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>,
                 <argument><expr><name>ADC_CR2_ALIGN</name>   <operator>|</operator>
                 <name>ADC_CR2_EXTSEL</name>  <operator>|</operator>
                 <name>ADC_CR2_EXTTRIG</name> <operator>|</operator>
                 <name>ADC_CR2_CONT</name></expr></argument>       ,
                 <argument><expr><name>tmp_cr2</name></expr></argument>             )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Configuration of regular group sequencer:                              */</comment>
    <comment type="block">/* - if scan mode is disabled, regular channels sequence length is set to */</comment>
    <comment type="block">/*   0x00: 1 channel converted (channel on regular rank 1)                */</comment>
    <comment type="block">/*   Parameter "NbrOfConversion" is discarded.                            */</comment>
    <comment type="block">/*   Note: Scan mode is present by hardware on this device and, if        */</comment>
    <comment type="block">/*   disabled, discards automatically nb of conversions. Anyway, nb of    */</comment>
    <comment type="block">/*   conversions is forced to 0x00 for alignment over all STM32 devices.  */</comment>
    <comment type="block">/* - if scan mode is enabled, regular channels sequence length is set to  */</comment>
    <comment type="block">/*   parameter "NbrOfConversion"                                          */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_CR1_SCAN_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ScanConvMode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ADC_SCAN_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>tmp_sqr1</name> <operator>=</operator> <call><name>ADC_SQR1_L_SHIFT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NbrOfConversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
      
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR1</name></name></expr></argument>,
               <argument><expr><name>ADC_SQR1_L</name></expr></argument>          ,
               <argument><expr><name>tmp_sqr1</name></expr></argument>             )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check back that ADC registers have effectively been configured to      */</comment>
    <comment type="block">/* ensure of no potential problem of ADC core IP clocking.                */</comment>
    <comment type="block">/* Check through register CR2 (excluding bits set in other functions:     */</comment>
    <comment type="block">/* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */</comment>
    <comment type="block">/* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */</comment>
    <comment type="block">/* measurement path bit (TSVREFE).                                        */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>ADC_CR2_ADON</name> <operator>|</operator> <name>ADC_CR2_DMA</name> <operator>|</operator>
                                        <name>ADC_CR2_SWSTART</name> <operator>|</operator> <name>ADC_CR2_JSWSTART</name> <operator>|</operator>
                                        <name>ADC_CR2_JEXTTRIG</name> <operator>|</operator> <name>ADC_CR2_JEXTSEL</name> <operator>|</operator>
                                        <name>ADC_CR2_TSVREFE</name>                     <operator>)</operator></expr></argument>)</argument_list></call>
         <operator>==</operator> <name>tmp_cr2</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC error code to none */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set the ADC state */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update ADC state machine to error */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set ADC error code to ADC IP internal error */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_ADC_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Deinitialize the ADC peripheral registers to their default reset
  *         values, with deinitialization of the ADC MSP.
  *         If needed, the example code can be copied and uncommented into
  *         function HAL_ADC_MspDeInit().
  * @param  hadc: ADC handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_DeInit</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check ADC handle */</comment>
  <if_stmt><if>if<condition>(<expr><name>hadc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set ADC state */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
  <comment type="block">/* Disable ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  
  <comment type="block">/* Configuration of ADC parameters if previous preliminary actions are      */</comment> 
  <comment type="block">/* correctly completed.                                                     */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* ========== Reset ADC registers ========== */</comment>




    <comment type="block">/* Reset register SR */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_FLAG_AWD</name> <operator>|</operator> <name>ADC_FLAG_JEOC</name> <operator>|</operator> <name>ADC_FLAG_EOC</name> <operator>|</operator>
                                <name>ADC_FLAG_JSTRT</name> <operator>|</operator> <name>ADC_FLAG_STRT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         
    <comment type="block">/* Reset register CR1 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR1_AWDEN</name>   <operator>|</operator> <name>ADC_CR1_JAWDEN</name> <operator>|</operator> <name>ADC_CR1_DISCNUM</name> <operator>|</operator> 
                                    <name>ADC_CR1_JDISCEN</name> <operator>|</operator> <name>ADC_CR1_DISCEN</name> <operator>|</operator> <name>ADC_CR1_JAUTO</name>   <operator>|</operator> 
                                    <name>ADC_CR1_AWDSGL</name>  <operator>|</operator> <name>ADC_CR1_SCAN</name>   <operator>|</operator> <name>ADC_CR1_JEOCIE</name>  <operator>|</operator>   
                                    <name>ADC_CR1_AWDIE</name>   <operator>|</operator> <name>ADC_CR1_EOCIE</name>  <operator>|</operator> <name>ADC_CR1_AWDCH</name>    <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register CR2 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR2_TSVREFE</name> <operator>|</operator> <name>ADC_CR2_SWSTART</name> <operator>|</operator> <name>ADC_CR2_JSWSTART</name> <operator>|</operator> 
                                    <name>ADC_CR2_EXTTRIG</name> <operator>|</operator> <name>ADC_CR2_EXTSEL</name>  <operator>|</operator> <name>ADC_CR2_JEXTTRIG</name> <operator>|</operator>  
                                    <name>ADC_CR2_JEXTSEL</name> <operator>|</operator> <name>ADC_CR2_ALIGN</name>   <operator>|</operator> <name>ADC_CR2_DMA</name>      <operator>|</operator>        
                                    <name>ADC_CR2_RSTCAL</name>  <operator>|</operator> <name>ADC_CR2_CAL</name>     <operator>|</operator> <name>ADC_CR2_CONT</name>     <operator>|</operator>          
                                    <name>ADC_CR2_ADON</name>                                          <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register SMPR1 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_SMPR1_SMP17</name> <operator>|</operator> <name>ADC_SMPR1_SMP16</name> <operator>|</operator> <name>ADC_SMPR1_SMP15</name> <operator>|</operator> 
                                      <name>ADC_SMPR1_SMP14</name> <operator>|</operator> <name>ADC_SMPR1_SMP13</name> <operator>|</operator> <name>ADC_SMPR1_SMP12</name> <operator>|</operator> 
                                      <name>ADC_SMPR1_SMP11</name> <operator>|</operator> <name>ADC_SMPR1_SMP10</name>                    <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register SMPR2 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_SMPR2_SMP9</name> <operator>|</operator> <name>ADC_SMPR2_SMP8</name> <operator>|</operator> <name>ADC_SMPR2_SMP7</name> <operator>|</operator> 
                                      <name>ADC_SMPR2_SMP6</name> <operator>|</operator> <name>ADC_SMPR2_SMP5</name> <operator>|</operator> <name>ADC_SMPR2_SMP4</name> <operator>|</operator> 
                                      <name>ADC_SMPR2_SMP3</name> <operator>|</operator> <name>ADC_SMPR2_SMP2</name> <operator>|</operator> <name>ADC_SMPR2_SMP1</name> <operator>|</operator> 
                                      <name>ADC_SMPR2_SMP0</name>                                    <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset register JOFR1 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR1</name></name></expr></argument>, <argument><expr><name>ADC_JOFR1_JOFFSET1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Reset register JOFR2 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR2</name></name></expr></argument>, <argument><expr><name>ADC_JOFR2_JOFFSET2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Reset register JOFR3 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR3</name></name></expr></argument>, <argument><expr><name>ADC_JOFR3_JOFFSET3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Reset register JOFR4 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR4</name></name></expr></argument>, <argument><expr><name>ADC_JOFR4_JOFFSET4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register HTR */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>HTR</name></name></expr></argument>, <argument><expr><name>ADC_HTR_HT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Reset register LTR */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LTR</name></name></expr></argument>, <argument><expr><name>ADC_LTR_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register SQR1 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR1</name></name></expr></argument>, <argument><expr><name>ADC_SQR1_L</name>    <operator>|</operator>
                                    <name>ADC_SQR1_SQ16</name> <operator>|</operator> <name>ADC_SQR1_SQ15</name> <operator>|</operator> 
                                    <name>ADC_SQR1_SQ14</name> <operator>|</operator> <name>ADC_SQR1_SQ13</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register SQR1 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR1</name></name></expr></argument>, <argument><expr><name>ADC_SQR1_L</name>    <operator>|</operator>
                                    <name>ADC_SQR1_SQ16</name> <operator>|</operator> <name>ADC_SQR1_SQ15</name> <operator>|</operator> 
                                    <name>ADC_SQR1_SQ14</name> <operator>|</operator> <name>ADC_SQR1_SQ13</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register SQR2 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR2</name></name></expr></argument>, <argument><expr><name>ADC_SQR2_SQ12</name> <operator>|</operator> <name>ADC_SQR2_SQ11</name> <operator>|</operator> <name>ADC_SQR2_SQ10</name> <operator>|</operator> 
                                    <name>ADC_SQR2_SQ9</name>  <operator>|</operator> <name>ADC_SQR2_SQ8</name>  <operator>|</operator> <name>ADC_SQR2_SQ7</name></expr></argument>   )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register SQR3 */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR3</name></name></expr></argument>, <argument><expr><name>ADC_SQR3_SQ6</name> <operator>|</operator> <name>ADC_SQR3_SQ5</name> <operator>|</operator> <name>ADC_SQR3_SQ4</name> <operator>|</operator> 
                                    <name>ADC_SQR3_SQ3</name> <operator>|</operator> <name>ADC_SQR3_SQ2</name> <operator>|</operator> <name>ADC_SQR3_SQ1</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register JSQR */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name></expr></argument>, <argument><expr><name>ADC_JSQR_JL</name> <operator>|</operator>
                                    <name>ADC_JSQR_JSQ4</name> <operator>|</operator> <name>ADC_JSQR_JSQ3</name> <operator>|</operator> 
                                    <name>ADC_JSQR_JSQ2</name> <operator>|</operator> <name>ADC_JSQR_JSQ1</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register JSQR */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name></expr></argument>, <argument><expr><name>ADC_JSQR_JL</name> <operator>|</operator>
                                    <name>ADC_JSQR_JSQ4</name> <operator>|</operator> <name>ADC_JSQR_JSQ3</name> <operator>|</operator> 
                                    <name>ADC_JSQR_JSQ2</name> <operator>|</operator> <name>ADC_JSQR_JSQ1</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset register DR */</comment>
    <comment type="block">/* bits in access mode read only, no direct reset applicable*/</comment>
    
    <comment type="block">/* Reset registers JDR1, JDR2, JDR3, JDR4 */</comment>
    <comment type="block">/* bits in access mode read only, no direct reset applicable*/</comment>
    
    <comment type="block">/* ========== Hard reset ADC peripheral ========== */</comment>
    <comment type="block">/* Performs a global reset of the entire ADC peripheral: ADC state is     */</comment>
    <comment type="block">/* forced to a similar state after device power-on.                       */</comment>
    <comment type="block">/* If needed, copy-paste and uncomment the following reset code into      */</comment>
    <comment type="block">/* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */</comment>
    <comment type="block">/*                                                                        */</comment>
    <comment type="block">/*  __HAL_RCC_ADC1_FORCE_RESET()                                          */</comment>
    <comment type="block">/*  __HAL_RCC_ADC1_RELEASE_RESET()                                        */</comment>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_ADC_MspDeInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspDeInit  */</comment>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* DeInit the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* DeInit the low level hardware */</comment>
    <expr_stmt><expr><call><name>HAL_ADC_MspDeInit</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
    
    <comment type="block">/* Set ADC error code to none */</comment>
    <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ADC_STATE_RESET</name></expr>;</expr_stmt> 
  
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the ADC MSP.
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADC_MspInit</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_MspInit must be implemented in the user file.
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the ADC MSP.
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADC_MspDeInit</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_MspDeInit must be implemented in the user file.
   */</comment> 
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User ADC Callback
  *         To be used instead of the weak predefined callback
  * @param  hadc Pointer to a ADC_HandleTypeDef structure that contains
  *                the configuration information for the specified ADC.
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_ADC_CONVERSION_COMPLETE_CB_ID      ADC conversion complete callback ID
  *          @arg @ref HAL_ADC_CONVERSION_HALF_CB_ID          ADC conversion complete callback ID
  *          @arg @ref HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID    ADC analog watchdog 1 callback ID
  *          @arg @ref HAL_ADC_ERROR_CB_ID                    ADC error callback ID
  *          @arg @ref HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID  ADC group injected conversion complete callback ID
  *          @arg @ref HAL_ADC_MSPINIT_CB_ID                  ADC Msp Init callback ID
  *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID                ADC Msp DeInit callback ID
  *          @arg @ref HAL_ADC_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name> <modifier>*</modifier></type><name>hadc</name></decl></parameter>, <parameter><decl><type><name>HAL_ADC_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pADC_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <name>HAL_ADC_STATE_READY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_ADC_CONVERSION_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ConvCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_CONVERSION_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ConvHalfCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>LevelOutOfWindowCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>InjectedConvCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_ADC_STATE_RESET</name> <operator>==</operator> <name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_ADC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
      
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a ADC Callback
  *         ADC callback is redirected to the weak predefined callback
  * @param  hadc Pointer to a ADC_HandleTypeDef structure that contains
  *                the configuration information for the specified ADC.
  * @param  CallbackID ID of the callback to be unregistered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_ADC_CONVERSION_COMPLETE_CB_ID      ADC conversion complete callback ID
  *          @arg @ref HAL_ADC_CONVERSION_HALF_CB_ID          ADC conversion complete callback ID
  *          @arg @ref HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID    ADC analog watchdog 1 callback ID
  *          @arg @ref HAL_ADC_ERROR_CB_ID                    ADC error callback ID
  *          @arg @ref HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID  ADC group injected conversion complete callback ID
  *          @arg @ref HAL_ADC_MSPINIT_CB_ID                  ADC Msp Init callback ID
  *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID                ADC Msp DeInit callback ID
  *          @arg @ref HAL_ADC_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name> <modifier>*</modifier></type><name>hadc</name></decl></parameter>, <parameter><decl><type><name>HAL_ADC_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <name>HAL_ADC_STATE_READY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_ADC_CONVERSION_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ConvCpltCallback</name></name> <operator>=</operator> <name>HAL_ADC_ConvCpltCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_CONVERSION_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ConvHalfCpltCallback</name></name> <operator>=</operator> <name>HAL_ADC_ConvHalfCpltCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>LevelOutOfWindowCallback</name></name> <operator>=</operator> <name>HAL_ADC_LevelOutOfWindowCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>HAL_ADC_ErrorCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>InjectedConvCpltCallback</name></name> <operator>=</operator> <name>HAL_ADCEx_InjectedConvCpltCallback</name></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_ADC_MspInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>
      
      <case>case <expr><name>HAL_ADC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_ADC_MspDeInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>
      
      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
        
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_ADC_STATE_RESET</name> <operator>==</operator> <name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_ADC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_ADC_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>
        
      <case>case <expr><name>HAL_ADC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_ADC_MspDeInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>
        
      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
        
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADC_Exported_Functions_Group2 IO operation functions
 *  @brief    Input and Output operation functions
 *
@verbatim   
 ===============================================================================
                      ##### IO operation functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Start conversion of regular group.
      (+) Stop conversion of regular group.
      (+) Poll for conversion complete on regular group.
      (+) Poll for conversion event.
      (+) Get result of regular channel conversion.
      (+) Start conversion of regular group and enable interruptions.
      (+) Stop conversion of regular group and disable interruptions.
      (+) Handle ADC interrupt request
      (+) Start conversion of regular group and enable DMA transfer.
      (+) Stop conversion of regular group and disable ADC DMA transfer.
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Enables ADC, starts conversion of regular group.
  *         Interruptions enabled in this function: None.
  * @param  hadc: ADC handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_Start</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   
  <comment type="block">/* Enable the ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_Enable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state                                                          */</comment>
    <comment type="block">/* - Clear state bitfield related to regular group conversion results     */</comment>
    <comment type="block">/* - Set state bitfield related to regular operation                      */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_EOC</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set group injected state (from auto-injection) and multimode state     */</comment>
    <comment type="block">/* for all cases of multimode: independent mode, multimode ADC master     */</comment>
    <comment type="block">/* or multimode ADC slave (for devices with several ADCs):                */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state (ADC independent or master) */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* If conversions on group regular are also triggering group injected,  */</comment>
      <comment type="block">/* update ADC state.                                                    */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Set ADC state (ADC slave) */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* If conversions on group regular are also triggering group injected,  */</comment>
      <comment type="block">/* update ADC state.                                                    */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ADC_MULTIMODE_AUTO_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* State machine update: Check if an injected conversion is ongoing */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Reset ADC error code fields related to conversions on group regular */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><operator>(</operator><name>HAL_ADC_ERROR_OVR</name> <operator>|</operator> <name>HAL_ADC_ERROR_DMA</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>         
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Reset ADC all error code fields */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* Clear regular group conversion flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable conversion of regular group.                                    */</comment>
    <comment type="block">/* If software start has been selected, conversion starts immediately.    */</comment>
    <comment type="block">/* If external trigger has been selected, conversion will start at next   */</comment>
    <comment type="block">/* trigger event.                                                         */</comment>
    <comment type="block">/* Case of multimode enabled:                                             */</comment> 
    <comment type="block">/*  - if ADC is slave, ADC is enabled only (conversion is not started).   */</comment>
    <comment type="block">/*  - if ADC is master, ADC is enabled and conversion is started.         */</comment>
    <comment type="block">/* If ADC is master, ADC is enabled and conversion is started.            */</comment>
    <comment type="block">/* Note: Alternate trigger for single conversion could be to force an     */</comment>
    <comment type="block">/*       additional set of bit ADON "hadc-&gt;Instance-&gt;CR2 |= ADC_CR2_ADON;"*/</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator>
        <call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>  )</condition>
    <block>{<block_content>
      <comment type="block">/* Start ADC conversion on regular group with SW start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR2_SWSTART</name> <operator>|</operator> <name>ADC_CR2_EXTTRIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Start ADC conversion on regular group with external trigger */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
    
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop ADC conversion of regular group (and injected channels in 
  *         case of auto_injection mode), disable ADC peripheral.
  * @note:  ADC peripheral disable is forcing stop of potential 
  *         conversion on injected group. If injected group is under use, it
  *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
  * @param  hadc: ADC handle
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_Stop</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
  <comment type="block">/* Disable ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if ADC is effectively disabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Wait for regular group conversion to be completed.
  * @note   This function cannot be used in a particular setup: ADC configured 
  *         in DMA mode.
  *         In this case, DMA resets the flag EOC and polling cannot be
  *         performed on each conversion.
  * @note   On STM32F1 devices, limitation in case of sequencer enabled
  *         (several ranks selected): polling cannot be done on each 
  *         conversion inside the sequence. In this case, polling is replaced by
  *         wait for maximum conversion time.
  * @param  hadc: ADC handle
  * @param  Timeout: Timeout value in millisecond.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_PollForConversion</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Variables for polling in case of scan mode enabled and polling for each  */</comment>
  <comment type="block">/* conversion.                                                              */</comment>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Conversion_Timeout_CPU_cycles</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Conversion_Timeout_CPU_cycles_max</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
 
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Get tick count */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Verification that ADC configuration is compliant with polling for        */</comment>
  <comment type="block">/* each conversion:                                                         */</comment>
  <comment type="block">/* Particular case is ADC configured in DMA mode                            */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_DMA</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Polling for end of conversion: differentiation if single/sequence        */</comment>
  <comment type="block">/* conversion.                                                              */</comment>
  <comment type="block">/*  - If single conversion for regular group (Scan mode disabled or enabled */</comment>
  <comment type="block">/*    with NbrOfConversion =1), flag EOC is used to determine the           */</comment>
  <comment type="block">/*    conversion completion.                                                */</comment>
  <comment type="block">/*  - If sequence conversion for regular group (scan mode enabled and       */</comment>
  <comment type="block">/*    NbrOfConversion &gt;=2), flag EOC is set only at the end of the          */</comment>
  <comment type="block">/*    sequence.                                                             */</comment>
  <comment type="block">/*    To poll for each conversion, the maximum conversion time is computed  */</comment>
  <comment type="block">/*    from ADC conversion time (selected sampling time + conversion time of */</comment>
  <comment type="block">/*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */</comment>
  <comment type="block">/*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */</comment>
  <comment type="block">/*    As flag EOC is not set after each conversion, no timeout status can   */</comment>
  <comment type="block">/*    be set.                                                               */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_SCAN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR1</name></name></expr></argument>, <argument><expr><name>ADC_SQR1_L</name></expr></argument>)</argument_list></call></expr>    )</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until End of Conversion flag is raised */</comment>
    <while>while<condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name></expr></argument>, <argument><expr><name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check if timeout is disabled (set to infinite wait) */</comment>
      <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update ADC state machine to timeout */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Process unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Replace polling by wait for maximum conversion time */</comment>
    <comment type="block">/*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */</comment>
    <comment type="block">/*    and ADC maximum conversion cycles on all channels.                  */</comment>
    <comment type="block">/*  - Wait for the expected ADC clock cycles delay                        */</comment>
    <expr_stmt><expr><name>Conversion_Timeout_CPU_cycles_max</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SystemCoreClock</name>
                                          <operator>/</operator> <call><name>HAL_RCCEx_GetPeriphCLKFreq</name><argument_list>(<argument><expr><name>RCC_PERIPHCLK_ADC</name></expr></argument>)</argument_list></call><operator>)</operator>
                                         <operator>*</operator> <call><name>ADC_CONVCYCLES_MAX_RANGE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>                 <operator>)</operator></expr>;</expr_stmt>
    
    <while>while<condition>(<expr><name>Conversion_Timeout_CPU_cycles</name> <operator>&lt;</operator> <name>Conversion_Timeout_CPU_cycles_max</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check if timeout is disabled (set to infinite wait) */</comment>
      <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update ADC state machine to timeout */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Process unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>Conversion_Timeout_CPU_cycles</name> <operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Clear regular group conversion flag */</comment>
  <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_STRT</name> <operator>|</operator> <name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update ADC state machine */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Determine whether any further conversion upcoming on group regular       */</comment>
  <comment type="block">/* by external trigger, continuous mode or scan sequence on going.          */</comment>
  <comment type="block">/* Note: On STM32F1 devices, in case of sequencer enabled                   */</comment>
  <comment type="block">/*       (several ranks selected), end of conversion flag is raised         */</comment>
  <comment type="block">/*       at the end of the sequence.                                        */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>        <operator>&amp;&amp;</operator> 
     <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name><operator>)</operator></expr>   )</condition>
  <block>{<block_content>   
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   

    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Return ADC state */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Poll for conversion event.
  * @param  hadc: ADC handle
  * @param  EventType: the ADC event type.
  *          This parameter can be one of the following values:
  *            @arg ADC_AWD_EVENT: ADC Analog watchdog event.
  * @param  Timeout: Timeout value in millisecond.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_PollForEvent</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>EventType</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt> 

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_EVENT_TYPE</name><argument_list>(<argument><expr><name>EventType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Get tick count */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check selected event flag */</comment>
  <while>while<condition>(<expr><call><name>__HAL_ADC_GET_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>EventType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if timeout is disabled (set to infinite wait) */</comment>
    <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update ADC state machine to timeout */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Analog watchdog (level out of window) event */</comment>
  <comment type="block">/* Set ADC state */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_AWD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Clear ADC analog watchdog flag */</comment>
  <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_AWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return ADC state */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables ADC, starts conversion of regular group with interruption.
  *         Interruptions enabled in this function:
  *          - EOC (end of conversion of regular group)
  *         Each of these interruptions has its dedicated callback function.
  * @param  hadc: ADC handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_Start_IT</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Enable the ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_Enable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state                                                          */</comment>
    <comment type="block">/* - Clear state bitfield related to regular group conversion results     */</comment>
    <comment type="block">/* - Set state bitfield related to regular operation                      */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_EOC</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_OVR</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_EOSMP</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set group injected state (from auto-injection) and multimode state     */</comment>
    <comment type="block">/* for all cases of multimode: independent mode, multimode ADC master     */</comment>
    <comment type="block">/* or multimode ADC slave (for devices with several ADCs):                */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state (ADC independent or master) */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* If conversions on group regular are also triggering group injected,  */</comment>
      <comment type="block">/* update ADC state.                                                    */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Set ADC state (ADC slave) */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* If conversions on group regular are also triggering group injected,  */</comment>
      <comment type="block">/* update ADC state.                                                    */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ADC_MULTIMODE_AUTO_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* State machine update: Check if an injected conversion is ongoing */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Reset ADC error code fields related to conversions on group regular */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><operator>(</operator><name>HAL_ADC_ERROR_OVR</name> <operator>|</operator> <name>HAL_ADC_ERROR_DMA</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>         
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Reset ADC all error code fields */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Clear regular group conversion flag and overrun flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable end of conversion interrupt for regular group */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable conversion of regular group.                                    */</comment>
    <comment type="block">/* If software start has been selected, conversion starts immediately.    */</comment>
    <comment type="block">/* If external trigger has been selected, conversion will start at next   */</comment>
    <comment type="block">/* trigger event.                                                         */</comment>
    <comment type="block">/* Case of multimode enabled:                                             */</comment> 
    <comment type="block">/*  - if ADC is slave, ADC is enabled only (conversion is not started).   */</comment>
    <comment type="block">/*  - if ADC is master, ADC is enabled and conversion is started.         */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator>
        <call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>  )</condition>
    <block>{<block_content>
      <comment type="block">/* Start ADC conversion on regular group with SW start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR2_SWSTART</name> <operator>|</operator> <name>ADC_CR2_EXTTRIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Start ADC conversion on regular group with external trigger */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop ADC conversion of regular group (and injected group in 
  *         case of auto_injection mode), disable interrution of 
  *         end-of-conversion, disable ADC peripheral.
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_Stop_IT</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
  <comment type="block">/* Disable ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if ADC is effectively disabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable ADC end of conversion interrupt for regular group */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables ADC, starts conversion of regular group and transfers result
  *         through DMA.
  *         Interruptions enabled in this function:
  *          - DMA transfer complete
  *          - DMA half transfer
  *         Each of these interruptions has its dedicated callback function.
  * @note   For devices with several ADCs: This function is for single-ADC mode 
  *         only. For multimode, use the dedicated MultimodeStart function.
  * @note   On STM32F1 devices, only ADC1 and ADC3 (ADC availability depending
  *         on devices) have DMA capability.
  *         ADC2 converted data can be transferred in dual ADC mode using DMA
  *         of ADC1 (ADC master in multimode).
  *         In case of using ADC1 with DMA on a device featuring 2 ADC
  *         instances: ADC1 conversion register DR contains ADC1 conversion 
  *         result (ADC1 register DR bits 0 to 11) and, additionally, ADC2 last
  *         conversion result (ADC1 register DR bits 16 to 27). Therefore, to
  *         have DMA transferring the conversion results of ADC1 only, DMA must
  *         be configured to transfer size: half word.
  * @param  hadc: ADC handle
  * @param  pData: The destination Buffer address.
  * @param  Length: The length of data to be transferred from ADC peripheral to memory.
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_Start_DMA</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>pData</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_DMA_CAPABILITY_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Verification if multimode is disabled (for devices with several ADC)     */</comment>
  <comment type="block">/* If multimode is enabled, dedicated function multimode conversion         */</comment>
  <comment type="block">/* start DMA must be used.                                                  */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>ADC_MULTIMODE_IS_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Process locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable the ADC peripheral */</comment>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_Enable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
    <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state                                                        */</comment>
      <comment type="block">/* - Clear state bitfield related to regular group conversion results   */</comment>
      <comment type="block">/* - Set state bitfield related to regular operation                    */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_EOC</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_OVR</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_EOSMP</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set group injected state (from auto-injection) and multimode state     */</comment>
    <comment type="block">/* for all cases of multimode: independent mode, multimode ADC master     */</comment>
    <comment type="block">/* or multimode ADC slave (for devices with several ADCs):                */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state (ADC independent or master) */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* If conversions on group regular are also triggering group injected,  */</comment>
      <comment type="block">/* update ADC state.                                                    */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Set ADC state (ADC slave) */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* If conversions on group regular are also triggering group injected,  */</comment>
      <comment type="block">/* update ADC state.                                                    */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ADC_MULTIMODE_AUTO_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
      
      <comment type="block">/* State machine update: Check if an injected conversion is ongoing */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Reset ADC error code fields related to conversions on group regular */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><operator>(</operator><name>HAL_ADC_ERROR_OVR</name> <operator>|</operator> <name>HAL_ADC_ERROR_DMA</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>         
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Reset ADC all error code fields */</comment>
        <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      
      <comment type="block">/* Process unlocked */</comment>
      <comment type="block">/* Unlock before starting ADC conversions: in case of potential         */</comment>
      <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                 */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set the DMA transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>ADC_DMAConvCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA half transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>ADC_DMAHalfConvCplt</name></expr>;</expr_stmt>
      
      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>ADC_DMAError</name></expr>;</expr_stmt>

      
      <comment type="block">/* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC   */</comment>
      <comment type="block">/* start (in case of SW start):                                         */</comment>
      
      <comment type="block">/* Clear regular group conversion flag and overrun flag */</comment>
      <comment type="block">/* (To ensure of no unknown state from potential previous ADC           */</comment>
      <comment type="block">/* operations)                                                          */</comment>
      <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Enable ADC DMA mode */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Start the DMA channel */</comment>
      <expr_stmt><expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Enable conversion of regular group.                                  */</comment>
      <comment type="block">/* If software start has been selected, conversion starts immediately.  */</comment>
      <comment type="block">/* If external trigger has been selected, conversion will start at next */</comment>
      <comment type="block">/* trigger event.                                                       */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Start ADC conversion on regular group with SW start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR2_SWSTART</name> <operator>|</operator> <name>ADC_CR2_EXTTRIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Start ADC conversion on regular group with external trigger */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Process unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop ADC conversion of regular group (and injected group in 
  *         case of auto_injection mode), disable ADC DMA transfer, disable 
  *         ADC peripheral.
  * @note:  ADC peripheral disable is forcing stop of potential 
  *         conversion on injected group. If injected group is under use, it
  *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
  * @note   For devices with several ADCs: This function is for single-ADC mode 
  *         only. For multimode, use the dedicated MultimodeStop function.
  * @note   On STM32F1 devices, only ADC1 and ADC3 (ADC availability depending
  *         on devices) have DMA capability.
  * @param  hadc: ADC handle
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_Stop_DMA</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_DMA_CAPABILITY_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
  <comment type="block">/* Disable ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if ADC is effectively disabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable ADC DMA mode */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Disable the DMA channel (in case of DMA in circular mode or stop while */</comment>
    <comment type="block">/* DMA transfer is on going)                                              */</comment>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if DMA channel effectively disabled */</comment>
    <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update ADC state machine to error */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
    
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Get ADC regular group conversion result.
  * @note   Reading register DR automatically clears ADC flag EOC
  *         (ADC group regular end of unitary conversion).
  * @note   This function does not clear ADC flag EOS 
  *         (ADC group regular end of sequence conversion).
  *         Occurrence of flag EOS rising:
  *          - If sequencer is composed of 1 rank, flag EOS is equivalent
  *            to flag EOC.
  *          - If sequencer is composed of several ranks, during the scan
  *            sequence flag EOC only is raised, at the end of the scan sequence
  *            both flags EOC and EOS are raised.
  *         To clear this flag, either use function: 
  *         in programming model IT: @ref HAL_ADC_IRQHandler(), in programming
  *         model polling: @ref HAL_ADC_PollForConversion() 
  *         or @ref __HAL_ADC_CLEAR_FLAG(&amp;hadc, ADC_FLAG_EOS).
  * @param  hadc: ADC handle
  * @retval ADC group regular conversion data
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_ADC_GetValue</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Note: EOC flag is not cleared here by software because automatically     */</comment>
  <comment type="block">/*       cleared by hardware when reading register DR.                      */</comment>
  
  <comment type="block">/* Return ADC converted value */</comment> 
  <return>return <expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handles ADC interrupt request  
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_ADC_IRQHandler</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_REGULAR_NB_CONV</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NbrOfConversion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  
  <comment type="block">/* ========== Check End of Conversion flag for regular group ========== */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_ADC_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_EOC</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_ADC_GET_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr> )</condition>
    <block>{<block_content>
      <comment type="block">/* Update state machine on conversion status if not in error state */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set ADC state */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* Determine whether any further conversion upcoming on group regular   */</comment>
      <comment type="block">/* by external trigger, continuous mode or scan sequence on going.      */</comment>
      <comment type="block">/* Note: On STM32F1 devices, in case of sequencer enabled               */</comment>
      <comment type="block">/*       (several ranks selected), end of conversion flag is raised     */</comment>
      <comment type="block">/*       at the end of the sequence.                                    */</comment>
      <if_stmt><if>if<condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>        <operator>&amp;&amp;</operator> 
         <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name><operator>)</operator></expr>   )</condition>
      <block>{<block_content>
        <comment type="block">/* Disable ADC end of conversion interrupt on group regular */</comment>
        <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Set ADC state */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
        
        <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Conversion complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>ConvCpltCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_ADC_ConvCpltCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
      
      <comment type="block">/* Clear regular group conversion flag */</comment>
      <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_STRT</name> <operator>|</operator> <name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* ========== Check End of Conversion flag for injected group ========== */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_ADC_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_JEOC</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_ADC_GET_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update state machine on conversion status if not in error state */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set ADC state */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Determine whether any further conversion upcoming on group injected  */</comment>
      <comment type="block">/* by external trigger, scan sequence on going or by automatic injected */</comment>
      <comment type="block">/* conversion from group regular (same conditions as group regular      */</comment>
      <comment type="block">/* interruption disabling above).                                       */</comment>
      <comment type="block">/* Note: On STM32F1 devices, in case of sequencer enabled               */</comment>
      <comment type="block">/*       (several ranks selected), end of conversion flag is raised     */</comment>
      <comment type="block">/*       at the end of the sequence.                                    */</comment>
      <if_stmt><if>if<condition>(<expr><call><name>ADC_IS_SOFTWARE_START_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>                     <operator>||</operator> 
         <operator>(</operator><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>     
         <operator>(</operator><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>        <operator>&amp;&amp;</operator>
          <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name><operator>)</operator>   <operator>)</operator>        <operator>)</operator></expr>   )</condition>
      <block>{<block_content>
        <comment type="block">/* Disable ADC end of conversion interrupt on group injected */</comment>
        <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Set ADC state */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   

        <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Conversion complete callback */</comment> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>InjectedConvCpltCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_ADCEx_InjectedConvCpltCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
      
      <comment type="block">/* Clear injected group conversion flag */</comment>
      <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_FLAG_JSTRT</name> <operator>|</operator> <name>ADC_FLAG_JEOC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
   
  <comment type="block">/* ========== Check Analog watchdog flags ========== */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_ADC_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_AWD</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_ADC_GET_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_AWD</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_AWD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Level out of window callback */</comment> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>LevelOutOfWindowCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_ADC_LevelOutOfWindowCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
      
      <comment type="block">/* Clear the ADC analog watchdog flag */</comment>
      <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_AWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Conversion complete callback in non blocking mode 
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADC_ConvCpltCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ConvCpltCallback must be implemented in the user file.
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Conversion DMA half-transfer callback in non blocking mode 
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADC_ConvHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
  */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Analog watchdog callback in non blocking mode. 
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADC_LevelOutOfWindowCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
  */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  ADC error callback in non blocking mode
  *        (ADC conversion with interruption or transfer by DMA)
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADC_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name> <modifier>*</modifier></type><name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ErrorCallback must be implemented in the user file.
  */</comment>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADC_Exported_Functions_Group3 Peripheral Control functions
 *  @brief    Peripheral Control functions
 *
@verbatim   
 ===============================================================================
             ##### Peripheral Control functions #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Configure channels on regular group
      (+) Configure the analog watchdog
      
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Configures the the selected channel to be linked to the regular
  *         group.
  * @note   In case of usage of internal measurement channels:
  *         Vbat/VrefInt/TempSensor.
  *         These internal paths can be be disabled using function 
  *         HAL_ADC_DeInit().
  * @note   Possibility to update parameters on the fly:
  *         This function initializes channel into regular group, following  
  *         calls to this function can be used to reconfigure some parameters 
  *         of structure "ADC_ChannelConfTypeDef" on the fly, without reseting 
  *         the ADC.
  *         The setting of these parameters is conditioned to ADC state.
  *         For parameters constraints, see comments of structure 
  *         "ADC_ChannelConfTypeDef".
  * @param  hadc: ADC handle
  * @param  sConfig: Structure of ADC channel for regular group.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_ConfigChannel</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>ADC_ChannelConfTypeDef</name><modifier>*</modifier></type> <name>sConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>wait_loop_index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_CHANNEL</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_REGULAR_RANK</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_SAMPLE_TIME</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>SamplingTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  
  <comment type="block">/* Regular sequence configuration */</comment>
  <comment type="block">/* For Rank 1 to 6 */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name> <operator>&lt;</operator> <literal type="number">7U</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR3</name></name></expr></argument>                        ,
               <argument><expr><call><name>ADC_SQR3_RK</name><argument_list>(<argument><expr><name>ADC_SQR3_SQ1</name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name></expr></argument>)</argument_list></call></expr></argument>    ,
               <argument><expr><call><name>ADC_SQR3_RK</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* For Rank 7 to 12 */</comment>
  <if type="elseif">else if <condition>(<expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name> <operator>&lt;</operator> <literal type="number">13U</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR2</name></name></expr></argument>                        ,
               <argument><expr><call><name>ADC_SQR2_RK</name><argument_list>(<argument><expr><name>ADC_SQR2_SQ7</name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name></expr></argument>)</argument_list></call></expr></argument>    ,
               <argument><expr><call><name>ADC_SQR2_RK</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* For Rank 13 to 16 */</comment>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR1</name></name></expr></argument>                        ,
               <argument><expr><call><name>ADC_SQR1_RK</name><argument_list>(<argument><expr><name>ADC_SQR1_SQ13</name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name></expr></argument>)</argument_list></call></expr></argument>   ,
               <argument><expr><call><name>ADC_SQR1_RK</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Rank</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  
  <comment type="block">/* Channel sampling time configuration */</comment>
  <comment type="block">/* For channels 10 to 17 */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name> <operator>&gt;=</operator> <name>ADC_CHANNEL_10</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR1</name></name></expr></argument>                             ,
               <argument><expr><call><name>ADC_SMPR1</name><argument_list>(<argument><expr><name>ADC_SMPR1_SMP10</name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>)</argument_list></call></expr></argument>      ,
               <argument><expr><call><name>ADC_SMPR1</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>SamplingTime</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <comment type="block">/* For channels 0 to 9 */</comment>
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR2</name></name></expr></argument>                             ,
               <argument><expr><call><name>ADC_SMPR2</name><argument_list>(<argument><expr><name>ADC_SMPR2_SMP0</name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>)</argument_list></call></expr></argument>       ,
               <argument><expr><call><name>ADC_SMPR2</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>SamplingTime</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */</comment>
  <comment type="block">/* and VREFINT measurement path.                                            */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name> <operator>==</operator> <name>ADC_CHANNEL_TEMPSENSOR</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name> <operator>==</operator> <name>ADC_CHANNEL_VREFINT</name><operator>)</operator></expr>      )</condition>
  <block>{<block_content>
    <comment type="block">/* For STM32F1 devices with several ADC: Only ADC1 can access internal    */</comment>
    <comment type="block">/* measurement channels (VrefInt/TempSensor). If these channels are       */</comment>
    <comment type="block">/* intended to be set on other ADC instances, an error is reported.       */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name> <operator>==</operator> <name>ADC1</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_TSVREFE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_TSVREFE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>Channel</name></name> <operator>==</operator> <name>ADC_CHANNEL_TEMPSENSOR</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Delay for temperature sensor stabilization time */</comment>
          <comment type="block">/* Compute number of CPU cycles to wait for */</comment>
          <expr_stmt><expr><name>wait_loop_index</name> <operator>=</operator> <operator>(</operator><name>ADC_TEMPSENSOR_DELAY_US</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">1000000U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <while>while<condition>(<expr><name>wait_loop_index</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><name>wait_loop_index</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update ADC state machine to error */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures the analog watchdog.
  * @note   Analog watchdog thresholds can be modified while ADC conversion
  *         is on going.
  *         In this case, some constraints must be taken into account:
  *         the programmed threshold values are effective from the next
  *         ADC EOC (end of unitary conversion).
  *         Considering that registers write delay may happen due to
  *         bus activity, this might cause an uncertainty on the
  *         effective timing of the new programmed threshold values.
  * @param  hadc: ADC handle
  * @param  AnalogWDGConfig: Structure of ADC analog watchdog configuration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADC_AnalogWDGConfig</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>ADC_AnalogWDGConfTypeDef</name><modifier>*</modifier></type> <name>AnalogWDGConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ANALOG_WATCHDOG_MODE</name><argument_list>(<argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>WatchdogMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>ITMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_RANGE</name><argument_list>(<argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>HighThreshold</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_RANGE</name><argument_list>(<argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>LowThreshold</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>WatchdogMode</name></name> <operator>==</operator> <name>ADC_ANALOGWATCHDOG_SINGLE_REG</name><operator>)</operator>     <operator>||</operator>
     <operator>(</operator><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>WatchdogMode</name></name> <operator>==</operator> <name>ADC_ANALOGWATCHDOG_SINGLE_INJEC</name><operator>)</operator>   <operator>||</operator>
     <operator>(</operator><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>WatchdogMode</name></name> <operator>==</operator> <name>ADC_ANALOGWATCHDOG_SINGLE_REGINJEC</name><operator>)</operator></expr>  )</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_CHANNEL</name><argument_list>(<argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Analog watchdog configuration */</comment>

  <comment type="block">/* Configure ADC Analog watchdog interrupt */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>ITMode</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the ADC Analog watchdog interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_AWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Disable the ADC Analog watchdog interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_AWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Configuration of analog watchdog:                                        */</comment>
  <comment type="block">/*  - Set the analog watchdog enable mode: regular and/or injected groups,  */</comment>
  <comment type="block">/*    one or all channels.                                                  */</comment>
  <comment type="block">/*  - Set the Analog watchdog channel (is not used if watchdog              */</comment>
  <comment type="block">/*    mode "all channels": ADC_CFGR_AWD1SGL=0).                             */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>            ,
             <argument><expr><name>ADC_CR1_AWDSGL</name> <operator>|</operator>
             <name>ADC_CR1_JAWDEN</name> <operator>|</operator>
             <name>ADC_CR1_AWDEN</name>  <operator>|</operator>
             <name>ADC_CR1_AWDCH</name></expr></argument>                  ,
             <argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>WatchdogMode</name></name> <operator>|</operator>
             <name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>Channel</name></name></expr></argument>        )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the high threshold */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>HTR</name></name></expr></argument>, <argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>HighThreshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the low threshold */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LTR</name></name></expr></argument>, <argument><expr><name><name>AnalogWDGConfig</name><operator>-&gt;</operator><name>LowThreshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @}
  */</comment>


<comment type="block" format="doxygen">/** @defgroup ADC_Exported_Functions_Group4 Peripheral State functions
 *  @brief    Peripheral State functions
 *
@verbatim
 ===============================================================================
            ##### Peripheral State and Errors functions #####
 ===============================================================================  
    [..]
    This subsection provides functions to get in run-time the status of the  
    peripheral.
      (+) Check the ADC state
      (+) Check the ADC error code

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  return the ADC state
  * @param  hadc: ADC handle
  * @retval HAL state
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_ADC_GetState</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return ADC state */</comment>
  <return>return <expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the ADC error code
  * @param  hadc: ADC handle
  * @retval ADC Error Code
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_ADC_GetError</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name> <modifier>*</modifier></type><name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADC_Private_Functions ADC Private Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Enable the selected ADC.
  * @note   Prerequisite condition to use this function: ADC must be disabled
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param  hadc: ADC handle
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>ADC_Enable</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>wait_loop_index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* ADC enable and wait for ADC ready (in case of ADC is disabled or         */</comment>
  <comment type="block">/* enabling phase not yet completed: flag ADC ready not yet set).           */</comment>
  <comment type="block">/* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */</comment>
  <comment type="block">/* causes: ADC clock not running, ...).                                     */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the Peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Delay for ADC stabilization time */</comment>
    <comment type="block">/* Compute number of CPU cycles to wait for */</comment>
    <expr_stmt><expr><name>wait_loop_index</name> <operator>=</operator> <operator>(</operator><name>ADC_STAB_DELAY_US</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">1000000U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>wait_loop_index</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>wait_loop_index</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <comment type="block">/* Get tick count */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait for ADC effectively enabled */</comment>
    <while>while<condition>(<expr><call><name>ADC_IS_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>ADC_ENABLE_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update ADC state machine to error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
        <comment type="block">/* Set ADC error code to ADC IP internal error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_ADC_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
   
  <comment type="block">/* Return HAL status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop ADC conversion and disable the selected ADC
  * @note   Prerequisite condition to use this function: ADC conversions must be
  *         stopped to disable the ADC.
  * @param  hadc: ADC handle
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>ADC_ConversionStop_Disable</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Verification if ADC is not already disabled */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the ADC peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_DISABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
    <comment type="block">/* Get tick count */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Wait for ADC effectively disabled */</comment>
    <while>while<condition>(<expr><call><name>ADC_IS_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>ADC_DISABLE_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update ADC state machine to error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Set ADC error code to ADC IP internal error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_ADC_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Return HAL status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>ADC_DMAConvCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Retrieve ADC handle corresponding to current DMA handle */</comment>
  <decl_stmt><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name> <init>= <expr><operator>(</operator> <name>ADC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
 
  <comment type="block">/* Update state machine on conversion status if not in error state */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name> <operator>|</operator> <name>HAL_ADC_STATE_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Determine whether any further conversion upcoming on group regular     */</comment>
    <comment type="block">/* by external trigger, continuous mode or scan sequence on going.        */</comment>
    <comment type="block">/* Note: On STM32F1 devices, in case of sequencer enabled                 */</comment>
    <comment type="block">/*       (several ranks selected), end of conversion flag is raised       */</comment>
    <comment type="block">/*       at the end of the sequence.                                      */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>        <operator>&amp;&amp;</operator> 
       <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name><operator>)</operator></expr>   )</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
      
      <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Conversion complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>ConvCpltCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_ADC_ConvCpltCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Call DMA error callback */</comment>
    <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferErrorCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA half transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>ADC_DMAHalfConvCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
  <comment type="block">/* Retrieve ADC handle corresponding to current DMA handle */</comment>
  <decl_stmt><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name> <init>= <expr><operator>(</operator> <name>ADC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Half conversion callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>ConvHalfCpltCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_ADC_ConvHalfCpltCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA error callback 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>ADC_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
  <comment type="block">/* Retrieve ADC handle corresponding to current DMA handle */</comment>
  <decl_stmt><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name> <init>= <expr><operator>(</operator> <name>ADC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Set ADC state */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set ADC error code to DMA error */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_ADC_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ADC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_ADC_ErrorCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ADC_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_ADC_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
