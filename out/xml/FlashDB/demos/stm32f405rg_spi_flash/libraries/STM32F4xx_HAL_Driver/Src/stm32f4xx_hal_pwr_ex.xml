<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_pwr_ex.c
  * @author  MCD Application Team
  * @brief   Extended PWR HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of PWR extension peripheral:           
  *           + Peripheral Extended features functions
  *         
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup PWREx PWREx
  * @brief PWR HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_PWR_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup PWREx_Private_Constants
  * @{
  */</comment>    
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_OVERDRIVE_TIMEOUT_VALUE</name></cpp:macro>  <cpp:value>1000U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_UDERDRIVE_TIMEOUT_VALUE</name></cpp:macro>  <cpp:value>1000U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_BKPREG_TIMEOUT_VALUE</name></cpp:macro>     <cpp:value>1000U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_VOSRDY_TIMEOUT_VALUE</name></cpp:macro>     <cpp:value>1000U</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

   
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup PWREx_Exported_Functions PWREx Exported Functions
  *  @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions 
  *  @brief Peripheral Extended features functions 
  *
@verbatim   

 ===============================================================================
                 ##### Peripheral extended features functions #####
 ===============================================================================

    *** Main and Backup Regulators configuration ***
    ================================================
    [..] 
      (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
          the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
          retained even in Standby or VBAT mode when the low power backup regulator
          is enabled. It can be considered as an internal EEPROM when VBAT is 
          always present. You can use the HAL_PWREx_EnableBkUpReg() function to 
          enable the low power backup regulator. 

      (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
          the backup SRAM is powered from VDD which replaces the VBAT power supply to 
          save battery life.

      (+) The backup SRAM is not mass erased by a tamper event. It is read 
          protected to prevent confidential data, such as cryptographic private 
          key, from being accessed. The backup SRAM can be erased only through 
          the Flash interface when a protection level change from level 1 to 
          level 0 is requested. 
      -@- Refer to the description of Read protection (RDP) in the Flash 
          programming manual.

      (+) The main internal regulator can be configured to have a tradeoff between 
          performance and power consumption when the device does not operate at 
          the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() 
          macro which configure VOS bit in PWR_CR register
          
        Refer to the product datasheets for more details.

    *** FLASH Power Down configuration ****
    =======================================
    [..] 
      (+) By setting the FPDS bit in the PWR_CR register by using the 
          HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power 
          down mode when the device enters Stop mode. When the Flash memory 
          is in power down mode, an additional startup delay is incurred when 
          waking up from Stop mode.
          
           (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, the scale can be modified only when the PLL 
           is OFF and the HSI or HSE clock source is selected as system clock. 
           The new value programmed is active only when the PLL is ON.
           When the PLL is OFF, the voltage scale 3 is automatically selected. 
        Refer to the datasheets for more details.

    *** Over-Drive and Under-Drive configuration ****
    =================================================
    [..]         
       (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, in Run mode: the main regulator has
           2 operating modes available:
        (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
             voltage scaling (scale 1, scale 2 or scale 3)
        (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
            higher frequency than the normal mode for a given voltage scaling (scale 1,  
            scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and
            disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow 
            the sequence described in Reference manual.
             
       (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, in Stop mode: the main regulator or low power regulator 
           supplies a low power voltage to the 1.2V domain, thus preserving the content of registers 
           and internal SRAM. 2 operating modes are available:
         (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
              available when the main regulator or the low power regulator is used in Scale 3 or 
              low voltage mode.
         (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only
              available when the main regulator or the low power regulator is in low voltage mode.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief Enables the Backup Regulator.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_PWREx_EnableBkUpReg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CSR_BRE_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ENABLE</name></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait till Backup regulator ready flag is set */</comment>  
  <while>while<condition>(<expr><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_BRR</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PWR_BKPREG_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt> 
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Disables the Backup Regulator.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_PWREx_DisableBkUpReg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CSR_BRE_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait till Backup regulator ready flag is set */</comment>  
  <while>while<condition>(<expr><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_BRR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PWR_BKPREG_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt> 
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Enables the Flash Power Down in Stop mode.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWREx_EnableFlashPowerDown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_FPDS_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ENABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Disables the Flash Power Down in Stop mode.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWREx_DisableFlashPowerDown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_FPDS_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Return Voltage Scaling Range.
  * @retval The configured scale for the regulator voltage(VOS bit field).
  *         The returned value can be one of the following:
  *            - @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
  *            - @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
  *            - @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output Scale 3 mode
  */</comment>  
<function><type><name>uint32_t</name></type> <name>HAL_PWREx_GetVoltageRange</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>PWR</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>PWR_CR_VOS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F405xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F415xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F407xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F417xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief Configures the main internal regulator output voltage.
  * @param  VoltageScaling specifies the regulator output voltage to achieve
  *         a tradeoff between performance and power consumption.
  *          This parameter can be one of the following values:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
  *                                               the maximum value of fHCLK = 168 MHz.
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
  *                                               the maximum value of fHCLK = 144 MHz.
  * @note  When moving from Range 1 to Range 2, the system frequency must be decreased to
  *        a value below 144 MHz before calling HAL_PWREx_ConfigVoltageScaling() API.
  *        When moving from Range 2 to Range 1, the system frequency can be increased to
  *        a value up to 168 MHz after calling HAL_PWREx_ConfigVoltageScaling() API.
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_PWREx_ControlVoltageScaling</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>VoltageScaling</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_VOLTAGE_SCALING_RANGE</name><argument_list>(<argument><expr><name>VoltageScaling</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable PWR RCC Clock Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_RCC_PWR_CLK_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set Range */</comment>
  <expr_stmt><expr><call><name>__HAL_PWR_VOLTAGESCALING_CONFIG</name><argument_list>(<argument><expr><name>VoltageScaling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Get Start Tick*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>(<expr><operator>(</operator><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_VOSRDY</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PWR_VOSRDY_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt> 
  </block_content>}</block></while>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator> \
      <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> \
      <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> \
      <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> \
      <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block" format="doxygen">/**
  * @brief Configures the main internal regulator output voltage.
  * @param  VoltageScaling specifies the regulator output voltage to achieve
  *         a tradeoff between performance and power consumption.
  *          This parameter can be one of the following values:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
  *                                               the maximum value of fHCLK is 168 MHz. It can be extended to
  *                                               180 MHz by activating the over-drive mode.
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
  *                                               the maximum value of fHCLK is 144 MHz. It can be extended to,                
  *                                               168 MHz by activating the over-drive mode.
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 3 mode,
  *                                               the maximum value of fHCLK is 120 MHz.
  * @note To update the system clock frequency(SYSCLK):
  *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().
  *        - Call the HAL_RCC_OscConfig() to configure the PLL.
  *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.
  *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().
  * @note The scale can be modified only when the HSI or HSE clock source is selected 
  *        as system clock source, otherwise the API returns HAL_ERROR.  
  * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits
  *       value in the PWR_CR1 register are not taken in account.
  * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.
  * @note The new voltage scale is active only when the PLL is ON.  
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_PWREx_ControlVoltageScaling</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>VoltageScaling</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_VOLTAGE_SCALING_RANGE</name><argument_list>(<argument><expr><name>VoltageScaling</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable PWR RCC Clock Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_RCC_PWR_CLK_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if the PLL is used as system clock or not */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_RCC_GET_SYSCLK_SOURCE</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>RCC_CFGR_SWS_PLL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the main PLL */</comment>
    <expr_stmt><expr><call><name>__HAL_RCC_PLL_DISABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Get Start Tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    
    <comment type="block">/* Wait till PLL is disabled */</comment>  
    <while>while<condition>(<expr><call><name>__HAL_RCC_GET_FLAG</name><argument_list>(<argument><expr><name>RCC_FLAG_PLLRDY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PLL_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    
    <comment type="block">/* Set Range */</comment>
    <expr_stmt><expr><call><name>__HAL_PWR_VOLTAGESCALING_CONFIG</name><argument_list>(<argument><expr><name>VoltageScaling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable the main PLL */</comment>
    <expr_stmt><expr><call><name>__HAL_RCC_PLL_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Get Start Tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Wait till PLL is ready */</comment>  
    <while>while<condition>(<expr><call><name>__HAL_RCC_GET_FLAG</name><argument_list>(<argument><expr><name>RCC_FLAG_PLLRDY</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PLL_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt> 
    </block_content>}</block></while>
    
    <comment type="block">/* Get Start Tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_VOSRDY</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PWR_VOSRDY_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt> 
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief Enables Main Regulator low voltage mode.
  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
  *        STM32F413xx/STM32F423xx devices.   
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWREx_EnableMainRegulatorLowVoltage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_MRLVDS_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ENABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Disables Main Regulator low voltage mode.
  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
  *        STM32F413xx/STM32F423xxdevices. 
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWREx_DisableMainRegulatorLowVoltage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_MRLVDS_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Enables Low Power Regulator low voltage mode.
  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
  *        STM32F413xx/STM32F423xx devices.   
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWREx_EnableLowRegulatorLowVoltage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_LPLVDS_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ENABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Disables Low Power Regulator low voltage mode.
  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
  *        STM32F413xx/STM32F423xx  devices.   
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWREx_DisableLowRegulatorLowVoltage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_LPLVDS_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx ||
          STM32F413xx || STM32F423xx */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Activates the Over-Drive mode.
  * @note   This function can be used only for STM32F42xx/STM32F43xx/STM32F446xx/STM32F469xx/STM32F479xx devices.
  *         This mode allows the CPU and the core logic to operate at a higher frequency
  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
  * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
  *         critical tasks and when the system clock source is either HSI or HSE. 
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_PWREx_EnableOverDrive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>__HAL_RCC_PWR_CLK_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the Over-drive to extend the clock frequency to 180 Mhz */</comment>
  <expr_stmt><expr><call><name>__HAL_PWR_OVERDRIVE_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>(<expr><operator>!</operator><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_ODRDY</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>PWR_OVERDRIVE_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Enable the Over-drive switch */</comment>
  <expr_stmt><expr><call><name>__HAL_PWR_OVERDRIVESWITCHING_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>(<expr><operator>!</operator><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_ODSWRDY</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PWR_OVERDRIVE_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while> 
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Deactivates the Over-Drive mode.
  * @note   This function can be used only for STM32F42xx/STM32F43xx/STM32F446xx/STM32F469xx/STM32F479xx devices.
  *         This mode allows the CPU and the core logic to operate at a higher frequency
  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    
  * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
  *         critical tasks and when the system clock source is either HSI or HSE. 
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_PWREx_DisableOverDrive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>__HAL_RCC_PWR_CLK_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Disable the Over-drive switch */</comment>
  <expr_stmt><expr><call><name>__HAL_PWR_OVERDRIVESWITCHING_DISABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 
  <while>while<condition>(<expr><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_ODSWRDY</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>PWR_OVERDRIVE_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while> 
  
  <comment type="block">/* Disable the Over-drive */</comment>
  <expr_stmt><expr><call><name>__HAL_PWR_OVERDRIVE_DISABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>(<expr><call><name>__HAL_PWR_GET_FLAG</name><argument_list>(<argument><expr><name>PWR_FLAG_ODRDY</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>PWR_OVERDRIVE_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enters in Under-Drive STOP mode.
  *  
  * @note   This mode is only available for STM32F42xxx/STM32F43xxx/STM32F446xx/STM32F469xx/STM32F479xx devices.
  * 
  * @note    This mode can be selected only when the Under-Drive is already active 
  *   
  * @note    This mode is enabled only with STOP low power mode.
  *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
  *          mode is only available when the main regulator or the low power regulator 
  *          is in low voltage mode
  *        
  * @note   If the Under-drive mode was enabled, it is automatically disabled after 
  *         exiting Stop mode. 
  *         When the voltage regulator operates in Under-drive mode, an additional  
  *         startup delay is induced when waking up from Stop mode.
  *                    
  * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
  *   
  * @note   When exiting Stop mode by issuing an interrupt or a wake-up event, 
  *         the HSI RC oscillator is selected as system clock.
  *           
  * @note   When the voltage regulator operates in low power mode, an additional 
  *         startup delay is incurred when waking up from Stop mode. 
  *         By keeping the internal regulator ON during Stop mode, the consumption 
  *         is higher although the startup time is reduced.
  *     
  * @param  Regulator specifies the regulator state in STOP mode.
  *          This parameter can be one of the following values:
  *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode 
  *                 and Flash memory in power-down when the device is in Stop under-drive mode
  *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode 
  *                and Flash memory in power-down when the device is in Stop under-drive mode
  * @param  STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.
  *          This parameter can be one of the following values:
  *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
  *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_PWREx_EnterUnderDriveSTOPMode</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Regulator</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>STOPEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_REGULATOR_UNDERDRIVE</name><argument_list>(<argument><expr><name>Regulator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_STOP_ENTRY</name><argument_list>(<argument><expr><name>STOPEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable Power ctrl clock */</comment>
  <expr_stmt><expr><call><name>__HAL_RCC_PWR_CLK_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Enable the Under-drive Mode ---------------------------------------------*/</comment>
  <comment type="block">/* Clear Under-drive flag */</comment>
  <expr_stmt><expr><call><name>__HAL_PWR_CLEAR_ODRUDR_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the Under-drive */</comment> 
  <expr_stmt><expr><call><name>__HAL_PWR_UNDERDRIVE_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Select the regulator state in STOP mode ---------------------------------*/</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <name><name>PWR</name><operator>-&gt;</operator><name>CR</name></name></expr>;</expr_stmt>
  <comment type="block">/* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>~</operator><operator>(</operator><name>PWR_CR_PDDS</name> <operator>|</operator> <name>PWR_CR_LPDS</name> <operator>|</operator> <name>PWR_CR_LPUDS</name> <operator>|</operator> <name>PWR_CR_MRUDS</name><operator>)</operator></expr>;</expr_stmt>
  
  <comment type="block">/* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <name>Regulator</name></expr>;</expr_stmt>
  
  <comment type="block">/* Store the new value */</comment>
  <expr_stmt><expr><name><name>PWR</name><operator>-&gt;</operator><name>CR</name></name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
  
  <comment type="block">/* Set SLEEPDEEP bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name> <operator>|=</operator> <name>SCB_SCR_SLEEPDEEP_Msk</name></expr>;</expr_stmt>
  
  <comment type="block">/* Select STOP mode entry --------------------------------------------------*/</comment>
  <if_stmt><if>if<condition>(<expr><name>STOPEntry</name> <operator>==</operator> <name>PWR_SLEEPENTRY_WFI</name></expr>)</condition>
  <block>{<block_content>   
    <comment type="block">/* Request Wait For Interrupt */</comment>
    <expr_stmt><expr><call><name>__WFI</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Request Wait For Event */</comment>
    <expr_stmt><expr><call><name>__WFE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Reset SLEEPDEEP bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SLEEPDEEP_Msk</name><operator>)</operator></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_PWR_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
