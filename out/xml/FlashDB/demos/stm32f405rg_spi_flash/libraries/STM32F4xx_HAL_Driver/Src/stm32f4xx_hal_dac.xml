<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dac.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_dac.c
  * @author  MCD Application Team
  * @brief   DAC HAL module driver.
  *         This file provides firmware functions to manage the following 
  *         functionalities of the Digital to Analog Converter (DAC) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State and Errors functions      
  *     
  *
  @verbatim      
  ==============================================================================
                      ##### DAC Peripheral features #####
  ==============================================================================
    [..]        
      *** DAC Channels ***
      ====================  
    [..]
    The device integrates two 12-bit Digital Analog Converters that can 
    be used independently or simultaneously (dual mode):
      (#) DAC channel1 with DAC_OUT1 (PA4) as output
      (#) DAC channel2 with DAC_OUT2 (PA5) as output
      
      *** DAC Triggers ***
      ====================
    [..]
    Digital to Analog conversion can be non-triggered using DAC_TRIGGER_NONE
    and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register. 
    [..] 
    Digital to Analog conversion can be triggered by:
      (#) External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_TRIGGER_EXT_IT9.
          The used pin (GPIOx_Pin9) must be configured in input mode.
  
      (#) Timers TRGO: TIM2, TIM4, TIM5, TIM6, TIM7 and TIM8 
          (DAC_TRIGGER_T2_TRGO, DAC_TRIGGER_T4_TRGO...)
  
      (#) Software using DAC_TRIGGER_SOFTWARE
  
      *** DAC Buffer mode feature ***
      =============================== 
      [..] 
      Each DAC channel integrates an output buffer that can be used to 
      reduce the output impedance, and to drive external loads directly
      without having to add an external operational amplifier.
      To enable, the output buffer use  
      sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
      [..]           
      (@) Refer to the device datasheet for more details about output 
          impedance value with and without output buffer.
            
       *** DAC wave generation feature ***
       =================================== 
       [..]     
       Both DAC channels can be used to generate
         (#) Noise wave 
         (#) Triangle wave
            
       *** DAC data format ***
       =======================
       [..]   
       The DAC data format can be:
         (#) 8-bit right alignment using DAC_ALIGN_8B_R
         (#) 12-bit left alignment using DAC_ALIGN_12B_L
         (#) 12-bit right alignment using DAC_ALIGN_12B_R
  
       *** DAC data value to voltage correspondence ***  
       ================================================ 
       [..] 
       The analog output voltage on each DAC channel pin is determined
       by the following equation: 
       DAC_OUTx = VREF+ * DOR / 4095
       with  DOR is the Data Output Register
          VEF+ is the input voltage reference (refer to the device datasheet)
        e.g. To set DAC_OUT1 to 0.7V, use
          Assuming that VREF+ = 3.3V, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
  
       *** DMA requests  ***
       =====================
       [..]    
       A DMA1 request can be generated when an external trigger (but not
       a software trigger) occurs if DMA1 requests are enabled using
       HAL_DAC_Start_DMA()
       [..]
       DMA1 requests are mapped as following:
         (#) DAC channel1 : mapped on DMA1 Stream5 channel7 which must be 
             already configured
         (#) DAC channel2 : mapped on DMA1 Stream6 channel7 which must be 
             already configured
       
    -@- For Dual mode and specific signal (Triangle and noise) generation please 
        refer to Extension Features Driver description        
  
      
                      ##### How to use this driver #####
  ==============================================================================
    [..]          
      (+) DAC APB clock must be enabled to get write access to DAC
          registers using HAL_DAC_Init()
      (+) Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
      (+) Configure the DAC channel using HAL_DAC_ConfigChannel() function.
      (+) Enable the DAC channel using HAL_DAC_Start() or HAL_DAC_Start_DMA functions

     *** Polling mode IO operation ***
     =================================
     [..]    
       (+) Start the DAC peripheral using HAL_DAC_Start() 
       (+) To read the DAC last data output value, use the HAL_DAC_GetValue() function.
       (+) Stop the DAC peripheral using HAL_DAC_Stop()
       
     *** DMA mode IO operation ***    
     ==============================
     [..]    
       (+) Start the DAC peripheral using HAL_DAC_Start_DMA(), at this stage the user specify the length 
           of data to be transferred at each end of conversion 
       (+) At The end of data transfer HAL_DAC_ConvCpltCallbackCh1()or HAL_DAC_ConvCpltCallbackCh2()  
           function is executed and user can add his own code by customization of function pointer 
           HAL_DAC_ConvCpltCallbackCh1 or HAL_DAC_ConvCpltCallbackCh2
       (+) In case of transfer Error, HAL_DAC_ErrorCallbackCh1() function is executed and user can 
            add his own code by customization of function pointer HAL_DAC_ErrorCallbackCh1
       (+) Stop the DAC peripheral using HAL_DAC_Stop_DMA()
                    
    *** Callback registration ***
    =============================================
    [..]
      The compilation define  USE_HAL_DAC_REGISTER_CALLBACKS when set to 1
      allows the user to configure dynamically the driver callbacks.

    Use Functions @ref HAL_DAC_RegisterCallback() to register a user callback,
      it allows to register following callbacks:
      (+) ConvCpltCallbackCh1     : callback when a half transfer is completed on Ch1.
      (+) ConvHalfCpltCallbackCh1 : callback when a transfer is completed on Ch1.
      (+) ErrorCallbackCh1        : callback when an error occurs on Ch1.
      (+) DMAUnderrunCallbackCh1  : callback when an underrun error occurs on Ch1.
      (+) ConvCpltCallbackCh2     : callback when a half transfer is completed on Ch2.
      (+) ConvHalfCpltCallbackCh2 : callback when a transfer is completed on Ch2.
      (+) ErrorCallbackCh2        : callback when an error occurs on Ch2.
      (+) DMAUnderrunCallbackCh2  : callback when an underrun error occurs on Ch2.
      (+) MspInitCallback         : DAC MspInit.
      (+) MspDeInitCallback       : DAC MspdeInit.
      This function takes as parameters the HAL peripheral handle, the Callback ID
      and a pointer to the user callback function.

    Use function @ref HAL_DAC_UnRegisterCallback() to reset a callback to the default
      weak (surcharged) function. It allows to reset following callbacks:
      (+) ConvCpltCallbackCh1     : callback when a half transfer is completed on Ch1.
      (+) ConvHalfCpltCallbackCh1 : callback when a transfer is completed on Ch1.
      (+) ErrorCallbackCh1        : callback when an error occurs on Ch1.
      (+) DMAUnderrunCallbackCh1  : callback when an underrun error occurs on Ch1.
      (+) ConvCpltCallbackCh2     : callback when a half transfer is completed on Ch2.
      (+) ConvHalfCpltCallbackCh2 : callback when a transfer is completed on Ch2.
      (+) ErrorCallbackCh2        : callback when an error occurs on Ch2.
      (+) DMAUnderrunCallbackCh2  : callback when an underrun error occurs on Ch2.
      (+) MspInitCallback         : DAC MspInit.
      (+) MspDeInitCallback       : DAC MspdeInit.
      (+) All Callbacks
      This function) takes as parameters the HAL peripheral handle and the Callback ID.

      By default, after the @ref HAL_DAC_Init and if the state is HAL_DAC_STATE_RESET
      all callbacks are reset to the corresponding legacy weak (surcharged) functions.
      Exception done for MspInit and MspDeInit callbacks that are respectively
      reset to the legacy weak (surcharged) functions in the @ref HAL_DAC_Init
      and @ref  HAL_DAC_DeInit only when these callbacks are null (not registered beforehand).
      If not, MspInit or MspDeInit are not null, the @ref HAL_DAC_Init and @ref HAL_DAC_DeInit
      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

      Callbacks can be registered/unregistered in READY state only.
      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
      during the Init/DeInit.
      In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_DAC_RegisterCallback before calling @ref HAL_DAC_DeInit
      or @ref HAL_DAC_Init function.

      When The compilation define USE_HAL_DAC_REGISTER_CALLBACKS is set to 0 or
      not defined, the callback registering feature is not available
      and weak (surcharged) callbacks are used.
     *** DAC HAL driver macros list ***
     ============================================= 
     [..]
       Below the list of most used macros in DAC HAL driver.
       
      (+) __HAL_DAC_ENABLE : Enable the DAC peripheral
      (+) __HAL_DAC_DISABLE : Disable the DAC peripheral
      (+) __HAL_DAC_CLEAR_FLAG: Clear the DAC's pending flags
      (+) __HAL_DAC_GET_FLAG: Get the selected DAC's flag status
      
     [..]
      (@) You can refer to the DAC HAL driver header file for more useful macros  
   
 @endverbatim    
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 


<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DAC DAC
  * @brief DAC driver modules
  * @{
  */</comment> 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_DAC_MODULE_ENABLED</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F405xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F415xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F407xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F417xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup DAC_Private_Functions
  * @{
  */</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DAC_DMAConvCpltCh1</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DAC_DMAErrorCh1</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DAC_DMAHalfConvCpltCh1</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl> 
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup DAC_Exported_Functions DAC Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DAC_Exported_Functions_Group1 Initialization and de-initialization functions 
 *  @brief    Initialization and Configuration functions 
 *
@verbatim    
  ==============================================================================
              ##### Initialization and de-initialization functions #####
  ==============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the DAC. 
      (+) De-initialize the DAC. 
         
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the DAC peripheral according to the specified parameters
  *         in the DAC_InitStruct.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_Init</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <comment type="block">/* Check DAC handle */</comment>
  <if_stmt><if>if<condition>(<expr><name>hdac</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DAC_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Init the DAC Callback settings */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh1</name></name>           <operator>=</operator> <name>HAL_DAC_ConvCpltCallbackCh1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh1</name></name>       <operator>=</operator> <name>HAL_DAC_ConvHalfCpltCallbackCh1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh1</name></name>              <operator>=</operator> <name>HAL_DAC_ErrorCallbackCh1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh1</name></name>        <operator>=</operator> <name>HAL_DAC_DMAUnderrunCallbackCh1</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh2</name></name>           <operator>=</operator> <name>HAL_DACEx_ConvCpltCallbackCh2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh2</name></name>       <operator>=</operator> <name>HAL_DACEx_ConvHalfCpltCallbackCh2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh2</name></name>              <operator>=</operator> <name>HAL_DACEx_ErrorCallbackCh2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh2</name></name>        <operator>=</operator> <name>HAL_DACEx_DMAUnderrunCallbackCh2</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name>               <operator>=</operator> <name>HAL_DAC_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name>HAL_DAC_MspInit</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Initialize the DAC state*/</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Set DAC error code to none */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DAC_ERROR_NONE</name></expr>;</expr_stmt>
  
  <comment type="block">/* Initialize the DAC state*/</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_DeInit</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check DAC handle */</comment>
  <if_stmt><if>if<condition>(<expr><name>hdac</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_BUSY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if<condition>(<expr><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_DAC_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name>HAL_DAC_MspDeInit</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Set DAC error code to none */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DAC_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the DAC MSP.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DAC_MspInit</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_MspInit could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the DAC MSP.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.  
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DAC_MspDeInit</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_MspDeInit could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DAC_Exported_Functions_Group2 IO operation functions
 *  @brief    IO operation functions 
 *
@verbatim   
  ==============================================================================
             ##### IO operation functions #####
  ==============================================================================  
    [..]  This section provides functions allowing to:
      (+) Start conversion.
      (+) Stop conversion.
      (+) Start conversion and enable DMA transfer.
      (+) Stop conversion and disable DMA transfer.
      (+) Get result of conversion.
                     
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Enables DAC and starts conversion of channel.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @param  Channel The selected DAC channel. 
  *          This parameter can be one of the following values:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_Start</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp2</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_CHANNEL</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_DAC_ENABLE</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>Channel</name> <operator>==</operator> <name>DAC_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DAC_CR_TEN1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DAC_CR_TSEL1</name></expr>;</expr_stmt>
    <comment type="block">/* Check if software trigger enabled */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>tmp1</name> <operator>==</operator>  <name>DAC_CR_TEN1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp2</name> <operator>==</operator>  <name>DAC_CR_TSEL1</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable the selected DAC software conversion */</comment>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SWTRIGR</name></name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DAC_SWTRIGR_SWTRIG1</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DAC_CR_TEN2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DAC_CR_TSEL2</name></expr>;</expr_stmt>    
    <comment type="block">/* Check if software trigger enabled */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>tmp1</name> <operator>==</operator> <name>DAC_CR_TEN2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp2</name> <operator>==</operator> <name>DAC_CR_TSEL2</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable the selected DAC software conversion*/</comment>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SWTRIGR</name></name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DAC_SWTRIGR_SWTRIG2</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables DAC and stop conversion of channel.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @param  Channel The selected DAC channel. 
  *          This parameter can be one of the following values:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_Stop</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_CHANNEL</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_DAC_DISABLE</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables DAC and starts conversion of channel.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @param  Channel The selected DAC channel. 
  *          This parameter can be one of the following values:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @param  pData The destination peripheral Buffer address.
  * @param  Length The length of data to be transferred from memory to DAC peripheral
  * @param  Alignment Specifies the data alignment for DAC channel.
  *          This parameter can be one of the following values:
  *            @arg DAC_ALIGN_8B_R: 8bit right data alignment selected
  *            @arg DAC_ALIGN_12B_L: 12bit left data alignment selected
  *            @arg DAC_ALIGN_12B_R: 12bit right data alignment selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_Start_DMA</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>pData</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Length</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Alignment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
    
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_CHANNEL</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_ALIGN</name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_BUSY</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>Channel</name> <operator>==</operator> <name>DAC_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set the DMA transfer complete callback for channel1 */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle1</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>DAC_DMAConvCpltCh1</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA half transfer complete callback for channel1 */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle1</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>DAC_DMAHalfConvCpltCh1</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA error callback for channel1 */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle1</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>DAC_DMAErrorCh1</name></expr>;</expr_stmt>

    <comment type="block">/* Enable the selected DAC channel1 DMA request */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>DAC_CR_DMAEN1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Case of use of channel 1 */</comment>
    <switch>switch<condition>(<expr><name>Alignment</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>DAC_ALIGN_12B_R</name></expr>:</case>
        <comment type="block">/* Get DHR12R1 address */</comment>
        <expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DHR12R1</name></name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DAC_ALIGN_12B_L</name></expr>:</case>
        <comment type="block">/* Get DHR12L1 address */</comment>
        <expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DHR12L1</name></name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DAC_ALIGN_8B_R</name></expr>:</case>
        <comment type="block">/* Get DHR8R1 address */</comment>
        <expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DHR8R1</name></name></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Set the DMA transfer complete callback for channel2 */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle2</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>DAC_DMAConvCpltCh2</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA half transfer complete callback for channel2 */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle2</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>DAC_DMAHalfConvCpltCh2</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA error callback for channel2 */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle2</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>DAC_DMAErrorCh2</name></expr>;</expr_stmt>

    <comment type="block">/* Enable the selected DAC channel2 DMA request */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>DAC_CR_DMAEN2</name></expr>;</expr_stmt>

    <comment type="block">/* Case of use of channel 2 */</comment>
    <switch>switch<condition>(<expr><name>Alignment</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>DAC_ALIGN_12B_R</name></expr>:</case>
        <comment type="block">/* Get DHR12R2 address */</comment>
        <expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DHR12R2</name></name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DAC_ALIGN_12B_L</name></expr>:</case>
        <comment type="block">/* Get DHR12L2 address */</comment>
        <expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DHR12L2</name></name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DAC_ALIGN_8B_R</name></expr>:</case>
        <comment type="block">/* Get DHR8R2 address */</comment>
        <expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DHR8R2</name></name></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Enable the DMA Stream */</comment>
  <if_stmt><if>if<condition>(<expr><name>Channel</name> <operator>==</operator> <name>DAC_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the DAC DMA underrun interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_DAC_ENABLE_IT</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>DAC_IT_DMAUDR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable the DMA Stream */</comment>
    <expr_stmt><expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>tmpreg</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> 
  <else>else
  <block>{<block_content>
    <comment type="block">/* Enable the DAC DMA underrun interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_DAC_ENABLE_IT</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>DAC_IT_DMAUDR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable the DMA Stream */</comment>
    <expr_stmt><expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>tmpreg</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_DAC_ENABLE</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables DAC and stop conversion of channel.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @param  Channel The selected DAC channel. 
  *          This parameter can be one of the following values:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected   
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_Stop_DMA</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_CHANNEL</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Disable the selected DAC channel DMA request */</comment>
   <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DAC_CR_DMAEN1</name> <operator>&lt;&lt;</operator> <name>Channel</name><operator>)</operator></expr>;</expr_stmt>
    
  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_DAC_DISABLE</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Disable the DMA Channel */</comment>
  <comment type="block">/* Channel1 is used */</comment>
  <if_stmt><if>if<condition>(<expr><name>Channel</name> <operator>==</operator> <name>DAC_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content> 
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <comment type="block">/* Channel2 is used for */</comment>
  <block>{<block_content> 
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMA_Handle2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Check if DMA Channel effectively disabled */</comment>
  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update DAC state machine to error */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_ERROR</name></expr>;</expr_stmt>      
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Change DAC state */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_READY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Returns the last data output value of the selected DAC channel.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @param  Channel The selected DAC channel. 
  *          This parameter can be one of the following values:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @retval The selected DAC channel data output value.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_DAC_GetValue</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_CHANNEL</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Returns the DAC channel data output register value */</comment>
  <if_stmt><if>if<condition>(<expr><name>Channel</name> <operator>==</operator> <name>DAC_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DOR1</name></name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DOR2</name></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handles DAC interrupt request  
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_DAC_IRQHandler</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check underrun channel 1 flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_DAC_GET_FLAG</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>DAC_FLAG_DMAUDR1</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Change DAC state to error state */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_ERROR</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set DAC error code to channel1 DMA underrun error */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_DMAUNDERRUNCH1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Clear the underrun flag */</comment>
    <expr_stmt><expr><call><name>__HAL_DAC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>,<argument><expr><name>DAC_FLAG_DMAUDR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Disable the selected DAC channel1 DMA request */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DAC_CR_DMAEN1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Error callback */</comment> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh1</name></name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_DAC_DMAUnderrunCallbackCh1</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Check underrun channel 2 flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_DAC_GET_FLAG</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>, <argument><expr><name>DAC_FLAG_DMAUDR2</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Change DAC state to error state */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_ERROR</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set DAC error code to channel2 DMA underrun error */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_DMAUNDERRUNCH2</name></expr>;</expr_stmt>
    
    <comment type="block">/* Clear the underrun flag */</comment>
    <expr_stmt><expr><call><name>__HAL_DAC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>,<argument><expr><name>DAC_FLAG_DMAUDR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Disable the selected DAC channel1 DMA request */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DAC_CR_DMAEN2</name></expr>;</expr_stmt>
    
    <comment type="block">/* Error callback */</comment> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh2</name></name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_DACEx_DMAUnderrunCallbackCh2</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Conversion complete callback in non blocking mode for Channel1 
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DAC_ConvCpltCallbackCh1</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ConvCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Conversion half DMA transfer callback in non blocking mode for Channel1 
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DAC_ConvHalfCpltCallbackCh1</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ConvHalfCpltCallbackCh1 could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Error DAC callback for Channel1.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DAC_ErrorCallbackCh1</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name> <modifier>*</modifier></type><name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ErrorCallbackCh1 could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA underrun DAC callback for channel1.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DAC_DMAUnderrunCallbackCh1</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name> <modifier>*</modifier></type><name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_DMAUnderrunCallbackCh1 could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<comment type="block" format="doxygen">/** @defgroup DAC_Exported_Functions_Group3 Peripheral Control functions
 *  @brief   	Peripheral Control functions 
 *
@verbatim   
  ==============================================================================
             ##### Peripheral Control functions #####
  ==============================================================================  
    [..]  This section provides functions allowing to:
      (+) Configure channels. 
      (+) Set the specified data holding register value for DAC channel.
      
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Configures the selected DAC channel.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @param  sConfig DAC configuration structure.
  * @param  Channel The selected DAC channel. 
  *          This parameter can be one of the following values:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_ConfigChannel</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>, <parameter><decl><type><name>DAC_ChannelConfTypeDef</name><modifier>*</modifier></type> <name>sConfig</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmpreg2</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the DAC parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_TRIGGER</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>DAC_Trigger</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_OUTPUT_BUFFER_STATE</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>DAC_OutputBuffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_CHANNEL</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get the DAC CR value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name></expr>;</expr_stmt>
  <comment type="block">/* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>DAC_CR_MAMP1</name> <operator>|</operator> <name>DAC_CR_WAVE1</name> <operator>|</operator> <name>DAC_CR_TSEL1</name> <operator>|</operator> <name>DAC_CR_TEN1</name> <operator>|</operator> <name>DAC_CR_BOFF1</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name>Channel</name><operator>)</operator></expr>;</expr_stmt>
  <comment type="block">/* Configure for the selected DAC channel: buffer output, trigger */</comment>
  <comment type="block">/* Set TSELx and TENx bits according to DAC_Trigger value */</comment>
  <comment type="block">/* Set BOFFx bit according to DAC_OutputBuffer value */</comment>   
  <expr_stmt><expr><name>tmpreg2</name> <operator>=</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>DAC_Trigger</name></name> <operator>|</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>DAC_OutputBuffer</name></name><operator>)</operator></expr>;</expr_stmt>
  <comment type="block">/* Calculate CR register value depending on DAC_Channel */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <name>tmpreg2</name> <operator>&lt;&lt;</operator> <name>Channel</name></expr>;</expr_stmt>
  <comment type="block">/* Write to DAC CR */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
  <comment type="block">/* Disable wave generation */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DAC_CR_WAVE1</name> <operator>&lt;&lt;</operator> <name>Channel</name><operator>)</operator></expr>;</expr_stmt>
  
  <comment type="block">/* Change DAC state */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DAC_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Set the specified data holding register value for DAC channel.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @param  Channel The selected DAC channel. 
  *          This parameter can be one of the following values:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected  
  * @param  Alignment Specifies the data alignment.
  *          This parameter can be one of the following values:
  *            @arg DAC_ALIGN_8B_R: 8bit right data alignment selected
  *            @arg DAC_ALIGN_12B_L: 12bit left data alignment selected
  *            @arg DAC_ALIGN_12B_R: 12bit right data alignment selected
  * @param  Data Data to be loaded in the selected data holding register.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_SetValue</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Alignment</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_CHANNEL</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_ALIGN</name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DAC_DATA</name><argument_list>(<argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hdac</name><operator>-&gt;</operator><name>Instance</name></name></expr>;</expr_stmt> 
  <if_stmt><if>if<condition>(<expr><name>Channel</name> <operator>==</operator> <name>DAC_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp</name> <operator>+=</operator> <call><name>DAC_DHR12R1_ALIGNMENT</name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>tmp</name> <operator>+=</operator> <call><name>DAC_DHR12R2_ALIGNMENT</name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the DAC channel1 selected data holding register */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>tmp</name> <operator>=</operator> <name>Data</name></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DAC_Exported_Functions_Group4 Peripheral State and Errors functions
 *  @brief   Peripheral State and Errors functions 
 *
@verbatim   
  ==============================================================================
            ##### Peripheral State and Errors functions #####
  ==============================================================================  
    [..]
    This subsection provides functions allowing to
      (+) Check the DAC state.
      (+) Check the DAC Errors.
        
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  return the DAC state
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_DAC_StateTypeDef</name></type> <name>HAL_DAC_GetState</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return DAC state */</comment>
  <return>return <expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Return the DAC error code
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval DAC Error Code
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_DAC_GetError</name><parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name> <modifier>*</modifier></type><name>hdac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup DAC_Exported_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup DAC_Exported_Functions_Group1
  * @{
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User DAC Callback
  *         To be used instead of the weak (surcharged) predefined callback
  * @param hdac DAC handle
  * @param  CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_DAC_ERROR_INVALID_CALLBACK   DAC Error Callback ID
  *          @arg @ref HAL_DAC_CH1_COMPLETE_CB_ID       DAC CH1 Complete Callback ID
  *          @arg @ref HAL_DAC_CH1_HALF_COMPLETE_CB_ID  DAC CH1 Half Complete Callback ID
  *          @arg @ref HAL_DAC_CH1_ERROR_ID             DAC CH1 Error Callback ID
  *          @arg @ref HAL_DAC_CH1_UNDERRUN_CB_ID       DAC CH1 UnderRun Callback ID
  *          @arg @ref HAL_DAC_CH2_COMPLETE_CB_ID       DAC CH2 Complete Callback ID
  *          @arg @ref HAL_DAC_CH2_HALF_COMPLETE_CB_ID  DAC CH2 Half Complete Callback ID
  *          @arg @ref HAL_DAC_CH2_ERROR_ID             DAC CH2 Error Callback ID
  *          @arg @ref HAL_DAC_CH2_UNDERRUN_CB_ID       DAC CH2 UnderRun Callback ID
  *          @arg @ref HAL_DAC_MSP_INIT_CB_ID           DAC MSP Init Callback ID
  *          @arg @ref HAL_DAC_MSP_DEINIT_CB_ID         DAC MSP DeInit Callback ID
  *
    * @param pCallback pointer to the Callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_RegisterCallback</name> <parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name> <modifier>*</modifier></type><name>hdac</name></decl></parameter>, <parameter><decl><type><name>HAL_DAC_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pDAC_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DAC_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_DAC_CH1_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh1</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH1_HALF_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh1</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH1_ERROR_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh1</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH1_UNDERRUN_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh1</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh2</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_HALF_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh2</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_ERROR_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh2</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_UNDERRUN_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh2</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* Update the error code */</comment>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DAC_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_DAC_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* Update the error code */</comment>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    <comment type="block">/* update return status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a User DAC Callback
  *         DAC Callback is redirected to the weak (surcharged) predefined callback
  * @param hdac DAC handle
  * @param  CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_DAC_CH1_COMPLETE_CB_ID          DAC CH1 tranfer Complete Callback ID
  *          @arg @ref HAL_DAC_CH1_HALF_COMPLETE_CB_ID     DAC CH1 Half Complete Callback ID
  *          @arg @ref HAL_DAC_CH1_ERROR_ID                DAC CH1 Error Callback ID
  *          @arg @ref HAL_DAC_CH1_UNDERRUN_CB_ID          DAC CH1 UnderRun Callback ID
  *          @arg @ref HAL_DAC_CH2_COMPLETE_CB_ID          DAC CH2 Complete Callback ID
  *          @arg @ref HAL_DAC_CH2_HALF_COMPLETE_CB_ID     DAC CH2 Half Complete Callback ID
  *          @arg @ref HAL_DAC_CH2_ERROR_ID                DAC CH2 Error Callback ID
  *          @arg @ref HAL_DAC_CH2_UNDERRUN_CB_ID          DAC CH2 UnderRun Callback ID
  *          @arg @ref HAL_DAC_MSP_INIT_CB_ID              DAC MSP Init Callback ID
  *          @arg @ref HAL_DAC_MSP_DEINIT_CB_ID            DAC MSP DeInit Callback ID
  *          @arg @ref HAL_DAC_ALL_CB_ID                   DAC All callbacks
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DAC_UnRegisterCallback</name> <parameter_list>(<parameter><decl><type><name>DAC_HandleTypeDef</name> <modifier>*</modifier></type><name>hdac</name></decl></parameter>, <parameter><decl><type><name>HAL_DAC_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DAC_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_DAC_CH1_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_ConvCpltCallbackCh1</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH1_HALF_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_ConvHalfCpltCallbackCh1</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH1_ERROR_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_ErrorCallbackCh1</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH1_UNDERRUN_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_DMAUnderrunCallbackCh1</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_ConvCpltCallbackCh2</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_HALF_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_ConvHalfCpltCallbackCh2</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_ERROR_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_ErrorCallbackCh2</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_CH2_UNDERRUN_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_DMAUnderrunCallbackCh2</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_DAC_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_DAC_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_ALL_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_ConvCpltCallbackCh1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_ConvHalfCpltCallbackCh1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_ErrorCallbackCh1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh1</name></name> <operator>=</operator> <name>HAL_DAC_DMAUnderrunCallbackCh1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_ConvCpltCallbackCh2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_ConvHalfCpltCallbackCh2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_ErrorCallbackCh2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>DMAUnderrunCallbackCh2</name></name> <operator>=</operator> <name>HAL_DACEx_DMAUnderrunCallbackCh2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_DAC_MspInit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_DAC_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* Update the error code */</comment>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DAC_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_DAC_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_DAC_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_DAC_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_DAC_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* Update the error code */</comment>
      <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    <comment type="block">/* update return status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup DAC_Private_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  DMA conversion complete callback. 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DAC_DMAConvCpltCh1</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
  <decl_stmt><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name> <init>= <expr><operator>(</operator> <name>DAC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hdac</name><operator>-&gt;</operator><name>ConvCpltCallbackCh1</name></name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_DAC_ConvCpltCallbackCh1</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>
  
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_DAC_STATE_READY</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA half transfer complete callback. 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DAC_DMAHalfConvCpltCh1</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
    <decl_stmt><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name> <init>= <expr><operator>(</operator> <name>DAC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Conversion complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hdac</name><operator>-&gt;</operator><name>ConvHalfCpltCallbackCh1</name></name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_DAC_ConvHalfCpltCallbackCh1</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA error callback 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DAC_DMAErrorCh1</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
  <decl_stmt><decl><type><name>DAC_HandleTypeDef</name><modifier>*</modifier></type> <name>hdac</name> <init>= <expr><operator>(</operator> <name>DAC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
    
  <comment type="block">/* Set DAC error code to DMA error */</comment>
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DAC_ERROR_DMA</name></expr>;</expr_stmt>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DAC_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hdac</name><operator>-&gt;</operator><name>ErrorCallbackCh1</name></name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_DAC_ErrorCallbackCh1</name><argument_list>(<argument><expr><name>hdac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DAC_REGISTER_CALLBACKS */</comment>
    
  <expr_stmt><expr><name><name>hdac</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_DAC_STATE_READY</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx ||\
          STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||\
          STM32F410xx || STM32F446xx || STM32F469xx || STM32F479xx ||\
		  STM32F413xx || STM32F423xx */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_DAC_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
