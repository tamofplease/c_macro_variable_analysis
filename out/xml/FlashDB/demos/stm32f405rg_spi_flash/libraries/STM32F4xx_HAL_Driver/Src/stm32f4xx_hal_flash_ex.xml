<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_flash_ex.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_flash_ex.c
  * @author  MCD Application Team
  * @brief   Extended FLASH HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of the FLASH extension peripheral:
  *           + Extended programming operations functions
  *  
  @verbatim
  ==============================================================================
                   ##### Flash Extension features #####
  ==============================================================================
           
  [..] Comparing to other previous devices, the FLASH interface for STM32F427xx/437xx and 
       STM32F429xx/439xx devices contains the following additional features 
       
       (+) Capacity up to 2 Mbyte with dual bank architecture supporting read-while-write
           capability (RWW)
       (+) Dual bank memory organization       
       (+) PCROP protection for all banks
   
                      ##### How to use this driver #####
  ==============================================================================
  [..] This driver provides functions to configure and program the FLASH memory 
       of all STM32F427xx/437xx, STM32F429xx/439xx, STM32F469xx/479xx and STM32F446xx 
       devices. It includes
      (#) FLASH Memory Erase functions: 
           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
                HAL_FLASH_Lock() functions
           (++) Erase function: Erase sector, erase all sectors
           (++) There are two modes of erase :
             (+++) Polling Mode using HAL_FLASHEx_Erase()
             (+++) Interrupt Mode using HAL_FLASHEx_Erase_IT()
             
      (#) Option Bytes Programming functions: Use HAL_FLASHEx_OBProgram() to :
           (++) Set/Reset the write protection
           (++) Set the Read protection Level
           (++) Set the BOR level
           (++) Program the user Option Bytes
      (#) Advanced Option Bytes Programming functions: Use HAL_FLASHEx_AdvOBProgram() to :  
       (++) Extended space (bank 2) erase function
       (++) Full FLASH space (2 Mo) erase (bank 1 and bank 2)
       (++) Dual Boot activation
       (++) Write protection configuration for bank 2
       (++) PCROP protection configuration and control for both banks
  
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup FLASHEx FLASHEx
  * @brief FLASH HAL Extension module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_FLASH_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup FLASHEx_Private_Constants
  * @{
  */</comment>    
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLASH_TIMEOUT_VALUE</name></cpp:macro>       <cpp:value>50000U</cpp:value></cpp:define> <comment type="block">/* 50 s */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
    
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup FLASHEx_Private_Variables
  * @{
  */</comment>    
<decl_stmt><decl><type><specifier>extern</specifier> <name>FLASH_ProcessTypeDef</name></type> <name>pFlash</name></decl>;</decl_stmt>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup FLASHEx_Private_Functions
  * @{
  */</comment>
<comment type="block">/* Option bytes control */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type>               <name>FLASH_MassErase</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>VoltageRange</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type>  <name>FLASH_OB_EnableWRP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WRPSector</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type>  <name>FLASH_OB_DisableWRP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WRPSector</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type>  <name>FLASH_OB_RDP_LevelConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>Level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type>  <name>FLASH_OB_UserConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>Iwdg</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Stop</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Stdby</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type>  <name>FLASH_OB_BOR_LevelConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>Level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint8_t</name></type>            <name>FLASH_OB_GetUser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint16_t</name></type>           <name>FLASH_OB_GetWRP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint8_t</name></type>            <name>FLASH_OB_GetRDP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint8_t</name></type>            <name>FLASH_OB_GetBOR</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type>  <name>FLASH_OB_EnablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Sector</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type>  <name>FLASH_OB_DisablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Sector</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
          STM32F413xx || STM32F423xx */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call><operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if> 
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_EnablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>SectorBank1</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SectorBank2</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_DisablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>SectorBank1</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SectorBank2</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_BootConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>BootConfig</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */</comment>

<function_decl><type><specifier>extern</specifier> <name>HAL_StatusTypeDef</name></type>         <name>FLASH_WaitForLastOperation</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup FLASHEx_Exported_Functions_Group1 Extended IO operation functions
 *  @brief   Extended IO operation functions 
 *
@verbatim   
 ===============================================================================
                ##### Extended programming operation functions #####
 ===============================================================================  
    [..]
    This subsection provides a set of functions allowing to manage the Extension FLASH 
    programming operations.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Perform a mass erase or erase the specified FLASH memory sectors 
  * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
  *         contains the configuration information for the erasing.
  * 
  * @param[out]  SectorError pointer to variable  that
  *         contains the configuration information on faulty sector in case of error 
  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASHEx_Erase</name><parameter_list>(<parameter><decl><type><name>FLASH_EraseInitTypeDef</name> <modifier>*</modifier></type><name>pEraseInit</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>SectorError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_TYPEERASE</name><argument_list>(<argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>TypeErase</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*Initialization of SectorError variable*/</comment>
    <expr_stmt><expr><operator>*</operator><name>SectorError</name> <operator>=</operator> <literal type="number">0xFFFFFFFFU</literal></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>TypeErase</name></name> <operator>==</operator> <name>FLASH_TYPEERASE_MASSERASE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*Mass erase to be done*/</comment>
      <expr_stmt><expr><call><name>FLASH_MassErase</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>VoltageRange</name></name></expr></argument>, <argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>Banks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Wait for last operation to be completed */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* if the erase operation is completed, disable the MER Bit */</comment>
      <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>FLASH_MER_BIT</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_NBSECTORS</name><argument_list>(<argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>NbSectors</name></name> <operator>+</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>Sector</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Erase by sector by sector to be done*/</comment>
      <for>for<control>(<init><expr><name>index</name> <operator>=</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>Sector</name></name></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <operator>(</operator><name><name>pEraseInit</name><operator>-&gt;</operator><name>NbSectors</name></name> <operator>+</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>Sector</name></name><operator>)</operator></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
        <expr_stmt><expr><call><name>FLASH_Erase_Sector</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>VoltageRange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Wait for last operation to be completed */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* If the erase operation is completed, disable the SER and SNB Bits */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FLASH_CR_SER</name> <operator>|</operator> <name>FLASH_CR_SNB</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>status</name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition> 
        <block>{<block_content>
          <comment type="block">/* In case of error, stop erase procedure and return the faulty sector*/</comment>
          <expr_stmt><expr><operator>*</operator><name>SectorError</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Flush the caches to be sure of the data consistency */</comment>
    <expr_stmt><expr><call><name>FLASH_FlushCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Perform a mass erase or erase the specified FLASH memory sectors  with interrupt enabled
  * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
  *         contains the configuration information for the erasing.
  * 
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASHEx_Erase_IT</name><parameter_list>(<parameter><decl><type><name>FLASH_EraseInitTypeDef</name> <modifier>*</modifier></type><name>pEraseInit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_TYPEERASE</name><argument_list>(<argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>TypeErase</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable End of FLASH Operation interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_FLASH_ENABLE_IT</name><argument_list>(<argument><expr><name>FLASH_IT_EOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable Error source interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_FLASH_ENABLE_IT</name><argument_list>(<argument><expr><name>FLASH_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Clear pending flags (if any) */</comment>  
  <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_EOP</name>    <operator>|</operator> <name>FLASH_FLAG_OPERR</name> <operator>|</operator> <name>FLASH_FLAG_WRPERR</name> <operator>|</operator>\
                         <name>FLASH_FLAG_PGAERR</name> <operator>|</operator> <name>FLASH_FLAG_PGPERR</name><operator>|</operator> <name>FLASH_FLAG_PGSERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
  
  <if_stmt><if>if<condition>(<expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>TypeErase</name></name> <operator>==</operator> <name>FLASH_TYPEERASE_MASSERASE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*Mass erase to be done*/</comment>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>=</operator> <name>FLASH_PROC_MASSERASE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>Bank</name></name> <operator>=</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>Banks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FLASH_MassErase</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>VoltageRange</name></name></expr></argument>, <argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>Banks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Erase by sector to be done*/</comment>

    <comment type="block">/* Check the parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_NBSECTORS</name><argument_list>(<argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>NbSectors</name></name> <operator>+</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>Sector</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>=</operator> <name>FLASH_PROC_SECTERASE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>NbSectorsToErase</name></name> <operator>=</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>NbSectors</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>Sector</name></name> <operator>=</operator> <name><name>pEraseInit</name><operator>-&gt;</operator><name>Sector</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>VoltageForErase</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>pEraseInit</name><operator>-&gt;</operator><name>VoltageRange</name></name></expr>;</expr_stmt>

    <comment type="block">/*Erase 1st sector and wait for IT*/</comment>
    <expr_stmt><expr><call><name>FLASH_Erase_Sector</name><argument_list>(<argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>Sector</name></name></expr></argument>, <argument><expr><name><name>pEraseInit</name><operator>-&gt;</operator><name>VoltageRange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief   Program option bytes
  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
  *         contains the configuration information for the programming.
  * 
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASHEx_OBProgram</name><parameter_list>(<parameter><decl><type><name>FLASH_OBProgramInitTypeDef</name> <modifier>*</modifier></type><name>pOBInit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_ERROR</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OPTIONBYTE</name><argument_list>(<argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>OptionType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*Write protection configuration*/</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>pOBInit</name><operator>-&gt;</operator><name>OptionType</name></name> <operator>&amp;</operator> <name>OPTIONBYTE_WRP</name><operator>)</operator> <operator>==</operator> <name>OPTIONBYTE_WRP</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_WRPSTATE</name><argument_list>(<argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>WRPState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>pOBInit</name><operator>-&gt;</operator><name>WRPState</name></name> <operator>==</operator> <name>OB_WRPSTATE_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*Enable of Write protection on the selected Sector*/</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_EnableWRP</name><argument_list>(<argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>WRPSector</name></name></expr></argument>, <argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>Banks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/*Disable of Write protection on the selected Sector*/</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_DisableWRP</name><argument_list>(<argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>WRPSector</name></name></expr></argument>, <argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>Banks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*Read protection configuration*/</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>pOBInit</name><operator>-&gt;</operator><name>OptionType</name></name> <operator>&amp;</operator> <name>OPTIONBYTE_RDP</name><operator>)</operator> <operator>==</operator> <name>OPTIONBYTE_RDP</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_RDP_LevelConfig</name><argument_list>(<argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>RDPLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*USER  configuration*/</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>pOBInit</name><operator>-&gt;</operator><name>OptionType</name></name> <operator>&amp;</operator> <name>OPTIONBYTE_USER</name><operator>)</operator> <operator>==</operator> <name>OPTIONBYTE_USER</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_UserConfig</name><argument_list>(<argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>USERConfig</name></name><operator>&amp;</operator><name>OB_IWDG_SW</name></expr></argument>, 
                                     <argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>USERConfig</name></name><operator>&amp;</operator><name>OB_STOP_NO_RST</name></expr></argument>,
                                     <argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>USERConfig</name></name><operator>&amp;</operator><name>OB_STDBY_NO_RST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*BOR Level  configuration*/</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>pOBInit</name><operator>-&gt;</operator><name>OptionType</name></name> <operator>&amp;</operator> <name>OPTIONBYTE_BOR</name><operator>)</operator> <operator>==</operator> <name>OPTIONBYTE_BOR</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_BOR_LevelConfig</name><argument_list>(<argument><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>BORLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief   Get the Option byte configuration
  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
  *         contains the configuration information for the programming.
  * 
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_FLASHEx_OBGetConfig</name><parameter_list>(<parameter><decl><type><name>FLASH_OBProgramInitTypeDef</name> <modifier>*</modifier></type><name>pOBInit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>OptionType</name></name> <operator>=</operator> <name>OPTIONBYTE_WRP</name> <operator>|</operator> <name>OPTIONBYTE_RDP</name> <operator>|</operator> <name>OPTIONBYTE_USER</name> <operator>|</operator> <name>OPTIONBYTE_BOR</name></expr>;</expr_stmt>

  <comment type="block">/*Get WRP*/</comment>
  <expr_stmt><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>WRPSector</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>FLASH_OB_GetWRP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*Get RDP Level*/</comment>
  <expr_stmt><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>RDPLevel</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>FLASH_OB_GetRDP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*Get USER*/</comment>
  <expr_stmt><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>USERConfig</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>FLASH_OB_GetUser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*Get BOR Level*/</comment>
  <expr_stmt><expr><name><name>pOBInit</name><operator>-&gt;</operator><name>BORLevel</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>FLASH_OB_GetBOR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief   Program option bytes
  * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that
  *         contains the configuration information for the programming.
  * 
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASHEx_AdvOBProgram</name> <parameter_list>(<parameter><decl><type><name>FLASH_AdvOBProgramInitTypeDef</name> <modifier>*</modifier></type><name>pAdvOBInit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_ERROR</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OBEX</name><argument_list>(<argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>OptionType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*Program PCROP option byte*/</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>OptionType</name></name><operator>)</operator> <operator>&amp;</operator> <name>OPTIONBYTE_PCROP</name><operator>)</operator> <operator>==</operator> <name>OPTIONBYTE_PCROP</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check the parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PCROPSTATE</name><argument_list>(<argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>PCROPState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>PCROPState</name></name><operator>)</operator> <operator>==</operator> <name>OB_PCROP_STATE_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*Enable of Write protection on the selected Sector*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_EnablePCROP</name><argument_list>(<argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>Sectors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_EnablePCROP</name><argument_list>(<argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>SectorsBank1</name></name></expr></argument>, <argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>SectorsBank2</name></name></expr></argument>, <argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>Banks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
          STM32F413xx || STM32F423xx */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/*Disable of Write protection on the selected Sector*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_DisablePCROP</name><argument_list>(<argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>Sectors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_DisablePCROP</name><argument_list>(<argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>SectorsBank1</name></name></expr></argument>, <argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>SectorsBank2</name></name></expr></argument>, <argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>Banks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
          STM32F413xx || STM32F423xx */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
   
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/*Program BOOT config option byte*/</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>OptionType</name></name><operator>)</operator> <operator>&amp;</operator> <name>OPTIONBYTE_BOOTCONFIG</name><operator>)</operator> <operator>==</operator> <name>OPTIONBYTE_BOOTCONFIG</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_OB_BootConfig</name><argument_list>(<argument><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>BootConfig</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */</comment>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief   Get the OBEX byte configuration
  * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that
  *         contains the configuration information for the programming.
  * 
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_FLASHEx_AdvOBGetConfig</name><parameter_list>(<parameter><decl><type><name>FLASH_AdvOBProgramInitTypeDef</name> <modifier>*</modifier></type><name>pAdvOBInit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/*Get Sector*/</comment>
  <expr_stmt><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>Sectors</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR_BYTE2_ADDRESS</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */</comment>
  <comment type="block">/*Get Sector for Bank1*/</comment>
  <expr_stmt><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>SectorsBank1</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR_BYTE2_ADDRESS</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/*Get Sector for Bank2*/</comment>
  <expr_stmt><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>SectorsBank2</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR1_BYTE2_ADDRESS</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/*Get Boot config OB*/</comment>
  <expr_stmt><expr><name><name>pAdvOBInit</name><operator>-&gt;</operator><name>BootConfig</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
          STM32F413xx || STM32F423xx */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Select the Protection Mode 
  * 
  * @note   After PCROP activated Option Byte modification NOT POSSIBLE! excepted 
  *         Global Read Out Protection modification (from level1 to level0) 
  * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
  * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
  * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F401xx/STM32F411xx/STM32F446xx/
  *         STM32F469xx/STM32F479xx/STM32F412xx/STM32F413xx devices.
  * 
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASHEx_OB_SelectPCROP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>optiontmp</name> <init>= <expr><literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Mask SPRMOD bit */</comment>
  <expr_stmt><expr><name>optiontmp</name> <operator>=</operator>  <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE3_ADDRESS</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt> 
  
  <comment type="block">/* Update Option Byte */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE3_ADDRESS</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>OB_PCROP_SELECTED</name> <operator>|</operator> <name>optiontmp</name><operator>)</operator></expr>;</expr_stmt> 
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Deselect the Protection Mode 
  * 
  * @note   After PCROP activated Option Byte modification NOT POSSIBLE! excepted 
  *         Global Read Out Protection modification (from level1 to level0) 
  * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
  * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
  * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F401xx/STM32F411xx/STM32F446xx/
  *         STM32F469xx/STM32F479xx/STM32F412xx/STM32F413xx devices.
  * 
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASHEx_OB_DeSelectPCROP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>optiontmp</name> <init>= <expr><literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Mask SPRMOD bit */</comment>
  <expr_stmt><expr><name>optiontmp</name> <operator>=</operator>  <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE3_ADDRESS</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt> 
  
  <comment type="block">/* Update Option Byte */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE3_ADDRESS</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>OB_PCROP_DESELECTED</name> <operator>|</operator> <name>optiontmp</name><operator>)</operator></expr>;</expr_stmt>  
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410xx ||\
          STM32F411xE || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
          STM32F413xx || STM32F423xx */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call><operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Returns the FLASH Write Protection Option Bytes value for Bank 2
  * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx devices.  
  * @retval The FLASH Write Protection  Option Bytes value
  */</comment>
<function><type><name>uint16_t</name></type> <name>HAL_FLASHEx_OB_GetBank2WRP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>                            
  <comment type="block">/* Return the FLASH write protection Register value */</comment>
  <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR1_BYTE2_ADDRESS</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Full erase of FLASH memory sectors 
  * @param  VoltageRange The device voltage range which defines the erase parallelism.  
  *          This parameter can be one of the following values:
  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
  *                                  the operation will be done by byte (8-bit) 
  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
  *                                  the operation will be done by half word (16-bit)
  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
  *                                  the operation will be done by word (32-bit)
  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
  *                                  the operation will be done by double word (64-bit)
  * 
  * @param  Banks Banks to be erased
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: Bank1 to be erased
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FLASH_MassErase</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>VoltageRange</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_VOLTAGERANGE</name><argument_list>(<argument><expr><name>VoltageRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* if the previous operation is completed, proceed to erase all sectors */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* bank1 &amp; bank2 will be erased*/</comment>
    <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_MER_BIT</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_1</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*Only bank1 will be erased*/</comment>
    <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_MER1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/*Only bank2 will be erased*/</comment>
    <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_MER2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_STRT</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>VoltageRange</name> <operator>&lt;&lt;</operator><literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Erase the specified FLASH memory sector
  * @param  Sector FLASH sector to erase
  *         The value of this parameter depend on device used within the same series      
  * @param  VoltageRange The device voltage range which defines the erase parallelism.  
  *          This parameter can be one of the following values:
  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
  *                                  the operation will be done by byte (8-bit) 
  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
  *                                  the operation will be done by half word (16-bit)
  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
  *                                  the operation will be done by word (32-bit)
  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>FLASH_Erase_Sector</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Sector</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>VoltageRange</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_psize</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_SECTOR</name><argument_list>(<argument><expr><name>Sector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_VOLTAGERANGE</name><argument_list>(<argument><expr><name>VoltageRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>VoltageRange</name> <operator>==</operator> <name>FLASH_VOLTAGE_RANGE_1</name></expr>)</condition>
  <block>{<block_content>
     <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_BYTE</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>VoltageRange</name> <operator>==</operator> <name>FLASH_VOLTAGE_RANGE_2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_HALF_WORD</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>VoltageRange</name> <operator>==</operator> <name>FLASH_VOLTAGE_RANGE_3</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_WORD</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_DOUBLE_WORD</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */</comment>
  <if_stmt><if>if<condition>(<expr><name>Sector</name> <operator>&gt;</operator> <name>FLASH_SECTOR_11</name></expr>)</condition> 
  <block>{<block_content>
    <expr_stmt><expr><name>Sector</name> <operator>+=</operator> <literal type="number">4U</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* If the previous operation is completed, proceed to erase the sector */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>tmp_psize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_SNB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_SER</name> <operator>|</operator> <operator>(</operator><name>Sector</name> <operator>&lt;&lt;</operator> <name>FLASH_CR_SNB_Pos</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_STRT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable the write protection of the desired bank1 or bank 2 sectors
  *
  * @note   When the memory read protection level is selected (RDP level = 1), 
  *         it is not possible to program or erase the flash sector i if CortexM4  
  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
  * 
  * @param  WRPSector specifies the sector(s) to be write protected.
  *          This parameter can be one of the following values:
  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_23
  *            @arg OB_WRP_SECTOR_All
  * @note   BANK2 starts from OB_WRP_SECTOR_12
  *
  * @param  Banks Enable write protection on all the sectors for the specific bank
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: WRP on all sectors of bank1
  *            @arg FLASH_BANK_2: WRP on all sectors of bank2
  *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 &amp; bank2
  *
  * @retval HAL FLASH State   
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_EnableWRP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WRPSector</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_WRP_SECTOR</name><argument_list>(<argument><expr><name>WRPSector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name>WRPSector</name> <operator>==</operator> <name>OB_WRP_SECTOR_All</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
         <operator>(</operator><name>WRPSector</name> <operator>&lt;</operator> <name>OB_WRP_SECTOR_12</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
       <if_stmt><if>if<condition>(<expr><name>WRPSector</name> <operator>==</operator> <name>OB_WRP_SECTOR_All</name></expr>)</condition>
       <block>{<block_content>
          <comment type="block">/*Write protection on all sector of BANK1*/</comment>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>WRPSector</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>  
       </block_content>}</block></if>
       <else>else
       <block>{<block_content>
          <comment type="block">/*Write protection done on sectors of BANK1*/</comment>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>WRPSector</name><operator>)</operator></expr>;</expr_stmt>  
       </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
      <comment type="block">/*Write protection done on sectors of BANK2*/</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>WRPSector</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>  
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*Write protection on all sector of BANK2*/</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>WRPSector</name> <operator>==</operator> <name>OB_WRP_SECTOR_All</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait for last operation to be completed */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content> 
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>WRPSector</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>  
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disable the write protection of the desired bank1 or bank 2 sectors
  *
  * @note   When the memory read protection level is selected (RDP level = 1), 
  *         it is not possible to program or erase the flash sector i if CortexM4  
  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
  * 
  * @param  WRPSector specifies the sector(s) to be write protected.
  *          This parameter can be one of the following values:
  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_23
  *            @arg OB_WRP_Sector_All
  * @note   BANK2 starts from OB_WRP_SECTOR_12
  *
  * @param  Banks Disable write protection on all the sectors for the specific bank
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: Bank1 to be erased
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status   
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_DisableWRP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WRPSector</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_WRP_SECTOR</name><argument_list>(<argument><expr><name>WRPSector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name>WRPSector</name> <operator>==</operator> <name>OB_WRP_SECTOR_All</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
         <operator>(</operator><name>WRPSector</name> <operator>&lt;</operator> <name>OB_WRP_SECTOR_12</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
       <if_stmt><if>if<condition>(<expr><name>WRPSector</name> <operator>==</operator> <name>OB_WRP_SECTOR_All</name></expr>)</condition>
       <block>{<block_content>
          <comment type="block">/*Write protection on all sector of BANK1*/</comment>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>WRPSector</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt> 
       </block_content>}</block></if>
       <else>else
       <block>{<block_content>
          <comment type="block">/*Write protection done on sectors of BANK1*/</comment>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>WRPSector</name></expr>;</expr_stmt> 
       </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
      <comment type="block">/*Write protection done on sectors of BANK2*/</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>WRPSector</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt> 
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*Write protection on all sector  of BANK2*/</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>WRPSector</name> <operator>==</operator> <name>OB_WRP_SECTOR_All</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait for last operation to be completed */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content> 
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>WRPSector</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the Dual Bank Boot.
  *   
  * @note   This function can be used only for STM32F42xxx/43xxx devices.
  *      
  * @param  BootConfig specifies the Dual Bank Boot Option byte.
  *          This parameter can be one of the following values:
  *            @arg OB_Dual_BootEnabled: Dual Bank Boot Enable
  *            @arg OB_Dual_BootDisabled: Dual Bank Boot Disabled
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_BootConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>BootConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_BOOT</name><argument_list>(<argument><expr><name>BootConfig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for last operation to be completed */</comment>  
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content> 
    <comment type="block">/* Set Dual Bank Boot */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>FLASH_OPTCR_BFB2</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name> <operator>|=</operator> <name>BootConfig</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable the read/write protection (PCROP) of the desired 
  *         sectors of Bank 1 and/or Bank 2.
  * @note   This function can be used only for STM32F42xxx/43xxx devices.
  * @param  SectorBank1 Specifies the sector(s) to be read/write protected or unprotected for bank1.
  *          This parameter can be one of the following values:
  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_11
  *            @arg OB_PCROP_SECTOR__All                         
  * @param  SectorBank2 Specifies the sector(s) to be read/write protected or unprotected for bank2.
  *          This parameter can be one of the following values:
  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_12 and OB_PCROP_SECTOR_23
  *            @arg OB_PCROP_SECTOR__All                         
  * @param  Banks Enable PCROP protection on all the sectors for the specific bank
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: WRP on all sectors of bank1
  *            @arg FLASH_BANK_2: WRP on all sectors of bank2
  *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 &amp; bank2
  *
  * @retval HAL Status  
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_EnablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>SectorBank1</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SectorBank2</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>SectorBank1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/*Write protection done on sectors of BANK1*/</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>SectorBank1</name></expr>;</expr_stmt> 
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>SectorBank2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/*Write protection done on sectors of BANK2*/</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>SectorBank2</name></expr>;</expr_stmt> 
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*Write protection on all sector  of BANK2*/</comment>
    <if_stmt><if>if<condition>(<expr><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>SectorBank2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Wait for last operation to be completed */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content> 
        <comment type="block">/*Write protection done on sectors of BANK2*/</comment>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>SectorBank2</name></expr>;</expr_stmt> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Disable the read/write protection (PCROP) of the desired 
  *         sectors  of Bank 1 and/or Bank 2.
  * @note   This function can be used only for STM32F42xxx/43xxx devices.
  * @param  SectorBank1 specifies the sector(s) to be read/write protected or unprotected for bank1.
  *          This parameter can be one of the following values:
  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_11
  *            @arg OB_PCROP_SECTOR__All                         
  * @param  SectorBank2 Specifies the sector(s) to be read/write protected or unprotected for bank2.
  *          This parameter can be one of the following values:
  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_12 and OB_PCROP_SECTOR_23
  *            @arg OB_PCROP_SECTOR__All                         
  * @param  Banks Disable PCROP protection on all the sectors for the specific bank
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: WRP on all sectors of bank1
  *            @arg FLASH_BANK_2: WRP on all sectors of bank2
  *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 &amp; bank2
  *
  * @retval HAL Status  
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_DisablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>SectorBank1</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SectorBank2</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>SectorBank1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/*Write protection done on sectors of BANK1*/</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>SectorBank1</name><operator>)</operator></expr>;</expr_stmt> 
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
      <comment type="block">/*Write protection done on sectors of BANK2*/</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>SectorBank2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>SectorBank2</name><operator>)</operator></expr>;</expr_stmt> 
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*Write protection on all sector  of BANK2*/</comment>
    <if_stmt><if>if<condition>(<expr><name>Banks</name> <operator>==</operator> <name>FLASH_BANK_BOTH</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>SectorBank2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="block">/* Wait for last operation to be completed */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content> 
        <comment type="block">/*Write protection done on sectors of BANK2*/</comment>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR1_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>SectorBank2</name><operator>)</operator></expr>;</expr_stmt> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F405xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F415xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F407xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F417xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Mass erase of FLASH memory
  * @param  VoltageRange The device voltage range which defines the erase parallelism.  
  *          This parameter can be one of the following values:
  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
  *                                  the operation will be done by byte (8-bit) 
  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
  *                                  the operation will be done by half word (16-bit)
  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
  *                                  the operation will be done by word (32-bit)
  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
  *                                  the operation will be done by double word (64-bit)
  * 
  * @param  Banks Banks to be erased
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: Bank1 to be erased
  *
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FLASH_MassErase</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>VoltageRange</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_VOLTAGERANGE</name><argument_list>(<argument><expr><name>VoltageRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If the previous operation is completed, proceed to erase all sectors */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_MER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_STRT</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>VoltageRange</name> <operator>&lt;&lt;</operator><literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Erase the specified FLASH memory sector
  * @param  Sector FLASH sector to erase
  *         The value of this parameter depend on device used within the same series      
  * @param  VoltageRange The device voltage range which defines the erase parallelism.  
  *          This parameter can be one of the following values:
  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
  *                                  the operation will be done by byte (8-bit) 
  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
  *                                  the operation will be done by half word (16-bit)
  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
  *                                  the operation will be done by word (32-bit)
  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>FLASH_Erase_Sector</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Sector</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>VoltageRange</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_psize</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_SECTOR</name><argument_list>(<argument><expr><name>Sector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_VOLTAGERANGE</name><argument_list>(<argument><expr><name>VoltageRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>VoltageRange</name> <operator>==</operator> <name>FLASH_VOLTAGE_RANGE_1</name></expr>)</condition>
  <block>{<block_content>
     <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_BYTE</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>VoltageRange</name> <operator>==</operator> <name>FLASH_VOLTAGE_RANGE_2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_HALF_WORD</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>VoltageRange</name> <operator>==</operator> <name>FLASH_VOLTAGE_RANGE_3</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_WORD</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_psize</name> <operator>=</operator> <name>FLASH_PSIZE_DOUBLE_WORD</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If the previous operation is completed, proceed to erase the sector */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>tmp_psize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_SNB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_SER</name> <operator>|</operator> <operator>(</operator><name>Sector</name> <operator>&lt;&lt;</operator> <name>FLASH_CR_SNB_Pos</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_STRT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable the write protection of the desired bank 1 sectors
  *
  * @note   When the memory read protection level is selected (RDP level = 1), 
  *         it is not possible to program or erase the flash sector i if CortexM4  
  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
  * 
  * @param  WRPSector specifies the sector(s) to be write protected.
  *         The value of this parameter depend on device used within the same series 
  * 
  * @param  Banks Enable write protection on all the sectors for the specific bank
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: WRP on all sectors of bank1
  *
  * @retval HAL Status 
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_EnableWRP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WRPSector</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_WRP_SECTOR</name><argument_list>(<argument><expr><name>WRPSector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content> 
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>WRPSector</name><operator>)</operator></expr>;</expr_stmt>  
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disable the write protection of the desired bank 1 sectors
  *
  * @note   When the memory read protection level is selected (RDP level = 1), 
  *         it is not possible to program or erase the flash sector i if CortexM4  
  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
  * 
  * @param  WRPSector specifies the sector(s) to be write protected.
  *         The value of this parameter depend on device used within the same series 
  * 
  * @param  Banks Enable write protection on all the sectors for the specific bank
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: WRP on all sectors of bank1
  *
  * @retval HAL Status 
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_DisableWRP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WRPSector</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Banks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_WRP_SECTOR</name><argument_list>(<argument><expr><name>WRPSector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_BANK</name><argument_list>(<argument><expr><name>Banks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content> 
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>WRPSector</name></expr>;</expr_stmt> 
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
          STM32F413xx || STM32F423xx */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F401xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Tx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F410Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F411xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Zx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Vx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Rx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F412Cx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F413xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F423xx</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Enable the read/write protection (PCROP) of the desired sectors.
  * @note   This function can be used only for STM32F401xx devices.
  * @param  Sector specifies the sector(s) to be read/write protected or unprotected.
  *          This parameter can be one of the following values:
  *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector5
  *            @arg OB_PCROP_Sector_All                         
  * @retval HAL Status  
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_EnablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Sector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>Sector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>  
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content> 
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>Sector</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Disable the read/write protection (PCROP) of the desired sectors.
  * @note   This function can be used only for STM32F401xx devices.
  * @param  Sector specifies the sector(s) to be read/write protected or unprotected.
  *          This parameter can be one of the following values:
  *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector5
  *            @arg OB_PCROP_Sector_All                         
  * @retval HAL Status  
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_DisablePCROP</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Sector</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_PCROP</name><argument_list>(<argument><expr><name>Sector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>  
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content> 
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE2_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>Sector</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
          STM32F413xx || STM32F423xx */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Set the read protection level.
  * @param  Level specifies the read protection level.
  *          This parameter can be one of the following values:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *   
  * @note WARNING: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  *    
  * @retval HAL Status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_RDP_LevelConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>Level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_RDP_LEVEL</name><argument_list>(<argument><expr><name>Level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content> 
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name><operator>*</operator><operator>)</operator><name>OPTCR_BYTE1_ADDRESS</name> <operator>=</operator> <name>Level</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
  * @param  Iwdg Selects the IWDG mode
  *          This parameter can be one of the following values:
  *            @arg OB_IWDG_SW: Software IWDG selected
  *            @arg OB_IWDG_HW: Hardware IWDG selected
  * @param  Stop Reset event when entering STOP mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP
  *            @arg OB_STOP_RST: Reset generated when entering in STOP
  * @param  Stdby Reset event when entering Standby mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY
  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval HAL Status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_UserConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>Iwdg</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Stop</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Stdby</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>optiontmp</name> <init>= <expr><literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_IWDG_SOURCE</name><argument_list>(<argument><expr><name>Iwdg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_STOP_SOURCE</name><argument_list>(<argument><expr><name>Stop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_STDBY_SOURCE</name><argument_list>(<argument><expr><name>Stdby</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>     
    <comment type="block">/* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */</comment>
    <expr_stmt><expr><name>optiontmp</name> <operator>=</operator>  <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x1F</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Update User Option Byte */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name> <operator>=</operator> <name>Iwdg</name> <operator>|</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>Stdby</name> <operator>|</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>Stop</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><name>optiontmp</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt> 
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Set the BOR Level. 
  * @param  Level specifies the Option Bytes BOR Reset Level.
  *          This parameter can be one of the following values:
  *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
  *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
  * @retval HAL Status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>FLASH_OB_BOR_LevelConfig</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>Level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_OB_BOR_LEVEL</name><argument_list>(<argument><expr><name>Level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the BOR Level */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>FLASH_OPTCR_BOR_LEV</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name> <operator>|=</operator> <name>Level</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the FLASH User Option Byte value.
  * @retval uint8_t FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
  *         and RST_STDBY(Bit2).
  */</comment>
<function><type><specifier>static</specifier> <name>uint8_t</name></type> <name>FLASH_OB_GetUser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return the User Option Byte */</comment>
  <return>return <expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>FLASH</name><operator>-&gt;</operator><name>OPTCR</name></name> <operator>&amp;</operator> <literal type="number">0xE0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the FLASH Write Protection Option Bytes value.
  * @retval uint16_t FLASH Write Protection Option Bytes value
  */</comment>
<function><type><specifier>static</specifier> <name>uint16_t</name></type> <name>FLASH_OB_GetWRP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return the FLASH write protection Register value */</comment>
  <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR_BYTE2_ADDRESS</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Returns the FLASH Read Protection level.
  * @retval FLASH ReadOut Protection Status:
  *         This parameter can be one of the following values:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */</comment>
<function><type><specifier>static</specifier> <name>uint8_t</name></type> <name>FLASH_OB_GetRDP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>readstatus</name> <init>= <expr><name>OB_RDP_LEVEL_0</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR_BYTE1_ADDRESS</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>OB_RDP_LEVEL_2</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>readstatus</name> <operator>=</operator> <name>OB_RDP_LEVEL_2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR_BYTE1_ADDRESS</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>OB_RDP_LEVEL_0</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>readstatus</name> <operator>=</operator> <name>OB_RDP_LEVEL_0</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else 
  <block>{<block_content>
    <expr_stmt><expr><name>readstatus</name> <operator>=</operator> <name>OB_RDP_LEVEL_1</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>readstatus</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Returns the FLASH BOR level.
  * @retval uint8_t The FLASH BOR level:
  *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  */</comment>
<function><type><specifier>static</specifier> <name>uint8_t</name></type> <name>FLASH_OB_GetBOR</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return the FLASH BOR level */</comment>
  <return>return <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>OPTCR_BYTE0_ADDRESS</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x0C</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Flush the instruction and data caches
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>FLASH_FlushCaches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Flush instruction cache  */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>ACR</name></name></expr></argument>, <argument><expr><name>FLASH_ACR_ICEN</name></expr></argument>)</argument_list></call><operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable instruction cache  */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_INSTRUCTION_CACHE_DISABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Reset instruction cache */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_INSTRUCTION_CACHE_RESET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Enable instruction cache */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_INSTRUCTION_CACHE_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Flush data cache */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>ACR</name></name></expr></argument>, <argument><expr><name>FLASH_ACR_DCEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable data cache  */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_DATA_CACHE_DISABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Reset data cache */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_DATA_CACHE_RESET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Enable data cache */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_DATA_CACHE_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_FLASH_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
