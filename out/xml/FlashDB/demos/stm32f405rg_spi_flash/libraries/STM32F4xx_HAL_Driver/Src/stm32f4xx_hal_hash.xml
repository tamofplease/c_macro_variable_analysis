<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_hash.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_hash.c
  * @author  MCD Application Team
  * @brief   HASH HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the HASH peripheral:
  *           + Initialization and de-initialization methods
  *           + HASH or HMAC processing in polling mode
  *           + HASH or HMAC processing in interrupt mode
  *           + HASH or HMAC processing in DMA mode
  *           + Peripheral State methods
  *           + HASH or HMAC processing suspension/resumption
  *
  @verbatim
 ===============================================================================
                     ##### How to use this driver #####
 ===============================================================================
    [..]
    The HASH HAL driver can be used as follows:

    (#)Initialize the HASH low level resources by implementing the HAL_HASH_MspInit():
        (##) Enable the HASH interface clock using __HASH_CLK_ENABLE()
        (##) When resorting to interrupt-based APIs (e.g. HAL_HASH_xxx_Start_IT())
            (+++) Configure the HASH interrupt priority using HAL_NVIC_SetPriority()
            (+++) Enable the HASH IRQ handler using HAL_NVIC_EnableIRQ()
            (+++) In HASH IRQ handler, call HAL_HASH_IRQHandler() API
        (##) When resorting to DMA-based APIs  (e.g. HAL_HASH_xxx_Start_DMA())
            (+++) Enable the DMAx interface clock using
                   __DMAx_CLK_ENABLE()
            (+++) Configure and enable one DMA stream to manage data transfer from
                memory to peripheral (input stream). Managing data transfer from
                peripheral to memory can be performed only using CPU.
            (+++) Associate the initialized DMA handle to the HASH DMA handle
                using  __HAL_LINKDMA()
            (+++) Configure the priority and enable the NVIC for the transfer complete
                interrupt on the DMA Stream: use
                 HAL_NVIC_SetPriority() and
                 HAL_NVIC_EnableIRQ()

    (#)Initialize the HASH HAL using HAL_HASH_Init(). This function:
        (##) resorts to HAL_HASH_MspInit() for low-level initialization,
        (##) configures the data type: 1-bit, 8-bit, 16-bit or 32-bit.

    (#)Three processing schemes are available:
        (##) Polling mode: processing APIs are blocking functions
             i.e. they process the data and wait till the digest computation is finished,
             e.g. HAL_HASH_xxx_Start() for HASH or HAL_HMAC_xxx_Start() for HMAC
        (##) Interrupt mode: processing APIs are not blocking functions
                i.e. they process the data under interrupt,
                e.g. HAL_HASH_xxx_Start_IT() for HASH or HAL_HMAC_xxx_Start_IT() for HMAC
        (##) DMA mode: processing APIs are not blocking functions and the CPU is
             not used for data transfer i.e. the data transfer is ensured by DMA,
                e.g. HAL_HASH_xxx_Start_DMA() for HASH or HAL_HMAC_xxx_Start_DMA()
                for HMAC. Note that in DMA mode, a call to HAL_HASH_xxx_Finish()
                is then required to retrieve the digest.

    (#)When the processing function is called after HAL_HASH_Init(), the HASH peripheral is
       initialized and processes the buffer fed in input. When the input data have all been
       fed to the IP, the digest computation can start.

    (#)Multi-buffer processing is possible in polling and DMA mode.
        (##) In polling mode, only multi-buffer HASH processing is possible.
             API HAL_HASH_xxx_Accumulate() must be called for each input buffer, except for the last one.
             User must resort to HAL_HASH_xxx_Start() to enter the last one and retrieve as
             well the computed digest.

        (##) In DMA mode, multi-buffer HASH and HMAC processing are possible.
              (+++) HASH processing: once initialization is done, MDMAT bit must be set thru __HAL_HASH_SET_MDMAT() macro.
             From that point, each buffer can be fed to the IP thru HAL_HASH_xxx_Start_DMA() API.
             Before entering the last buffer, reset the MDMAT bit with __HAL_HASH_RESET_MDMAT()
             macro then wrap-up the HASH processing in feeding the last input buffer thru the
             same API HAL_HASH_xxx_Start_DMA(). The digest can then be retrieved with a call to
             API HAL_HASH_xxx_Finish().
             (+++) HMAC processing (requires to resort to extended functions):
             after initialization, the key and the first input buffer are entered
             in the IP with the API HAL_HMACEx_xxx_Step1_2_DMA(). This carries out HMAC step 1 and
             starts step 2.
             The following buffers are next entered with the API  HAL_HMACEx_xxx_Step2_DMA(). At this
             point, the HMAC processing is still carrying out step 2.
             Then, step 2 for the last input buffer and step 3 are carried out by a single call
             to HAL_HMACEx_xxx_Step2_3_DMA().

             The digest can finally be retrieved with a call to API HAL_HASH_xxx_Finish().


    (#)Context swapping.
        (##) Two APIs are available to suspend HASH or HMAC processing:
             (+++) HAL_HASH_SwFeed_ProcessSuspend() when data are entered by software (polling or IT mode),
             (+++) HAL_HASH_DMAFeed_ProcessSuspend() when data are entered by DMA.

        (##) When HASH or HMAC processing is suspended, HAL_HASH_ContextSaving() allows
            to save in memory the IP context. This context can be restored afterwards
            to resume the HASH processing thanks to HAL_HASH_ContextRestoring().

        (##) Once the HASH IP has been restored to the same configuration as that at suspension
             time, processing can be restarted with the same API call (same API, same handle,
             same parameters) as done before the suspension. Relevant parameters to restart at
             the proper location are internally saved in the HASH handle.

    (#)Call HAL_HASH_DeInit() to deinitialize the HASH peripheral.

     *** Callback registration ***
     ===================================
     [..]
      (#) The compilation define  USE_HAL_HASH_REGISTER_CALLBACKS when set to 1
          allows the user to configure dynamically the driver callbacks.
          Use function @ref HAL_HASH_RegisterCallback() to register a user callback.

      (#) Function @ref HAL_HASH_RegisterCallback() allows to register following callbacks:
            (+) InCpltCallback    : callback for input completion.
            (+) DgstCpltCallback  : callback for digest computation completion.
            (+) ErrorCallback     : callback for error.
            (+) MspInitCallback   : HASH MspInit.
            (+) MspDeInitCallback : HASH MspDeInit.
          This function takes as parameters the HAL peripheral handle, the Callback ID
          and a pointer to the user callback function.

      (#) Use function @ref HAL_HASH_UnRegisterCallback() to reset a callback to the default
          weak (surcharged) function.
          @ref HAL_HASH_UnRegisterCallback() takes as parameters the HAL peripheral handle,
          and the Callback ID.
          This function allows to reset following callbacks:
            (+) InCpltCallback    : callback for input completion.
            (+) DgstCpltCallback  : callback for digest computation completion.
            (+) ErrorCallback     : callback for error.
            (+) MspInitCallback   : HASH MspInit.
            (+) MspDeInitCallback : HASH MspDeInit.

      (#) By default, after the @ref HAL_HASH_Init and if the state is HAL_HASH_STATE_RESET
          all callbacks are reset to the corresponding legacy weak (surcharged) functions:
          examples @ref HAL_HASH_InCpltCallback(), @ref HAL_HASH_DgstCpltCallback()
          Exception done for MspInit and MspDeInit callbacks that are respectively
          reset to the legacy weak (surcharged) functions in the @ref HAL_HASH_Init
          and @ref HAL_HASH_DeInit only when these callbacks are null (not registered beforehand)
          If not, MspInit or MspDeInit are not null, the @ref HAL_HASH_Init and @ref HAL_HASH_DeInit
          keep and use the user MspInit/MspDeInit callbacks (registered beforehand).

          Callbacks can be registered/unregistered in READY state only.
          Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
          in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
          during the Init/DeInit.
          In that case first register the MspInit/MspDeInit user callbacks
          using @ref HAL_HASH_RegisterCallback before calling @ref HAL_HASH_DeInit
          or @ref HAL_HASH_Init function.

          When The compilation define USE_HAL_HASH_REGISTER_CALLBACKS is set to 0 or
          not defined, the callback registering feature is not available
          and weak (surcharged) callbacks are used.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>


<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>HASH</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block" format="doxygen">/** @defgroup HASH  HASH
  * @brief HASH HAL module driver.
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_HASH_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup HASH_Private_Constants HASH Private Constants
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Digest_Calculation_Status HASH Digest Calculation Status
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_DIGEST_CALCULATION_NOT_STARTED</name></cpp:macro>       <cpp:value>((uint32_t)0x00000000U)</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; DCAL not set after input data written in DIN register */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_DIGEST_CALCULATION_STARTED</name></cpp:macro>           <cpp:value>((uint32_t)0x00000001U)</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; DCAL set after input data written in DIN register     */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Number_Of_CSR_Registers HASH Number of Context Swap Registers
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_NUMBER_OF_CSR_REGISTERS</name></cpp:macro>              <cpp:value>54U</cpp:value></cpp:define>     <comment type="block" format="doxygen">/*!&lt; Number of Context Swap Registers */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_TimeOut_Value HASH TimeOut Value
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_TIMEOUTVALUE</name></cpp:macro>                         <cpp:value>1000U</cpp:value></cpp:define>   <comment type="block" format="doxygen">/*!&lt; Time-out value  */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_DMA_Suspension_Words_Limit HASH DMA suspension words limit
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_DMA_SUSPENSION_WORDS_LIMIT</name></cpp:macro>             <cpp:value>20U</cpp:value></cpp:define>   <comment type="block" format="doxygen">/*!&lt; Number of words below which DMA suspension is aborted */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup HASH_Private_Functions HASH Private Functions
  * @{
  */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HASH_DMAXferCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HASH_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HASH_GetDigest</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pMsgDigest</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HASH_WaitOnFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>Status</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HASH_WriteData</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HASH_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>HASH_Write_Block_Data</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HMAC_Processing</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions HASH Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization, configuration and call-back functions.
 *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize the HASH according to the specified parameters
          in the HASH_InitTypeDef and create the associated handle
      (+) DeInitialize the HASH peripheral
      (+) Initialize the HASH MCU Specific Package (MSP)
      (+) DeInitialize the HASH MSP

    [..]  This section provides as well call back functions definitions for user
          code to manage:
      (+) Input data transfer to IP completion
      (+) Calculated digest retrieval completion
      (+) Error management



@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH according to the specified parameters in the
            HASH_HandleTypeDef and create the associated handle.
  * @note   Only MDMAT and DATATYPE bits of HASH IP are set by HAL_HASH_Init(),
  *         other configuration bits are set by HASH or HMAC processing APIs.
  * @note   MDMAT bit is systematically reset by HAL_HASH_Init(). To set it for
  *         multi-buffer HASH processing, user needs to resort to
  *         __HAL_HASH_SET_MDMAT() macro. For HMAC multi-buffer processing, the
  *         relevant APIs manage themselves the MDMAT bit.
  * @param  hhash: HASH handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_Init</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_HASH_DATATYPE</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the hash handle allocation */</comment>
  <if_stmt><if>if<condition>(<expr><name>hhash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

    <comment type="block">/* Reset Callback pointers in HAL_HASH_STATE_RESET only */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>InCpltCallback</name></name> <operator>=</operator>  <name>HAL_HASH_InCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak (surcharged) input completion callback */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>DgstCpltCallback</name></name> <operator>=</operator>  <name>HAL_HASH_DgstCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak (surcharged) digest computation completion callback */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator>  <name>HAL_HASH_ErrorCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak (surcharged) error callback */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_HASH_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name>HAL_HASH_MspInit</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* (USE_HAL_HASH_REGISTER_CALLBACKS) */</comment>

    <comment type="block">/* Change the HASH state */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Reset HashInCount, HashITCounter, HashBuffSize and NbWordsAlreadyPushed */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>NbWordsAlreadyPushed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* Reset digest calculation bridle (MDMAT bit control) */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>DigestCalculationDisable</name></name> <operator>=</operator> <name>RESET</name></expr>;</expr_stmt>
  <comment type="block">/* Set phase to READY */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Set the data type bit */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_DATATYPE</name></expr></argument>, <argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Reset MDMAT bit */</comment>
<expr_stmt><expr><call><name>__HAL_HASH_RESET_MDMAT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* Reset HASH handle status */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>HAL_OK</name></expr>;</expr_stmt>

  <comment type="block">/* Set the HASH state to Ready */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Initialise the error code */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_HASH_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitialize the HASH peripheral.
  * @param  hhash: HASH handle.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_DeInit</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the HASH handle allocation */</comment>
  <if_stmt><if>if<condition>(<expr><name>hhash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the HASH state */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Set the default HASH phase */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Reset HashInCount, HashITCounter and HashBuffSize */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* Reset digest calculation bridle (MDMAT bit control) */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>DigestCalculationDisable</name></name> <operator>=</operator> <name>RESET</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_HASH_MspDeInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* DeInit the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name>HAL_HASH_MspDeInit</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* (USE_HAL_HASH_REGISTER_CALLBACKS) */</comment>


  <comment type="block">/* Reset HASH handle status */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>HAL_OK</name></expr>;</expr_stmt>

  <comment type="block">/* Set the HASH state to Ready */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Initialise the error code */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_HASH_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH MSP.
  * @param  hhash: HASH handle.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_HASH_MspInit</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified; when the callback is needed,
            HAL_HASH_MspInit() can be implemented in the user file.
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitialize the HASH MSP.
  * @param  hhash: HASH handle.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_HASH_MspDeInit</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified; when the callback is needed,
            HAL_HASH_MspDeInit() can be implemented in the user file.
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Input data transfer complete call back.
  * @note   HAL_HASH_InCpltCallback() is called when the complete input message
  *         has been fed to the IP. This API is invoked only when input data are
  *         entered under interruption or thru DMA.
  * @note   In case of HASH or HMAC multi-buffer DMA feeding case (MDMAT bit set),
  *         HAL_HASH_InCpltCallback() is called at the end of each buffer feeding
  *         to the IP.
  * @param  hhash: HASH handle.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_HASH_InCpltCallback</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified; when the callback is needed,
            HAL_HASH_InCpltCallback() can be implemented in the user file.
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Digest computation complete call back.
  * @note   HAL_HASH_DgstCpltCallback() is used under interruption, is not
  *         relevant with DMA.
  * @param  hhash: HASH handle.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_HASH_DgstCpltCallback</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified; when the callback is needed,
            HAL_HASH_DgstCpltCallback() can be implemented in the user file.
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Error callback.
  * @note   Code user can resort to hhash-&gt;Status (HAL_ERROR, HAL_TIMEOUT,...)
  *         to retrieve the error type.
  * @param  hhash: HASH handle.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_HASH_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified; when the callback is needed,
            HAL_HASH_ErrorCallback() can be implemented in the user file.
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User HASH Callback
  *         To be used instead of the weak (surcharged) predefined callback
  * @param hhash HASH handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_HASH_INPUTCPLT_CB_ID HASH input completion Callback ID
  *          @arg @ref HAL_HASH_DGSTCPLT_CB_ID HASH digest computation completion Callback ID
  *          @arg @ref HAL_HASH_ERROR_CB_ID HASH error Callback ID
  *          @arg @ref HAL_HASH_MSPINIT_CB_ID HASH MspInit callback ID
  *          @arg @ref HAL_HASH_MSPDEINIT_CB_ID HASH MspDeInit callback ID
  * @param pCallback pointer to the Callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>HAL_HASH_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pHASH_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>HAL_HASH_STATE_READY</name> <operator>==</operator> <name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_HASH_INPUTCPLT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>InCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_DGSTCPLT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>DgstCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_ERROR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default :</default>
     <comment type="block">/* Update the error code */</comment>
     <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
     <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>HAL_HASH_STATE_RESET</name> <operator>==</operator> <name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_HASH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default :</default>
     <comment type="block">/* Update the error code */</comment>
     <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
     <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
     <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
     <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a HASH Callback
  *         HASH Callback is redirected to the weak (surcharged) predefined callback
  * @param hhash HASH handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_HASH_INPUTCPLT_CB_ID HASH input completion Callback ID
  *          @arg @ref HAL_HASH_DGSTCPLT_CB_ID HASH digest computation completion Callback ID
  *          @arg @ref HAL_HASH_ERROR_CB_ID HASH error Callback ID
  *          @arg @ref HAL_HASH_MSPINIT_CB_ID HASH MspInit callback ID
  *          @arg @ref HAL_HASH_MSPDEINIT_CB_ID HASH MspDeInit callback ID
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>HAL_HASH_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>HAL_HASH_STATE_READY</name> <operator>==</operator> <name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_HASH_INPUTCPLT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>InCpltCallback</name></name> <operator>=</operator> <name>HAL_HASH_InCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak (surcharged) input completion callback */</comment>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_DGSTCPLT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>DgstCpltCallback</name></name> <operator>=</operator> <name>HAL_HASH_DgstCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak (surcharged) digest computation completion callback */</comment>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_ERROR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>HAL_HASH_ErrorCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak (surcharged) error callback */</comment>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_HASH_MspInit</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak (surcharged) Msp Init */</comment>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_HASH_MspDeInit</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak (surcharged) Msp DeInit */</comment>
      <break>break;</break>

    <default>default :</default>
     <comment type="block">/* Update the error code */</comment>
     <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
     <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>HAL_HASH_STATE_RESET</name> <operator>==</operator> <name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_HASH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_HASH_MspInit</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak (surcharged) Msp Init */</comment>
      <break>break;</break>

    <case>case <expr><name>HAL_HASH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_HASH_MspDeInit</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak (surcharged) Msp DeInit */</comment>
      <break>break;</break>

    <default>default :</default>
     <comment type="block">/* Update the error code */</comment>
     <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
     <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
     <comment type="block">/* Update the error code */</comment>
     <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
     <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group2 HASH processing functions in polling mode
 *  @brief   HASH processing functions using polling mode.
 *
@verbatim
 ===============================================================================
                 ##### Polling mode HASH processing functions #####
 ===============================================================================
    [..]  This section provides functions allowing to calculate in polling mode
          the hash value using one of the following algorithms:
      (+) MD5
         (++) HAL_HASH_MD5_Start()
         (++) HAL_HASH_MD5_Accumulate()
      (+) SHA1
         (++) HAL_HASH_SHA1_Start()
         (++) HAL_HASH_SHA1_Accumulate()

    [..] For a single buffer to be hashed, user can resort to HAL_HASH_xxx_Start().

    [..]  In case of multi-buffer HASH processing (a single digest is computed while
          several buffers are fed to the IP), the user can resort to successive calls
          to HAL_HASH_xxx_Accumulate() and wrap-up the digest computation by a call
          to HAL_HASH_xxx_Start().

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in MD5 mode, next process pInBuffer then
  *         read the computed digest.
  * @note   Digest is available in pOutBuffer.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 16 bytes.
  * @param  Timeout: Timeout value
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_MD5_Start</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HASH_Start</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_MD5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  If not already done, initialize the HASH peripheral in MD5 mode then
  *         processes pInBuffer.
  * @note   Consecutive calls to HAL_HASH_MD5_Accumulate() can be used to feed
  *         several input buffers back-to-back to the IP that will yield a single
  *         HASH signature once all buffers have been entered. Wrap-up of input
  *         buffers feeding and retrieval of digest is done by a call to
  *         HAL_HASH_MD5_Start().
  * @note   Field hhash-&gt;Phase of HASH handle is tested to check whether or not
  *         the IP has already been initialized.
  * @note   Digest is not retrieved by this API, user must resort to HAL_HASH_MD5_Start()
  *         to read it, feeding at the same time the last input buffer to the IP.
  * @note   The input buffer size (in bytes) must be a multiple of 4 otherwise, the
  *         HASH digest computation is corrupted. Only HAL_HASH_MD5_Start() is able
  *         to manage the ending buffer with a length in bytes not a multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_MD5_Accumulate</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return  <expr><call><name>HASH_Accumulate</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>,<argument><expr><name>HASH_ALGOSELECTION_MD5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in SHA1 mode, next process pInBuffer then
  *         read the computed digest.
  * @note   Digest is available in pOutBuffer.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 20 bytes.
  * @param  Timeout: Timeout value
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_SHA1_Start</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HASH_Start</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_SHA1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  If not already done, initialize the HASH peripheral in SHA1 mode then
  *         processes pInBuffer.
  * @note   Consecutive calls to HAL_HASH_SHA1_Accumulate() can be used to feed
  *         several input buffers back-to-back to the IP that will yield a single
  *         HASH signature once all buffers have been entered. Wrap-up of input
  *         buffers feeding and retrieval of digest is done by a call to
  *         HAL_HASH_SHA1_Start().
  * @note   Field hhash-&gt;Phase of HASH handle is tested to check whether or not
  *         the IP has already been initialized.
  * @note   Digest is not retrieved by this API, user must resort to HAL_HASH_SHA1_Start()
  *         to read it, feeding at the same time the last input buffer to the IP.
  * @note   The input buffer size (in bytes) must be a multiple of 4 otherwise, the
  *         HASH digest computation is corrupted. Only HAL_HASH_SHA1_Start() is able
  *         to manage the ending buffer with a length in bytes not a multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_SHA1_Accumulate</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return  <expr><call><name>HASH_Accumulate</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>,<argument><expr><name>HASH_ALGOSELECTION_SHA1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group3 HASH processing functions in interrupt mode
 *  @brief   HASH processing functions using interrupt mode.
 *
@verbatim
 ===============================================================================
                 ##### Interruption mode HASH processing functions #####
 ===============================================================================
    [..]  This section provides functions allowing to calculate in interrupt mode
          the hash value using one of the following algorithms:
      (+) MD5
         (++) HAL_HASH_MD5_Start_IT()
      (+) SHA1
         (++) HAL_HASH_SHA1_Start_IT()

    [..]  API HAL_HASH_IRQHandler() manages each HASH interruption.

    [..] Note that HAL_HASH_IRQHandler() manages as well HASH IP interruptions when in
         HMAC processing mode.


@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in MD5 mode, next process pInBuffer then
  *         read the computed digest in interruption mode.
  * @note   Digest is available in pOutBuffer.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 16 bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_MD5_Start_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HASH_Start_IT</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>,<argument><expr><name>HASH_ALGOSELECTION_MD5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in SHA1 mode, next process pInBuffer then
  *         read the computed digest in interruption mode.
  * @note   Digest is available in pOutBuffer.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 20 bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_SHA1_Start_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HASH_Start_IT</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>,<argument><expr><name>HASH_ALGOSELECTION_SHA1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Handle HASH interrupt request.
  * @param hhash: HASH handle.
  * @note  HAL_HASH_IRQHandler() handles interrupts in HMAC processing as well.
  * @note  In case of error reported during the HASH interruption processing,
  *        HAL_HASH_ErrorCallback() API is called so that user code can
  *        manage the error. The error type is available in hhash-&gt;Status field.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_HASH_IRQHandler</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <call><name>HASH_IT</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_IT</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_HASH_ErrorCallback</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>
    <comment type="block">/* After error handling by code user, reset HASH handle HAL status */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>HAL_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group4 HASH processing functions in DMA mode
 *  @brief   HASH processing functions using DMA mode.
 *
@verbatim
 ===============================================================================
                    ##### DMA mode HASH processing functions #####
 ===============================================================================
    [..]  This section provides functions allowing to calculate in DMA mode
          the hash value using one of the following algorithms:
      (+) MD5
         (++) HAL_HASH_MD5_Start_DMA()
         (++) HAL_HASH_MD5_Finish()
      (+) SHA1
         (++) HAL_HASH_SHA1_Start_DMA()
         (++) HAL_HASH_SHA1_Finish()

    [..]  When resorting to DMA mode to enter the data in the IP, user must resort
          to  HAL_HASH_xxx_Start_DMA() then read the resulting digest with
          HAL_HASH_xxx_Finish().
    [..]  In case of multi-buffer HASH processing, MDMAT bit must first be set before
          the successive calls to HAL_HASH_xxx_Start_DMA(). Then, MDMAT bit needs to be
          reset before the last call to HAL_HASH_xxx_Start_DMA(). Digest is finally
          retrieved thanks to HAL_HASH_xxx_Finish().

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in MD5 mode then initiate a DMA transfer
  *         to feed the input buffer to the IP.
  * @note   Once the DMA transfer is finished, HAL_HASH_MD5_Finish() API must
  *         be called to retrieve the computed digest.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_MD5_Start_DMA</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HASH_Start_DMA</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_MD5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the computed digest in MD5 mode.
  * @note   The API waits for DCIS to be set then reads the computed digest.
  * @note   HAL_HASH_MD5_Finish() can be used as well to retrieve the digest in
  *         HMAC MD5 mode.
  * @param  hhash: HASH handle.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 16 bytes.
  * @param  Timeout: Timeout value.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_MD5_Finish</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <return>return <expr><call><name>HASH_Finish</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in SHA1 mode then initiate a DMA transfer
  *         to feed the input buffer to the IP.
  * @note   Once the DMA transfer is finished, HAL_HASH_SHA1_Finish() API must
  *         be called to retrieve the computed digest.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_SHA1_Start_DMA</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HASH_Start_DMA</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_SHA1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Return the computed digest in SHA1 mode.
  * @note   The API waits for DCIS to be set then reads the computed digest.
  * @note   HAL_HASH_SHA1_Finish() can be used as well to retrieve the digest in
  *         HMAC SHA1 mode.
  * @param  hhash: HASH handle.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 20 bytes.
  * @param  Timeout: Timeout value.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_SHA1_Finish</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <return>return <expr><call><name>HASH_Finish</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group5 HMAC processing functions in polling mode
 *  @brief   HMAC processing functions using polling mode.
 *
@verbatim
 ===============================================================================
                 ##### Polling mode HMAC processing functions #####
 ===============================================================================
    [..]  This section provides functions allowing to calculate in polling mode
          the HMAC value using one of the following algorithms:
      (+) MD5
         (++) HAL_HMAC_MD5_Start()
      (+) SHA1
         (++) HAL_HMAC_SHA1_Start()


@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC MD5 mode, next process pInBuffer then
  *         read the computed digest.
  * @note   Digest is available in pOutBuffer.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 16 bytes.
  * @param  Timeout: Timeout value.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HMAC_MD5_Start</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HMAC_Start</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_MD5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC SHA1 mode, next process pInBuffer then
  *         read the computed digest.
  * @note   Digest is available in pOutBuffer.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 20 bytes.
  * @param  Timeout: Timeout value.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HMAC_SHA1_Start</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>HMAC_Start</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_SHA1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>


<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group6 HMAC processing functions in interrupt mode
 *  @brief   HMAC processing functions using interrupt mode.
 *
@verbatim
 ===============================================================================
                 ##### Interrupt mode HMAC processing functions #####
 ===============================================================================
    [..]  This section provides functions allowing to calculate in interrupt mode
          the HMAC value using one of the following algorithms:
      (+) MD5
         (++) HAL_HMAC_MD5_Start_IT()
      (+) SHA1
         (++) HAL_HMAC_SHA1_Start_IT()

@endverbatim
  * @{
  */</comment>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC MD5 mode, next process pInBuffer then
  *         read the computed digest in interrupt mode.
  * @note   Digest is available in pOutBuffer.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 16 bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HMAC_MD5_Start_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return  <expr><call><name>HMAC_Start_IT</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_MD5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC SHA1 mode, next process pInBuffer then
  *         read the computed digest in interrupt mode.
  * @note   Digest is available in pOutBuffer.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest. Digest size is 20 bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HMAC_SHA1_Start_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return  <expr><call><name>HMAC_Start_IT</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_SHA1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>



<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group7 HMAC processing functions in DMA mode
 *  @brief   HMAC processing functions using DMA modes.
 *
@verbatim
 ===============================================================================
                 ##### DMA mode HMAC processing functions #####
 ===============================================================================
    [..]  This section provides functions allowing to calculate in DMA mode
          the HMAC value using one of the following algorithms:
      (+) MD5
         (++) HAL_HMAC_MD5_Start_DMA()
      (+) SHA1
         (++) HAL_HMAC_SHA1_Start_DMA()

    [..]  When resorting to DMA mode to enter the data in the IP for HMAC processing,
          user must resort to  HAL_HMAC_xxx_Start_DMA() then read the resulting digest
          with HAL_HASH_xxx_Finish().

@endverbatim
  * @{
  */</comment>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC MD5 mode then initiate the required
  *         DMA transfers to feed the key and the input buffer to the IP.
  * @note   Once the DMA transfers are finished (indicated by hhash-&gt;State set back
  *         to HAL_HASH_STATE_READY), HAL_HASH_MD5_Finish() API must be called to retrieve
  *         the computed digest.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @note   If MDMAT bit is set before calling this function (multi-buffer
  *          HASH processing case), the input buffer size (in bytes) must be
  *          a multiple of 4 otherwise, the HASH digest computation is corrupted.
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HMAC_MD5_Start_DMA</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return  <expr><call><name>HMAC_Start_DMA</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_MD5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC SHA1 mode then initiate the required
  *         DMA transfers to feed the key and the input buffer to the IP.
  * @note   Once the DMA transfers are finished (indicated by hhash-&gt;State set back
  *         to HAL_HASH_STATE_READY), HAL_HASH_SHA1_Finish() API must be called to retrieve
  *         the computed digest.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @note   If MDMAT bit is set before calling this function (multi-buffer
  *          HASH processing case), the input buffer size (in bytes) must be
  *          a multiple of 4 otherwise, the HASH digest computation is corrupted.
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HMAC_SHA1_Start_DMA</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return  <expr><call><name>HMAC_Start_DMA</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>HASH_ALGOSELECTION_SHA1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Exported_Functions_Group8 Peripheral states functions
 *  @brief   Peripheral State functions.
 *
@verbatim
 ===============================================================================
                      ##### Peripheral State methods #####
 ===============================================================================
    [..]
    This section permits to get in run-time the state and the peripheral handle
    status of the peripheral:
      (+) HAL_HASH_GetState()
      (+) HAL_HASH_GetStatus()

    [..]
    Additionally, this subsection provides functions allowing to save and restore
    the HASH or HMAC processing context in case of calculation suspension:
      (+) HAL_HASH_ContextSaving()
      (+) HAL_HASH_ContextRestoring()

    [..]
    This subsection provides functions allowing to suspend the HASH processing
      (+) when input are fed to the IP by software
          (++) HAL_HASH_SwFeed_ProcessSuspend()
      (+) when input are fed to the IP by DMA
          (++) HAL_HASH_DMAFeed_ProcessSuspend()



@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the HASH handle state.
  * @note   The API yields the current state of the handle (BUSY, READY,...).
  * @param  hhash: HASH handle.
  * @retval HAL HASH state
  */</comment>
<function><type><name>HAL_HASH_StateTypeDef</name></type> <name>HAL_HASH_GetState</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief Return the HASH HAL status.
  * @note  The API yields the HAL status of the handle: it is the result of the
  *        latest HASH processing and allows to report any issue (e.g. HAL_TIMEOUT).
  * @param  hhash: HASH handle.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_GetStatus</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Save the HASH context in case of processing suspension.
  * @param  hhash: HASH handle.
  * @param  pMemBuffer: pointer to the memory buffer where the HASH context
  *         is saved.
  * @note   The IMR, STR, CR then all the CSR registers are saved
  *         in that order. Only the r/w bits are read to be restored later on.
  * @note   By default, all the context swap registers (there are
  *         HASH_NUMBER_OF_CSR_REGISTERS of those) are saved.
  * @note   pMemBuffer points to a buffer allocated by the user. The buffer size
  *         must be at least (HASH_NUMBER_OF_CSR_REGISTERS + 3) * 4 uint8 long.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_HASH_ContextSaving</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pMemBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>mem_ptr</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pMemBuffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>csr_ptr</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>HASH</name><operator>-&gt;</operator><name>CSR</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Save IMR register content */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator> <operator>=</operator> <call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>IMR</name></name></expr></argument>,<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
  <comment type="block">/* Save STR register content */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator> <operator>=</operator> <call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>STR</name></name></expr></argument>,<argument><expr><name>HASH_STR_NBLW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
  <comment type="block">/* Save CR register content */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator> <operator>=</operator> <call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>,<argument><expr><name>HASH_CR_DMAE</name><operator>|</operator><name>HASH_CR_DATATYPE</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator> <operator>=</operator> <call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>,<argument><expr><name>HASH_CR_DMAE</name><operator>|</operator><name>HASH_CR_DATATYPE</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_LKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
  <comment type="block">/* By default, save all CSRs registers */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>HASH_NUMBER_OF_CSR_REGISTERS</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator><literal type="number">0U</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>csr_ptr</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>csr_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Restore the HASH context in case of processing resumption.
  * @param  hhash: HASH handle.
  * @param  pMemBuffer: pointer to the memory buffer where the HASH context
  *         is stored.
  * @note   The IMR, STR, CR then all the CSR registers are restored
  *         in that order. Only the r/w bits are restored.
  * @note   By default, all the context swap registers (HASH_NUMBER_OF_CSR_REGISTERS
  *         of those) are restored (all of them have been saved by default
  *         beforehand).
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_HASH_ContextRestoring</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pMemBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>mem_ptr</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pMemBuffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>csr_ptr</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>HASH</name><operator>-&gt;</operator><name>CSR</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Restore IMR register content */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>IMR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
  <comment type="block">/* Restore STR register content */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>STR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
  <comment type="block">/* Restore CR register content */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>

  <comment type="block">/* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */</comment>
  <expr_stmt><expr><call><name>__HAL_HASH_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* By default, restore all CSR registers */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>HASH_NUMBER_OF_CSR_REGISTERS</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator><literal type="number">0U</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>csr_ptr</name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>mem_ptr</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>csr_ptr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Initiate HASH processing suspension when in polling or interruption mode.
  * @param  hhash: HASH handle.
  * @note   Set the handle field SuspendRequest to the appropriate value so that
  *         the on-going HASH processing is suspended as soon as the required
  *         conditions are met. Note that the actual suspension is carried out
  *         by the functions HASH_WriteData() in polling mode and HASH_IT() in
  *         interruption mode.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_HASH_SwFeed_ProcessSuspend</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set Handle Suspend Request field */</comment>
  <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>SuspendRequest</name></name> <operator>=</operator> <name>HAL_HASH_SUSPEND</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Suspend the HASH processing when in DMA mode.
  * @param  hhash: HASH handle.
  * @note   When suspension attempt occurs at the very end of a DMA transfer and
  *         all the data have already been entered in the IP, hhash-&gt;State is
  *         set to HAL_HASH_STATE_READY and the API returns HAL_ERROR. It is
  *         recommended to wrap-up the processing in reading the digest as usual.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_HASH_DMAFeed_ProcessSuspend</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_remaining_DMATransferSize_inWords</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_initial_DMATransferSize_inWords</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_words_already_pushed</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>

   <comment type="block">/* Make sure there is enough time to suspend the processing */</comment>
    <expr_stmt><expr><name>tmp_remaining_DMATransferSize_inWords</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DMA_Stream_TypeDef</name> <operator>*</operator><operator>)</operator><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>NDTR</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>tmp_remaining_DMATransferSize_inWords</name> <operator>&lt;=</operator> <name>HASH_DMA_SUSPENSION_WORDS_LIMIT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* No suspension attempted since almost to the end of the transferred data. */</comment>
      <comment type="block">/* Best option for user code is to wrap up low priority message hashing     */</comment>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Wait for DMAS to be reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>HASH_TIMEOUTVALUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
       <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>__HAL_HASH_GET_FLAG</name><argument_list>(<argument><expr><name>HASH_FLAG_DCIS</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Wait for DMAS to be set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_BUSY</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>HASH_TIMEOUTVALUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
       <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable DMA channel */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name></name></expr></argument>)</argument_list></call> <operator>==</operator><name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*
      Note that the Abort function will
      - Clear the transfer error flags
      - Unlock
      - Set the State
      */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear DMAE bit */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>,<argument><expr><name>HASH_CR_DMAE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>HASH_TIMEOUTVALUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>__HAL_HASH_GET_FLAG</name><argument_list>(<argument><expr><name>HASH_FLAG_DCIS</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* At this point, DMA interface is disabled and no transfer is on-going */</comment>
    <comment type="block">/* Retrieve from the DMA handle how many words remain to be written */</comment>
    <expr_stmt><expr><name>tmp_remaining_DMATransferSize_inWords</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DMA_Stream_TypeDef</name> <operator>*</operator><operator>)</operator><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>NDTR</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>tmp_remaining_DMATransferSize_inWords</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* All the DMA transfer is actually done. Suspension occurred at the very end
         of the transfer. Either the digest computation is about to start (HASH case)
         or processing is about to move from one step to another (HMAC case).
         In both cases, the processing can't be suspended at this point. It is
         safer to
         - retrieve the low priority block digest before starting the high
           priority block processing (HASH case)
         - re-attempt a new suspension (HMAC case)
         */</comment>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

      <comment type="block">/* Compute how many words were supposed to be transferred by DMA */</comment>
      <expr_stmt><expr><name>tmp_initial_DMATransferSize_inWords</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name><operator>%</operator><literal type="number">4U</literal><operator>)</operator><operator>!=</operator><literal type="number">0U</literal><operator>)</operator></expr> ?</condition><then>  <expr><operator>(</operator><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name><operator>+</operator><literal type="number">3U</literal><operator>)</operator><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></then><else>: <expr><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

      <comment type="block">/* If discrepancy between the number of words reported by DMA IP and the numbers of words entered as reported
        by HASH IP, correct it */</comment>
      <comment type="block">/* tmp_words_already_pushed reflects the number of words that were already pushed before
         the start of DMA transfer (multi-buffer processing case) */</comment>
      <expr_stmt><expr><name>tmp_words_already_pushed</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>NbWordsAlreadyPushed</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>tmp_words_already_pushed</name> <operator>+</operator> <name>tmp_initial_DMATransferSize_inWords</name> <operator>-</operator> <name>tmp_remaining_DMATransferSize_inWords</name><operator>)</operator> <operator>%</operator><literal type="number">16U</literal><operator>)</operator>  <operator>!=</operator> <call><name>HASH_NBW_PUSHED</name><argument_list>()</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>tmp_remaining_DMATransferSize_inWords</name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* one less word to be transferred again */</comment>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Accordingly, update the input pointer that points at the next word to be transferred to the IP by DMA */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name> <operator>+=</operator>  <literal type="number">4U</literal> <operator>*</operator> <operator>(</operator><name>tmp_initial_DMATransferSize_inWords</name> <operator>-</operator> <name>tmp_remaining_DMATransferSize_inWords</name><operator>)</operator></expr> ;</expr_stmt>

      <comment type="block">/* And store in HashInCount the remaining size to transfer (in bytes) */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <literal type="number">4U</literal> <operator>*</operator> <name>tmp_remaining_DMATransferSize_inWords</name></expr>;</expr_stmt>

    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set State as suspended */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>

  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the HASH handle error code.
  * @param  hhash: pointer to a HASH_HandleTypeDef structure.
  * @retval HASH Error Code
*/</comment>
<function><type><name>uint32_t</name></type> <name>HAL_HASH_GetError</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return HASH Error Code */</comment>
  <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>


<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup HASH_Private_Functions HASH Private Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief DMA HASH Input Data transfer completion callback.
  * @param hdma: DMA handle.
  * @note  In case of HMAC processing, HASH_DMAXferCplt() initiates
  *        the next DMA transfer for the following HMAC step.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HASH_DMAXferCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HASH_HandleTypeDef</name><modifier>*</modifier></type> <name>hhash</name> <init>= <expr><operator>(</operator> <name>HASH_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>inputaddr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>buffersize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name></decl> ;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
  <block>{<block_content>
    
    <comment type="block">/* Disable the DMA transfer */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_DMAE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_MODE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* If no HMAC processing, input data transfer is now over */</comment>
      
      <comment type="block">/* Change the HASH state to ready */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Call Input data transfer complete call back */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>InCpltCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_HASH_InCpltCallback</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>
      
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* HMAC processing: depending on the current HMAC step and whether or
      not multi-buffer processing is on-going, the next step is initiated
      and MDMAT bit is set.  */</comment>
      
      
      <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* This is the end of HMAC processing */</comment>
        
        <comment type="block">/* Change the HASH state to ready */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
        
        <comment type="block">/* Call Input data transfer complete call back
        (note that the last DMA transfer was that of the key
        for the outer HASH operation). */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>InCpltCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_HASH_InCpltCallback</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>
        
        <return>return;</return>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hhash</name><operator>-&gt;</operator><name>pHashMsgBuffPtr</name></name></expr>;</expr_stmt>     <comment type="block">/* DMA transfer start address */</comment>
        <expr_stmt><expr><name>buffersize</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name></expr>;</expr_stmt>                 <comment type="block">/* DMA transfer size (in bytes) */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name></expr>;</expr_stmt>        <comment type="block">/* Move phase from Step 1 to Step 2 */</comment>
        
        <comment type="block">/* In case of suspension request, save the new starting parameters */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name></expr>;</expr_stmt>         <comment type="block">/* Initial DMA transfer size (in bytes) */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name>  <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>pHashMsgBuffPtr</name></name></expr> ;</expr_stmt> <comment type="block">/* DMA transfer start address           */</comment>
        
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>NbWordsAlreadyPushed</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>                  <comment type="block">/* Reset number of words already pushed */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <comment type="block">/* Check whether or not digest calculation must be disabled (in case of multi-buffer HMAC processing) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>DigestCalculationDisable</name></name> <operator>!=</operator> <name>RESET</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Digest calculation is disabled: Step 2 must start with MDMAT bit set,
          no digest calculation will be triggered at the end of the input buffer feeding to the IP */</comment>
          <expr_stmt><expr><call><name>__HAL_HASH_SET_MDMAT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
      </block_content>}</block></if>
      <else>else  <comment type="block">/*case (hhash-&gt;Phase == HAL_HASH_PHASE_HMAC_STEP_2)*/</comment>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>DigestCalculationDisable</name></name> <operator>!=</operator> <name>RESET</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* No automatic move to Step 3 as a new message buffer will be fed to the IP
          (case of multi-buffer HMAC processing):
          DCAL must not be set.
          Phase remains in Step 2, MDMAT remains set at this point.
          Change the HASH state to ready and call Input data transfer complete call back. */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
          <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>InCpltCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>HAL_HASH_InCpltCallback</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>
          <return>return ;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Digest calculation is not disabled (case of single buffer input or last buffer
          of multi-buffer HMAC processing) */</comment>
          <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr>;</expr_stmt>       <comment type="block">/* DMA transfer start address */</comment>
          <expr_stmt><expr><name>buffersize</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt>             <comment type="block">/* DMA transfer size (in bytes) */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name></expr>;</expr_stmt>    <comment type="block">/* Move phase from Step 2 to Step 3 */</comment>
          <comment type="block">/* In case of suspension request, save the new starting parameters */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt>     <comment type="block">/* Initial size for second DMA transfer (input data) */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name>  <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr> ;</expr_stmt>   <comment type="block">/* address passed to DMA, now entering data message */</comment>
          
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>NbWordsAlreadyPushed</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>              <comment type="block">/* Reset number of words already pushed */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
   
    <comment type="block">/* Configure the Number of valid bits in last word of the message */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the HASH DMA transfert completion call back */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>HASH_DMAXferCplt</name></expr>;</expr_stmt>
     
      <comment type="block">/* Enable the DMA In DMA Stream */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name></name></expr></argument>, <argument><expr><name>inputaddr</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>HASH</name><operator>-&gt;</operator><name>DIN</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>buffersize</name> <operator>%</operator><literal type="number">4U</literal><operator>)</operator><operator>!=</operator><literal type="number">0U</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>buffersize</name><operator>+</operator><operator>(</operator><literal type="number">4U</literal><operator>-</operator><operator>(</operator><name>buffersize</name> <operator>%</operator><literal type="number">4U</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></then><else>:<expr><operator>(</operator><name>buffersize</name><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable DMA requests */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_DMAE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
          <comment type="block">/* Return function status */</comment>
      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update DAC state machine to error */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_ERROR</name></expr>;</expr_stmt>      
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Change DAC state */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>     
  </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief DMA HASH communication error callback.
  * @param hdma: DMA handle.
  * @note  HASH_DMAError() callback invokes HAL_HASH_ErrorCallback() that
  *        can contain user code to manage the error.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HASH_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HASH_HandleTypeDef</name><modifier>*</modifier></type> <name>hhash</name> <init>= <expr><operator>(</operator> <name>HASH_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_HASH_ERROR_DMA</name></expr>;</expr_stmt>
    <comment type="block">/* Set HASH state to ready to prevent any blocking issue in user code
       present in HAL_HASH_ErrorCallback() */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
    <comment type="block">/* Set HASH handle status to error */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_HASH_ErrorCallback</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>
    <comment type="block">/* After error handling by code user, reset HASH handle HAL status */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>HAL_OK</name></expr>;</expr_stmt>

  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Feed the input buffer to the HASH IP.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to input buffer.
  * @param  Size: the size of input buffer in bytes.
  * @note   HASH_WriteData() regularly reads hhash-&gt;SuspendRequest to check whether
  *         or not the HASH processing must be suspended. If this is the case, the
  *         processing is suspended when possible and the IP feeding point reached at
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HASH_WriteData</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>buffercounter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>inputaddr</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <name>pInBuffer</name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>buffercounter</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</init> <condition><expr><name>buffercounter</name> <operator>&lt;</operator> <name>Size</name></expr>;</condition> <incr><expr><name>buffercounter</name><operator>+=</operator><literal type="number">4U</literal></expr></incr>)</control>
  <block>{<block_content>
    <comment type="block">/* Write input data 4 bytes at a time */</comment>
    <expr_stmt><expr><name><name>HASH</name><operator>-&gt;</operator><name>DIN</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><name>inputaddr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>inputaddr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>

    <comment type="block">/* If the suspension flag has been raised and if the processing is not about
    to end, suspend processing */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>SuspendRequest</name></name> <operator>==</operator> <name>HAL_HASH_SUSPEND</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>buffercounter</name><operator>+</operator><literal type="number">4U</literal><operator>)</operator> <operator>&lt;</operator> <name>Size</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>__HAL_HASH_GET_FLAG</name><argument_list>(<argument><expr><name>HASH_FLAG_DINIS</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Reset SuspendRequest */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>SuspendRequest</name></name> <operator>=</operator> <name>HAL_HASH_SUSPEND_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Depending whether the key or the input data were fed to the IP, the feeding point
        reached at suspension time is not saved in the same handle fields */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_PROCESS</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Save current reading and writing locations of Input and Output buffers */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name> <operator>=</operator>  <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>inputaddr</name></expr>;</expr_stmt>
          <comment type="block">/* Save the number of bytes that remain to be processed at this point */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name>    <operator>=</operator>  <name>Size</name> <operator>-</operator> <operator>(</operator><name>buffercounter</name> <operator>+</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Save current reading and writing locations of Input and Output buffers */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashKeyBuffPtr</name></name>  <operator>=</operator>  <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>inputaddr</name></expr>;</expr_stmt>
          <comment type="block">/* Save the number of bytes that remain to be processed at this point */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashKeyCount</name></name>  <operator>=</operator>  <name>Size</name> <operator>-</operator> <operator>(</operator><name>buffercounter</name> <operator>+</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Unexpected phase: unlock process and report error */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Set the HASH state to Suspended and exit to stop entering data */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt> <comment type="block">/* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))  */</comment>
    </block_content>}</block></if></if_stmt> <comment type="block">/* if ((hhash-&gt;SuspendRequest == HAL_HASH_SUSPEND) &amp;&amp; ((buffercounter+4) &lt; Size)) */</comment>
  </block_content>}</block></for>   <comment type="block">/* for(buffercounter = 0; buffercounter &lt; Size; buffercounter+=4)                 */</comment>

  <comment type="block">/* At this point, all the data have been entered to the IP: exit */</comment>
  <return>return  <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Retrieve the message digest.
  * @param  pMsgDigest: pointer to the computed digest.
  * @param  Size: message digest size in bytes.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HASH_GetDigest</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pMsgDigest</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>msgdigest</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pMsgDigest</name></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>(<expr><name>Size</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Read the message digest */</comment>
    <case>case <expr><literal type="number">16</literal></expr>:</case>  <comment type="block">/* MD5 */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><literal type="number">20</literal></expr>:</case>  <comment type="block">/* SHA1 */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><literal type="number">28</literal></expr>:</case>  <comment type="block">/* SHA224 */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH_DIGEST</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH_DIGEST</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
  <case>case <expr><literal type="number">32</literal></expr>:</case>   <comment type="block">/* SHA256 */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH_DIGEST</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH_DIGEST</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgdigest</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>msgdigest</name><operator>)</operator> <operator>=</operator> <call><name>__REV</name><argument_list>(<argument><expr><name><name>HASH_DIGEST</name><operator>-&gt;</operator><name>HR</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
    <default>default:</default>
    <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>



<comment type="block" format="doxygen">/**
  * @brief  Handle HASH processing Timeout.
  * @param  hhash: HASH handle.
  * @param  Flag: specifies the HASH flag to check.
  * @param  Status: the Flag status (SET or RESET).
  * @param  Timeout: Timeout duration.
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HASH_WaitOnFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>Status</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Wait until flag is set */</comment>
  <if_stmt><if>if<condition>(<expr><name>Status</name> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <while>while<condition>(<expr><call><name>__HAL_HASH_GET_FLAG</name><argument_list>(<argument><expr><name>Flag</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call><operator>-</operator><name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Set State to Ready to be able to restart later on */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name>  <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
          <comment type="block">/* Store time out issue in handle status */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <while>while<condition>(<expr><call><name>__HAL_HASH_GET_FLAG</name><argument_list>(<argument><expr><name>Flag</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call><operator>-</operator><name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Set State to Ready to be able to restart later on */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name>  <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
          <comment type="block">/* Store time out issue in handle status */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  HASH processing in interruption mode.
  * @param  hhash: HASH handle.
  * @note   HASH_IT() regularly reads hhash-&gt;SuspendRequest to check whether
  *         or not the HASH processing must be suspended. If this is the case, the
  *         processing is suspended when possible and the IP feeding point reached at
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HASH_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* ITCounter must not be equal to 0 at this point. Report an error if this is the case. */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Interrupts */</comment>
      <expr_stmt><expr><call><name>__HAL_HASH_DISABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* HASH state set back to Ready to prevent any issue in user code
         present in HAL_HASH_ErrorCallback() */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
    <block>{<block_content>
     <comment type="block">/* This is the first call to HASH_IT, the first input data are about to be
        entered in the IP. A specific processing is carried out at this point to
        start-up the processing. */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">2U</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Cruise speed reached, HashITCounter remains equal to 3 until the end of
        the HASH processing or the end of the current step for HMAC processing. */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">3U</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If digest is ready */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_HASH_GET_FLAG</name><argument_list>(<argument><expr><name>HASH_FLAG_DCIS</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read the digest */</comment>
      <expr_stmt><expr><call><name>HASH_GetDigest</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashOutBuffPtr</name></name></expr></argument>, <argument><expr><call><name>HASH_DIGEST_LENGTH</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable Interrupts */</comment>
      <expr_stmt><expr><call><name>__HAL_HASH_DISABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <comment type="block">/* Call digest computation complete call back */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>DgstCpltCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_HASH_DgstCpltCallback</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>

      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If IP ready to accept new data */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_HASH_GET_FLAG</name><argument_list>(<argument><expr><name>HASH_FLAG_DINIS</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>

      <comment type="block">/* If the suspension flag has been raised and if the processing is not about
         to end, suspend processing */</comment>
      <if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator>  <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>SuspendRequest</name></name> <operator>==</operator> <name>HAL_HASH_SUSPEND</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable Interrupts */</comment>
        <expr_stmt><expr><call><name>__HAL_HASH_DISABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Reset SuspendRequest */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>SuspendRequest</name></name> <operator>=</operator> <name>HAL_HASH_SUSPEND_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Change the HASH state */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Enter input data in the IP thru HASH_Write_Block_Data() call and
        check whether the digest calculation has been triggered */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HASH_Write_Block_Data</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>HASH_DIGEST_CALCULATION_STARTED</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Call Input data transfer complete call back
           (called at the end of each step for HMAC) */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_HASH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hhash</name><operator>-&gt;</operator><name>InCpltCallback</name></name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_HASH_InCpltCallback</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_HASH_REGISTER_CALLBACKS */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Wait until IP is not busy anymore */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>HASH_TIMEOUTVALUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Disable Interrupts */</comment>
            <expr_stmt><expr><call><name>__HAL_HASH_DISABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* Initialization start for HMAC STEP 2 */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name></expr>;</expr_stmt>        <comment type="block">/* Move phase from Step 1 to Step 2 */</comment>
          <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Set NBLW for the input message */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name></expr>;</expr_stmt>         <comment type="block">/* Set the input data size (in bytes) */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>pHashMsgBuffPtr</name></name></expr>;</expr_stmt>   <comment type="block">/* Set the input data address */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>                         <comment type="block">/* Set ITCounter to 1 to indicate the start of a new phase */</comment>
          <expr_stmt><expr><call><name>__HAL_HASH_ENABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* Enable IT (was disabled in HASH_Write_Block_Data) */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Wait until IP is not busy anymore */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>HASH_TIMEOUTVALUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Disable Interrupts */</comment>
            <expr_stmt><expr><call><name>__HAL_HASH_DISABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* Initialization start for HMAC STEP 3 */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name></expr>;</expr_stmt>         <comment type="block">/* Move phase from Step 2 to Step 3 */</comment>
          <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Set NBLW for the key */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt>          <comment type="block">/* Set the key size (in bytes) */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr>;</expr_stmt>          <comment type="block">/* Set the key address */</comment>
          <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>                          <comment type="block">/* Set ITCounter to 1 to indicate the start of a new phase */</comment>
          <expr_stmt><expr><call><name>__HAL_HASH_ENABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* Enable IT (was disabled in HASH_Write_Block_Data) */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Nothing to do */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt> <comment type="block">/* if (HASH_Write_Block_Data(hhash) == HASH_DIGEST_CALCULATION_STARTED) */</comment>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))*/</comment>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Write a block of data in HASH IP in interruption mode.
  * @param  hhash: HASH handle.
  * @note   HASH_Write_Block_Data() is called under interruption by HASH_IT().
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>HASH_Write_Block_Data</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>inputaddr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>buffercounter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>inputcounter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ret</name> <init>= <expr><name>HASH_DIGEST_CALCULATION_NOT_STARTED</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If there are more than 64 bytes remaining to be entered */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>&gt;</operator> <literal type="number">64U</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name></expr>;</expr_stmt>
    <comment type="block">/* Write the Input block in the Data IN register
      (16 32-bit words, or 64 bytes are entered) */</comment>
    <for>for<control>(<init><expr><name>buffercounter</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</init> <condition><expr><name>buffercounter</name> <operator>&lt;</operator> <literal type="number">64U</literal></expr>;</condition> <incr><expr><name>buffercounter</name><operator>+=</operator><literal type="number">4U</literal></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name><name>HASH</name><operator>-&gt;</operator><name>DIN</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><name>inputaddr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>inputaddr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* If this is the start of input data entering, an additional word
      must be entered to start up the HASH processing */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>HASH</name><operator>-&gt;</operator><name>DIN</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><name>inputaddr</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>&gt;=</operator> <literal type="number">68U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* There are still data waiting to be entered in the IP.
           Decrement buffer counter and set pointer to the proper
           memory location for the next data entering round. */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>-=</operator> <literal type="number">68U</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name><operator>+=</operator> <literal type="number">68U</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* All the input buffer has been fed to the HW. */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* 64 bytes have been entered and there are still some remaining:
         Decrement buffer counter and set pointer to the proper
        memory location for the next data entering round.*/</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>-=</operator> <literal type="number">64U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name><operator>+=</operator> <literal type="number">64U</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* 64 or less bytes remain to be entered. This is the last
      data entering round. */</comment>

    <comment type="block">/* Get the buffer address */</comment>
    <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name></expr>;</expr_stmt>
    <comment type="block">/* Get the buffer counter */</comment>
    <expr_stmt><expr><name>inputcounter</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name></expr>;</expr_stmt>
    <comment type="block">/* Disable Interrupts */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_DISABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write the Input block in the Data IN register */</comment>
    <for>for<control>(<init><expr><name>buffercounter</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</init> <condition><expr><name>buffercounter</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>inputcounter</name><operator>+</operator><literal type="number">3U</literal><operator>)</operator><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr>;</condition> <incr><expr><name>buffercounter</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name><name>HASH</name><operator>-&gt;</operator><name>DIN</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><name>inputaddr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>inputaddr</name><operator>+=</operator><literal type="number">4U</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Start the Digest calculation */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_START_DIGEST</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Return indication that digest calculation has started:
       this return value triggers the call to Input data transfer
       complete call back as well as the proper transition from
       one step to another in HMAC mode. */</comment>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>HASH_DIGEST_CALCULATION_STARTED</name></expr>;</expr_stmt>
    <comment type="block">/* Reset buffer counter */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Return whether or digest calculation has started */</comment>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  HMAC processing in polling mode.
  * @param  hhash: HASH handle.
  * @param  Timeout: Timeout value.
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>HMAC_Processing</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Ensure first that Phase is correct */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>!=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>!=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>!=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Change the HASH state */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlock */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* HMAC Step 1 processing */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block" format="doxygen">/************************** STEP 1 ******************************************/</comment>
    <comment type="block">/* Configure the Number of valid bits in last word of the message */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write input buffer in Data register */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <call><name>HASH_WriteData</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashKeyBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashKeyCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check whether or not key entering process has been suspended */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Stop right there and return function status */</comment>
      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No processing suspension at this point: set DCAL bit. */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_START_DIGEST</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait for BUSY flag to be cleared */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Move from Step 1 to Step 2 */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name></expr>;</expr_stmt>

  </block_content>}</block></if></if_stmt>

  <comment type="block">/* HMAC Step 2 processing.
     After phase check, HMAC_Processing() may
     - directly start up from this point in resumption case
       if the same Step 2 processing was suspended previously
    - or fall through from the Step 1 processing carried out hereabove */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block" format="doxygen">/************************** STEP 2 ******************************************/</comment>
    <comment type="block">/* Configure the Number of valid bits in last word of the message */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write input buffer in Data register */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <call><name>HASH_WriteData</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check whether or not data entering process has been suspended */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Stop right there and return function status */</comment>
      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No processing suspension at this point: set DCAL bit. */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_START_DIGEST</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait for BUSY flag to be cleared */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Move from Step 2 to Step 3 */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name></expr>;</expr_stmt>
    <comment type="block">/* In case Step 1 phase was suspended then resumed,
       set again Key input buffers and size before moving to
       next step */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashKeyBuffPtr</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashKeyCount</name></name>    <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>


 <comment type="block">/* HMAC Step 3 processing.
     After phase check, HMAC_Processing() may
     - directly start up from this point in resumption case
       if the same Step 3 processing was suspended previously
    - or fall through from the Step 2 processing carried out hereabove */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block" format="doxygen">/************************** STEP 3 ******************************************/</comment>
    <comment type="block">/* Configure the Number of valid bits in last word of the message */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write input buffer in Data register */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <call><name>HASH_WriteData</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashKeyBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashKeyCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check whether or not key entering process has been suspended */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Stop right there and return function status */</comment>
      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No processing suspension at this point: start the Digest calculation. */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_START_DIGEST</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait for DCIS flag to be set */</comment>
     <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_DCIS</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read the message digest */</comment>
    <expr_stmt><expr><call><name>HASH_GetDigest</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashOutBuffPtr</name></name></expr></argument>, <argument><expr><call><name>HASH_DIGEST_LENGTH</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

   <comment type="block">/* Change the HASH state */</comment>
   <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>

   <comment type="block">/* Process Unlock */</comment>
   <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <comment type="block">/* Return function status */</comment>
   <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral, next process pInBuffer then
  *         read the computed digest.
  * @note   Digest is available in pOutBuffer.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest.
  * @param  Timeout: Timeout value.
  * @param  Algorithm: HASH algorithm.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HASH_Start</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer_tmp</name></decl>;</decl_stmt>  <comment type="block">/* input data address, input parameter of HASH_WriteData()         */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Size_tmp</name></decl>;</decl_stmt> <comment type="block">/* input data size (in bytes), input parameter of HASH_WriteData() */</comment>
  <decl_stmt><decl><type><name>HAL_HASH_StateTypeDef</name></type> <name>State_tmp</name> <init>= <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt> 

  
  <comment type="block">/* Initiate HASH processing in case of start or resumption */</comment>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>  
    <comment type="block">/* Check input parameters */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pInBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pOutBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if initialization phase has not been already performed */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Configure the number of valid bits in last word of the message */</comment>
      <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
      input parameters of HASH_WriteData() */</comment>
      <expr_stmt><expr><name>pInBuffer_tmp</name> <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>   <comment type="block">/* pInBuffer_tmp is set to the input data address */</comment>
      <expr_stmt><expr><name>Size_tmp</name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>             <comment type="block">/* Size_tmp contains the input data size in bytes */</comment>
      
      <comment type="block">/* Set the phase */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_PROCESS</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_PROCESS</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* if the IP has already been initialized, two cases are possible */</comment>
      
      <comment type="block">/* Process resumption time ... */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
        to the API input parameters but to those saved beforehand by HASH_WriteData()
        when the processing was suspended */</comment>
        <expr_stmt><expr><name>pInBuffer_tmp</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Size_tmp</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <comment type="block">/* ... or multi-buffer HASH processing end */</comment>
      <else>else
      <block>{<block_content>
        <comment type="block">/* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
        input parameters of HASH_WriteData() */</comment>
        <expr_stmt><expr><name>pInBuffer_tmp</name> <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Size_tmp</name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
        <comment type="block">/* Configure the number of valid bits in last word of the message */</comment>
        <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Phase error */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Return function status */</comment>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
    
    
    <comment type="block">/* Write input buffer in Data register */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <call><name>HASH_WriteData</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer_tmp</name></expr></argument>, <argument><expr><name>Size_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* If the process has not been suspended, carry on to digest calculation */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Start the Digest calculation */</comment>
      <expr_stmt><expr><call><name>__HAL_HASH_START_DIGEST</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Wait for DCIS flag to be set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_DCIS</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* Read the message digest */</comment>
      <expr_stmt><expr><call><name>HASH_GetDigest</name><argument_list>(<argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><call><name>HASH_DIGEST_LENGTH</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
    
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  If not already done, initialize the HASH peripheral then
  *         processes pInBuffer.
  * @note   Field hhash-&gt;Phase of HASH handle is tested to check whether or not
  *         the IP has already been initialized.
  * @note   The input buffer size (in bytes) must be a multiple of 4 otherwise, the
  *         HASH digest computation is corrupted.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm: HASH algorithm.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HASH_Accumulate</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer_tmp</name></decl>;</decl_stmt>   <comment type="block">/* input data address, input parameter of HASH_WriteData()         */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Size_tmp</name></decl>;</decl_stmt>  <comment type="block">/* input data size (in bytes), input parameter of HASH_WriteData() */</comment>
  <decl_stmt><decl><type><name>HAL_HASH_StateTypeDef</name></type> <name>State_tmp</name> <init>= <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt> 
   
  <comment type="block">/* Make sure the input buffer size (in bytes) is a multiple of 4 */</comment>
   <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_HASH_POLLING_MULTIBUFFER_SIZE</name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initiate HASH processing in case of start or resumption */</comment>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content> 
    <comment type="block">/* Check input parameters */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pInBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

     <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If resuming the HASH processing */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

      <comment type="block">/* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
         to the API input parameters but to those saved beforehand by HASH_WriteData()
         when the processing was suspended */</comment>
      <expr_stmt><expr><name>pInBuffer_tmp</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name></expr>;</expr_stmt>  <comment type="block">/* pInBuffer_tmp is set to the input data address */</comment>
      <expr_stmt><expr><name>Size_tmp</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name></expr>;</expr_stmt>          <comment type="block">/* Size_tmp contains the input data size in bytes */</comment>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

      <comment type="block">/* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
         input parameters of HASH_WriteData() */</comment>
      <expr_stmt><expr><name>pInBuffer_tmp</name> <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>    <comment type="block">/* pInBuffer_tmp is set to the input data address */</comment>
      <expr_stmt><expr><name>Size_tmp</name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>              <comment type="block">/* Size_tmp contains the input data size in bytes */</comment>

      <comment type="block">/* Check if initialization phase has already be performed */</comment>
      <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_READY</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */</comment>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Set the phase */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_PROCESS</name></expr>;</expr_stmt>

    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Write input buffer in Data register */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <call><name>HASH_WriteData</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>pInBuffer_tmp</name></expr></argument>, <argument><expr><name>Size_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name><name>hhash</name><operator>-&gt;</operator><name>Status</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the process has not been suspended, move the state to Ready */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_HASH_STATE_SUSPENDED</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>

  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>


</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral, next process pInBuffer then
  *         read the computed digest in interruption mode.
  * @note   Digest is available in pOutBuffer.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest.
  * @param  Algorithm: HASH algorithm.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HASH_Start_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>HAL_HASH_StateTypeDef</name></type> <name>State_tmp</name> <init>= <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If State is ready or suspended, start or resume IT-based HASH processing */</comment>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>     
    <comment type="block">/* Check input parameters */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pInBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pOutBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change the HASH state */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize IT counter */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Check if initialization phase has already be performed */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the number of valid bits in last word of the message */</comment>
     <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>               <comment type="block">/* Counter used to keep track of number of data
                                                  to be fed to the IP */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name> <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>       <comment type="block">/* Points at data which will be fed to the IP at
                                                  the next interruption */</comment>
     <comment type="block">/* In case of suspension, hhash-&gt;HashInCount and hhash-&gt;pHashInBuffPtr contain
        the information describing where the HASH process is stopped.
        These variables are used later on to resume the HASH processing at the
        correct location. */</comment>

      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashOutBuffPtr</name></name> <operator>=</operator> <name>pOutBuffer</name></expr>;</expr_stmt>     <comment type="block">/* Points at the computed digest */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set the phase */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_PROCESS</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlock */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable Interrupts */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_ENABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral then initiate a DMA transfer
  *         to feed the input buffer to the IP.
  * @note   If MDMAT bit is set before calling this function (multi-buffer
  *          HASH processing case), the input buffer size (in bytes) must be
  *          a multiple of 4 otherwise, the HASH digest computation is corrupted.
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  Algorithm: HASH algorithm.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HASH_Start_DMA</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>inputaddr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>inputSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name></decl> ;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_HASH_StateTypeDef</name></type> <name>State_tmp</name> <init>= <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Make sure the input buffer size (in bytes) is a multiple of 4 when MDMAT bit is set
     (case of multi-buffer HASH processing) */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_HASH_DMA_MULTIBUFFER_SIZE</name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MDMA defined*/</comment>
   <comment type="block">/* If State is ready or suspended, start or resume polling-based HASH processing */</comment>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content> 
    <comment type="block">/* Check input parameters */</comment>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>pInBuffer</name> <operator>==</operator> <name>NULL</name> <operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator>
    <comment type="block">/* Check phase coherency. Phase must be
       either READY (fresh start)
       or PROCESS (multi-buffer HASH management) */</comment>
       <operator>(</operator><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>!=</operator> <name>HAL_HASH_PHASE_READY</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><call><name>IS_HASH_PROCESSING</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If not a resumption case */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

      <comment type="block">/* Check if initialization phase has already been performed.
         If Phase is already set to HAL_HASH_PHASE_PROCESS, this means the
         API is processing a new input data message in case of multi-buffer HASH
         computation. */</comment>
      <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_READY</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */</comment>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set the phase */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_PROCESS</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Configure the Number of valid bits in last word of the message */</comment>
      <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pInBuffer</name></expr>;</expr_stmt>     <comment type="block">/* DMA transfer start address   */</comment>
      <expr_stmt><expr><name>inputSize</name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>                    <comment type="block">/* DMA transfer size (in bytes) */</comment>

      <comment type="block">/* In case of suspension request, save the starting parameters */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name> <operator>=</operator>  <name>pInBuffer</name></expr>;</expr_stmt>  <comment type="block">/* DMA transfer start address   */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>           <comment type="block">/* DMA transfer size (in bytes) */</comment>

    </block_content>}</block></if>
    <comment type="block">/* If resumption case */</comment>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

      <comment type="block">/* Resumption case, inputaddr and inputSize are not set to the API input parameters
         but to those saved beforehand by HAL_HASH_DMAFeed_ProcessSuspend() when the
         processing was suspended */</comment>
      <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name></expr>;</expr_stmt>  <comment type="block">/* DMA transfer start address   */</comment>
      <expr_stmt><expr><name>inputSize</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name></expr>;</expr_stmt>               <comment type="block">/* DMA transfer size (in bytes) */</comment>

    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set the HASH DMA transfert complete callback */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>HASH_DMAXferCplt</name></expr>;</expr_stmt>
    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>HASH_DMAError</name></expr>;</expr_stmt>

    <comment type="block">/* Store number of words already pushed to manage proper DMA processing suspension */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>NbWordsAlreadyPushed</name></name> <operator>=</operator> <call><name>HASH_NBW_PUSHED</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable the DMA In DMA Stream */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name></name></expr></argument>, <argument><expr><name>inputaddr</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>HASH</name><operator>-&gt;</operator><name>DIN</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>inputSize</name> <operator>%</operator><literal type="number">4U</literal><operator>)</operator><operator>!=</operator><literal type="number">0U</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>inputSize</name><operator>+</operator><operator>(</operator><literal type="number">4U</literal><operator>-</operator><operator>(</operator><name>inputSize</name> <operator>%</operator><literal type="number">4U</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></then><else>:<expr><operator>(</operator><name>inputSize</name><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable DMA requests */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_DMAE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlock */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Return function status */</comment>
    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update HASH state machine to error */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_ERROR</name></expr>;</expr_stmt>      
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Change HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <return>return <expr><name>status</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the computed digest.
  * @note   The API waits for DCIS to be set then reads the computed digest.
  * @param  hhash: HASH handle.
  * @param  pOutBuffer: pointer to the computed digest.
  * @param  Timeout: Timeout value.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HASH_Finish</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>

  <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check parameter */</comment>
    <if_stmt><if>if <condition>(<expr><name>pOutBuffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change the HASH state to busy */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

    <comment type="block">/* Wait for DCIS flag to be set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HASH_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>HASH_FLAG_DCIS</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read the message digest */</comment>
    <expr_stmt><expr><call><name>HASH_GetDigest</name><argument_list>(<argument><expr><name>pOutBuffer</name></expr></argument>, <argument><expr><call><name>HASH_DIGEST_LENGTH</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change the HASH state to ready */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>

    <comment type="block">/* Process UnLock */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>

  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC mode, next process pInBuffer then
  *         read the computed digest.
  * @note   Digest is available in pOutBuffer.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest.
  * @param  Timeout: Timeout value.
  * @param  Algorithm: HASH algorithm.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HMAC_Start</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HAL_HASH_StateTypeDef</name></type> <name>State_tmp</name> <init>= <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt> 
  
   <comment type="block">/* If State is ready or suspended, start or resume polling-based HASH processing */</comment>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content> 
    <comment type="block">/* Check input parameters */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pInBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pOutBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change the HASH state */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

    <comment type="block">/* Check if initialization phase has already be performed */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits */</comment>
      <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name> <operator>&gt;</operator> <literal type="number">64U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_HMAC_KEYTYPE_LONGKEY</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <comment type="block">/* Set the phase to Step 1 */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name></expr>;</expr_stmt>
      <comment type="block">/* Resort to hhash internal fields to feed the IP.
         Parameters will be updated in case of suspension to contain the proper
         information at resumption time. */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashOutBuffPtr</name></name>  <operator>=</operator> <name>pOutBuffer</name></expr>;</expr_stmt>            <comment type="block">/* Output digest address                                              */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name>   <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>             <comment type="block">/* Input data address, HMAC_Processing input parameter for Step 2     */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name>      <operator>=</operator> <name>Size</name></expr>;</expr_stmt>                  <comment type="block">/* Input data size, HMAC_Processing input parameter for Step 2        */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name>     <operator>=</operator> <name>Size</name></expr>;</expr_stmt>                  <comment type="block">/* Store the input buffer size for the whole HMAC process             */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashKeyBuffPtr</name></name>  <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr>;</expr_stmt>      <comment type="block">/* Key address, HMAC_Processing input parameter for Step 1 and Step 3 */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashKeyCount</name></name>     <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt>   <comment type="block">/* Key size, HMAC_Processing input parameter for Step 1 and Step 3    */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Carry out HMAC processing */</comment>
    <return>return <expr><call><name>HMAC_Processing</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</return>

  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC mode, next process pInBuffer then
  *         read the computed digest in interruption mode.
  * @note   Digest is available in pOutBuffer.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  pOutBuffer: pointer to the computed digest.
  * @param  Algorithm: HASH algorithm.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HMAC_Start_IT</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>pOutBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HAL_HASH_StateTypeDef</name></type> <name>State_tmp</name> <init>= <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt> 
    
  <comment type="block">/* If State is ready or suspended, start or resume IT-based HASH processing */</comment>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content> 
    <comment type="block">/* Check input parameters */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pInBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pOutBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change the HASH state */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize IT counter */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashITCounter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Check if initialization phase has already be performed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits */</comment>
      <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name> <operator>&gt;</operator> <literal type="number">64U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_HMAC_KEYTYPE_LONGKEY</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Resort to hhash internal fields hhash-&gt;pHashInBuffPtr and hhash-&gt;HashInCount
         to feed the IP whatever the HMAC step.
         Lines below are set to start HMAC Step 1 processing where key is entered first. */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name>     <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt> <comment type="block">/* Key size                      */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name>  <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr> ;</expr_stmt>   <comment type="block">/* Key address                   */</comment>

      <comment type="block">/* Store input and output parameters in handle fields to manage steps transition
         or possible HMAC suspension/resumption */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashKeyBuffPtr</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr>;</expr_stmt>    <comment type="block">/* Key address                   */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashMsgBuffPtr</name></name> <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>           <comment type="block">/* Input message address         */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name>    <operator>=</operator> <name>Size</name></expr>;</expr_stmt>                <comment type="block">/* Input message size (in bytes) */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashOutBuffPtr</name></name> <operator>=</operator> <name>pOutBuffer</name></expr>;</expr_stmt>          <comment type="block">/* Output digest address         */</comment>

      <comment type="block">/* Configure the number of valid bits in last word of the key */</comment>
      <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the phase to Step 1 */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_3</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Restart IT-based HASH processing after Step 1 or Step 3 suspension */</comment>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Restart IT-based HASH processing after Step 2 suspension */</comment>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Error report as phase incorrect */</comment>
      <comment type="block">/* Process Unlock */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Process Unlock */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable Interrupts */</comment>
    <expr_stmt><expr><call><name>__HAL_HASH_ENABLE_IT</name><argument_list>(<argument><expr><name>HASH_IT_DINI</name><operator>|</operator><name>HASH_IT_DCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

</block_content>}</block></function>



<comment type="block" format="doxygen">/**
  * @brief  Initialize the HASH peripheral in HMAC mode then initiate the required
  *         DMA transfers to feed the key and the input buffer to the IP.
  * @note   Same key is used for the inner and the outer hash functions; pointer to key and
  *         key size are respectively stored in hhash-&gt;Init.pKey and hhash-&gt;Init.KeySize.
  * @note   In case of multi-buffer HMAC processing, the input buffer size (in bytes) must
  *         be a multiple of 4 otherwise, the HASH digest computation is corrupted.
  *         Only the length of the last buffer of the thread doesn't have to be a
  *         multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
  * @param  Size: length of the input buffer in bytes.
  * @param  Algorithm: HASH algorithm.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HMAC_Start_DMA</name><parameter_list>(<parameter><decl><type><name>HASH_HandleTypeDef</name> <modifier>*</modifier></type><name>hhash</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pInBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>inputaddr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>inputSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name></decl> ;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_HASH_StateTypeDef</name></type> <name>State_tmp</name> <init>= <expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>  
   <comment type="block">/* Make sure the input buffer size (in bytes) is a multiple of 4 when digest calculation
      is disabled (multi-buffer HMAC processing, MDMAT bit to be set) */</comment>
   <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_HMAC_DMA_MULTIBUFFER_SIZE</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* If State is ready or suspended, start or resume DMA-based HASH processing */</comment>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>State_tmp</name> <operator>==</operator> <name>HAL_HASH_STATE_SUSPENDED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>   
    <comment type="block">/* Check input parameters */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pInBuffer</name> <operator>==</operator> <name>NULL</name> <operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name> <operator>==</operator> <name>NULL</name> <operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator>
   <comment type="block">/* Check phase coherency. Phase must be
       either READY (fresh start)
       or one of HMAC PROCESS steps (multi-buffer HASH management) */</comment>
       <operator>(</operator><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>!=</operator> <name>HAL_HASH_PHASE_READY</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><call><name>IS_HMAC_PROCESSING</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If not a case of resumption after suspension */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_HASH_STATE_READY</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Check whether or not initialization phase has already be performed */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <comment type="block">/* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits.
         At the same time, ensure MDMAT bit is cleared. */</comment>
      <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name> <operator>&gt;</operator> <literal type="number">64U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_MDMAT</name><operator>|</operator><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_HMAC_KEYTYPE_LONGKEY</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_MDMAT</name><operator>|</operator><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits */</comment>
      <if_stmt><if>if<condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name> <operator>&gt;</operator> <literal type="number">64U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_HMAC_KEYTYPE_LONGKEY</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_LKEY</name><operator>|</operator><name>HASH_CR_ALGO</name><operator>|</operator><name>HASH_CR_MODE</name><operator>|</operator><name>HASH_CR_INIT</name></expr></argument>, <argument><expr><name>Algorithm</name> <operator>|</operator> <name>HASH_ALGOMODE_HMAC</name> <operator>|</operator> <name>HASH_CR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     
      <comment type="block">/* Store input aparameters in handle fields to manage steps transition
         or possible HMAC suspension/resumption */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt>   <comment type="block">/* Initial size for first DMA transfer (key size)      */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashKeyBuffPtr</name></name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr>;</expr_stmt>  <comment type="block">/* Key address                                         */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name>  <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name></expr> ;</expr_stmt> <comment type="block">/* First address passed to DMA (key address at Step 1) */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashMsgBuffPtr</name></name> <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>         <comment type="block">/* Input data address                                  */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashBuffSize</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>                 <comment type="block">/* input data size (in bytes)                          */</comment>

      <comment type="block">/* Set DMA input parameters */</comment>
      <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>pKey</name></name><operator>)</operator></expr>;</expr_stmt>   <comment type="block">/* Address passed to DMA (start by entering Key message) */</comment>
      <expr_stmt><expr><name>inputSize</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr>;</expr_stmt>            <comment type="block">/* Size for first DMA transfer (in bytes) */</comment>

      <comment type="block">/* Configure the number of valid bits in last word of the key */</comment>
      <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>KeySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the phase to Step 1 */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>=</operator> <name>HAL_HASH_PHASE_HMAC_STEP_1</name></expr>;</expr_stmt>

    </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>Phase</name></name> <operator>==</operator> <name>HAL_HASH_PHASE_HMAC_STEP_2</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process a new input data message in case of multi-buffer HMAC processing
        (this is not a resumption case) */</comment>

      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

      <comment type="block">/* Save input parameters to be able to manage possible suspension/resumption */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>                <comment type="block">/* Input message address       */</comment>
        <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name> <operator>=</operator> <name>pInBuffer</name></expr>;</expr_stmt>        <comment type="block">/* Input message size in bytes */</comment>

      <comment type="block">/* Set DMA input parameters */</comment>
        <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pInBuffer</name></expr>;</expr_stmt>           <comment type="block">/* Input message address       */</comment>
        <expr_stmt><expr><name>inputSize</name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>                          <comment type="block">/* Input message size in bytes */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>hhash</name><operator>-&gt;</operator><name>DigestCalculationDisable</name></name> <operator>==</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* This means this is the last buffer of the multi-buffer sequence: DCAL needs to be set. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_CR_MDMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><call><name>__HAL_HASH_RESET_MDMAT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>__HAL_HASH_SET_NBVALIDBITS</name><argument_list>(<argument><expr><name>inputSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Phase not aligned with handle READY state */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Return function status */</comment>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
       <comment type="block">/* Resumption case (phase may be Step 1, 2 or 3) */</comment>

      <comment type="block">/* Change the HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_BUSY</name></expr>;</expr_stmt>

      <comment type="block">/* Set DMA input parameters at resumption location;
         inputaddr and inputSize are not set to the API input parameters
         but to those saved beforehand by HAL_HASH_DMAFeed_ProcessSuspend() when the
         processing was suspended. */</comment>
      <expr_stmt><expr><name>inputaddr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>hhash</name><operator>-&gt;</operator><name>pHashInBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Input message address       */</comment>
      <expr_stmt><expr><name>inputSize</name> <operator>=</operator> <name><name>hhash</name><operator>-&gt;</operator><name>HashInCount</name></name></expr>;</expr_stmt>                 <comment type="block">/* Input message size in bytes */</comment>
    </block_content>}</block></else></if_stmt>


    <comment type="block">/* Set the HASH DMA transfert complete callback */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>HASH_DMAXferCplt</name></expr>;</expr_stmt>
    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>HASH_DMAError</name></expr>;</expr_stmt>

    <comment type="block">/* Store number of words already pushed to manage proper DMA processing suspension */</comment>
    <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>NbWordsAlreadyPushed</name></name> <operator>=</operator> <call><name>HASH_NBW_PUSHED</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable the DMA In DMA Stream */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hhash</name><operator>-&gt;</operator><name>hdmain</name></name></expr></argument>, <argument><expr><name>inputaddr</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>HASH</name><operator>-&gt;</operator><name>DIN</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>inputSize</name> <operator>%</operator><literal type="number">4U</literal><operator>)</operator><operator>!=</operator><literal type="number">0U</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>inputSize</name><operator>+</operator><operator>(</operator><literal type="number">4U</literal><operator>-</operator><operator>(</operator><name>inputSize</name> <operator>%</operator><literal type="number">4U</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></then><else>:<expr><operator>(</operator><name>inputSize</name><operator>/</operator><literal type="number">4U</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Enable DMA requests */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>HASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>HASH_CR_DMAE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Return function status */</comment>
    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update HASH state machine to error */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Change HASH state */</comment>
      <expr_stmt><expr><name><name>hhash</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_HASH_STATE_READY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>status</name></expr>;</return> 
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_HASH_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*  HASH*/</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>



<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
