<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_adc_ex.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_adc_ex.c
  * @author  MCD Application Team
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the ADC extension peripheral:
  *           + Extended features functions
  *         
  @verbatim
  ==============================================================================
                    ##### How to use this driver #####
  ==============================================================================
    [..]
    (#)Initialize the ADC low level resources by implementing the HAL_ADC_MspInit():
       (##) Enable the ADC interface clock using __HAL_RCC_ADC_CLK_ENABLE()
       (##) ADC pins configuration
             (+++) Enable the clock for the ADC GPIOs using the following function:
                   __HAL_RCC_GPIOx_CLK_ENABLE()  
             (+++) Configure these ADC pins in analog mode using HAL_GPIO_Init() 
       (##) In case of using interrupts (e.g. HAL_ADC_Start_IT())
             (+++) Configure the ADC interrupt priority using HAL_NVIC_SetPriority()
             (+++) Enable the ADC IRQ handler using HAL_NVIC_EnableIRQ()
             (+++) In ADC IRQ handler, call HAL_ADC_IRQHandler()
      (##) In case of using DMA to control data transfer (e.g. HAL_ADC_Start_DMA())
             (+++) Enable the DMAx interface clock using __HAL_RCC_DMAx_CLK_ENABLE()
             (+++) Configure and enable two DMA streams stream for managing data
                 transfer from peripheral to memory (output stream)
             (+++) Associate the initialized DMA handle to the ADC DMA handle
                 using  __HAL_LINKDMA()
             (+++) Configure the priority and enable the NVIC for the transfer complete
                 interrupt on the two DMA Streams. The output stream should have higher
                 priority than the input stream.
     (#) Configure the ADC Prescaler, conversion resolution and data alignment 
         using the HAL_ADC_Init() function. 
  
     (#) Configure the ADC Injected channels group features, use HAL_ADC_Init()
         and HAL_ADC_ConfigChannel() functions.
         
     (#) Three operation modes are available within this driver :     
  
     *** Polling mode IO operation ***
     =================================
     [..]    
       (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart() 
       (+) Wait for end of conversion using HAL_ADC_PollForConversion(), at this stage
           user can specify the value of timeout according to his end application      
       (+) To read the ADC converted values, use the HAL_ADCEx_InjectedGetValue() function.
       (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop()
  
     *** Interrupt mode IO operation ***    
     ===================================
     [..]    
       (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart_IT() 
       (+) Use HAL_ADC_IRQHandler() called under ADC_IRQHandler() Interrupt subroutine
       (+) At ADC end of conversion HAL_ADCEx_InjectedConvCpltCallback() function is executed and user can 
            add his own code by customization of function pointer HAL_ADCEx_InjectedConvCpltCallback 
       (+) In case of ADC Error, HAL_ADCEx_InjectedErrorCallback() function is executed and user can 
            add his own code by customization of function pointer HAL_ADCEx_InjectedErrorCallback
       (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop_IT()
       
            
     *** DMA mode IO operation ***    
     ==============================
     [..]    
       (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart_DMA(), at this stage the user specify the length 
           of data to be transferred at each end of conversion 
       (+) At The end of data transfer ba HAL_ADCEx_InjectedConvCpltCallback() function is executed and user can 
            add his own code by customization of function pointer HAL_ADCEx_InjectedConvCpltCallback 
       (+) In case of transfer Error, HAL_ADCEx_InjectedErrorCallback() function is executed and user can 
            add his own code by customization of function pointer HAL_ADCEx_InjectedErrorCallback
        (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop_DMA()
        
     *** Multi mode ADCs Regular channels configuration ***
     ======================================================
     [..]        
       (+) Select the Multi mode ADC regular channels features (dual or triple mode)  
          and configure the DMA mode using HAL_ADCEx_MultiModeConfigChannel() functions. 
       (+) Start the ADC peripheral using HAL_ADCEx_MultiModeStart_DMA(), at this stage the user specify the length 
           of data to be transferred at each end of conversion           
       (+) Read the ADCs converted values using the HAL_ADCEx_MultiModeGetValue() function.
  
  
    @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADCEx ADCEx
  * @brief ADC Extended driver modules
  * @{
  */</comment> 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_ADC_MODULE_ENABLED</name></cpp:ifdef>
    
<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment> 
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup ADCEx_Private_Functions
  * @{
  */</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ADC_MultiModeDMAConvCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ADC_MultiModeDMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ADC_MultiModeDMAHalfConvCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl> 
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup ADCEx_Exported_Functions ADC Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADCEx_Exported_Functions_Group1  Extended features functions 
  *  @brief    Extended features functions  
  *
@verbatim   
 ===============================================================================
                 ##### Extended features functions #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Start conversion of injected channel.
      (+) Stop conversion of injected channel.
      (+) Start multimode and enable DMA transfer.
      (+) Stop multimode and disable DMA transfer.
      (+) Get result of injected channel conversion.
      (+) Get result of multimode conversion.
      (+) Configure injected channels.
      (+) Configure multimode.
               
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Enables the selected ADC software start conversion of the injected channels.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStart</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>counter</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp2</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ADC_Common_TypeDef</name> <modifier>*</modifier></type><name>tmpADC_Common</name></decl>;</decl_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the ADC peripheral */</comment>
  
  <comment type="block">/* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>ADC_CR2_ADON</name><operator>)</operator> <operator>!=</operator> <name>ADC_CR2_ADON</name></expr>)</condition>
  <block>{<block_content>  
    <comment type="block">/* Enable the Peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Delay for ADC stabilization time */</comment>
    <comment type="block">/* Compute number of CPU cycles to wait for */</comment>
    <expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>(</operator><name>ADC_STAB_DELAY_US</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">1000000U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>counter</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>counter</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_ADON</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state                                                          */</comment>
    <comment type="block">/* - Clear state bitfield related to injected group conversion results    */</comment>
    <comment type="block">/* - Set state bitfield related to injected operation                     */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if a regular conversion is ongoing */</comment>
    <comment type="block">/* Note: On this device, there is no ADC error code fields related to     */</comment>
    <comment type="block">/*       conversions on group injected only. In case of conversion on     */</comment>
    <comment type="block">/*       going on group regular, no error code is reset.                  */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Reset ADC all error code fields */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Clear injected group conversion flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Pointer to the common control register to which is belonging hadc    */</comment>
    <comment type="block">/* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */</comment>
    <comment type="block">/* control register)                                                    */</comment>
    <expr_stmt><expr><name>tmpADC_Common</name> <operator>=</operator> <call><name>ADC_COMMON_REGISTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if Multimode enabled */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name></expr></argument>, <argument><expr><name>ADC_CCR_MULTI</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_JEXTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><name>tmp1</name> <operator>&amp;&amp;</operator> <name>tmp2</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable the selected ADC software conversion for injected group */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name>ADC_CR2_JSWSTART</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_JEXTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name> <operator>==</operator> <name>ADC1</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>tmp1</name> <operator>&amp;&amp;</operator> <name>tmp2</name></expr>)</condition>  
      <block>{<block_content>
        <comment type="block">/* Enable the selected ADC software conversion for injected group */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name>ADC_CR2_JSWSTART</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables the interrupt and starts ADC conversion of injected channels.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStart_IT</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>counter</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp2</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ADC_Common_TypeDef</name> <modifier>*</modifier></type><name>tmpADC_Common</name></decl>;</decl_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the ADC peripheral */</comment>
  
  <comment type="block">/* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>ADC_CR2_ADON</name><operator>)</operator> <operator>!=</operator> <name>ADC_CR2_ADON</name></expr>)</condition>
  <block>{<block_content>  
    <comment type="block">/* Enable the Peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Delay for ADC stabilization time */</comment>
    <comment type="block">/* Compute number of CPU cycles to wait for */</comment>
    <expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>(</operator><name>ADC_STAB_DELAY_US</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">1000000U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>counter</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>counter</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_ADON</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state                                                          */</comment>
    <comment type="block">/* - Clear state bitfield related to injected group conversion results    */</comment>
    <comment type="block">/* - Set state bitfield related to injected operation                     */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if a regular conversion is ongoing */</comment>
    <comment type="block">/* Note: On this device, there is no ADC error code fields related to     */</comment>
    <comment type="block">/*       conversions on group injected only. In case of conversion on     */</comment>
    <comment type="block">/*       going on group regular, no error code is reset.                  */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Reset ADC all error code fields */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Clear injected group conversion flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable end of conversion interrupt for injected channels */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Pointer to the common control register to which is belonging hadc    */</comment>
    <comment type="block">/* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */</comment>
    <comment type="block">/* control register)                                                    */</comment>
    <expr_stmt><expr><name>tmpADC_Common</name> <operator>=</operator> <call><name>ADC_COMMON_REGISTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if Multimode enabled */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name></expr></argument>, <argument><expr><name>ADC_CCR_MULTI</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_JEXTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><name>tmp1</name> <operator>&amp;&amp;</operator> <name>tmp2</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable the selected ADC software conversion for injected group */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name>ADC_CR2_JSWSTART</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_JEXTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name> <operator>==</operator> <name>ADC1</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>tmp1</name> <operator>&amp;&amp;</operator> <name>tmp2</name></expr>)</condition>  
      <block>{<block_content>
        <comment type="block">/* Enable the selected ADC software conversion for injected group */</comment>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name>ADC_CR2_JSWSTART</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop conversion of injected channels. Disable ADC peripheral if
  *         no regular conversion is on going.
  * @note   If ADC must be disabled and if conversion is on going on 
  *         regular group, function HAL_ADC_Stop must be used to stop both
  *         injected and regular groups, and disable the ADC.
  * @note   If injected group mode auto-injection is enabled,
  *         function HAL_ADC_Stop must be used.
  * @note   In case of auto-injection mode, HAL_ADC_Stop must be used.
  * @param  hadc ADC handle
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStop</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Stop potential conversion and disable ADC peripheral                     */</comment>
  <comment type="block">/* Conditioned to:                                                          */</comment>
  <comment type="block">/* - No conversion on the other group (regular group) is intended to        */</comment>
  <comment type="block">/*   continue (injected and regular groups stop conversion and ADC disable  */</comment>
  <comment type="block">/*   are common)                                                            */</comment>
  <comment type="block">/* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <name>HAL_ADC_STATE_REG_BUSY</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator>  <operator>&amp;&amp;</operator>
     <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>   )</condition>
  <block>{<block_content>
    <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
    <comment type="block">/* Disable ADC peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_DISABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if ADC is effectively disabled */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_ADON</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Poll for injected conversion complete
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  Timeout Timeout value in millisecond.  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedPollForConversion</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get tick */</comment> 
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check End of conversion flag */</comment>
  <while>while<condition>(<expr><operator>!</operator><operator>(</operator><call><name>__HAL_ADC_GET_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator><operator>||</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ADC_STATE_TIMEOUT</name></expr>;</expr_stmt>
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Clear injected group conversion flag */</comment>
  <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JSTRT</name> <operator>|</operator> <name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Update ADC state machine */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Determine whether any further conversion upcoming on group injected      */</comment>
  <comment type="block">/* by external trigger, continuous mode or scan sequence on going.          */</comment>
  <comment type="block">/* Note: On STM32F4, there is no independent flag of end of sequence.       */</comment>
  <comment type="block">/*       The test of scan sequence on going is done either with scan        */</comment>
  <comment type="block">/*       sequence disabled or with end of conversion flag set to            */</comment>
  <comment type="block">/*       of end of sequence.                                                */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>ADC_IS_SOFTWARE_START_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>                    <operator>&amp;&amp;</operator>
     <operator>(</operator><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name></expr></argument>, <argument><expr><name>ADC_JSQR_JL</name></expr></argument>)</argument_list></call>  <operator>||</operator>
      <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_EOCS</name></expr></argument>)</argument_list></call>    <operator>)</operator> <operator>&amp;&amp;</operator>
     <operator>(</operator><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>(</operator><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name><operator>)</operator>   <operator>)</operator>       <operator>)</operator></expr>   )</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Return ADC state */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>      
  
<comment type="block" format="doxygen">/**
  * @brief  Stop conversion of injected channels, disable interruption of 
  *         end-of-conversion. Disable ADC peripheral if no regular conversion
  *         is on going.
  * @note   If ADC must be disabled and if conversion is on going on 
  *         regular group, function HAL_ADC_Stop must be used to stop both
  *         injected and regular groups, and disable the ADC.
  * @note   If injected group mode auto-injection is enabled,
  *         function HAL_ADC_Stop must be used.
  * @param  hadc ADC handle
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStop_IT</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Stop potential conversion and disable ADC peripheral                     */</comment>
  <comment type="block">/* Conditioned to:                                                          */</comment>
  <comment type="block">/* - No conversion on the other group (regular group) is intended to        */</comment>
  <comment type="block">/*   continue (injected and regular groups stop conversion and ADC disable  */</comment>
  <comment type="block">/*   are common)                                                            */</comment>
  <comment type="block">/* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */</comment> 
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <name>HAL_ADC_STATE_REG_BUSY</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator>  <operator>&amp;&amp;</operator>
     <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>   )</condition>
  <block>{<block_content>
    <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
    <comment type="block">/* Disable ADC peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_DISABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if ADC is effectively disabled */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_ADON</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable ADC end of conversion interrupt for injected channels */</comment>
      <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Gets the converted value from data register of injected channel.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  InjectedRank the ADC injected rank.
  *          This parameter can be one of the following values:
  *            @arg ADC_INJECTED_RANK_1: Injected Channel1 selected
  *            @arg ADC_INJECTED_RANK_2: Injected Channel2 selected
  *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
  *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
  * @retval None
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_ADCEx_InjectedGetValue</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>InjectedRank</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_INJECTED_RANK</name><argument_list>(<argument><expr><name>InjectedRank</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Clear injected group conversion flag to have similar behaviour as        */</comment>
  <comment type="block">/* regular group: reading data register also clears end of conversion flag. */</comment>
  <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return the selected ADC converted value */</comment> 
  <switch>switch<condition>(<expr><name>InjectedRank</name></expr>)</condition>
  <block>{<block_content>  
    <case>case <expr><name>ADC_INJECTED_RANK_4</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>tmp</name> <operator>=</operator>  <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR4</name></name></expr>;</expr_stmt>
    </block_content>}</block>  
    <break>break;</break>
    <case>case <expr><name>ADC_INJECTED_RANK_3</name></expr>:</case> 
    <block>{<block_content>  
      <expr_stmt><expr><name>tmp</name> <operator>=</operator>  <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR3</name></name></expr>;</expr_stmt>
    </block_content>}</block>  
    <break>break;</break>
    <case>case <expr><name>ADC_INJECTED_RANK_2</name></expr>:</case> 
    <block>{<block_content>  
      <expr_stmt><expr><name>tmp</name> <operator>=</operator>  <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR2</name></name></expr>;</expr_stmt>
    </block_content>}</block>
    <break>break;</break>
    <case>case <expr><name>ADC_INJECTED_RANK_1</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>tmp</name> <operator>=</operator>  <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR1</name></name></expr>;</expr_stmt>
    </block_content>}</block>
    <break>break;</break>
    <default>default:</default>
    <break>break;</break>  
  </block_content>}</block></switch>
  <return>return <expr><name>tmp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables ADC DMA request after last transfer (Multi-ADC mode) and enables ADC peripheral
  * 
  * @note   Caution: This function must be used only with the ADC master.  
  *
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  pData   Pointer to buffer in which transferred from ADC peripheral to memory will be stored. 
  * @param  Length  The length of data to be transferred from ADC peripheral to memory.  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_MultiModeStart_DMA</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>pData</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>counter</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ADC_Common_TypeDef</name> <modifier>*</modifier></type><name>tmpADC_Common</name></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_EXT_TRIG_EDGE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ExternalTrigConvEdge</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DMAContinuousRequests</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>ADC_CR2_ADON</name><operator>)</operator> <operator>!=</operator> <name>ADC_CR2_ADON</name></expr>)</condition>
  <block>{<block_content>  
    <comment type="block">/* Enable the Peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Delay for temperature sensor stabilization time */</comment>
    <comment type="block">/* Compute number of CPU cycles to wait for */</comment>
    <expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>(</operator><name>ADC_STAB_DELAY_US</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">1000000U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>counter</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>counter</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_ADON</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state                                                          */</comment>
    <comment type="block">/* - Clear state bitfield related to regular group conversion results     */</comment>
    <comment type="block">/* - Set state bitfield related to regular group operation                */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_EOC</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_OVR</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* If conversions on group regular are also triggering group injected,    */</comment>
    <comment type="block">/* update ADC state.                                                      */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* State machine update: Check if an injected conversion is ongoing */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Reset ADC error code fields related to conversions on group regular */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><operator>(</operator><name>HAL_ADC_ERROR_OVR</name> <operator>|</operator> <name>HAL_ADC_ERROR_DMA</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>         
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Reset ADC all error code fields */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set the DMA transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>ADC_MultiModeDMAConvCplt</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set the DMA half transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>ADC_MultiModeDMAHalfConvCplt</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>ADC_MultiModeDMAError</name></expr> ;</expr_stmt>
    
    <comment type="block">/* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */</comment>
    <comment type="block">/* start (in case of SW start):                                           */</comment>
    
    <comment type="block">/* Clear regular group conversion flag and overrun flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable ADC overrun interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_OVR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Pointer to the common control register to which is belonging hadc    */</comment>
    <comment type="block">/* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */</comment>
    <comment type="block">/* control register)                                                    */</comment>
    <expr_stmt><expr><name>tmpADC_Common</name> <operator>=</operator> <call><name>ADC_COMMON_REGISTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DMAContinuousRequests</name></name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable the selected ADC DMA request after last transfer */</comment>
      <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <name>ADC_CCR_DDS</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Disable the selected ADC EOC rising on each regular channel conversion */</comment>
      <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ADC_CCR_DDS</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* Enable the DMA Stream */</comment>
    <expr_stmt><expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CDR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* if no external trigger present enable software conversion of regular channels */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>ADC_CR2_EXTEN</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition> 
    <block>{<block_content>
      <comment type="block">/* Enable the selected ADC software conversion for regular group */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ADC_CR2_SWSTART</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables ADC DMA (multi-ADC mode) and disables ADC peripheral    
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_MultiModeStop_DMA</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ADC_Common_TypeDef</name> <modifier>*</modifier></type><name>tmpADC_Common</name></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
  <comment type="block">/* Disable ADC peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_ADC_DISABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Pointer to the common control register to which is belonging hadc    */</comment>
  <comment type="block">/* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */</comment>
  <comment type="block">/* control register)                                                    */</comment>
  <expr_stmt><expr><name>tmpADC_Common</name> <operator>=</operator> <call><name>ADC_COMMON_REGISTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if ADC is effectively disabled */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_ADON</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the selected ADC DMA mode for multimode */</comment>
    <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ADC_CCR_DDS</name></expr>;</expr_stmt>
    
    <comment type="block">/* Disable the DMA channel (in case of DMA in circular mode or stop while */</comment>
    <comment type="block">/* DMA transfer is on going)                                              */</comment>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Disable ADC overrun interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_OVR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
  *         data in the selected multi mode.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval The converted data value.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_ADCEx_MultiModeGetValue</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ADC_Common_TypeDef</name> <modifier>*</modifier></type><name>tmpADC_Common</name></decl>;</decl_stmt>

  <comment type="block">/* Pointer to the common control register to which is belonging hadc    */</comment>
  <comment type="block">/* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */</comment>
  <comment type="block">/* control register)                                                    */</comment>
  <expr_stmt><expr><name>tmpADC_Common</name> <operator>=</operator> <call><name>ADC_COMMON_REGISTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return the multi mode conversion value */</comment>
  <return>return <expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CDR</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Injected conversion complete callback in non blocking mode 
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADCEx_InjectedConvCpltCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures for the selected ADC injected channel its corresponding
  *         rank in the sequencer and its sample time.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  sConfigInjected ADC configuration structure for injected channel. 
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedConfigChannel</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>ADC_InjectionConfTypeDef</name><modifier>*</modifier></type> <name>sConfigInjected</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_FULL_ASSERT</name></cpp:ifdef>  
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_FULL_ASSERT  */</comment>

  <decl_stmt><decl><type><name>ADC_Common_TypeDef</name> <modifier>*</modifier></type><name>tmpADC_Common</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_CHANNEL</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_INJECTED_RANK</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_SAMPLE_TIME</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedSamplingTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_EXT_INJEC_TRIG</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_INJECTED_LENGTH</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>AutoInjectedConv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedDiscontinuousConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_FULL_ASSERT</name></cpp:ifdef>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>ADC_GET_RESOLUTION</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_RANGE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_FULL_ASSERT  */</comment>

  <if_stmt><if>if<condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConv</name></name> <operator>!=</operator> <name>ADC_INJECTED_SOFTWARE_START</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_EXT_INJEC_TRIG_EDGE</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConvEdge</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* if ADC_Channel_10 ... ADC_Channel_18 is selected */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>&gt;</operator> <name>ADC_CHANNEL_9</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Clear the old sample time */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR1</name></name> <operator>&amp;=</operator> <operator>~</operator><call><name>ADC_SMPR1</name><argument_list>(<argument><expr><name>ADC_SMPR1_SMP10</name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set the new sample time */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR1</name></name> <operator>|=</operator> <call><name>ADC_SMPR1</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedSamplingTime</name></name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <comment type="block">/* ADC_Channel include in ADC_Channel_[0..9] */</comment>
  <block>{<block_content>
    <comment type="block">/* Clear the old sample time */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR2</name></name> <operator>&amp;=</operator> <operator>~</operator><call><name>ADC_SMPR2</name><argument_list>(<argument><expr><name>ADC_SMPR2_SMP0</name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set the new sample time */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR2</name></name> <operator>|=</operator> <call><name>ADC_SMPR2</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedSamplingTime</name></name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/*---------------------------- ADCx JSQR Configuration -----------------*/</comment>
  <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_JSQR_JL</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name> <operator>|=</operator>  <call><name>ADC_SQR1</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Rank configuration */</comment>
  
  <comment type="block">/* Clear the old SQx bits for the selected rank */</comment>
  <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name> <operator>&amp;=</operator> <operator>~</operator><call><name>ADC_JSQR</name><argument_list>(<argument><expr><name>ADC_JSQR_JSQ1</name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr></argument>,<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   
  <comment type="block">/* Set the SQx bits for the selected rank */</comment>
  <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name> <operator>|=</operator> <call><name>ADC_JSQR</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr></argument>,<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable external trigger if trigger selection is different of software  */</comment>
  <comment type="block">/* start.                                                                 */</comment>
  <comment type="block">/* Note: This configuration keeps the hardware feature of parameter       */</comment>
  <comment type="block">/*       ExternalTrigConvEdge "trigger edge none" equivalent to           */</comment>
  <comment type="block">/*       software start.                                                  */</comment> 
  <if_stmt><if>if<condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConv</name></name> <operator>!=</operator> <name>ADC_INJECTED_SOFTWARE_START</name></expr>)</condition>
  <block>{<block_content>  
    <comment type="block">/* Select external trigger to start conversion */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CR2_JEXTSEL</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator>  <name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConv</name></name></expr>;</expr_stmt>
    
    <comment type="block">/* Select external trigger polarity */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CR2_JEXTEN</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConvEdge</name></name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Reset the external trigger */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CR2_JEXTSEL</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CR2_JEXTEN</name><operator>)</operator></expr>;</expr_stmt>  
  </block_content>}</block></else></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>AutoInjectedConv</name></name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the selected ADC automatic injected group conversion */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>|=</operator> <name>ADC_CR1_JAUTO</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Disable the selected ADC automatic injected group conversion */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CR1_JAUTO</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedDiscontinuousConvMode</name></name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the selected ADC injected discontinuous mode */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>|=</operator> <name>ADC_CR1_JDISCEN</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Disable the selected ADC injected discontinuous mode */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CR1_JDISCEN</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <switch>switch<condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><literal type="number">1U</literal></expr>:</case>
      <comment type="block">/* Set injected channel 1 offset */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR1</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_JOFR1_JOFFSET1</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR1</name></name> <operator>|=</operator> <name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">2U</literal></expr>:</case>
      <comment type="block">/* Set injected channel 2 offset */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR2</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_JOFR2_JOFFSET2</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR2</name></name> <operator>|=</operator> <name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">3U</literal></expr>:</case>
      <comment type="block">/* Set injected channel 3 offset */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR3</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_JOFR3_JOFFSET3</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR3</name></name> <operator>|=</operator> <name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <comment type="block">/* Set injected channel 4 offset */</comment>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR4</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_JOFR4_JOFFSET4</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR4</name></name> <operator>|=</operator> <name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Pointer to the common control register to which is belonging hadc    */</comment>
  <comment type="block">/* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */</comment>
  <comment type="block">/* control register)                                                    */</comment>
    <expr_stmt><expr><name>tmpADC_Common</name> <operator>=</operator> <call><name>ADC_COMMON_REGISTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* if ADC1 Channel_18 is selected enable VBAT Channel */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name> <operator>==</operator> <name>ADC1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_VBAT</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the VBAT channel*/</comment>
    <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <name>ADC_CCR_VBATE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name> <operator>==</operator> <name>ADC1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_TEMPSENSOR</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_VREFINT</name><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the TSVREFE channel*/</comment>
    <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <name>ADC_CCR_TSVREFE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures the ADC multi-mode 
  * @param  hadc       pointer to a ADC_HandleTypeDef structure that contains
  *                     the configuration information for the specified ADC.  
  * @param  multimode  pointer to an ADC_MultiModeTypeDef structure that contains 
  *                     the configuration information for  multimode.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_MultiModeConfigChannel</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>ADC_MultiModeTypeDef</name><modifier>*</modifier></type> <name>multimode</name></decl></parameter>)</parameter_list>
<block>{<block_content>

  <decl_stmt><decl><type><name>ADC_Common_TypeDef</name> <modifier>*</modifier></type><name>tmpADC_Common</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_MODE</name><argument_list>(<argument><expr><name><name>multimode</name><operator>-&gt;</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_DMA_ACCESS_MODE</name><argument_list>(<argument><expr><name><name>multimode</name><operator>-&gt;</operator><name>DMAAccessMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_SAMPLING_DELAY</name><argument_list>(<argument><expr><name><name>multimode</name><operator>-&gt;</operator><name>TwoSamplingDelay</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Pointer to the common control register to which is belonging hadc    */</comment>
  <comment type="block">/* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */</comment>
  <comment type="block">/* control register)                                                    */</comment>
  <expr_stmt><expr><name>tmpADC_Common</name> <operator>=</operator> <call><name>ADC_COMMON_REGISTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set ADC mode */</comment>
  <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CCR_MULTI</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <name><name>multimode</name><operator>-&gt;</operator><name>Mode</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ADC DMA access mode */</comment>
  <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CCR_DMA</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <name><name>multimode</name><operator>-&gt;</operator><name>DMAAccessMode</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* Set delay between two sampling phases */</comment>
  <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ADC_CCR_DELAY</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmpADC_Common</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <name><name>multimode</name><operator>-&gt;</operator><name>TwoSamplingDelay</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  DMA transfer complete callback. 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ADC_MultiModeDMAConvCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
  <comment type="block">/* Retrieve ADC handle corresponding to current DMA handle */</comment>
  <decl_stmt><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name> <init>= <expr><operator>(</operator> <name>ADC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Update state machine on conversion status if not in error state */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name> <operator>|</operator> <name>HAL_ADC_STATE_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Determine whether any further conversion upcoming on group regular   */</comment>
    <comment type="block">/* by external trigger, continuous mode or scan sequence on going.      */</comment>
    <comment type="block">/* Note: On STM32F4, there is no independent flag of end of sequence.   */</comment>
    <comment type="block">/*       The test of scan sequence on going is done either with scan    */</comment>
    <comment type="block">/*       sequence disabled or with end of conversion flag set to        */</comment>
    <comment type="block">/*       of end of sequence.                                            */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>                   <operator>&amp;&amp;</operator>
       <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name><operator>)</operator>            <operator>&amp;&amp;</operator>
       <operator>(</operator><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SQR1</name></name></expr></argument>, <argument><expr><name>ADC_SQR1_L</name></expr></argument>)</argument_list></call> <operator>||</operator> 
        <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_EOCS</name></expr></argument>)</argument_list></call>  <operator>)</operator></expr>   )</condition>
    <block>{<block_content>
      <comment type="block">/* Disable ADC end of single conversion interrupt on group regular */</comment>
      <comment type="block">/* Note: Overrun interrupt was enabled with EOC interrupt in          */</comment>
      <comment type="block">/* HAL_ADC_Start_IT(), but is not disabled here because can be used   */</comment>
      <comment type="block">/* by overrun IRQ process below.                                      */</comment>
      <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
      
      <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Conversion complete callback */</comment>
    <expr_stmt><expr><call><name>HAL_ADC_ConvCpltCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Call DMA error callback */</comment>
    <expr_stmt><expr><call><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferErrorCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA half transfer complete callback. 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ADC_MultiModeDMAHalfConvCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
    <decl_stmt><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name> <init>= <expr><operator>(</operator> <name>ADC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Conversion complete callback */</comment>
    <expr_stmt><expr><call><name>HAL_ADC_ConvHalfCpltCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA error callback 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ADC_MultiModeDMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>   
<block>{<block_content>
    <decl_stmt><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name> <init>= <expr><operator>(</operator> <name>ADC_HandleTypeDef</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name><operator>*</operator> <operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ADC_STATE_ERROR_DMA</name></expr>;</expr_stmt>
    <comment type="block">/* Set ADC error code to DMA error */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_ADC_ERROR_DMA</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HAL_ADC_ErrorCallback</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_ADC_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment> 

<comment type="block" format="doxygen">/**
  * @}
  */</comment> 

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
