<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_eth.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_eth.c
  * @author  MCD Application Team
  * @brief   ETH HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of the Ethernet (ETH) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions 
  *           + Peripheral State and Errors functions
  *
  @verbatim
  ==============================================================================
                    ##### How to use this driver #####
  ==============================================================================
    [..]
      (#)Declare a ETH_HandleTypeDef handle structure, for example:
         ETH_HandleTypeDef  heth;
        
      (#)Fill parameters of Init structure in heth handle
  
      (#)Call HAL_ETH_Init() API to initialize the Ethernet peripheral (MAC, DMA, ...) 

      (#)Initialize the ETH low level resources through the HAL_ETH_MspInit() API:
          (##) Enable the Ethernet interface clock using 
               (+++) __HAL_RCC_ETHMAC_CLK_ENABLE();
               (+++) __HAL_RCC_ETHMACTX_CLK_ENABLE();
               (+++) __HAL_RCC_ETHMACRX_CLK_ENABLE();
           
          (##) Initialize the related GPIO clocks
          (##) Configure Ethernet pin-out
          (##) Configure Ethernet NVIC interrupt (IT mode)   
    
      (#)Initialize Ethernet DMA Descriptors in chain mode and point to allocated buffers:
          (##) HAL_ETH_DMATxDescListInit(); for Transmission process
          (##) HAL_ETH_DMARxDescListInit(); for Reception process

      (#)Enable MAC and DMA transmission and reception:
          (##) HAL_ETH_Start();

      (#)Prepare ETH DMA TX Descriptors and give the hand to ETH DMA to transfer 
         the frame to MAC TX FIFO:
         (##) HAL_ETH_TransmitFrame();

      (#)Poll for a received frame in ETH RX DMA Descriptors and get received 
         frame parameters
         (##) HAL_ETH_GetReceivedFrame(); (should be called into an infinite loop)

      (#) Get a received frame when an ETH RX interrupt occurs:
         (##) HAL_ETH_GetReceivedFrame_IT(); (called in IT mode only)

      (#) Communicate with external PHY device:
         (##) Read a specific register from the PHY  
              HAL_ETH_ReadPHYRegister();
         (##) Write data to a specific RHY register:
              HAL_ETH_WritePHYRegister();

      (#) Configure the Ethernet MAC after ETH peripheral initialization
          HAL_ETH_ConfigMAC(); all MAC parameters should be filled.
      
      (#) Configure the Ethernet DMA after ETH peripheral initialization
          HAL_ETH_ConfigDMA(); all DMA parameters should be filled.
      
      -@- The PTP protocol and the DMA descriptors ring mode are not supported 
          in this driver
*** Callback registration ***
  =============================================

  The compilation define  USE_HAL_ETH_REGISTER_CALLBACKS when set to 1
  allows the user to configure dynamically the driver callbacks.
  Use Function @ref HAL_ETH_RegisterCallback() to register an interrupt callback.

  Function @ref HAL_ETH_RegisterCallback() allows to register following callbacks:
    (+) TxCpltCallback   : Tx Complete Callback.
    (+) RxCpltCallback   : Rx Complete Callback.
    (+) DMAErrorCallback : DMA Error Callback.
    (+) MspInitCallback  : MspInit Callback.
    (+) MspDeInitCallback: MspDeInit Callback.

  This function takes as parameters the HAL peripheral handle, the Callback ID
  and a pointer to the user callback function.

  Use function @ref HAL_ETH_UnRegisterCallback() to reset a callback to the default
  weak function.
  @ref HAL_ETH_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.
  This function allows to reset following callbacks:
    (+) TxCpltCallback   : Tx Complete Callback.
    (+) RxCpltCallback   : Rx Complete Callback.
    (+) DMAErrorCallback : DMA Error Callback.
    (+) MspInitCallback  : MspInit Callback.
    (+) MspDeInitCallback: MspDeInit Callback.

  By default, after the HAL_ETH_Init and when the state is HAL_ETH_STATE_RESET
  all callbacks are set to the corresponding weak functions:
  examples @ref HAL_ETH_TxCpltCallback(), @ref HAL_ETH_RxCpltCallback().
  Exception done for MspInit and MspDeInit functions that are
  reset to the legacy weak function in the HAL_ETH_Init/ @ref HAL_ETH_DeInit only when
  these callbacks are null (not registered beforehand).
  if not, MspInit or MspDeInit are not null, the HAL_ETH_Init/ @ref HAL_ETH_DeInit
  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

  Callbacks can be registered/unregistered in HAL_ETH_STATE_READY state only.
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_ETH_STATE_READY or HAL_ETH_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using @ref HAL_ETH_RegisterCallback() before calling @ref HAL_ETH_DeInit
  or HAL_ETH_Init function.

  When The compilation define USE_HAL_ETH_REGISTER_CALLBACKS is set to 0 or
  not defined, the callback registration feature is not available and all callbacks
  are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ETH ETH 
  * @brief ETH HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_ETH_MODULE_ENABLED</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F407xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F417xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup ETH_Private_Constants ETH Private Constants
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETH_TIMEOUT_SWRESET</name></cpp:macro>               <cpp:value>500U</cpp:value></cpp:define>  
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETH_TIMEOUT_LINKED_STATE</name></cpp:macro>          <cpp:value>5000U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETH_TIMEOUT_AUTONEGO_COMPLETED</name></cpp:macro>    <cpp:value>5000U</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup ETH_Private_Functions ETH Private Functions
  * @{
  */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACDMAConfig</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACAddressConfig</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>MacAddr</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>Addr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACReceptionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACReceptionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACTransmissionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACTransmissionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMATransmissionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMATransmissionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMAReceptionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMAReceptionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_FlushTransmitFIFO</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_Delay</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>mdelay</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ETH_InitCallbacksToDefault</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ETH_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup ETH_Exported_Functions ETH Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ETH_Exported_Functions_Group1 Initialization and de-initialization functions 
  *  @brief   Initialization and Configuration functions 
  *
  @verbatim    
  ===============================================================================
            ##### Initialization and de-initialization functions #####
  ===============================================================================
  [..]  This section provides functions allowing to:
      (+) Initialize and configure the Ethernet peripheral
      (+) De-initialize the Ethernet peripheral

  @endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the Ethernet MAC and DMA according to default
  *         parameters.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_Init</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>phyreg</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>hclk</name> <init>= <expr><literal type="number">60000000U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>err</name> <init>= <expr><name>ETH_SUCCESS</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the ETH peripheral state */</comment>
  <if_stmt><if>if<condition>(<expr><name>heth</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Check parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_AUTONEGOTIATION</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoNegotiation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RX_MODE</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>RxMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_CHECKSUM_MODE</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ChecksumMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_MEDIA_INTERFACE</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MediaInterface</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
  
  <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ETH_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name>ETH_InitCallbacksToDefault</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC. */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_ETH_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>heth</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC. */</comment>
    <expr_stmt><expr><call><name>HAL_ETH_MspInit</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ETH_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Enable SYSCFG Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_RCC_SYSCFG_CLK_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Select MII or RMII Mode*/</comment>
  <expr_stmt><expr><name><name>SYSCFG</name><operator>-&gt;</operator><name>PMC</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>SYSCFG_PMC_MII_RMII_SEL</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>SYSCFG</name><operator>-&gt;</operator><name>PMC</name></name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MediaInterface</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* Ethernet Software reset */</comment>
  <comment type="block">/* Set the SWR bit: resets all MAC subsystem internal registers and logic */</comment>
  <comment type="block">/* After reset all the registers holds their respective reset values */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name> <operator>|=</operator> <name>ETH_DMABMR_SR</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Wait for software reset */</comment>
  <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name> <operator>&amp;</operator> <name>ETH_DMABMR_SR</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>ETH_TIMEOUT_SWRESET</name></expr>)</condition>
    <block>{<block_content>     
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_TIMEOUT</name></expr>;</expr_stmt>
  
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
      <comment type="block">/* Note: The SWR is not performed if the ETH_RX_CLK or the ETH_TX_CLK are  
         not available, please check your external PHY or the IO configuration */</comment>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/*-------------------------------- MAC Initialization ----------------------*/</comment>
  <comment type="block">/* Get the ETHERNET MACMIIAR value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACMIIAR</name></expr>;</expr_stmt>
  <comment type="block">/* Clear CSR Clock Range CR[2:0] bits */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <name>ETH_MACMIIAR_CR_MASK</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get hclk frequency value */</comment>
  <expr_stmt><expr><name>hclk</name> <operator>=</operator> <call><name>HAL_RCC_GetHCLKFreq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set CR bits depending on hclk value */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>hclk</name> <operator>&gt;=</operator> <literal type="number">20000000U</literal><operator>)</operator><operator>&amp;&amp;</operator><operator>(</operator><name>hclk</name> <operator>&lt;</operator> <literal type="number">35000000U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* CSR Clock Range between 20-35 MHz */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ETH_MACMIIAR_CR_Div16</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>hclk</name> <operator>&gt;=</operator> <literal type="number">35000000U</literal><operator>)</operator><operator>&amp;&amp;</operator><operator>(</operator><name>hclk</name> <operator>&lt;</operator> <literal type="number">60000000U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* CSR Clock Range between 35-60 MHz */</comment> 
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ETH_MACMIIAR_CR_Div26</name></expr>;</expr_stmt>
  </block_content>}</block></if>  
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>hclk</name> <operator>&gt;=</operator> <literal type="number">60000000U</literal><operator>)</operator><operator>&amp;&amp;</operator><operator>(</operator><name>hclk</name> <operator>&lt;</operator> <literal type="number">100000000U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* CSR Clock Range between 60-100 MHz */</comment> 
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ETH_MACMIIAR_CR_Div42</name></expr>;</expr_stmt>
  </block_content>}</block></if>  
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>hclk</name> <operator>&gt;=</operator> <literal type="number">100000000U</literal><operator>)</operator><operator>&amp;&amp;</operator><operator>(</operator><name>hclk</name> <operator>&lt;</operator> <literal type="number">150000000U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* CSR Clock Range between 100-150 MHz */</comment> 
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ETH_MACMIIAR_CR_Div62</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <comment type="block">/* ((hclk &gt;= 150000000)&amp;&amp;(hclk &lt;= 183000000)) */</comment>
  <block>{<block_content>
    <comment type="block">/* CSR Clock Range between 150-183 MHz */</comment> 
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ETH_MACMIIAR_CR_Div102</name></expr>;</expr_stmt>    
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACMIIAR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>
  
  <comment type="block">/*-------------------- PHY initialization and configuration ----------------*/</comment>
  <comment type="block">/* Put the PHY in reset mode */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_ETH_WritePHYRegister</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>PHY_BCR</name></expr></argument>, <argument><expr><name>PHY_RESET</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* In case of write timeout */</comment>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <name>ETH_ERROR</name></expr>;</expr_stmt>
    
    <comment type="block">/* Config MAC and DMA */</comment>
    <expr_stmt><expr><call><name>ETH_MACDMAConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set the ETH peripheral state to READY */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
    
    <comment type="block">/* Return HAL_ERROR */</comment>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Delay to assure PHY reset */</comment>
  <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>PHY_RESET_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>AutoNegotiation</name> <operator>!=</operator> <name>ETH_AUTONEGOTIATION_DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Get tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* We wait for linked status */</comment>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><call><name>HAL_ETH_ReadPHYRegister</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>PHY_BSR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phyreg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>ETH_TIMEOUT_LINKED_STATE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* In case of write timeout */</comment>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>ETH_ERROR</name></expr>;</expr_stmt>
      
        <comment type="block">/* Config MAC and DMA */</comment>
        <expr_stmt><expr><call><name>ETH_MACDMAConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>(</operator><operator>(</operator><name>phyreg</name> <operator>&amp;</operator> <name>PHY_LINKED_STATUS</name><operator>)</operator> <operator>!=</operator> <name>PHY_LINKED_STATUS</name><operator>)</operator></expr>)</condition>;</do>

    
    <comment type="block">/* Enable Auto-Negotiation */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_ETH_WritePHYRegister</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>PHY_BCR</name></expr></argument>, <argument><expr><name>PHY_AUTONEGOTIATION</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* In case of write timeout */</comment>
      <expr_stmt><expr><name>err</name> <operator>=</operator> <name>ETH_ERROR</name></expr>;</expr_stmt>
      
      <comment type="block">/* Config MAC and DMA */</comment>
      <expr_stmt><expr><call><name>ETH_MACDMAConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set the ETH peripheral state to READY */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Return HAL_ERROR */</comment>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>   
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Get tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Wait until the auto-negotiation will be completed */</comment>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><call><name>HAL_ETH_ReadPHYRegister</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>PHY_BSR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phyreg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>ETH_TIMEOUT_AUTONEGO_COMPLETED</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* In case of write timeout */</comment>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>ETH_ERROR</name></expr>;</expr_stmt>
      
        <comment type="block">/* Config MAC and DMA */</comment>
        <expr_stmt><expr><call><name>ETH_MACDMAConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      
    </block_content>}</block> while <condition>(<expr><operator>(</operator><operator>(</operator><name>phyreg</name> <operator>&amp;</operator> <name>PHY_AUTONEGO_COMPLETE</name><operator>)</operator> <operator>!=</operator> <name>PHY_AUTONEGO_COMPLETE</name><operator>)</operator></expr>)</condition>;</do>
    
    <comment type="block">/* Read the result of the auto-negotiation */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_ETH_ReadPHYRegister</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>PHY_SR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phyreg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* In case of write timeout */</comment>
      <expr_stmt><expr><name>err</name> <operator>=</operator> <name>ETH_ERROR</name></expr>;</expr_stmt>
      
      <comment type="block">/* Config MAC and DMA */</comment>
      <expr_stmt><expr><call><name>ETH_MACDMAConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set the ETH peripheral state to READY */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Return HAL_ERROR */</comment>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>   
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>phyreg</name> <operator>&amp;</operator> <name>PHY_DUPLEX_STATUS</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */</comment>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>DuplexMode</name> <operator>=</operator> <name>ETH_MODE_FULLDUPLEX</name></expr>;</expr_stmt>  
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */</comment>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>DuplexMode</name> <operator>=</operator> <name>ETH_MODE_HALFDUPLEX</name></expr>;</expr_stmt>           
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Configure the MAC with the speed fixed by the auto-negotiation process */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>phyreg</name> <operator>&amp;</operator> <name>PHY_SPEED_STATUS</name><operator>)</operator> <operator>==</operator> <name>PHY_SPEED_STATUS</name></expr>)</condition>
    <block>{<block_content>  
      <comment type="block">/* Set Ethernet speed to 10M following the auto-negotiation */</comment>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>Speed</name> <operator>=</operator> <name>ETH_SPEED_10M</name></expr>;</expr_stmt> 
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>   
      <comment type="block">/* Set Ethernet speed to 100M following the auto-negotiation */</comment> 
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>Speed</name> <operator>=</operator> <name>ETH_SPEED_100M</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else <comment type="block">/* AutoNegotiation Disable */</comment>
  <block>{<block_content>
    <comment type="block">/* Check parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_SPEED</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Speed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_DUPLEX_MODE</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DuplexMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set MAC Speed and Duplex Mode */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>HAL_ETH_WritePHYRegister</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>PHY_BCR</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>DuplexMode</name> <operator>&gt;&gt;</operator> <literal type="number">3U</literal><operator>)</operator> <operator>|</operator>
                                                <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>Speed</name> <operator>&gt;&gt;</operator> <literal type="number">1U</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* In case of write timeout */</comment>
      <expr_stmt><expr><name>err</name> <operator>=</operator> <name>ETH_ERROR</name></expr>;</expr_stmt>
      
      <comment type="block">/* Config MAC and DMA */</comment>
      <expr_stmt><expr><call><name>ETH_MACDMAConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set the ETH peripheral state to READY */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Return HAL_ERROR */</comment>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>  
    
    <comment type="block">/* Delay to assure PHY configuration */</comment>
    <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>PHY_CONFIG_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Config MAC and DMA */</comment>
  <expr_stmt><expr><call><name>ETH_MACDMAConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set ETH HAL State to Ready */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  De-Initializes the ETH peripheral. 
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_DeInit</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_ETH_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* De-Init the low level hardware : GPIO, CLOCK, NVIC. */</comment>
  <expr_stmt><expr><call><name><name>heth</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* De-Init the low level hardware : GPIO, CLOCK, NVIC. */</comment>
  <expr_stmt><expr><call><name>HAL_ETH_MspDeInit</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="block">/* Set ETH HAL state to Disabled */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the DMA Tx descriptors in chain mode.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module  
  * @param  DMATxDescTab Pointer to the first Tx desc list 
  * @param  TxBuff Pointer to the first TxBuffer list
  * @param  TxBuffCount Number of the used Tx desc in the list
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_DMATxDescListInit</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>ETH_DMADescTypeDef</name> <modifier>*</modifier></type><name>DMATxDescTab</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>TxBuff</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TxBuffCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ETH_DMADescTypeDef</name> <modifier>*</modifier></type><name>dmatxdesc</name></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name></name> <operator>=</operator> <name>DMATxDescTab</name></expr>;</expr_stmt>
  
  <comment type="block">/* Fill each DMATxDesc descriptor with the right values */</comment>   
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0U</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TxBuffCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <comment type="block">/* Get the pointer on the ith member of the Tx Desc list */</comment>
    <expr_stmt><expr><name>dmatxdesc</name> <operator>=</operator> <name>DMATxDescTab</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set Second Address Chained bit */</comment>
    <expr_stmt><expr><name><name>dmatxdesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>ETH_DMATXDESC_TCH</name></expr>;</expr_stmt>  
    
    <comment type="block">/* Set Buffer1 address pointer */</comment>
    <expr_stmt><expr><name><name>dmatxdesc</name><operator>-&gt;</operator><name>Buffer1Addr</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>TxBuff</name><index>[<expr><name>i</name><operator>*</operator><name>ETH_TX_BUF_SIZE</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>ChecksumMode</name> <operator>==</operator> <name>ETH_CHECKSUM_BY_HARDWARE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the DMA Tx descriptors checksum insertion */</comment>
      <expr_stmt><expr><name><name>dmatxdesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>|=</operator> <name>ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Initialize the next descriptor with the Next Descriptor Polling Enable */</comment>
    <if_stmt><if>if<condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>TxBuffCount</name><operator>-</operator><literal type="number">1U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set next descriptor address register with next descriptor base address */</comment>
      <expr_stmt><expr><name><name>dmatxdesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>DMATxDescTab</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* For last descriptor, set next descriptor address register equal to the first descriptor base address */</comment> 
      <expr_stmt><expr><name><name>dmatxdesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator> <name>DMATxDescTab</name></expr>;</expr_stmt>  
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  
  <comment type="block">/* Set Transmit Descriptor List Address Register */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMATDLAR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator> <name>DMATxDescTab</name></expr>;</expr_stmt>
  
  <comment type="block">/* Set ETH HAL State to Ready */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the DMA Rx descriptors in chain mode.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module  
  * @param  DMARxDescTab Pointer to the first Rx desc list 
  * @param  RxBuff Pointer to the first RxBuffer list
  * @param  RxBuffCount Number of the used Rx desc in the list
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_DMARxDescListInit</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>ETH_DMADescTypeDef</name> <modifier>*</modifier></type><name>DMARxDescTab</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>RxBuff</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>RxBuffCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ETH_DMADescTypeDef</name> <modifier>*</modifier></type><name>DMARxDesc</name></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Set the Ethernet RxDesc pointer with the first one of the DMARxDescTab list */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name> <operator>=</operator> <name>DMARxDescTab</name></expr>;</expr_stmt> 
  
  <comment type="block">/* Fill each DMARxDesc descriptor with the right values */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0U</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>RxBuffCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <comment type="block">/* Get the pointer on the ith member of the Rx Desc list */</comment>
    <expr_stmt><expr><name>DMARxDesc</name> <operator>=</operator> <name>DMARxDescTab</name><operator>+</operator><name>i</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set Own bit of the Rx descriptor Status */</comment>
    <expr_stmt><expr><name><name>DMARxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>=</operator> <name>ETH_DMARXDESC_OWN</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set Buffer1 size and Second Address Chained bit */</comment>
    <expr_stmt><expr><name><name>DMARxDesc</name><operator>-&gt;</operator><name>ControlBufferSize</name></name> <operator>=</operator> <name>ETH_DMARXDESC_RCH</name> <operator>|</operator> <name>ETH_RX_BUF_SIZE</name></expr>;</expr_stmt>  
    
    <comment type="block">/* Set Buffer1 address pointer */</comment>
    <expr_stmt><expr><name><name>DMARxDesc</name><operator>-&gt;</operator><name>Buffer1Addr</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>RxBuff</name><index>[<expr><name>i</name><operator>*</operator><name>ETH_RX_BUF_SIZE</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>RxMode</name> <operator>==</operator> <name>ETH_RXINTERRUPT_MODE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Ethernet DMA Rx Descriptor interrupt */</comment>
      <expr_stmt><expr><name><name>DMARxDesc</name><operator>-&gt;</operator><name>ControlBufferSize</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_DMARXDESC_DIC</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Initialize the next descriptor with the Next Descriptor Polling Enable */</comment>
    <if_stmt><if>if<condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>RxBuffCount</name><operator>-</operator><literal type="number">1U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set next descriptor address register with next descriptor base address */</comment>
      <expr_stmt><expr><name><name>DMARxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>DMARxDescTab</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt> 
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* For last descriptor, set next descriptor address register equal to the first descriptor base address */</comment> 
      <expr_stmt><expr><name><name>DMARxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>DMARxDescTab</name><operator>)</operator></expr>;</expr_stmt> 
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  
  <comment type="block">/* Set Receive Descriptor List Address Register */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMARDLAR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator> <name>DMARxDescTab</name></expr>;</expr_stmt>
  
  <comment type="block">/* Set ETH HAL State to Ready */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the ETH MSP.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ETH_MspInit</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_MspInit could be implemented in the user file
  */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes ETH MSP.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ETH_MspDeInit</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_MspDeInit could be implemented in the user file
  */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User ETH Callback
  *         To be used instead of the weak predefined callback
  * @param heth eth handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_ETH_TX_COMPLETE_CB_ID Tx Complete Callback ID
  *          @arg @ref HAL_ETH_RX_COMPLETE_CB_ID Rx Complete Callback ID
  *          @arg @ref HAL_ETH_DMA_ERROR_CB_ID   DMA Error Callback ID
  *          @arg @ref HAL_ETH_MSPINIT_CB_ID     MspInit callback ID
  *          @arg @ref HAL_ETH_MSPDEINIT_CB_ID   MspDeInit callback ID
  * @param pCallback pointer to the Callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>HAL_ETH_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pETH_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ETH_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_ETH_TX_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_RX_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_DMA_ERROR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>DMAErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default :</default>
      <comment type="block">/* Return error status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ETH_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_ETH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default :</default>
      <comment type="block">/* Return error status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister an ETH Callback
  *         ETH callabck is redirected to the weak predefined callback
  * @param heth eth handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_ETH_TX_COMPLETE_CB_ID Tx Complete Callback ID
  *          @arg @ref HAL_ETH_RX_COMPLETE_CB_ID Rx Complete Callback ID
  *          @arg @ref HAL_ETH_DMA_ERROR_CB_ID      DMA Error Callback ID
  *          @arg @ref HAL_ETH_MSPINIT_CB_ID     MspInit callback ID
  *          @arg @ref HAL_ETH_MSPDEINIT_CB_ID   MspDeInit callback ID
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>HAL_ETH_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ETH_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_ETH_TX_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxCpltCallback</name></name> <operator>=</operator> <name>HAL_ETH_TxCpltCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_RX_COMPLETE_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxCpltCallback</name></name> <operator>=</operator> <name>HAL_ETH_RxCpltCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_DMA_ERROR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>DMAErrorCallback</name></name> <operator>=</operator> <name>HAL_ETH_ErrorCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_ETH_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_ETH_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default :</default>
      <comment type="block">/* Return error status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ETH_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_ETH_MSPINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_ETH_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>HAL_ETH_MSPDEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_ETH_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default :</default>
      <comment type="block">/* Return error status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ETH_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ETH_Exported_Functions_Group2 IO operation functions 
  *  @brief   Data transfers functions 
  *
  @verbatim   
  ==============================================================================
                          ##### IO operation functions #####
  ==============================================================================  
  [..]  This section provides functions allowing to:
        (+) Transmit a frame
            HAL_ETH_TransmitFrame();
        (+) Receive a frame
            HAL_ETH_GetReceivedFrame();
            HAL_ETH_GetReceivedFrame_IT();
        (+) Read from an External PHY register
            HAL_ETH_ReadPHYRegister();
        (+) Write to an External PHY register
            HAL_ETH_WritePHYRegister();

  @endverbatim
  
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Sends an Ethernet frame. 
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  FrameLength Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_TransmitFrame</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>FrameLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>bufcount</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>FrameLength</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition> 
  <block>{<block_content>
    <comment type="block">/* Set ETH HAL state to READY */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return>                                    
  </block_content>}</block></if></if_stmt>  
  
  <comment type="block">/* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name></name><operator>)</operator><operator>-&gt;</operator><name>Status</name> <operator>&amp;</operator> <name>ETH_DMATXDESC_OWN</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name></expr>)</condition>
  <block>{<block_content>  
    <comment type="block">/* OWN bit set */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY_TX</name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Get the number of needed Tx buffers for the current frame */</comment>
  <if_stmt><if>if <condition>(<expr><name>FrameLength</name> <operator>&gt;</operator> <name>ETH_TX_BUF_SIZE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>bufcount</name> <operator>=</operator> <name>FrameLength</name><operator>/</operator><name>ETH_TX_BUF_SIZE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>FrameLength</name> <operator>%</operator> <name>ETH_TX_BUF_SIZE</name></expr>)</condition> 
    <block>{<block_content>
      <expr_stmt><expr><name>bufcount</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else 
  <block>{<block_content>  
    <expr_stmt><expr><name>bufcount</name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>bufcount</name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set LAST and FIRST segment */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>|=</operator><name>ETH_DMATXDESC_FS</name><operator>|</operator><name>ETH_DMATXDESC_LS</name></expr>;</expr_stmt>
    <comment type="block">/* Set frame size */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>ControlBufferSize</name></name> <operator>=</operator> <operator>(</operator><name>FrameLength</name> <operator>&amp;</operator> <name>ETH_DMATXDESC_TBS1</name><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>|=</operator> <name>ETH_DMATXDESC_OWN</name></expr>;</expr_stmt>
    <comment type="block">/* Point to next descriptor */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name></name><operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0U</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name>bufcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <comment type="block">/* Clear FIRST and LAST segment bits */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ETH_DMATXDESC_FS</name> <operator>|</operator> <name>ETH_DMATXDESC_LS</name><operator>)</operator></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition> 
      <block>{<block_content>
        <comment type="block">/* Setting the first segment bit */</comment>
        <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>|=</operator> <name>ETH_DMATXDESC_FS</name></expr>;</expr_stmt>  
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* Program size */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>ControlBufferSize</name></name> <operator>=</operator> <operator>(</operator><name>ETH_TX_BUF_SIZE</name> <operator>&amp;</operator> <name>ETH_DMATXDESC_TBS1</name><operator>)</operator></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>(</operator><name>bufcount</name><operator>-</operator><literal type="number">1U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Setting the last segment bit */</comment>
        <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>|=</operator> <name>ETH_DMATXDESC_LS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <name>FrameLength</name> <operator>-</operator> <operator>(</operator><name>bufcount</name><operator>-</operator><literal type="number">1U</literal><operator>)</operator><operator>*</operator><name>ETH_TX_BUF_SIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>ControlBufferSize</name></name> <operator>=</operator> <operator>(</operator><name>size</name> <operator>&amp;</operator> <name>ETH_DMATXDESC_TBS1</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>|=</operator> <name>ETH_DMATXDESC_OWN</name></expr>;</expr_stmt>
      <comment type="block">/* point to next descriptor */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name></name> <operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>TxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* When Tx Buffer unavailable flag is set: clear it and resume transmission */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMASR</name> <operator>&amp;</operator> <name>ETH_DMASR_TBUS</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Clear TBUS ETHERNET DMA flag */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMASR</name> <operator>=</operator> <name>ETH_DMASR_TBUS</name></expr>;</expr_stmt>
    <comment type="block">/* Resume DMA transmission*/</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMATPDR</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Set ETH HAL State to Ready */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Checks for received frames. 
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_GetReceivedFrame</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>framelength</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the ETH state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Check if segment is not owned by DMA */</comment>
  <comment type="block">/* (((heth-&gt;RxDesc-&gt;Status &amp; ETH_DMARXDESC_OWN) == (uint32_t)RESET) &amp;&amp; ((heth-&gt;RxDesc-&gt;Status &amp; ETH_DMARXDESC_LS) != (uint32_t)RESET)) */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>&amp;</operator> <name>ETH_DMARXDESC_OWN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if last segment */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>&amp;</operator> <name>ETH_DMARXDESC_LS</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name><operator>)</operator></expr>)</condition> 
    <block>{<block_content>
      <comment type="block">/* increment segment count */</comment>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>SegCount</name><operator>++</operator></expr>;</expr_stmt>
      
      <comment type="block">/* Check if last segment is first segment: one segment contains the frame */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>SegCount</name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>FSRxDesc</name> <operator>=</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>LSRxDesc</name></name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name></expr>;</expr_stmt>
      
      <comment type="block">/* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */</comment>
      <expr_stmt><expr><name>framelength</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name><operator>)</operator><operator>-&gt;</operator><name>Status</name> <operator>&amp;</operator> <name>ETH_DMARXDESC_FL</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>ETH_DMARXDESC_FRAMELENGTHSHIFT</name><operator>)</operator> <operator>-</operator> <literal type="number">4U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>framelength</name></expr>;</expr_stmt>
      
      <comment type="block">/* Get the address of the buffer start address */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>FSRxDesc</name><operator>)</operator><operator>-&gt;</operator><name>Buffer1Addr</name></expr>;</expr_stmt>
      <comment type="block">/* point to next descriptor */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name> <operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name><operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name><operator>)</operator><operator>-&gt;</operator><name>Buffer2NextDescAddr</name><operator>)</operator></expr>;</expr_stmt>
      
      <comment type="block">/* Set HAL State to Ready */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Return function status */</comment>
      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if>
    <comment type="block">/* Check if first segment */</comment>
    <if type="elseif">else if<condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>&amp;</operator> <name>ETH_DMARXDESC_FS</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>FSRxDesc</name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>LSRxDesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>SegCount</name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>
      <comment type="block">/* Point to next descriptor */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name> <operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Check if intermediate segment */</comment> 
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>SegCount</name><operator>++</operator></expr>;</expr_stmt>
      <comment type="block">/* Point to next descriptor */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name> <operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt> 
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Set ETH HAL State to Ready */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Gets the Received frame in interrupt mode. 
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_GetReceivedFrame_IT</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>descriptorscancounter</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set ETH HAL State to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Scan descriptors owned by CPU */</comment>
  <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>&amp;</operator> <name>ETH_DMARXDESC_OWN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>descriptorscancounter</name> <operator>&lt;</operator> <name>ETH_RXBUFNB</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Just for security */</comment>
    <expr_stmt><expr><name>descriptorscancounter</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Check if first segment in frame */</comment>
    <comment type="block">/* ((heth-&gt;RxDesc-&gt;Status &amp; ETH_DMARXDESC_FS) != (uint32_t)RESET) &amp;&amp; ((heth-&gt;RxDesc-&gt;Status &amp; ETH_DMARXDESC_LS) == (uint32_t)RESET)) */</comment>  
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>&amp;</operator> <operator>(</operator><name>ETH_DMARXDESC_FS</name> <operator>|</operator> <name>ETH_DMARXDESC_LS</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ETH_DMARXDESC_FS</name></expr>)</condition>
    <block>{<block_content> 
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>FSRxDesc</name></name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>SegCount</name></name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>   
      <comment type="block">/* Point to next descriptor */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name> <operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Check if intermediate segment */</comment>
    <comment type="block">/* ((heth-&gt;RxDesc-&gt;Status &amp; ETH_DMARXDESC_LS) == (uint32_t)RESET)&amp;&amp; ((heth-&gt;RxDesc-&gt;Status &amp; ETH_DMARXDESC_FS) == (uint32_t)RESET)) */</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Status</name></name> <operator>&amp;</operator> <operator>(</operator><name>ETH_DMARXDESC_LS</name> <operator>|</operator> <name>ETH_DMARXDESC_FS</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Increment segment count */</comment>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>SegCount</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
      <comment type="block">/* Point to next descriptor */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name> <operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Should be last segment */</comment>
    <else>else
    <block>{<block_content> 
      <comment type="block">/* Last segment */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>LSRxDesc</name></name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name></expr>;</expr_stmt>
      
      <comment type="block">/* Increment segment count */</comment>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>SegCount</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
      
      <comment type="block">/* Check if last segment is first segment: one segment contains the frame */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>SegCount</name></name><operator>)</operator> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>FSRxDesc</name></name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>length</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name><operator>)</operator><operator>-&gt;</operator><name>Status</name> <operator>&amp;</operator> <name>ETH_DMARXDESC_FL</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>ETH_DMARXDESC_FRAMELENGTHSHIFT</name><operator>)</operator> <operator>-</operator> <literal type="number">4U</literal></expr>;</expr_stmt>
      
      <comment type="block">/* Get the address of the buffer start address */</comment> 
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name><operator>.</operator><name>buffer</name></name> <operator>=</operator><operator>(</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxFrameInfos</name></name><operator>)</operator><operator>.</operator><name>FSRxDesc</name><operator>)</operator><operator>-&gt;</operator><name>Buffer1Addr</name></expr>;</expr_stmt>
      
      <comment type="block">/* Point to next descriptor */</comment>      
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name></name> <operator>=</operator> <operator>(</operator><name>ETH_DMADescTypeDef</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>RxDesc</name><operator>-&gt;</operator><name>Buffer2NextDescAddr</name></name><operator>)</operator></expr>;</expr_stmt>
      
      <comment type="block">/* Set HAL State to Ready */</comment>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
      
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
      <comment type="block">/* Return function status */</comment>
      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Set HAL State to Ready */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles ETH interrupt request.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */</comment>
<function><type><name>void</name></type> <name>HAL_ETH_IRQHandler</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Frame received */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_ETH_DMA_GET_FLAG</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_DMA_FLAG_R</name></expr></argument>)</argument_list></call></expr>)</condition> 
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/*Call registered Receive complete callback*/</comment>
    <expr_stmt><expr><call><name><name>heth</name><operator>-&gt;</operator><name>RxCpltCallback</name></name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Receive complete callback */</comment>
    <expr_stmt><expr><call><name>HAL_ETH_RxCpltCallback</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ETH_REGISTER_CALLBACKS */</comment>

     <comment type="block">/* Clear the Eth DMA Rx IT pending bits */</comment>
    <expr_stmt><expr><call><name>__HAL_ETH_DMA_CLEAR_IT</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_DMA_IT_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set HAL State to Ready */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  </block_content>}</block></if>
  <comment type="block">/* Frame transmitted */</comment>
  <if type="elseif">else if <condition>(<expr><call><name>__HAL_ETH_DMA_GET_FLAG</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_DMA_FLAG_T</name></expr></argument>)</argument_list></call></expr>)</condition> 
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/*  Call resgistered Transfer complete callback*/</comment>
    <expr_stmt><expr><call><name><name>heth</name><operator>-&gt;</operator><name>TxCpltCallback</name></name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Transfer complete callback */</comment>
    <expr_stmt><expr><call><name>HAL_ETH_TxCpltCallback</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ETH_REGISTER_CALLBACKS */</comment>

    <comment type="block">/* Clear the Eth DMA Tx IT pending bits */</comment>
    <expr_stmt><expr><call><name>__HAL_ETH_DMA_CLEAR_IT</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_DMA_IT_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set HAL State to Ready */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Clear the interrupt flags */</comment>
  <expr_stmt><expr><call><name>__HAL_ETH_DMA_CLEAR_IT</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_DMA_IT_NIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* ETH DMA Error */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_ETH_DMA_GET_FLAG</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_DMA_FLAG_AIS</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>heth</name><operator>-&gt;</operator><name>DMAErrorCallback</name></name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Ethernet Error callback */</comment>
    <expr_stmt><expr><call><name>HAL_ETH_ErrorCallback</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ETH_REGISTER_CALLBACKS */</comment>

    <comment type="block">/* Clear the interrupt flags */</comment>
    <expr_stmt><expr><call><name>__HAL_ETH_DMA_CLEAR_IT</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_DMA_FLAG_AIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* Set HAL State to Ready */</comment>
    <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Tx Transfer completed callbacks.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ETH_TxCpltCallback</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_TxCpltCallback could be implemented in the user file
  */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx Transfer completed callbacks.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ETH_RxCpltCallback</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_TxCpltCallback could be implemented in the user file
  */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Ethernet transfer error callbacks
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ETH_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_TxCpltCallback could be implemented in the user file
  */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Reads a PHY register
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module                  
  * @param PHYReg PHY register address, is the index of one of the 32 PHY register. 
  *                This parameter can be one of the following values: 
  *                   PHY_BCR: Transceiver Basic Control Register, 
  *                   PHY_BSR: Transceiver Basic Status Register.   
  *                   More PHY register could be read depending on the used PHY
  * @param RegValue PHY register value                  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_ReadPHYRegister</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>PHYReg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>RegValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>     
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_PHY_ADDRESS</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PhyAddress</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the ETH peripheral state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ETH_STATE_BUSY_RD</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Set ETH HAL State to BUSY_RD */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY_RD</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get the ETHERNET MACMIIAR value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIAR</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* Keep only the CSR Clock Range CR[2:0] bits value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_MACMIIAR_CR_MASK</name></expr>;</expr_stmt>
  
  <comment type="block">/* Prepare the MII address register value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PhyAddress</name></name> <operator>&lt;&lt;</operator> <literal type="number">11U</literal><operator>)</operator> <operator>&amp;</operator> <name>ETH_MACMIIAR_PA</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Set the PHY device address   */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>PHYReg</name><operator>&lt;&lt;</operator><literal type="number">6U</literal><operator>)</operator> <operator>&amp;</operator> <name>ETH_MACMIIAR_MR</name><operator>)</operator></expr>;</expr_stmt>                   <comment type="block">/* Set the PHY register address */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_MACMIIAR_MW</name></expr>;</expr_stmt>                                            <comment type="block">/* Set the read mode            */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <name>ETH_MACMIIAR_MB</name></expr>;</expr_stmt>                                             <comment type="block">/* Set the MII Busy bit         */</comment>
  
  <comment type="block">/* Write the result value into the MII Address register */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIAR</name></name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check for the Busy flag */</comment>
  <while>while<condition>(<expr><operator>(</operator><name>tmpreg1</name> <operator>&amp;</operator> <name>ETH_MACMIIAR_MB</name><operator>)</operator> <operator>==</operator> <name>ETH_MACMIIAR_MB</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PHY_READ_TO</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIAR</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Get MACMIIDR value */</comment>
  <expr_stmt><expr><operator>*</operator><name>RegValue</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIDR</name></name><operator>)</operator></expr>;</expr_stmt>
  
  <comment type="block">/* Set ETH HAL State to READY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Writes to a PHY register.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module  
  * @param  PHYReg PHY register address, is the index of one of the 32 PHY register. 
  *          This parameter can be one of the following values: 
  *             PHY_BCR: Transceiver Control Register.  
  *             More PHY register could be written depending on the used PHY
  * @param  RegValue the value to write
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_WritePHYRegister</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>PHYReg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>RegValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_PHY_ADDRESS</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PhyAddress</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the ETH peripheral state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_ETH_STATE_BUSY_WR</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Set ETH HAL State to BUSY_WR */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY_WR</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get the ETHERNET MACMIIAR value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIAR</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* Keep only the CSR Clock Range CR[2:0] bits value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_MACMIIAR_CR_MASK</name></expr>;</expr_stmt>
  
  <comment type="block">/* Prepare the MII register address value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PhyAddress</name></name><operator>&lt;&lt;</operator><literal type="number">11U</literal><operator>)</operator> <operator>&amp;</operator> <name>ETH_MACMIIAR_PA</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Set the PHY device address */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>PHYReg</name><operator>&lt;&lt;</operator><literal type="number">6U</literal><operator>)</operator> <operator>&amp;</operator> <name>ETH_MACMIIAR_MR</name><operator>)</operator></expr>;</expr_stmt>                 <comment type="block">/* Set the PHY register address */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <name>ETH_MACMIIAR_MW</name></expr>;</expr_stmt>                                           <comment type="block">/* Set the write mode */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <name>ETH_MACMIIAR_MB</name></expr>;</expr_stmt>                                           <comment type="block">/* Set the MII Busy bit */</comment>
  
  <comment type="block">/* Give the value to the MII data register */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIDR</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>RegValue</name></expr>;</expr_stmt>
  
  <comment type="block">/* Write the result value into the MII Address register */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIAR</name></name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check for the Busy flag */</comment>
  <while>while<condition>(<expr><operator>(</operator><name>tmpreg1</name> <operator>&amp;</operator> <name>ETH_MACMIIAR_MB</name><operator>)</operator> <operator>==</operator> <name>ETH_MACMIIAR_MB</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>PHY_WRITE_TO</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <name><name>heth</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MACMIIAR</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Set ETH HAL State to READY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ETH_Exported_Functions_Group3 Peripheral Control functions
 *  @brief    Peripheral Control functions 
 *
@verbatim   
 ===============================================================================
                  ##### Peripheral Control functions #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Enable MAC and DMA transmission and reception.
          HAL_ETH_Start();
      (+) Disable MAC and DMA transmission and reception. 
          HAL_ETH_Stop();
      (+) Set the MAC configuration in runtime mode
          HAL_ETH_ConfigMAC();
      (+) Set the DMA configuration in runtime mode
          HAL_ETH_ConfigDMA();

@endverbatim
  * @{
  */</comment> 

 <comment type="block" format="doxygen">/**
  * @brief  Enables Ethernet MAC and DMA reception/transmission 
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_Start</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Enable transmit state machine of the MAC for transmission on the MII */</comment>
  <expr_stmt><expr><call><name>ETH_MACTransmissionEnable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable receive state machine of the MAC for reception from the MII */</comment>
  <expr_stmt><expr><call><name>ETH_MACReceptionEnable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Flush Transmit FIFO */</comment>
  <expr_stmt><expr><call><name>ETH_FlushTransmitFIFO</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Start DMA transmission */</comment>
  <expr_stmt><expr><call><name>ETH_DMATransmissionEnable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Start DMA reception */</comment>
  <expr_stmt><expr><call><name>ETH_DMAReceptionEnable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH state to READY*/</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop Ethernet MAC and DMA reception/transmission 
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_Stop</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Stop DMA transmission */</comment>
  <expr_stmt><expr><call><name>ETH_DMATransmissionDisable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Stop DMA reception */</comment>
  <expr_stmt><expr><call><name>ETH_DMAReceptionDisable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Disable receive state machine of the MAC for reception from the MII */</comment>
  <expr_stmt><expr><call><name>ETH_MACReceptionDisable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Flush Transmit FIFO */</comment>
  <expr_stmt><expr><call><name>ETH_FlushTransmitFIFO</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Disable transmit state machine of the MAC for transmission on the MII */</comment>
  <expr_stmt><expr><call><name>ETH_MACTransmissionDisable</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH state*/</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Set ETH MAC Configuration.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  macconf MAC Configuration structure  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_ConfigMAC</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>ETH_MACInitTypeDef</name> <modifier>*</modifier></type><name>macconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_SPEED</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Speed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_DUPLEX_MODE</name><argument_list>(<argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DuplexMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  
  <if_stmt><if>if <condition>(<expr><name>macconf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check the parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_WATCHDOG</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>Watchdog</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_JABBER</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>Jabber</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_INTER_FRAME_GAP</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>InterFrameGap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_CARRIER_SENSE</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>CarrierSense</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RECEIVE_OWN</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>ReceiveOwn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_LOOPBACK_MODE</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>LoopbackMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_CHECKSUM_OFFLOAD</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>ChecksumOffload</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RETRY_TRANSMISSION</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>RetryTransmission</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_AUTOMATIC_PADCRC_STRIP</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>AutomaticPadCRCStrip</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_BACKOFF_LIMIT</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>BackOffLimit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_DEFERRAL_CHECK</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>DeferralCheck</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RECEIVE_ALL</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>ReceiveAll</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_SOURCE_ADDR_FILTER</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>SourceAddrFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_CONTROL_FRAMES</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>PassControlFrames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_BROADCAST_FRAMES_RECEPTION</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>BroadcastFramesReception</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_DESTINATION_ADDR_FILTER</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>DestinationAddrFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_PROMISCUOUS_MODE</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>PromiscuousMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_MULTICAST_FRAMES_FILTER</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>MulticastFramesFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_UNICAST_FRAMES_FILTER</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>UnicastFramesFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_PAUSE_TIME</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>PauseTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_ZEROQUANTA_PAUSE</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>ZeroQuantaPause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_PAUSE_LOW_THRESHOLD</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>PauseLowThreshold</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_UNICAST_PAUSE_FRAME_DETECT</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>UnicastPauseFrameDetect</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RECEIVE_FLOWCONTROL</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>ReceiveFlowControl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_TRANSMIT_FLOWCONTROL</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>TransmitFlowControl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_VLAN_TAG_COMPARISON</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>VLANTagComparison</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_VLAN_TAG_IDENTIFIER</name><argument_list>(<argument><expr><name><name>macconf</name><operator>-&gt;</operator><name>VLANTagIdentifier</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*------------------------ ETHERNET MACCR Configuration --------------------*/</comment>
    <comment type="block">/* Get the ETHERNET MACCR value */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
    <comment type="block">/* Clear WD, PCE, PS, TE and RE bits */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <name>ETH_MACCR_CLEAR_MASK</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>macconf</name><operator>-&gt;</operator><name>Watchdog</name></name> <operator>|</operator> 
                         <name><name>macconf</name><operator>-&gt;</operator><name>Jabber</name></name> <operator>|</operator> 
                         <name><name>macconf</name><operator>-&gt;</operator><name>InterFrameGap</name></name> <operator>|</operator>
                         <name><name>macconf</name><operator>-&gt;</operator><name>CarrierSense</name></name> <operator>|</operator>
                         <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>Speed</name> <operator>|</operator> 
                         <name><name>macconf</name><operator>-&gt;</operator><name>ReceiveOwn</name></name> <operator>|</operator>
                         <name><name>macconf</name><operator>-&gt;</operator><name>LoopbackMode</name></name> <operator>|</operator>
                         <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>DuplexMode</name> <operator>|</operator> 
                         <name><name>macconf</name><operator>-&gt;</operator><name>ChecksumOffload</name></name> <operator>|</operator>    
                         <name><name>macconf</name><operator>-&gt;</operator><name>RetryTransmission</name></name> <operator>|</operator> 
                         <name><name>macconf</name><operator>-&gt;</operator><name>AutomaticPadCRCStrip</name></name> <operator>|</operator> 
                         <name><name>macconf</name><operator>-&gt;</operator><name>BackOffLimit</name></name> <operator>|</operator> 
                         <name><name>macconf</name><operator>-&gt;</operator><name>DeferralCheck</name></name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Write to ETHERNET MACCR */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Wait until the write operation will be taken into account :
    at least four TX_CLK/RX_CLK clock cycles */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt> 
    
    <comment type="block">/*----------------------- ETHERNET MACFFR Configuration --------------------*/</comment> 
    <comment type="block">/* Write to ETHERNET MACFFR */</comment>  
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFFR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>macconf</name><operator>-&gt;</operator><name>ReceiveAll</name></name> <operator>|</operator> 
                                          <name><name>macconf</name><operator>-&gt;</operator><name>SourceAddrFilter</name></name> <operator>|</operator>
                                          <name><name>macconf</name><operator>-&gt;</operator><name>PassControlFrames</name></name> <operator>|</operator>
                                          <name><name>macconf</name><operator>-&gt;</operator><name>BroadcastFramesReception</name></name> <operator>|</operator> 
                                          <name><name>macconf</name><operator>-&gt;</operator><name>DestinationAddrFilter</name></name> <operator>|</operator>
                                          <name><name>macconf</name><operator>-&gt;</operator><name>PromiscuousMode</name></name> <operator>|</operator>
                                          <name><name>macconf</name><operator>-&gt;</operator><name>MulticastFramesFilter</name></name> <operator>|</operator>
                                          <name><name>macconf</name><operator>-&gt;</operator><name>UnicastFramesFilter</name></name><operator>)</operator></expr>;</expr_stmt>
     
     <comment type="block">/* Wait until the write operation will be taken into account :
     at least four TX_CLK/RX_CLK clock cycles */</comment>
     <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFFR</name></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFFR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
     
     <comment type="block">/*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/</comment>
     <comment type="block">/* Write to ETHERNET MACHTHR */</comment>
     <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACHTHR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>macconf</name><operator>-&gt;</operator><name>HashTableHigh</name></name></expr>;</expr_stmt>
     
     <comment type="block">/* Write to ETHERNET MACHTLR */</comment>
     <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACHTLR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>macconf</name><operator>-&gt;</operator><name>HashTableLow</name></name></expr>;</expr_stmt>
     <comment type="block">/*----------------------- ETHERNET MACFCR Configuration --------------------*/</comment>
     
     <comment type="block">/* Get the ETHERNET MACFCR value */</comment>  
     <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name></expr>;</expr_stmt>
     <comment type="block">/* Clear xx bits */</comment>
     <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <name>ETH_MACFCR_CLEAR_MASK</name></expr>;</expr_stmt>
     
     <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>macconf</name><operator>-&gt;</operator><name>PauseTime</name></name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator> 
                          <name><name>macconf</name><operator>-&gt;</operator><name>ZeroQuantaPause</name></name> <operator>|</operator>
                          <name><name>macconf</name><operator>-&gt;</operator><name>PauseLowThreshold</name></name> <operator>|</operator>
                          <name><name>macconf</name><operator>-&gt;</operator><name>UnicastPauseFrameDetect</name></name> <operator>|</operator> 
                          <name><name>macconf</name><operator>-&gt;</operator><name>ReceiveFlowControl</name></name> <operator>|</operator>
                          <name><name>macconf</name><operator>-&gt;</operator><name>TransmitFlowControl</name></name><operator>)</operator></expr>;</expr_stmt> 
     
     <comment type="block">/* Write to ETHERNET MACFCR */</comment>
     <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>
     
     <comment type="block">/* Wait until the write operation will be taken into account :
     at least four TX_CLK/RX_CLK clock cycles */</comment>
     <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
     
     <comment type="block">/*----------------------- ETHERNET MACVLANTR Configuration -----------------*/</comment>
     <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACVLANTR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>macconf</name><operator>-&gt;</operator><name>VLANTagComparison</name></name> <operator>|</operator> 
                                              <name><name>macconf</name><operator>-&gt;</operator><name>VLANTagIdentifier</name></name><operator>)</operator></expr>;</expr_stmt>
      
      <comment type="block">/* Wait until the write operation will be taken into account :
      at least four TX_CLK/RX_CLK clock cycles */</comment>
      <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACVLANTR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACVLANTR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <comment type="block">/* macconf == NULL : here we just configure Speed and Duplex mode */</comment>
  <block>{<block_content>
    <comment type="block">/*------------------------ ETHERNET MACCR Configuration --------------------*/</comment>
    <comment type="block">/* Get the ETHERNET MACCR value */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
    
    <comment type="block">/* Clear FES and DM bits */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">0x00004800U</literal><operator>)</operator></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Speed</name></name> <operator>|</operator> <name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DuplexMode</name></name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Write to ETHERNET MACCR */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Wait until the write operation will be taken into account:
    at least four TX_CLK/RX_CLK clock cycles */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Set the ETH state to Ready */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sets ETH DMA Configuration.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  dmaconf DMA Configuration structure  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ETH_ConfigDMA</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>ETH_DMAInitTypeDef</name> <modifier>*</modifier></type><name>dmaconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set the ETH peripheral state to BUSY */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Check parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_DROP_TCPIP_CHECKSUM_FRAME</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>DropTCPIPChecksumErrorFrame</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RECEIVE_STORE_FORWARD</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>ReceiveStoreForward</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_FLUSH_RECEIVE_FRAME</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>FlushReceivedFrame</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_TRANSMIT_STORE_FORWARD</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>TransmitStoreForward</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_TRANSMIT_THRESHOLD_CONTROL</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>TransmitThresholdControl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_FORWARD_ERROR_FRAMES</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>ForwardErrorFrames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>ForwardUndersizedGoodFrames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RECEIVE_THRESHOLD_CONTROL</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>ReceiveThresholdControl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_SECOND_FRAME_OPERATE</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>SecondFrameOperate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_ADDRESS_ALIGNED_BEATS</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>AddressAlignedBeats</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_FIXED_BURST</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>FixedBurst</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_RXDMA_BURST_LENGTH</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>RxDMABurstLength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_TXDMA_BURST_LENGTH</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>TxDMABurstLength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_ENHANCED_DESCRIPTOR_FORMAT</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>EnhancedDescriptorFormat</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_DMA_DESC_SKIP_LENGTH</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>DescriptorSkipLength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX</name><argument_list>(<argument><expr><name><name>dmaconf</name><operator>-&gt;</operator><name>DMAArbitration</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/*----------------------- ETHERNET DMAOMR Configuration --------------------*/</comment>
  <comment type="block">/* Get the ETHERNET DMAOMR value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name></expr>;</expr_stmt>
  <comment type="block">/* Clear xx bits */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <name>ETH_DMAOMR_CLEAR_MASK</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>dmaconf</name><operator>-&gt;</operator><name>DropTCPIPChecksumErrorFrame</name></name> <operator>|</operator> 
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>ReceiveStoreForward</name></name> <operator>|</operator>
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>FlushReceivedFrame</name></name> <operator>|</operator>
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>TransmitStoreForward</name></name> <operator>|</operator> 
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>TransmitThresholdControl</name></name> <operator>|</operator>
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>ForwardErrorFrames</name></name> <operator>|</operator>
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>ForwardUndersizedGoodFrames</name></name> <operator>|</operator>
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>ReceiveThresholdControl</name></name> <operator>|</operator>
                       <name><name>dmaconf</name><operator>-&gt;</operator><name>SecondFrameOperate</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to ETHERNET DMAOMR */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>

  <comment type="block">/* Wait until the write operation will be taken into account:
  at least four TX_CLK/RX_CLK clock cycles */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>

  <comment type="block">/*----------------------- ETHERNET DMABMR Configuration --------------------*/</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>dmaconf</name><operator>-&gt;</operator><name>AddressAlignedBeats</name></name> <operator>|</operator> 
                                         <name><name>dmaconf</name><operator>-&gt;</operator><name>FixedBurst</name></name> <operator>|</operator>
                                         <name><name>dmaconf</name><operator>-&gt;</operator><name>RxDMABurstLength</name></name> <operator>|</operator> <comment type="block">/* !! if 4xPBL is selected for Tx or Rx it is applied for the other */</comment>
                                         <name><name>dmaconf</name><operator>-&gt;</operator><name>TxDMABurstLength</name></name> <operator>|</operator>
                                         <name><name>dmaconf</name><operator>-&gt;</operator><name>EnhancedDescriptorFormat</name></name> <operator>|</operator>
                                         <operator>(</operator><name><name>dmaconf</name><operator>-&gt;</operator><name>DescriptorSkipLength</name></name> <operator>&lt;&lt;</operator> <literal type="number">2U</literal><operator>)</operator> <operator>|</operator>
                                         <name><name>dmaconf</name><operator>-&gt;</operator><name>DMAArbitration</name></name> <operator>|</operator> 
                                         <name>ETH_DMABMR_USP</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Enable use of separate PBL for Rx and Tx */</comment>

   <comment type="block">/* Wait until the write operation will be taken into account:
      at least four TX_CLK/RX_CLK clock cycles */</comment>
   <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>

   <comment type="block">/* Set the ETH state to Ready */</comment>
   <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_ETH_STATE_READY</name></expr>;</expr_stmt>
   
   <comment type="block">/* Process Unlocked */</comment>
   <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   
   <comment type="block">/* Return function status */</comment>
   <return>return <expr><name>HAL_OK</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ETH_Exported_Functions_Group4 Peripheral State functions 
  *  @brief   Peripheral State functions 
  *
  @verbatim   
  ===============================================================================
                         ##### Peripheral State functions #####
  ===============================================================================  
  [..]
  This subsection permits to get in run-time the status of the peripheral 
  and the data flow.
       (+) Get the ETH handle state:
           HAL_ETH_GetState();
           

  @endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the ETH HAL state
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL state
  */</comment>
<function><type><name>HAL_ETH_StateTypeDef</name></type> <name>HAL_ETH_GetState</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
  <comment type="block">/* Return ETH state */</comment>
  <return>return <expr><name><name>heth</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<comment type="block" format="doxygen">/** @addtogroup ETH_Private_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Configures Ethernet MAC and DMA with default parameters.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  err Ethernet Init error
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACDMAConfig</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ETH_MACInitTypeDef</name></type> <name>macinit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ETH_DMAInitTypeDef</name></type> <name>dmainit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>ETH_SUCCESS</name></expr>)</condition> <comment type="block">/* Auto-negotiation failed */</comment>
  <block>{<block_content>
    <comment type="block">/* Set Ethernet duplex mode to Full-duplex */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>DuplexMode</name> <operator>=</operator> <name>ETH_MODE_FULLDUPLEX</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set Ethernet speed to 100M */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>Speed</name> <operator>=</operator> <name>ETH_SPEED_100M</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Ethernet MAC default initialization **************************************/</comment>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>Watchdog</name></name> <operator>=</operator> <name>ETH_WATCHDOG_ENABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>Jabber</name></name> <operator>=</operator> <name>ETH_JABBER_ENABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>InterFrameGap</name></name> <operator>=</operator> <name>ETH_INTERFRAMEGAP_96BIT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>CarrierSense</name></name> <operator>=</operator> <name>ETH_CARRIERSENCE_ENABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>ReceiveOwn</name></name> <operator>=</operator> <name>ETH_RECEIVEOWN_ENABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>LoopbackMode</name></name> <operator>=</operator> <name>ETH_LOOPBACKMODE_DISABLE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ChecksumMode</name></name> <operator>==</operator> <name>ETH_CHECKSUM_BY_HARDWARE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>ChecksumOffload</name></name> <operator>=</operator> <name>ETH_CHECKSUMOFFLAOD_ENABLE</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>ChecksumOffload</name></name> <operator>=</operator> <name>ETH_CHECKSUMOFFLAOD_DISABLE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>RetryTransmission</name></name> <operator>=</operator> <name>ETH_RETRYTRANSMISSION_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>AutomaticPadCRCStrip</name></name> <operator>=</operator> <name>ETH_AUTOMATICPADCRCSTRIP_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>BackOffLimit</name></name> <operator>=</operator> <name>ETH_BACKOFFLIMIT_10</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>DeferralCheck</name></name> <operator>=</operator> <name>ETH_DEFFERRALCHECK_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>ReceiveAll</name></name> <operator>=</operator> <name>ETH_RECEIVEAll_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>SourceAddrFilter</name></name> <operator>=</operator> <name>ETH_SOURCEADDRFILTER_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>PassControlFrames</name></name> <operator>=</operator> <name>ETH_PASSCONTROLFRAMES_BLOCKALL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>BroadcastFramesReception</name></name> <operator>=</operator> <name>ETH_BROADCASTFRAMESRECEPTION_ENABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>DestinationAddrFilter</name></name> <operator>=</operator> <name>ETH_DESTINATIONADDRFILTER_NORMAL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>PromiscuousMode</name></name> <operator>=</operator> <name>ETH_PROMISCUOUS_MODE_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>MulticastFramesFilter</name></name> <operator>=</operator> <name>ETH_MULTICASTFRAMESFILTER_PERFECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>UnicastFramesFilter</name></name> <operator>=</operator> <name>ETH_UNICASTFRAMESFILTER_PERFECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>HashTableHigh</name></name> <operator>=</operator> <literal type="number">0x0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>HashTableLow</name></name> <operator>=</operator> <literal type="number">0x0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>PauseTime</name></name> <operator>=</operator> <literal type="number">0x0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>ZeroQuantaPause</name></name> <operator>=</operator> <name>ETH_ZEROQUANTAPAUSE_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>PauseLowThreshold</name></name> <operator>=</operator> <name>ETH_PAUSELOWTHRESHOLD_MINUS4</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>UnicastPauseFrameDetect</name></name> <operator>=</operator> <name>ETH_UNICASTPAUSEFRAMEDETECT_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>ReceiveFlowControl</name></name> <operator>=</operator> <name>ETH_RECEIVEFLOWCONTROL_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>TransmitFlowControl</name></name> <operator>=</operator> <name>ETH_TRANSMITFLOWCONTROL_DISABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>VLANTagComparison</name></name> <operator>=</operator> <name>ETH_VLANTAGCOMPARISON_16BIT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>macinit</name><operator>.</operator><name>VLANTagIdentifier</name></name> <operator>=</operator> <literal type="number">0x0U</literal></expr>;</expr_stmt>
  
  <comment type="block">/*------------------------ ETHERNET MACCR Configuration --------------------*/</comment>
  <comment type="block">/* Get the ETHERNET MACCR value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
  <comment type="block">/* Clear WD, PCE, PS, TE and RE bits */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <name>ETH_MACCR_CLEAR_MASK</name></expr>;</expr_stmt>
  <comment type="block">/* Set the WD bit according to ETH Watchdog value */</comment>
  <comment type="block">/* Set the JD: bit according to ETH Jabber value */</comment>
  <comment type="block">/* Set the IFG bit according to ETH InterFrameGap value */</comment>
  <comment type="block">/* Set the DCRS bit according to ETH CarrierSense value */</comment>
  <comment type="block">/* Set the FES bit according to ETH Speed value */</comment> 
  <comment type="block">/* Set the DO bit according to ETH ReceiveOwn value */</comment> 
  <comment type="block">/* Set the LM bit according to ETH LoopbackMode value */</comment>
  <comment type="block">/* Set the DM bit according to ETH Mode value */</comment> 
  <comment type="block">/* Set the IPCO bit according to ETH ChecksumOffload value */</comment>
  <comment type="block">/* Set the DR bit according to ETH RetryTransmission value */</comment>
  <comment type="block">/* Set the ACS bit according to ETH AutomaticPadCRCStrip value */</comment>
  <comment type="block">/* Set the BL bit according to ETH BackOffLimit value */</comment>
  <comment type="block">/* Set the DC bit according to ETH DeferralCheck value */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>macinit</name><operator>.</operator><name>Watchdog</name></name> <operator>|</operator> 
                       <name><name>macinit</name><operator>.</operator><name>Jabber</name></name> <operator>|</operator> 
                       <name><name>macinit</name><operator>.</operator><name>InterFrameGap</name></name> <operator>|</operator>
                       <name><name>macinit</name><operator>.</operator><name>CarrierSense</name></name> <operator>|</operator>
                       <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>Speed</name> <operator>|</operator> 
                       <name><name>macinit</name><operator>.</operator><name>ReceiveOwn</name></name> <operator>|</operator>
                       <name><name>macinit</name><operator>.</operator><name>LoopbackMode</name></name> <operator>|</operator>
                       <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>DuplexMode</name> <operator>|</operator> 
                       <name><name>macinit</name><operator>.</operator><name>ChecksumOffload</name></name> <operator>|</operator>    
                       <name><name>macinit</name><operator>.</operator><name>RetryTransmission</name></name> <operator>|</operator> 
                       <name><name>macinit</name><operator>.</operator><name>AutomaticPadCRCStrip</name></name> <operator>|</operator> 
                       <name><name>macinit</name><operator>.</operator><name>BackOffLimit</name></name> <operator>|</operator> 
                       <name><name>macinit</name><operator>.</operator><name>DeferralCheck</name></name><operator>)</operator></expr>;</expr_stmt>
  
  <comment type="block">/* Write to ETHERNET MACCR */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>
  
  <comment type="block">/* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt> 
  
  <comment type="block">/*----------------------- ETHERNET MACFFR Configuration --------------------*/</comment> 
  <comment type="block">/* Set the RA bit according to ETH ReceiveAll value */</comment>
  <comment type="block">/* Set the SAF and SAIF bits according to ETH SourceAddrFilter value */</comment>
  <comment type="block">/* Set the PCF bit according to ETH PassControlFrames value */</comment>
  <comment type="block">/* Set the DBF bit according to ETH BroadcastFramesReception value */</comment>
  <comment type="block">/* Set the DAIF bit according to ETH DestinationAddrFilter value */</comment>
  <comment type="block">/* Set the PR bit according to ETH PromiscuousMode value */</comment>
  <comment type="block">/* Set the PM, HMC and HPF bits according to ETH MulticastFramesFilter value */</comment>
  <comment type="block">/* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */</comment>
  <comment type="block">/* Write to ETHERNET MACFFR */</comment>  
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFFR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>macinit</name><operator>.</operator><name>ReceiveAll</name></name> <operator>|</operator> 
                                        <name><name>macinit</name><operator>.</operator><name>SourceAddrFilter</name></name> <operator>|</operator>
                                        <name><name>macinit</name><operator>.</operator><name>PassControlFrames</name></name> <operator>|</operator>
                                        <name><name>macinit</name><operator>.</operator><name>BroadcastFramesReception</name></name> <operator>|</operator> 
                                        <name><name>macinit</name><operator>.</operator><name>DestinationAddrFilter</name></name> <operator>|</operator>
                                        <name><name>macinit</name><operator>.</operator><name>PromiscuousMode</name></name> <operator>|</operator>
                                        <name><name>macinit</name><operator>.</operator><name>MulticastFramesFilter</name></name> <operator>|</operator>
                                        <name><name>macinit</name><operator>.</operator><name>UnicastFramesFilter</name></name><operator>)</operator></expr>;</expr_stmt>
   
   <comment type="block">/* Wait until the write operation will be taken into account:
      at least four TX_CLK/RX_CLK clock cycles */</comment>
   <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFFR</name></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFFR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
   
   <comment type="block">/*--------------- ETHERNET MACHTHR and MACHTLR Configuration --------------*/</comment>
   <comment type="block">/* Write to ETHERNET MACHTHR */</comment>
   <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACHTHR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>macinit</name><operator>.</operator><name>HashTableHigh</name></name></expr>;</expr_stmt>
   
   <comment type="block">/* Write to ETHERNET MACHTLR */</comment>
   <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACHTLR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>macinit</name><operator>.</operator><name>HashTableLow</name></name></expr>;</expr_stmt>
   <comment type="block">/*----------------------- ETHERNET MACFCR Configuration -------------------*/</comment>
   
   <comment type="block">/* Get the ETHERNET MACFCR value */</comment>  
   <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name></expr>;</expr_stmt>
   <comment type="block">/* Clear xx bits */</comment>
   <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <name>ETH_MACFCR_CLEAR_MASK</name></expr>;</expr_stmt>
   
   <comment type="block">/* Set the PT bit according to ETH PauseTime value */</comment>
   <comment type="block">/* Set the DZPQ bit according to ETH ZeroQuantaPause value */</comment>
   <comment type="block">/* Set the PLT bit according to ETH PauseLowThreshold value */</comment>
   <comment type="block">/* Set the UP bit according to ETH UnicastPauseFrameDetect value */</comment>
   <comment type="block">/* Set the RFE bit according to ETH ReceiveFlowControl value */</comment>
   <comment type="block">/* Set the TFE bit according to ETH TransmitFlowControl value */</comment> 
   <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>macinit</name><operator>.</operator><name>PauseTime</name></name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator> 
                        <name><name>macinit</name><operator>.</operator><name>ZeroQuantaPause</name></name> <operator>|</operator>
                        <name><name>macinit</name><operator>.</operator><name>PauseLowThreshold</name></name> <operator>|</operator>
                        <name><name>macinit</name><operator>.</operator><name>UnicastPauseFrameDetect</name></name> <operator>|</operator> 
                        <name><name>macinit</name><operator>.</operator><name>ReceiveFlowControl</name></name> <operator>|</operator>
                        <name><name>macinit</name><operator>.</operator><name>TransmitFlowControl</name></name><operator>)</operator></expr>;</expr_stmt> 
   
   <comment type="block">/* Write to ETHERNET MACFCR */</comment>
   <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>
   
   <comment type="block">/* Wait until the write operation will be taken into account:
   at least four TX_CLK/RX_CLK clock cycles */</comment>
   <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACFCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
   
   <comment type="block">/*----------------------- ETHERNET MACVLANTR Configuration ----------------*/</comment>
   <comment type="block">/* Set the ETV bit according to ETH VLANTagComparison value */</comment>
   <comment type="block">/* Set the VL bit according to ETH VLANTagIdentifier value */</comment>  
   <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACVLANTR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>macinit</name><operator>.</operator><name>VLANTagComparison</name></name> <operator>|</operator> 
                                            <name><name>macinit</name><operator>.</operator><name>VLANTagIdentifier</name></name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Wait until the write operation will be taken into account:
       at least four TX_CLK/RX_CLK clock cycles */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACVLANTR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACVLANTR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Ethernet DMA default initialization ************************************/</comment>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>DropTCPIPChecksumErrorFrame</name></name> <operator>=</operator> <name>ETH_DROPTCPIPCHECKSUMERRORFRAME_ENABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>ReceiveStoreForward</name></name> <operator>=</operator> <name>ETH_RECEIVESTOREFORWARD_ENABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>FlushReceivedFrame</name></name> <operator>=</operator> <name>ETH_FLUSHRECEIVEDFRAME_ENABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>TransmitStoreForward</name></name> <operator>=</operator> <name>ETH_TRANSMITSTOREFORWARD_ENABLE</name></expr>;</expr_stmt>  
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>TransmitThresholdControl</name></name> <operator>=</operator> <name>ETH_TRANSMITTHRESHOLDCONTROL_64BYTES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>ForwardErrorFrames</name></name> <operator>=</operator> <name>ETH_FORWARDERRORFRAMES_DISABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>ForwardUndersizedGoodFrames</name></name> <operator>=</operator> <name>ETH_FORWARDUNDERSIZEDGOODFRAMES_DISABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>ReceiveThresholdControl</name></name> <operator>=</operator> <name>ETH_RECEIVEDTHRESHOLDCONTROL_64BYTES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>SecondFrameOperate</name></name> <operator>=</operator> <name>ETH_SECONDFRAMEOPERARTE_ENABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>AddressAlignedBeats</name></name> <operator>=</operator> <name>ETH_ADDRESSALIGNEDBEATS_ENABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>FixedBurst</name></name> <operator>=</operator> <name>ETH_FIXEDBURST_ENABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>RxDMABurstLength</name></name> <operator>=</operator> <name>ETH_RXDMABURSTLENGTH_32BEAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>TxDMABurstLength</name></name> <operator>=</operator> <name>ETH_TXDMABURSTLENGTH_32BEAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>EnhancedDescriptorFormat</name></name> <operator>=</operator> <name>ETH_DMAENHANCEDDESCRIPTOR_ENABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>DescriptorSkipLength</name></name> <operator>=</operator> <literal type="number">0x0U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dmainit</name><operator>.</operator><name>DMAArbitration</name></name> <operator>=</operator> <name>ETH_DMAARBITRATION_ROUNDROBIN_RXTX_1_1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Get the ETHERNET DMAOMR value */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name></expr>;</expr_stmt>
    <comment type="block">/* Clear xx bits */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>&amp;=</operator> <name>ETH_DMAOMR_CLEAR_MASK</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set the DT bit according to ETH DropTCPIPChecksumErrorFrame value */</comment>
    <comment type="block">/* Set the RSF bit according to ETH ReceiveStoreForward value */</comment>
    <comment type="block">/* Set the DFF bit according to ETH FlushReceivedFrame value */</comment>
    <comment type="block">/* Set the TSF bit according to ETH TransmitStoreForward value */</comment>
    <comment type="block">/* Set the TTC bit according to ETH TransmitThresholdControl value */</comment>
    <comment type="block">/* Set the FEF bit according to ETH ForwardErrorFrames value */</comment>
    <comment type="block">/* Set the FUF bit according to ETH ForwardUndersizedGoodFrames value */</comment>
    <comment type="block">/* Set the RTC bit according to ETH ReceiveThresholdControl value */</comment>
    <comment type="block">/* Set the OSF bit according to ETH SecondFrameOperate value */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>dmainit</name><operator>.</operator><name>DropTCPIPChecksumErrorFrame</name></name> <operator>|</operator> 
                         <name><name>dmainit</name><operator>.</operator><name>ReceiveStoreForward</name></name> <operator>|</operator>
                         <name><name>dmainit</name><operator>.</operator><name>FlushReceivedFrame</name></name> <operator>|</operator>
                         <name><name>dmainit</name><operator>.</operator><name>TransmitStoreForward</name></name> <operator>|</operator> 
                         <name><name>dmainit</name><operator>.</operator><name>TransmitThresholdControl</name></name> <operator>|</operator>
                         <name><name>dmainit</name><operator>.</operator><name>ForwardErrorFrames</name></name> <operator>|</operator>
                         <name><name>dmainit</name><operator>.</operator><name>ForwardUndersizedGoodFrames</name></name> <operator>|</operator>
                         <name><name>dmainit</name><operator>.</operator><name>ReceiveThresholdControl</name></name> <operator>|</operator>
                         <name><name>dmainit</name><operator>.</operator><name>SecondFrameOperate</name></name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Write to ETHERNET DMAOMR */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>tmpreg1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Wait until the write operation will be taken into account:
       at least four TX_CLK/RX_CLK clock cycles */</comment>
    <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
    
    <comment type="block">/*----------------------- ETHERNET DMABMR Configuration ------------------*/</comment>
    <comment type="block">/* Set the AAL bit according to ETH AddressAlignedBeats value */</comment>
    <comment type="block">/* Set the FB bit according to ETH FixedBurst value */</comment>
    <comment type="block">/* Set the RPBL and 4*PBL bits according to ETH RxDMABurstLength value */</comment>
    <comment type="block">/* Set the PBL and 4*PBL bits according to ETH TxDMABurstLength value */</comment>
    <comment type="block">/* Set the Enhanced DMA descriptors bit according to ETH EnhancedDescriptorFormat value*/</comment>
    <comment type="block">/* Set the DSL bit according to ETH DesciptorSkipLength value */</comment>
    <comment type="block">/* Set the PR and DA bits according to ETH DMAArbitration value */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>dmainit</name><operator>.</operator><name>AddressAlignedBeats</name></name> <operator>|</operator> 
                                          <name><name>dmainit</name><operator>.</operator><name>FixedBurst</name></name> <operator>|</operator>
                                          <name><name>dmainit</name><operator>.</operator><name>RxDMABurstLength</name></name> <operator>|</operator>    <comment type="block">/* !! if 4xPBL is selected for Tx or Rx it is applied for the other */</comment>
                                          <name><name>dmainit</name><operator>.</operator><name>TxDMABurstLength</name></name> <operator>|</operator>
                                          <name><name>dmainit</name><operator>.</operator><name>EnhancedDescriptorFormat</name></name> <operator>|</operator>
                                          <operator>(</operator><name><name>dmainit</name><operator>.</operator><name>DescriptorSkipLength</name></name> <operator>&lt;&lt;</operator> <literal type="number">2U</literal><operator>)</operator> <operator>|</operator>
                                          <name><name>dmainit</name><operator>.</operator><name>DMAArbitration</name></name> <operator>|</operator>
                                          <name>ETH_DMABMR_USP</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Enable use of separate PBL for Rx and Tx */</comment>
     
     <comment type="block">/* Wait until the write operation will be taken into account:
        at least four TX_CLK/RX_CLK clock cycles */</comment>
     <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMABMR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>

     <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator><operator>.</operator><name>RxMode</name> <operator>==</operator> <name>ETH_RXINTERRUPT_MODE</name></expr>)</condition>
     <block>{<block_content>
       <comment type="block">/* Enable the Ethernet Rx Interrupt */</comment>
       <expr_stmt><expr><call><name>__HAL_ETH_DMA_ENABLE_IT</name><argument_list>(<argument><expr><operator>(</operator><name>heth</name><operator>)</operator></expr></argument>, <argument><expr><name>ETH_DMA_IT_NIS</name> <operator>|</operator> <name>ETH_DMA_IT_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>

     <comment type="block">/* Initialize MAC address in ethernet MAC */</comment> 
     <expr_stmt><expr><call><name>ETH_MACAddressConfig</name><argument_list>(<argument><expr><name>heth</name></expr></argument>, <argument><expr><name>ETH_MAC_ADDRESS0</name></expr></argument>, <argument><expr><name><name>heth</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MACAddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures the selected MAC address.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  MacAddr The MAC address to configure
  *          This parameter can be one of the following values:
  *             @arg ETH_MAC_Address0: MAC Address0 
  *             @arg ETH_MAC_Address1: MAC Address1 
  *             @arg ETH_MAC_Address2: MAC Address2
  *             @arg ETH_MAC_Address3: MAC Address3
  * @param  Addr Pointer to MAC address buffer data (6 bytes)
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACAddressConfig</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>MacAddr</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>Addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg1</name></decl>;</decl_stmt>
  
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>heth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ETH_MAC_ADDRESS0123</name><argument_list>(<argument><expr><name>MacAddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Calculate the selected MAC address high register */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>Addr</name><index>[<expr><literal type="number">5U</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>Addr</name><index>[<expr><literal type="number">4U</literal></expr>]</index></name></expr>;</expr_stmt>
  <comment type="block">/* Load the selected MAC address high register */</comment>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ETH_MAC_ADDR_HBASE</name> <operator>+</operator> <name>MacAddr</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
  <comment type="block">/* Calculate the selected MAC address low register */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>Addr</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>Addr</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>Addr</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>|</operator> <name><name>Addr</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name></expr>;</expr_stmt>
  
  <comment type="block">/* Load the selected MAC address low register */</comment>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ETH_MAC_ADDR_LBASE</name> <operator>+</operator> <name>MacAddr</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables the MAC transmission.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module  
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACTransmissionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Enable the MAC transmission */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>|=</operator> <name>ETH_MACCR_TE</name></expr>;</expr_stmt>
  
  <comment type="block">/* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ETH_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables the MAC transmission.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module  
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACTransmissionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Disable the MAC transmission */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_MACCR_TE</name></expr>;</expr_stmt>
  
  <comment type="block">/* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ETH_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables the MAC reception.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module   
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACReceptionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Enable the MAC reception */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>|=</operator> <name>ETH_MACCR_RE</name></expr>;</expr_stmt>
  
  <comment type="block">/* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ETH_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables the MAC reception.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module   
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_MACReceptionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Disable the MAC reception */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_MACCR_RE</name></expr>;</expr_stmt> 
  
  <comment type="block">/* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ETH_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>MACCR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables the DMA transmission.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module   
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMATransmissionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Enable the DMA transmission */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>|=</operator> <name>ETH_DMAOMR_ST</name></expr>;</expr_stmt>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables the DMA transmission.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module   
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMATransmissionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <comment type="block">/* Disable the DMA transmission */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_DMAOMR_ST</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables the DMA reception.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module 
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMAReceptionEnable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
  <comment type="block">/* Enable the DMA reception */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>|=</operator> <name>ETH_DMAOMR_SR</name></expr>;</expr_stmt>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables the DMA reception.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module 
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_DMAReceptionDisable</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <comment type="block">/* Disable the DMA reception */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>&amp;=</operator> <operator>~</operator><name>ETH_DMAOMR_SR</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Clears the ETHERNET transmit FIFO.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_FlushTransmitFIFO</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmpreg1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Set the Flush Transmit FIFO bit */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>|=</operator> <name>ETH_DMAOMR_FTF</name></expr>;</expr_stmt>
  
  <comment type="block">/* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */</comment>
  <expr_stmt><expr><name>tmpreg1</name> <operator>=</operator> <operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ETH_Delay</name><argument_list>(<argument><expr><name>ETH_REG_WRITE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>heth</name><operator>-&gt;</operator><name>Instance</name></name><operator>)</operator><operator>-&gt;</operator><name>DMAOMR</name> <operator>=</operator> <name>tmpreg1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay specifies the delay time length, in milliseconds.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_Delay</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>mdelay</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Delay</name> <init>= <expr><name>mdelay</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">8U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <do>do 
  <block>{<block_content>
    <expr_stmt><expr><call><name>__NOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> 
  while <condition>(<expr><name>Delay</name> <operator>--</operator></expr>)</condition>;</do>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_ETH_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ETH_InitCallbacksToDefault</name><parameter_list>(<parameter><decl><type><name>ETH_HandleTypeDef</name> <modifier>*</modifier></type><name>heth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init the ETH Callback settings */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>TxCpltCallback</name></name>       <operator>=</operator> <name>HAL_ETH_TxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TxCpltCallback   */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>RxCpltCallback</name></name>       <operator>=</operator> <name>HAL_ETH_RxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak RxCpltCallback   */</comment>
  <expr_stmt><expr><name><name>heth</name><operator>-&gt;</operator><name>DMAErrorCallback</name></name>     <operator>=</operator> <name>HAL_ETH_ErrorCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak DMAErrorCallback */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_ETH_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx ||\
          STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_ETH_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
