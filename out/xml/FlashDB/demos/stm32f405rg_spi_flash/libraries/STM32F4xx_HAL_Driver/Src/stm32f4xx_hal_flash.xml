<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_flash.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_flash.c
  * @author  MCD Application Team
  * @brief   FLASH HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of the internal FLASH memory:
  *           + Program operations functions
  *           + Memory Control functions 
  *           + Peripheral Errors functions
  *         
  @verbatim
  ==============================================================================
                        ##### FLASH peripheral features #####
  ==============================================================================
           
  [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
       to the Flash memory. It implements the erase and program Flash memory operations 
       and the read and write protection mechanisms.
      
  [..] The Flash memory interface accelerates code execution with a system of instruction
       prefetch and cache lines. 

  [..] The FLASH main features are:
      (+) Flash memory read operations
      (+) Flash memory program/erase operations
      (+) Read / write protections
      (+) Prefetch on I-Code
      (+) 64 cache lines of 128 bits on I-Code
      (+) 8 cache lines of 128 bits on D-Code
      
      
                     ##### How to use this driver #####
  ==============================================================================
    [..]                             
      This driver provides functions and macros to configure and program the FLASH 
      memory of all STM32F4xx devices.
    
      (#) FLASH Memory IO Programming functions: 
           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
                HAL_FLASH_Lock() functions
           (++) Program functions: byte, half word, word and double word
           (++) There Two modes of programming :
            (+++) Polling mode using HAL_FLASH_Program() function
            (+++) Interrupt mode using HAL_FLASH_Program_IT() function
    
      (#) Interrupts and flags management functions : 
           (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
           (++) Wait for last FLASH operation according to its status
           (++) Get error flag status by calling HAL_SetErrorCode()          

    [..] 
      In addition to these functions, this driver includes a set of macros allowing
      to handle the following operations:
       (+) Set the latency
       (+) Enable/Disable the prefetch buffer
       (+) Enable/Disable the Instruction cache and the Data cache
       (+) Reset the Instruction cache and the Data cache
       (+) Enable/Disable the FLASH interrupts
       (+) Monitor the FLASH flags status
          
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup FLASH FLASH
  * @brief FLASH HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_FLASH_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup FLASH_Private_Constants
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLASH_TIMEOUT_VALUE</name></cpp:macro>       <cpp:value>50000U</cpp:value></cpp:define> <comment type="block">/* 50 s */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>         
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup FLASH_Private_Variables
  * @{
  */</comment>
<comment type="block">/* Variable used for Erase sectors under interruption */</comment>
<decl_stmt><decl><type><name>FLASH_ProcessTypeDef</name></type> <name>pFlash</name></decl>;</decl_stmt>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup FLASH_Private_Functions
  * @{
  */</comment>
<comment type="block">/* Program operations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>FLASH_Program_DoubleWord</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>FLASH_Program_Word</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>FLASH_Program_HalfWord</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>FLASH_Program_Byte</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>FLASH_SetErrorCode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HAL_StatusTypeDef</name></type> <name>FLASH_WaitForLastOperation</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup FLASH_Exported_Functions FLASH Exported Functions
  * @{
  */</comment>
  
<comment type="block" format="doxygen">/** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
 *  @brief   Programming operation functions 
 *
@verbatim   
 ===============================================================================
                  ##### Programming operation functions #####
 ===============================================================================  
    [..]
    This subsection provides a set of functions allowing to manage the FLASH 
    program operations.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Program byte, halfword, word or double word at a specified address
  * @param  TypeProgram  Indicate the way to program at a specified address.
  *                           This parameter can be a value of @ref FLASH_Type_Program
  * @param  Address  specifies the address to be programmed.
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASH_Program</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>TypeProgram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_ERROR</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_TYPEPROGRAM</name><argument_list>(<argument><expr><name>TypeProgram</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Wait for last operation to be completed */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>TypeProgram</name> <operator>==</operator> <name>FLASH_TYPEPROGRAM_BYTE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*Program byte (8-bit) at a specified address.*/</comment>
      <expr_stmt><expr><call><name>FLASH_Program_Byte</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>TypeProgram</name> <operator>==</operator> <name>FLASH_TYPEPROGRAM_HALFWORD</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*Program halfword (16-bit) at a specified address.*/</comment>
      <expr_stmt><expr><call><name>FLASH_Program_HalfWord</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator> <name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>TypeProgram</name> <operator>==</operator> <name>FLASH_TYPEPROGRAM_WORD</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*Program word (32-bit) at a specified address.*/</comment>
      <expr_stmt><expr><call><name>FLASH_Program_Word</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/*Program double word (64-bit) at a specified address.*/</comment>
      <expr_stmt><expr><call><name>FLASH_Program_DoubleWord</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* Wait for last operation to be completed */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* If the program operation is completed, disable the PG Bit */</comment>
    <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>FLASH_CR_PG</name><operator>)</operator></expr>;</expr_stmt>  
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
  * @param  TypeProgram  Indicate the way to program at a specified address.
  *                           This parameter can be a value of @ref FLASH_Type_Program
  * @param  Address  specifies the address to be programmed.
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASH_Program_IT</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>TypeProgram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_TYPEPROGRAM</name><argument_list>(<argument><expr><name>TypeProgram</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable End of FLASH Operation interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_FLASH_ENABLE_IT</name><argument_list>(<argument><expr><name>FLASH_IT_EOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable Error source interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_FLASH_ENABLE_IT</name><argument_list>(<argument><expr><name>FLASH_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>=</operator> <name>FLASH_PROC_PROGRAM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>Address</name></name> <operator>=</operator> <name>Address</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>TypeProgram</name> <operator>==</operator> <name>FLASH_TYPEPROGRAM_BYTE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*Program byte (8-bit) at a specified address.*/</comment>
      <expr_stmt><expr><call><name>FLASH_Program_Byte</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>TypeProgram</name> <operator>==</operator> <name>FLASH_TYPEPROGRAM_HALFWORD</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*Program halfword (16-bit) at a specified address.*/</comment>
    <expr_stmt><expr><call><name>FLASH_Program_HalfWord</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator> <name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>TypeProgram</name> <operator>==</operator> <name>FLASH_TYPEPROGRAM_WORD</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*Program word (32-bit) at a specified address.*/</comment>
    <expr_stmt><expr><call><name>FLASH_Program_Word</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/*Program double word (64-bit) at a specified address.*/</comment>
    <expr_stmt><expr><call><name>FLASH_Program_DoubleWord</name><argument_list>(<argument><expr><name>Address</name></expr></argument>, <argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_FLASH_IRQHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>addresstmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check FLASH operation error flags */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FLASH_SR_RDERR</name></expr></argument>)</argument_list></call></expr></cpp:if> 
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><operator>(</operator><name>FLASH_FLAG_OPERR</name> <operator>|</operator> <name>FLASH_FLAG_WRPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGAERR</name> <operator>|</operator> \
    <name>FLASH_FLAG_PGPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGSERR</name> <operator>|</operator> <name>FLASH_FLAG_RDERR</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><operator>(</operator><name>FLASH_FLAG_OPERR</name> <operator>|</operator> <name>FLASH_FLAG_WRPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGAERR</name> <operator>|</operator> \
    <name>FLASH_FLAG_PGPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGSERR</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FLASH_SR_RDERR */</comment>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>==</operator> <name>FLASH_PROC_SECTERASE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*return the faulty sector*/</comment>
      <expr_stmt><expr><name>addresstmp</name> <operator>=</operator> <name><name>pFlash</name><operator>.</operator><name>Sector</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>Sector</name></name> <operator>=</operator> <literal type="number">0xFFFFFFFFU</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>==</operator> <name>FLASH_PROC_MASSERASE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*return the faulty bank*/</comment>
      <expr_stmt><expr><name>addresstmp</name> <operator>=</operator> <name><name>pFlash</name><operator>.</operator><name>Bank</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/*return the faulty address*/</comment>
      <expr_stmt><expr><name>addresstmp</name> <operator>=</operator> <name><name>pFlash</name><operator>.</operator><name>Address</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/*Save the Error code*/</comment>
    <expr_stmt><expr><call><name>FLASH_SetErrorCode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* FLASH error interrupt user callback */</comment>
    <expr_stmt><expr><call><name>HAL_FLASH_OperationErrorCallback</name><argument_list>(<argument><expr><name>addresstmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*Stop the procedure ongoing*/</comment>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>=</operator> <name>FLASH_PROC_NONE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
  
  <comment type="block">/* Check FLASH End of Operation flag  */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_EOP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Clear FLASH End of Operation pending bit */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_EOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>==</operator> <name>FLASH_PROC_SECTERASE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*Nb of sector to erased can be decreased*/</comment>
      <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>NbSectorsToErase</name></name><operator>--</operator></expr>;</expr_stmt>
      
      <comment type="block">/* Check if there are still sectors to erase*/</comment>
      <if_stmt><if>if<condition>(<expr><name><name>pFlash</name><operator>.</operator><name>NbSectorsToErase</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>addresstmp</name> <operator>=</operator> <name><name>pFlash</name><operator>.</operator><name>Sector</name></name></expr>;</expr_stmt>
        <comment type="block">/*Indicate user which sector has been erased*/</comment>
        <expr_stmt><expr><call><name>HAL_FLASH_EndOfOperationCallback</name><argument_list>(<argument><expr><name>addresstmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*Increment sector number*/</comment>
        <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>Sector</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>addresstmp</name> <operator>=</operator> <name><name>pFlash</name><operator>.</operator><name>Sector</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FLASH_Erase_Sector</name><argument_list>(<argument><expr><name>addresstmp</name></expr></argument>, <argument><expr><name><name>pFlash</name><operator>.</operator><name>VoltageForErase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/*No more sectors to Erase, user callback can be called.*/</comment>
        <comment type="block">/*Reset Sector and stop Erase sectors procedure*/</comment>
        <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>Sector</name></name> <operator>=</operator> <name>addresstmp</name> <operator>=</operator> <literal type="number">0xFFFFFFFFU</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>=</operator> <name>FLASH_PROC_NONE</name></expr>;</expr_stmt>
        
        <comment type="block">/* Flush the caches to be sure of the data consistency */</comment>
        <expr_stmt><expr><call><name>FLASH_FlushCaches</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
                
        <comment type="block">/* FLASH EOP interrupt user callback */</comment>
        <expr_stmt><expr><call><name>HAL_FLASH_EndOfOperationCallback</name><argument_list>(<argument><expr><name>addresstmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>==</operator> <name>FLASH_PROC_MASSERASE</name></expr>)</condition> 
      <block>{<block_content>
        <comment type="block">/* MassErase ended. Return the selected bank */</comment>
        <comment type="block">/* Flush the caches to be sure of the data consistency */</comment>
        <expr_stmt><expr><call><name>FLASH_FlushCaches</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>

        <comment type="block">/* FLASH EOP interrupt user callback */</comment>
        <expr_stmt><expr><call><name>HAL_FLASH_EndOfOperationCallback</name><argument_list>(<argument><expr><name><name>pFlash</name><operator>.</operator><name>Bank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/*Program ended. Return the selected address*/</comment>
        <comment type="block">/* FLASH EOP interrupt user callback */</comment>
        <expr_stmt><expr><call><name>HAL_FLASH_EndOfOperationCallback</name><argument_list>(<argument><expr><name><name>pFlash</name><operator>.</operator><name>Address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>=</operator> <name>FLASH_PROC_NONE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>(<expr><name><name>pFlash</name><operator>.</operator><name>ProcedureOnGoing</name></name> <operator>==</operator> <name>FLASH_PROC_NONE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Operation is completed, disable the PG, SER, SNB and MER Bits */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FLASH_CR_PG</name> <operator>|</operator> <name>FLASH_CR_SER</name> <operator>|</operator> <name>FLASH_CR_SNB</name> <operator>|</operator> <name>FLASH_MER_BIT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable End of FLASH Operation interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_DISABLE_IT</name><argument_list>(<argument><expr><name>FLASH_IT_EOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Disable Error source interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_DISABLE_IT</name><argument_list>(<argument><expr><name>FLASH_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFlash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  FLASH end of operation interrupt callback
  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
  *                  Mass Erase: Bank number which has been requested to erase
  *                  Sectors Erase: Sector which has been erased 
  *                    (if 0xFFFFFFFFU, it means that all the selected sectors have been erased)
  *                  Program: Address which was selected for data program
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_FLASH_EndOfOperationCallback</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ReturnValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  FLASH operation error interrupt callback
  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
  *                 Mass Erase: Bank number which has been requested to erase
  *                 Sectors Erase: Sector number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_FLASH_OperationErrorCallback</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ReturnValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
 *  @brief   management functions 
 *
@verbatim   
 ===============================================================================
                      ##### Peripheral Control functions #####
 ===============================================================================  
    [..]
    This subsection provides a set of functions allowing to control the FLASH 
    memory operations.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASH_Unlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_LOCK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Authorize the FLASH Registers access */</comment>
    <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>KEYR</name></name></expr></argument>, <argument><expr><name>FLASH_KEY1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>KEYR</name></name></expr></argument>, <argument><expr><name>FLASH_KEY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Verify Flash is unlocked */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_LOCK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Locks the FLASH control register access
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASH_Lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set the LOCK Bit to lock the FLASH Registers access */</comment>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_LOCK</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASH_OB_Unlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>FLASH</name><operator>-&gt;</operator><name>OPTCR</name></name> <operator>&amp;</operator> <name>FLASH_OPTCR_OPTLOCK</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Authorizes the Option Byte register programming */</comment>
    <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>OPTKEYR</name></name> <operator>=</operator> <name>FLASH_OPT_KEY1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>OPTKEYR</name></name> <operator>=</operator> <name>FLASH_OPT_KEY2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>  
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status 
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASH_OB_Lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */</comment>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>OPTCR</name></name> <operator>|=</operator> <name>FLASH_OPTCR_OPTLOCK</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Launch the option byte loading.
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_FLASH_OB_Launch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set the OPTSTRT bit in OPTCR register */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>OPTCR_BYTE0_ADDRESS</name> <operator>|=</operator> <name>FLASH_OPTCR_OPTSTRT</name></expr>;</expr_stmt>

  <comment type="block">/* Wait for last operation to be completed */</comment>
  <return>return<expr><operator>(</operator><call><name>FLASH_WaitForLastOperation</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>FLASH_TIMEOUT_VALUE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
 *  @brief   Peripheral Errors functions 
 *
@verbatim   
 ===============================================================================
                ##### Peripheral Errors functions #####
 ===============================================================================  
    [..]
    This subsection permits to get in run-time Errors of the FLASH peripheral.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Get the specific FLASH error flag.
  * @retval FLASH_ErrorCode: The returned value can be a combination of:
  *            @arg HAL_FLASH_ERROR_RD: FLASH Read Protection error flag (PCROP)
  *            @arg HAL_FLASH_ERROR_PGS: FLASH Programming Sequence error flag 
  *            @arg HAL_FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
  *            @arg HAL_FLASH_ERROR_PGA: FLASH Programming Alignment error flag
  *            @arg HAL_FLASH_ERROR_WRP: FLASH Write protected error flag
  *            @arg HAL_FLASH_ERROR_OPERATION: FLASH operation Error flag 
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_FLASH_GetError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
   <return>return <expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>  
  
<comment type="block" format="doxygen">/**
  * @}
  */</comment>    

<comment type="block" format="doxygen">/**
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>FLASH_WaitForLastOperation</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Clear Error Code */</comment>
  <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_FLASH_ERROR_NONE</name></expr>;</expr_stmt>
  
  <comment type="block">/* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */</comment>
  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_BSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition> 
  <block>{<block_content> 
    <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator><operator>||</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt> 
  </block_content>}</block></while>

  <comment type="block">/* Check FLASH End of Operation flag  */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_EOP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Clear FLASH End of Operation pending bit */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_EOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FLASH_SR_RDERR</name></expr></argument>)</argument_list></call></expr></cpp:if>  
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><operator>(</operator><name>FLASH_FLAG_OPERR</name> <operator>|</operator> <name>FLASH_FLAG_WRPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGAERR</name> <operator>|</operator> \
                           <name>FLASH_FLAG_PGPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGSERR</name> <operator>|</operator> <name>FLASH_FLAG_RDERR</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><operator>(</operator><name>FLASH_FLAG_OPERR</name> <operator>|</operator> <name>FLASH_FLAG_WRPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGAERR</name> <operator>|</operator> \
                           <name>FLASH_FLAG_PGPERR</name> <operator>|</operator> <name>FLASH_FLAG_PGSERR</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FLASH_SR_RDERR */</comment>
  <block>{<block_content>
    <comment type="block">/*Save the error code*/</comment>
    <expr_stmt><expr><call><name>FLASH_SetErrorCode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If there is no error flag set */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
  
</block_content>}</block></function>  

<comment type="block" format="doxygen">/**
  * @brief  Program a double word (64-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         2.7V to 3.6V and Vpp in the range 7V to 9V.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FLASH_Program_DoubleWord</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_ADDRESS</name><argument_list>(<argument><expr><name>Address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If the previous operation is completed, proceed to program the new data */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_PSIZE_DOUBLE_WORD</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_PG</name></expr>;</expr_stmt>

  <comment type="block">/* Program the double-word */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name><operator>*</operator><operator>)</operator><name>Address</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>Data</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>Address</name><operator>+</operator><literal type="number">4</literal><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>Data</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Program word (32-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         2.7V to 3.6V.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FLASH_Program_Word</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_ADDRESS</name><argument_list>(<argument><expr><name>Address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If the previous operation is completed, proceed to program the new data */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_PSIZE_WORD</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_PG</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name><operator>*</operator><operator>)</operator><name>Address</name> <operator>=</operator> <name>Data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Program a half-word (16-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         2.1V to 3.6V.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FLASH_Program_HalfWord</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_ADDRESS</name><argument_list>(<argument><expr><name>Address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If the previous operation is completed, proceed to program the new data */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_PSIZE_HALF_WORD</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_PG</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name><operator>*</operator><operator>)</operator><name>Address</name> <operator>=</operator> <name>Data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Program byte (8-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         1.8V to 3.6V.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FLASH_Program_Byte</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Address</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FLASH_ADDRESS</name><argument_list>(<argument><expr><name>Address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If the previous operation is completed, proceed to program the new data */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>FLASH_CR_PSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_PSIZE_BYTE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>FLASH</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>FLASH_CR_PG</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name><operator>*</operator><operator>)</operator><name>Address</name> <operator>=</operator> <name>Data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FLASH_SetErrorCode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_WRPERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
   <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_FLASH_ERROR_WRP</name></expr>;</expr_stmt>
   
   <comment type="block">/* Clear FLASH write protection error pending bit */</comment>
   <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_WRPERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_PGAERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
   <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_FLASH_ERROR_PGA</name></expr>;</expr_stmt>
   
   <comment type="block">/* Clear FLASH Programming alignment error pending bit */</comment>
   <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_PGAERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_PGPERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_FLASH_ERROR_PGP</name></expr>;</expr_stmt>
    
    <comment type="block">/* Clear FLASH Programming parallelism error pending bit */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_PGPERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_PGSERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_FLASH_ERROR_PGS</name></expr>;</expr_stmt>
    
    <comment type="block">/* Clear FLASH Programming sequence error pending bit */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_PGSERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FLASH_SR_RDERR</name></expr></argument>)</argument_list></call></expr></cpp:if> 
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_RDERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_FLASH_ERROR_RD</name></expr>;</expr_stmt>
    
    <comment type="block">/* Clear FLASH Proprietary readout protection error pending bit */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_RDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FLASH_SR_RDERR */</comment>  
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_FLASH_GET_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_OPERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>pFlash</name><operator>.</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_FLASH_ERROR_OPERATION</name></expr>;</expr_stmt>
    
    <comment type="block">/* Clear FLASH Operation error pending bit */</comment>
    <expr_stmt><expr><call><name>__HAL_FLASH_CLEAR_FLAG</name><argument_list>(<argument><expr><name>FLASH_FLAG_OPERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_FLASH_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
