<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_sdram.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_sdram.c
  * @author  MCD Application Team
  * @brief   SDRAM HAL module driver.
  *          This file provides a generic firmware to drive SDRAM memories mounted 
  *          as external device.
  *         
  @verbatim
  ==============================================================================
                       ##### How to use this driver #####
  ============================================================================== 
  [..]
    This driver is a generic layered driver which contains a set of APIs used to 
    control SDRAM memories. It uses the FMC layer functions to interface 
    with SDRAM devices.  
    The following sequence should be followed to configure the FMC to interface
    with SDRAM memories: 
      
   (#) Declare a SDRAM_HandleTypeDef handle structure, for example:
          SDRAM_HandleTypeDef  hdsram 
          
       (++) Fill the SDRAM_HandleTypeDef handle "Init" field with the allowed 
            values of the structure member.
            
       (++) Fill the SDRAM_HandleTypeDef handle "Instance" field with a predefined 
            base register instance for NOR or SDRAM device 
             
   (#) Declare a FMC_SDRAM_TimingTypeDef structure; for example:
          FMC_SDRAM_TimingTypeDef  Timing;
      and fill its fields with the allowed values of the structure member.
      
   (#) Initialize the SDRAM Controller by calling the function HAL_SDRAM_Init(). This function
       performs the following sequence:
          
       (##) MSP hardware layer configuration using the function HAL_SDRAM_MspInit()
       (##) Control register configuration using the FMC SDRAM interface function 
            FMC_SDRAM_Init()
       (##) Timing register configuration using the FMC SDRAM interface function 
            FMC_SDRAM_Timing_Init()
       (##) Program the SDRAM external device by applying its initialization sequence
            according to the device plugged in your hardware. This step is mandatory
            for accessing the SDRAM device.   

   (#) At this stage you can perform read/write accesses from/to the memory connected 
       to the SDRAM Bank. You can perform either polling or DMA transfer using the
       following APIs:
       (++) HAL_SDRAM_Read()/HAL_SDRAM_Write() for polling read/write access
       (++) HAL_SDRAM_Read_DMA()/HAL_SDRAM_Write_DMA() for DMA read/write transfer
       
   (#) You can also control the SDRAM device by calling the control APIs HAL_SDRAM_WriteOperation_Enable()/
       HAL_SDRAM_WriteOperation_Disable() to respectively enable/disable the SDRAM write operation or 
       the function HAL_SDRAM_SendCommand() to send a specified command to the SDRAM
       device. The command to be sent must be configured with the FMC_SDRAM_CommandTypeDef 
       structure.   
       
   (#) You can continuously monitor the SDRAM device HAL state by calling the function
       HAL_SDRAM_GetState()

   *** Callback registration ***
    =============================================
    [..]
      The compilation define  USE_HAL_SDRAM_REGISTER_CALLBACKS when set to 1
      allows the user to configure dynamically the driver callbacks.

      Use Functions @ref HAL_SDRAM_RegisterCallback() to register a user callback,
      it allows to register following callbacks:
        (+) MspInitCallback    : SDRAM MspInit.
        (+) MspDeInitCallback  : SDRAM MspDeInit.
      This function takes as parameters the HAL peripheral handle, the Callback ID
      and a pointer to the user callback function.

      Use function @ref HAL_SDRAM_UnRegisterCallback() to reset a callback to the default
      weak (surcharged) function. It allows to reset following callbacks:
        (+) MspInitCallback    : SDRAM MspInit.
        (+) MspDeInitCallback  : SDRAM MspDeInit.
      This function) takes as parameters the HAL peripheral handle and the Callback ID.

      By default, after the @ref HAL_SDRAM_Init and if the state is HAL_SDRAM_STATE_RESET
      all callbacks are reset to the corresponding legacy weak (surcharged) functions.
      Exception done for MspInit and MspDeInit callbacks that are respectively
      reset to the legacy weak (surcharged) functions in the @ref HAL_SDRAM_Init
      and @ref  HAL_SDRAM_DeInit only when these callbacks are null (not registered beforehand).
      If not, MspInit or MspDeInit are not null, the @ref HAL_SDRAM_Init and @ref HAL_SDRAM_DeInit
      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

      Callbacks can be registered/unregistered in READY state only.
      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
      during the Init/DeInit.
      In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_SDRAM_RegisterCallback before calling @ref HAL_SDRAM_DeInit
      or @ref HAL_SDRAM_Init function.

      When The compilation define USE_HAL_SDRAM_REGISTER_CALLBACKS is set to 0 or
      not defined, the callback registering feature is not available
      and weak (surcharged) callbacks are used.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SDRAM SDRAM
  * @brief SDRAM driver modules
  * @{
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_SDRAM_MODULE_ENABLED</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>    
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>
<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup SDRAM_Exported_Functions SDRAM Exported Functions
  * @{
  */</comment>
  
<comment type="block" format="doxygen">/** @defgroup SDRAM_Exported_Functions_Group1 Initialization and de-initialization functions 
  * @brief    Initialization and Configuration functions 
  *
  @verbatim    
  ==============================================================================
           ##### SDRAM Initialization and de_initialization functions #####
  ==============================================================================
  [..]  
    This section provides functions allowing to initialize/de-initialize
    the SDRAM memory
  
@endverbatim
  * @{
  */</comment>
    
<comment type="block" format="doxygen">/**
  * @brief  Performs the SDRAM device initialization sequence.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure 
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Init</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>FMC_SDRAM_TimingTypeDef</name> <modifier>*</modifier></type><name>Timing</name></decl></parameter>)</parameter_list>
<block>{<block_content>   
  <comment type="block">/* Check the SDRAM handle parameter */</comment>
  <if_stmt><if>if<condition>(<expr><name>hsdram</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>  
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SDRAM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>RefreshErrorCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_RefreshErrorCallback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>DmaXferCpltCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_DMA_XferCpltCallback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>DmaXferErrorCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_DMA_XferErrorCallback</name></expr>;</expr_stmt>

    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hsdram</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Initialize the low level hardware (MSP) */</comment>
    <expr_stmt><expr><call><name>HAL_SDRAM_MspInit</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Initialize the SDRAM controller state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Initialize SDRAM control Interface */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_Init</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hsdram</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Initialize SDRAM timing Interface */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_Timing_Init</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Timing</name></expr></argument>, <argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>SDBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  
  <comment type="block">/* Update the SDRAM controller state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_READY</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Perform the SDRAM device initialization sequence.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_DeInit</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SDRAM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>hsdram</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Initialize the low level hardware (MSP) */</comment>
  <expr_stmt><expr><call><name>HAL_SDRAM_MspDeInit</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Configure the SDRAM registers with their reset values */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_DeInit</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>SDBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the SDRAM controller state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  SDRAM MSP Init.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SDRAM_MspInit</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  SDRAM MSP DeInit.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SDRAM_MspDeInit</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspDeInit could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles SDRAM refresh error interrupt request.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
*/</comment>
<function><type><name>void</name></type> <name>HAL_SDRAM_IRQHandler</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check SDRAM interrupt Rising edge flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__FMC_SDRAM_GET_FLAG</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>FMC_SDRAM_FLAG_REFRESH_IT</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* SDRAM refresh error interrupt callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SDRAM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hsdram</name><operator>-&gt;</operator><name>RefreshErrorCallback</name></name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SDRAM_RefreshErrorCallback</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Clear SDRAM refresh error interrupt pending bit */</comment>
    <expr_stmt><expr><call><name>__FMC_SDRAM_CLEAR_FLAG</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>FMC_SDRAM_FLAG_REFRESH_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  SDRAM Refresh error callback.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module. 
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SDRAM_RefreshErrorCallback</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA transfer complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SDRAM_DMA_XferCpltCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA transfer complete error callback.
  * @param  hdma DMA handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SDRAM_DMA_XferErrorCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
   */</comment> 
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SDRAM_Exported_Functions_Group2 Input and Output functions 
  * @brief    Input Output and memory control functions 
  *
  @verbatim    
  ==============================================================================
                    ##### SDRAM Input and Output functions #####
  ==============================================================================
  [..]  
    This section provides functions allowing to use and control the SDRAM memory
  
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Reads 8-bit data buffer from the SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer  
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Read_8b</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pDstBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint8_t</name> <modifier>*</modifier></type><name>pSdramAddress</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pAddress</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>  
  
  <comment type="block">/* Read data from source */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>BufferSize</name> <operator>!=</operator> <literal type="number">0U</literal></expr>;</condition> <incr><expr><name>BufferSize</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDstBuffer</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pSdramAddress</name></expr>;</expr_stmt>  
    <expr_stmt><expr><name>pDstBuffer</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSdramAddress</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return> 
</block_content>}</block></function>
 
<comment type="block" format="doxygen">/**
  * @brief  Writes 8-bit data buffer to SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write  
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Write_8b</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pSrcBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint8_t</name> <modifier>*</modifier></type><name>pSdramAddress</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pAddress</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Write data to memory */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>BufferSize</name> <operator>!=</operator> <literal type="number">0U</literal></expr>;</condition> <incr><expr><name>BufferSize</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pSdramAddress</name> <operator>=</operator> <operator>*</operator><name>pSrcBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrcBuffer</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSdramAddress</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>   
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Reads 16-bit data buffer from the SDRAM memory. 
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer  
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Read_16b</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pDstBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint16_t</name> <modifier>*</modifier></type><name>pSdramAddress</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pAddress</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>  
  
  <comment type="block">/* Read data from source */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>BufferSize</name> <operator>!=</operator> <literal type="number">0U</literal></expr>;</condition> <incr><expr><name>BufferSize</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDstBuffer</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pSdramAddress</name></expr>;</expr_stmt>  
    <expr_stmt><expr><name>pDstBuffer</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSdramAddress</name><operator>++</operator></expr>;</expr_stmt>               
  </block_content>}</block></for>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       
  
  <return>return <expr><name>HAL_OK</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Writes 16-bit data buffer to SDRAM memory. 
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write  
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Write_16b</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pSrcBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint16_t</name> <modifier>*</modifier></type><name>pSdramAddress</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pAddress</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Write data to memory */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>BufferSize</name> <operator>!=</operator> <literal type="number">0U</literal></expr>;</condition> <incr><expr><name>BufferSize</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pSdramAddress</name> <operator>=</operator> <operator>*</operator><name>pSrcBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrcBuffer</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSdramAddress</name><operator>++</operator></expr>;</expr_stmt>            
  </block_content>}</block></for>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>   
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Reads 32-bit data buffer from the SDRAM memory. 
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer  
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Read_32b</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pDstBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name> <modifier>*</modifier></type><name>pSdramAddress</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>pAddress</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>  
  
  <comment type="block">/* Read data from source */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>BufferSize</name> <operator>!=</operator> <literal type="number">0U</literal></expr>;</condition> <incr><expr><name>BufferSize</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDstBuffer</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator><name>pSdramAddress</name></expr>;</expr_stmt>  
    <expr_stmt><expr><name>pDstBuffer</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSdramAddress</name><operator>++</operator></expr>;</expr_stmt>               
  </block_content>}</block></for>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       
  
  <return>return <expr><name>HAL_OK</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Writes 32-bit data buffer to SDRAM memory. 
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write  
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Write_32b</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pSrcBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name> <modifier>*</modifier></type><name>pSdramAddress</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>pAddress</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Write data to memory */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>BufferSize</name> <operator>!=</operator> <literal type="number">0U</literal></expr>;</condition> <incr><expr><name>BufferSize</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator><name>pSdramAddress</name> <operator>=</operator> <operator>*</operator><name>pSrcBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrcBuffer</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSdramAddress</name><operator>++</operator></expr>;</expr_stmt>          
  </block_content>}</block></for>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Reads a Words data from the SDRAM memory using DMA transfer. 
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer  
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Read_DMA</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pDstBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
    
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>  
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>  
  
  <comment type="block">/* Configure DMA user callbacks */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name>  <operator>=</operator> <name>HAL_SDRAM_DMA_XferCpltCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_DMA_XferErrorCallback</name></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the DMA Stream */</comment>
  <expr_stmt><expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>hdma</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pAddress</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pDstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BufferSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
  
  <return>return <expr><name>HAL_OK</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Writes a Words data buffer to SDRAM memory using DMA transfer.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write  
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_Write_DMA</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pSrcBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BufferSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the SDRAM controller state */</comment>  
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp</name> <operator>==</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return  <expr><name>HAL_ERROR</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>  
  
  <comment type="block">/* Configure DMA user callbacks */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name>  <operator>=</operator> <name>HAL_SDRAM_DMA_XferCpltCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_DMA_XferErrorCallback</name></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the DMA Stream */</comment>
  <expr_stmt><expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>hdma</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pSrcBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pAddress</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BufferSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SDRAM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User SDRAM Callback
  *         To be used instead of the weak (surcharged) predefined callback
  * @param hsdram : SDRAM handle
  * @param CallbackId : ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_SDRAM_MSP_INIT_CB_ID       SDRAM MspInit callback ID
  *          @arg @ref HAL_SDRAM_MSP_DEINIT_CB_ID     SDRAM MspDeInit callback ID
  *          @arg @ref HAL_SDRAM_REFRESH_ERR_CB_ID    SDRAM Refresh Error callback ID
  * @param pCallback : pointer to the Callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_RegisterCallback</name> <parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>HAL_SDRAM_CallbackIDTypeDef</name></type> <name>CallbackId</name></decl></parameter>, <parameter><decl><type><name>pSDRAM_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_SDRAM_StateTypeDef</name></type> <name>state</name></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_SDRAM_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_SDRAM_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_REFRESH_ERR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>RefreshErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_SDRAM_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* update return status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a User SDRAM Callback
  *         SDRAM Callback is redirected to the weak (surcharged) predefined callback
  * @param hsdram : SDRAM handle
  * @param CallbackId : ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_SDRAM_MSP_INIT_CB_ID       SDRAM MspInit callback ID
  *          @arg @ref HAL_SDRAM_MSP_DEINIT_CB_ID     SDRAM MspDeInit callback ID
  *          @arg @ref HAL_SDRAM_REFRESH_ERR_CB_ID    SDRAM Refresh Error callback ID
  *          @arg @ref HAL_SDRAM_DMA_XFER_CPLT_CB_ID  SDRAM DMA Xfer Complete callback ID
  *          @arg @ref HAL_SDRAM_DMA_XFER_ERR_CB_ID   SDRAM DMA Xfer Error callback ID
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_UnRegisterCallback</name> <parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>HAL_SDRAM_CallbackIDTypeDef</name></type> <name>CallbackId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_SDRAM_StateTypeDef</name></type> <name>state</name></decl>;</decl_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_SDRAM_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_SDRAM_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_REFRESH_ERR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>RefreshErrorCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_RefreshErrorCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_DMA_XFER_CPLT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>DmaXferCpltCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_DMA_XferCpltCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_DMA_XFER_ERR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>DmaXferErrorCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_DMA_XferErrorCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_SDRAM_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SDRAM_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* update return status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Register a User SDRAM Callback for DMA transfers
  *         To be used instead of the weak (surcharged) predefined callback
  * @param hsdram : SDRAM handle
  * @param CallbackId : ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_SDRAM_DMA_XFER_CPLT_CB_ID  SDRAM DMA Xfer Complete callback ID
  *          @arg @ref HAL_SDRAM_DMA_XFER_ERR_CB_ID   SDRAM DMA Xfer Error callback ID
  * @param pCallback : pointer to the Callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_RegisterDmaCallback</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>HAL_SDRAM_CallbackIDTypeDef</name></type> <name>CallbackId</name></decl></parameter>, <parameter><decl><type><name>pSDRAM_DmaCallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_SDRAM_StateTypeDef</name></type> <name>state</name></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_SDRAM_STATE_READY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_SDRAM_DMA_XFER_CPLT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>DmaXferCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_SDRAM_DMA_XFER_ERR_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>DmaXferErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* update return status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsdram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<comment type="block" format="doxygen">/** @defgroup SDRAM_Exported_Functions_Group3 Control functions 
 *  @brief   management functions 
 *
@verbatim   
  ==============================================================================
                         ##### SDRAM Control functions #####
  ==============================================================================  
  [..]
    This subsection provides a set of functions allowing to control dynamically
    the SDRAM interface.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Enables dynamically SDRAM write protection.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_WriteProtection_Enable</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
  <comment type="block">/* Check the SDRAM controller state */</comment> 
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Enable write protection */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_WriteProtection_Enable</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>SDBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_WRITE_PROTECTED</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables dynamically SDRAM write protection.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_WriteProtection_Disable</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Disable write protection */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_WriteProtection_Disable</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>SDBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_READY</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sends Command to the SDRAM bank.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>  
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_SendCommand</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>FMC_SDRAM_CommandTypeDef</name> <modifier>*</modifier></type><name>Command</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Send SDRAM command */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_SendCommand</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Command</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>Command</name><operator>-&gt;</operator><name>CommandMode</name></name> <operator>==</operator> <name>FMC_SDRAM_CMD_PALL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_PRECHARGED</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_READY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Programs the SDRAM Memory Refresh rate.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate The SDRAM refresh rate value       
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_ProgramRefreshRate</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>RefreshRate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt> 
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Program the refresh rate */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_ProgramRefreshRate</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument> ,<argument><expr><name>RefreshRate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_READY</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>   
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sets the Number of consecutive SDRAM Memory auto Refresh commands.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.  
  * @param  AutoRefreshNumber The SDRAM auto Refresh number       
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SDRAM_SetAutoRefreshNumber</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>AutoRefreshNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the SDRAM controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt> 
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Set the Auto-Refresh number */</comment>
  <expr_stmt><expr><call><name>FMC_SDRAM_SetAutoRefreshNumber</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument> ,<argument><expr><name>AutoRefreshNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the SDRAM state */</comment>
  <expr_stmt><expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SDRAM_STATE_READY</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Returns the SDRAM memory current mode.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval The SDRAM memory mode.        
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_SDRAM_GetModeStatus</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return the SDRAM memory current mode */</comment>
  <return>return<expr><operator>(</operator><call><name>FMC_SDRAM_GetModeStatus</name><argument_list>(<argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hsdram</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>SDBank</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<comment type="block" format="doxygen">/** @defgroup SDRAM_Exported_Functions_Group4 State functions 
 *  @brief   Peripheral State functions 
 *
@verbatim   
  ==============================================================================
                      ##### SDRAM State functions #####
  ==============================================================================  
  [..]
    This subsection permits to get in run-time the status of the SDRAM controller 
    and the data flow.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Returns the SDRAM state.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_SDRAM_StateTypeDef</name></type> <name>HAL_SDRAM_GetState</name><parameter_list>(<parameter><decl><type><name>SDRAM_HandleTypeDef</name> <modifier>*</modifier></type><name>hsdram</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hsdram</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>    

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_SDRAM_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
