<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg_spi_flash/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_nand.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_nand.c
  * @author  MCD Application Team
  * @brief   NAND HAL module driver.
  *          This file provides a generic firmware to drive NAND memories mounted 
  *          as external device.
  *         
  @verbatim
  ==============================================================================
                         ##### How to use this driver #####
  ==============================================================================    
    [..]
      This driver is a generic layered driver which contains a set of APIs used to 
      control NAND flash memories. It uses the FMC/FSMC layer functions to interface 
      with NAND devices. This driver is used as follows:
    
      (+) NAND flash memory configuration sequence using the function HAL_NAND_Init() 
          with control and timing parameters for both common and attribute spaces.
            
      (+) Read NAND flash memory maker and device IDs using the function
          HAL_NAND_Read_ID(). The read information is stored in the NAND_ID_TypeDef 
          structure declared by the function caller. 
        
      (+) Access NAND flash memory by read/write operations using the functions
          HAL_NAND_Read_Page_8b()/HAL_NAND_Read_SpareArea_8b(), 
          HAL_NAND_Write_Page_8b()/HAL_NAND_Write_SpareArea_8b(),
          HAL_NAND_Read_Page_16b()/HAL_NAND_Read_SpareArea_16b(), 
          HAL_NAND_Write_Page_16b()/HAL_NAND_Write_SpareArea_16b()
          to read/write page(s)/spare area(s). These functions use specific device 
          information (Block, page size..) predefined by the user in the HAL_NAND_Info_TypeDef 
          structure. The read/write address information is contained by the Nand_Address_Typedef
          structure passed as parameter.
        
      (+) Perform NAND flash Reset chip operation using the function HAL_NAND_Reset().
        
      (+) Perform NAND flash erase block operation using the function HAL_NAND_Erase_Block().
          The erase block address information is contained in the Nand_Address_Typedef 
          structure passed as parameter.
    
      (+) Read the NAND flash status operation using the function HAL_NAND_Read_Status().
        
      (+) You can also control the NAND device by calling the control APIs HAL_NAND_ECC_Enable()/
          HAL_NAND_ECC_Disable() to respectively enable/disable the ECC code correction
          feature or the function HAL_NAND_GetECC() to get the ECC correction code. 
       
      (+) You can monitor the NAND device HAL state by calling the function
          HAL_NAND_GetState()  

    [..]
      (@) This driver is a set of generic APIs which handle standard NAND flash operations.
          If a NAND flash device contains different operations and/or implementations, 
          it should be implemented separately.

    *** Callback registration ***
    =============================================
    [..]
      The compilation define  USE_HAL_NAND_REGISTER_CALLBACKS when set to 1
      allows the user to configure dynamically the driver callbacks.

      Use Functions @ref HAL_NAND_RegisterCallback() to register a user callback,
      it allows to register following callbacks:
        (+) MspInitCallback    : NAND MspInit.
        (+) MspDeInitCallback  : NAND MspDeInit.
      This function takes as parameters the HAL peripheral handle, the Callback ID
      and a pointer to the user callback function.

      Use function @ref HAL_NAND_UnRegisterCallback() to reset a callback to the default
      weak (surcharged) function. It allows to reset following callbacks:
        (+) MspInitCallback    : NAND MspInit.
        (+) MspDeInitCallback  : NAND MspDeInit.
      This function) takes as parameters the HAL peripheral handle and the Callback ID.

      By default, after the @ref HAL_NAND_Init and if the state is HAL_NAND_STATE_RESET
      all callbacks are reset to the corresponding legacy weak (surcharged) functions.
      Exception done for MspInit and MspDeInit callbacks that are respectively
      reset to the legacy weak (surcharged) functions in the @ref HAL_NAND_Init
      and @ref  HAL_NAND_DeInit only when these callbacks are null (not registered beforehand).
      If not, MspInit or MspDeInit are not null, the @ref HAL_NAND_Init and @ref HAL_NAND_DeInit
      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

      Callbacks can be registered/unregistered in READY state only.
      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
      during the Init/DeInit.
      In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_NAND_RegisterCallback before calling @ref HAL_NAND_DeInit
      or @ref HAL_NAND_Init function.

      When The compilation define USE_HAL_NAND_REGISTER_CALLBACKS is set to 0 or
      not defined, the callback registering feature is not available
      and weak (surcharged) callbacks are used.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_NAND_MODULE_ENABLED</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STM32F405xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F415xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F407xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F417xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F427xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F437xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F429xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F439xx</name></expr></argument>)</argument_list></call> <operator>||</operator>\
    <call><name>defined</name><argument_list>(<argument><expr><name>STM32F446xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F469xx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>STM32F479xx</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block" format="doxygen">/** @defgroup NAND NAND 
  * @brief NAND HAL module driver
  * @{
  */</comment>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup NAND_Private_Constants NAND Private Constants
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>    
<comment type="block" format="doxygen">/** @defgroup NAND_Private_Macros NAND Private Macros
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup NAND_Exported_Functions NAND Exported Functions
  * @{
  */</comment>
    
<comment type="block" format="doxygen">/** @defgroup NAND_Exported_Functions_Group1 Initialization and de-initialization functions 
  * @brief    Initialization and Configuration functions 
  *
  @verbatim    
  ==============================================================================
            ##### NAND Initialization and de-initialization functions #####
  ==============================================================================
  [..]  
    This section provides functions allowing to initialize/de-initialize
    the NAND memory
  
@endverbatim
  * @{
  */</comment>
    
<comment type="block" format="doxygen">/**
  * @brief  Perform NAND memory Initialization sequence
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  ComSpace_Timing pointer to Common space timing structure
  * @param  AttSpace_Timing pointer to Attribute space timing structure
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type>  <name>HAL_NAND_Init</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>FMC_NAND_PCC_TimingTypeDef</name> <modifier>*</modifier></type><name>ComSpace_Timing</name></decl></parameter>, <parameter><decl><type><name>FMC_NAND_PCC_TimingTypeDef</name> <modifier>*</modifier></type><name>AttSpace_Timing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the NAND handle state */</comment>
  <if_stmt><if>if<condition>(<expr><name>hnand</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_NAND_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_NAND_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>ItCallback</name></name> <operator>=</operator> <name>HAL_NAND_ITCallback</name></expr>;</expr_stmt>

    <comment type="block">/* Init the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hnand</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Initialize the low level hardware (MSP) */</comment>
    <expr_stmt><expr><call><name>HAL_NAND_MspInit</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize NAND control Interface */</comment>
  <expr_stmt><expr><call><name>FMC_NAND_Init</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Init</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Initialize NAND common space timing Interface */</comment>  
  <expr_stmt><expr><call><name>FMC_NAND_CommonSpace_Timing_Init</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>ComSpace_Timing</name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Initialize NAND attribute space timing Interface */</comment>  
  <expr_stmt><expr><call><name>FMC_NAND_AttributeSpace_Timing_Init</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>AttSpace_Timing</name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Enable the NAND device */</comment>
  <expr_stmt><expr><call><name>__FMC_NAND_ENABLE</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Perform NAND memory De-Initialization sequence
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_DeInit</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>  
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_NAND_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_NAND_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>hnand</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Initialize the low level hardware (MSP) */</comment>
  <expr_stmt><expr><call><name>HAL_NAND_MspDeInit</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Configure the NAND registers with their reset values */</comment>
  <expr_stmt><expr><call><name>FMC_NAND_DeInit</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  NAND MSP Init
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_NAND_MspInit</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_NAND_MspInit could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  NAND MSP DeInit
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_NAND_MspDeInit</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_NAND_MspDeInit could be implemented in the user file
   */</comment> 
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  This function handles NAND device interrupt request.
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval HAL status
*/</comment>
<function><type><name>void</name></type> <name>HAL_NAND_IRQHandler</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check NAND interrupt Rising edge flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__FMC_NAND_GET_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_RISING_EDGE</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* NAND interrupt callback*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_NAND_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hnand</name><operator>-&gt;</operator><name>ItCallback</name></name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_NAND_ITCallback</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Clear NAND interrupt Rising edge pending bit */</comment>
    <expr_stmt><expr><call><name>__FMC_NAND_CLEAR_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_RISING_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Check NAND interrupt Level flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__FMC_NAND_GET_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_LEVEL</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* NAND interrupt callback*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_NAND_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hnand</name><operator>-&gt;</operator><name>ItCallback</name></name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_NAND_ITCallback</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Clear NAND interrupt Level pending bit */</comment>
    <expr_stmt><expr><call><name>__FMC_NAND_CLEAR_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_LEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check NAND interrupt Falling edge flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__FMC_NAND_GET_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_FALLING_EDGE</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* NAND interrupt callback*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_NAND_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hnand</name><operator>-&gt;</operator><name>ItCallback</name></name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_NAND_ITCallback</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Clear NAND interrupt Falling edge pending bit */</comment>
    <expr_stmt><expr><call><name>__FMC_NAND_CLEAR_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_FALLING_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Check NAND interrupt FIFO empty flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__FMC_NAND_GET_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_FEMPT</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* NAND interrupt callback*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_NAND_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hnand</name><operator>-&gt;</operator><name>ItCallback</name></name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_NAND_ITCallback</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Clear NAND interrupt FIFO empty pending bit */</comment>
    <expr_stmt><expr><call><name>__FMC_NAND_CLEAR_FLAG</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>FMC_FLAG_FEMPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  NAND interrupt feature callback
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_NAND_ITCallback</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_NAND_ITCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>
 
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<comment type="block" format="doxygen">/** @defgroup NAND_Exported_Functions_Group2 Input and Output functions 
  * @brief    Input Output and memory control functions 
  *
  @verbatim    
  ==============================================================================
                    ##### NAND Input and Output functions #####
  ==============================================================================
  [..]  
    This section provides functions allowing to use and control the NAND 
    memory
  
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Read the NAND memory electronic signature
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pNAND_ID NAND ID structure
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Read_ID</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_IDTypeDef</name> <modifier>*</modifier></type><name>pNAND_ID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>data</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>data1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Send Read ID command sequence */</comment>   
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator>  <operator>=</operator> <name>NAND_CMD_READID</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>

  <comment type="block">/* Read the electronic signature from NAND flash */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FSMC_PCR2_PWID</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemoryDataWidth</name></name> <operator>==</operator> <name>FSMC_NAND_PCC_MEM_BUS_WIDTH_8</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* FMC_PCR2_PWID is defined */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemoryDataWidth</name></name> <operator>==</operator> <name>FMC_NAND_PCC_MEM_BUS_WIDTH_8</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name></expr>;</expr_stmt>

    <comment type="block">/* Return the data read */</comment>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Maker_Id</name></name>   <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Device_Id</name></name>  <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Third_Id</name></name>   <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Fourth_Id</name></name>  <operator>=</operator> <call><name>ADDR_4TH_CYCLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>data1</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name> <operator>+</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Return the data read */</comment>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Maker_Id</name></name>   <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Device_Id</name></name>  <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Third_Id</name></name>   <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>data1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNAND_ID</name><operator>-&gt;</operator><name>Fourth_Id</name></name>  <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>data1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt></block_content></block></if></if_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  NAND memory reset
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Reset</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>  
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt> 
  
  <comment type="block">/* Send NAND reset command */</comment>  
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>


  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>

</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the device: Enter the physical parameters of the device
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pDeviceConfig  pointer to NAND_DeviceConfigTypeDef structure
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type>  <name>HAL_NAND_ConfigDevice</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_DeviceConfigTypeDef</name> <modifier>*</modifier></type><name>pDeviceConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name>           <operator>=</operator> <name><name>pDeviceConfig</name><operator>-&gt;</operator><name>PageSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name>      <operator>=</operator> <name><name>pDeviceConfig</name><operator>-&gt;</operator><name>SpareAreaSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name>          <operator>=</operator> <name><name>pDeviceConfig</name><operator>-&gt;</operator><name>BlockSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name>           <operator>=</operator> <name><name>pDeviceConfig</name><operator>-&gt;</operator><name>BlockNbr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PlaneSize</name></name>          <operator>=</operator> <name><name>pDeviceConfig</name><operator>-&gt;</operator><name>PlaneSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PlaneNbr</name></name>           <operator>=</operator> <name><name>pDeviceConfig</name><operator>-&gt;</operator><name>PlaneNbr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>ExtraCommandEnable</name></name> <operator>=</operator> <name><name>pDeviceConfig</name><operator>-&gt;</operator><name>ExtraCommandEnable</name></name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>
  
<comment type="block" format="doxygen">/**
  * @brief  Read Page(s) from NAND memory block (8-bits addressing)
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer  pointer to destination read buffer
  * @param  NumPageToRead  number of pages to read from block 
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Read_Page_8b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumPageToRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>   
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name>  <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numPagesRead</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* NAND raw address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Page(s) read loop */</comment>  
  <while>while<condition>(<expr><operator>(</operator><name>NumPageToRead</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>*</operator> <name>numPagesRead</name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Send read page command sequence */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>
   
    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator>  <operator>=</operator> <name>NAND_CMD_AREA_TRUE1</name></expr>;</expr_stmt>
      
    <comment type="block">/* Check if an extra command is needed for reading pages  */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>ExtraCommandEnable</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Read status until NAND is ready */</comment>
      <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
      
      <comment type="block">/* Go back to read mode */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x00</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__DSB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Get Data into Buffer */</comment>    
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <comment type="block">/* Increment read pages number */</comment>
    <expr_stmt><expr><name>numPagesRead</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement pages to read */</comment>
    <expr_stmt><expr><name>NumPageToRead</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Read Page(s) from NAND memory block (16-bits addressing)
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer  pointer to destination read buffer. pBuffer should be 16bits aligned
  * @param  NumPageToRead  number of pages to read from block 
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Read_Page_16b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumPageToRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>   
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name>  <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numPagesRead</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* NAND raw address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Page(s) read loop */</comment>  
  <while>while<condition>(<expr><operator>(</operator><name>NumPageToRead</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>*</operator> <name>numPagesRead</name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Send read page command sequence */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>  
    <expr_stmt><expr><call><name>__DSB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator>  <operator>=</operator> <name>NAND_CMD_AREA_TRUE1</name></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>ExtraCommandEnable</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Read status until NAND is ready */</comment>
      <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
      
      <comment type="block">/* Go back to read mode */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x00</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Get Data into Buffer */</comment>    
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <comment type="block">/* Increment read pages number */</comment>
    <expr_stmt><expr><name>numPagesRead</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement pages to read */</comment>
    <expr_stmt><expr><name>NumPageToRead</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Write Page(s) to NAND memory block (8-bits addressing)
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer  pointer to source buffer to write  
  * @param  NumPageToWrite   number of pages to write to block 
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Write_Page_8b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumPageToWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numPagesWritten</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* NAND raw address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Page(s) write loop */</comment>
  <while>while<condition>(<expr><operator>(</operator><name>NumPageToWrite</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>*</operator> <name>numPagesWritten</name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Send write page command sequence */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE0</name></expr>;</expr_stmt>

    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__DSB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__DSB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  

    <comment type="block">/* Write data to memory */</comment>
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
   
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE_TRUE1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Read status until NAND is ready */</comment>
    <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
 
    <comment type="block">/* Increment written pages number */</comment>
    <expr_stmt><expr><name>numPagesWritten</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement pages to write */</comment>
    <expr_stmt><expr><name>NumPageToWrite</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Write Page(s) to NAND memory block (16-bits addressing)
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer  pointer to source buffer to write. pBuffer should be 16bits aligned
  * @param  NumPageToWrite   number of pages to write to block 
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Write_Page_16b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumPageToWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numPagesWritten</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* NAND raw address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Page(s) write loop */</comment>
  <while>while<condition>(<expr><operator>(</operator><name>NumPageToWrite</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>*</operator> <name>numPagesWritten</name><operator>)</operator></expr>;</expr_stmt>
 
    <comment type="block">/* Send write page command sequence */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__DSB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE0</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__DSB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* Write data to memory */</comment>
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
   
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE_TRUE1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Read status until NAND is ready */</comment>
    <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
      </block_content>}</block></if></if_stmt> 
    </block_content>}</block></while>   
 
    <comment type="block">/* Increment written pages number */</comment>
    <expr_stmt><expr><name>numPagesWritten</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement pages to write */</comment>
    <expr_stmt><expr><name>NumPageToWrite</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Update the NAND controller state */</comment> 
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Read Spare area(s) from NAND memory 
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer pointer to source buffer to write  
  * @param  NumSpareAreaToRead Number of spare area to read  
  * @retval HAL status
*/</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Read_SpareArea_8b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumSpareAreaToRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numSpareAreaRead</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>columnaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* NAND raw address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Column in page address */</comment>
  <expr_stmt><expr><name>columnaddress</name> <operator>=</operator> <call><name>COLUMN_ADDRESS</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Spare area(s) read loop */</comment> 
  <while>while<condition>(<expr><operator>(</operator><name>NumSpareAreaToRead</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>     
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>*</operator> <name>numSpareAreaRead</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send read spare area command sequence */</comment>     
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_C</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <comment type="block">/* Send read spare area command sequence */</comment> 
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_TRUE1</name></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>ExtraCommandEnable</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Read status until NAND is ready */</comment>
      <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
      
      <comment type="block">/* Go back to read mode */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x00</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Get Data into Buffer */</comment>
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <comment type="block">/* Increment read spare areas number */</comment>
    <expr_stmt><expr><name>numSpareAreaRead</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement spare areas to read */</comment>
    <expr_stmt><expr><name>NumSpareAreaToRead</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Read Spare area(s) from NAND memory (16-bits addressing)
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer pointer to source buffer to write. pBuffer should be 16bits aligned.
  * @param  NumSpareAreaToRead Number of spare area to read  
  * @retval HAL status
*/</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Read_SpareArea_16b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumSpareAreaToRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numSpareAreaRead</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>columnaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* NAND raw address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Column in page address */</comment>
  <expr_stmt><expr><name>columnaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><call><name>COLUMN_ADDRESS</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2U</literal><operator>)</operator></expr>;</expr_stmt>
  
  <comment type="block">/* Spare area(s) read loop */</comment> 
  <while>while<condition>(<expr><operator>(</operator><name>NumSpareAreaToRead</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>*</operator> <name>numSpareAreaRead</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send read spare area command sequence */</comment>     
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_C</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <comment type="block">/* Send read spare area command sequence */</comment>     
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_TRUE1</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>ExtraCommandEnable</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Read status until NAND is ready */</comment>
      <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
      
      <comment type="block">/* Go back to read mode */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">0x00</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Get Data into Buffer */</comment>
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <comment type="block">/* Increment read spare areas number */</comment>
    <expr_stmt><expr><name>numSpareAreaRead</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement spare areas to read */</comment>
    <expr_stmt><expr><name>NumSpareAreaToRead</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     

  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Write Spare area(s) to NAND memory 
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer  pointer to source buffer to write  
  * @param  NumSpareAreaTowrite   number of spare areas to write to block
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Write_SpareArea_8b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumSpareAreaTowrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numSpareAreaWritten</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>columnaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the FMC_NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>  
  
  <comment type="block">/* Page address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  
  <comment type="block">/* Column in page address */</comment>
  <expr_stmt><expr><name>columnaddress</name> <operator>=</operator> <call><name>COLUMN_ADDRESS</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Spare area(s) write loop */</comment>
  <while>while<condition>(<expr><operator>(</operator><name>NumSpareAreaTowrite</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>*</operator> <name>numSpareAreaWritten</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send write Spare area command sequence */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_C</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE0</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <comment type="block">/* Send write Spare area command sequence */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE0</name></expr>;</expr_stmt>
    
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* Write data to memory */</comment>
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
   
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE_TRUE1</name></expr>;</expr_stmt>
    
    <comment type="block">/* Get tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Read status until NAND is ready */</comment>
    <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Increment written spare areas number */</comment>
    <expr_stmt><expr><name>numSpareAreaWritten</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement spare areas to write */</comment>
    <expr_stmt><expr><name>NumSpareAreaTowrite</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Write Spare area(s) to NAND memory (16-bits addressing)
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @param  pBuffer  pointer to source buffer to write. pBuffer should be 16bits aligned.  
  * @param  NumSpareAreaTowrite   number of spare areas to write to block
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Write_SpareArea_16b</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>NumSpareAreaTowrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>numSpareAreaWritten</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>nandaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>columnaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the FMC_NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>  
  
  <comment type="block">/* NAND raw address calculation */</comment>
  <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Column in page address */</comment>
  <expr_stmt><expr><name>columnaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><call><name>COLUMN_ADDRESS</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2U</literal><operator>)</operator></expr>;</expr_stmt>
  
  <comment type="block">/* Spare area(s) write loop */</comment>
  <while>while<condition>(<expr><operator>(</operator><name>NumSpareAreaTowrite</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nandaddress</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* update the buffer size */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>SpareAreaSize</name></name><operator>)</operator> <operator>*</operator> <name>numSpareAreaWritten</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Cards with page size &lt;= 512 bytes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PageSize</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">512U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send write Spare area command sequence */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_C</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE0</name></expr>;</expr_stmt>
    
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* (hnand-&gt;Config.PageSize) &gt; 512 */</comment>
    <block>{<block_content>
      <comment type="block">/* Send write Spare area command sequence */</comment>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_AREA_A</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE0</name></expr>;</expr_stmt>
    
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockNbr</name></name><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <literal type="number">65535U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <comment type="block">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</comment>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_1ST_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>COLUMN_2ND_CYCLE</name><argument_list>(<argument><expr><name>columnaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><name>nandaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* Write data to memory */</comment>
    <for>for<control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>pBuffer</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
   
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_WRITE_TRUE1</name></expr>;</expr_stmt>
   
    <comment type="block">/* Read status until NAND is ready */</comment>
    <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Increment written spare areas number */</comment>
    <expr_stmt><expr><name>numSpareAreaWritten</name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Decrement spare areas to write */</comment>
    <expr_stmt><expr><name>NumSpareAreaTowrite</name><operator>--</operator></expr>;</expr_stmt>
    
    <comment type="block">/* Increment the NAND address */</comment>
    <expr_stmt><expr><name>nandaddress</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nandaddress</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  NAND memory Block erase 
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  pAddress  pointer to NAND address structure
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_Erase_Block</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>  
  
  <comment type="block">/* Send Erase block command sequence */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_ERASE0</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_1ST_CYCLE</name><argument_list>(<argument><expr><call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_2ND_CYCLE</name><argument_list>(<argument><expr><call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>ADDR_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>ADDR_3RD_CYCLE</name><argument_list>(<argument><expr><call><name>ARRAY_ADDRESS</name><argument_list>(<argument><expr><name>pAddress</name></expr></argument>, <argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_ERASE1</name></expr>;</expr_stmt> 
  
  <comment type="block">/* Update the NAND controller state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Read status until NAND is ready */</comment>
  <while>while<condition>(<expr><call><name>HAL_NAND_Read_Status</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAND_READY</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>NAND_WRITE_TIMEOUT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return> 
    </block_content>}</block></if></if_stmt> 
  </block_content>}</block></while>    
 
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  NAND memory read status 
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval NAND status
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_NAND_Read_Status</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>data</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>deviceaddress</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Identify the device address */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name> <operator>==</operator> <name>FMC_NAND_BANK2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>deviceaddress</name> <operator>=</operator> <name>NAND_DEVICE2</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt> 

  <comment type="block">/* Send Read status operation command */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>deviceaddress</name> <operator>|</operator> <name>CMD_AREA</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>NAND_CMD_STATUS</name></expr>;</expr_stmt>
  
  <comment type="block">/* Read status register data */</comment>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>deviceaddress</name></expr>;</expr_stmt>

  <comment type="block">/* Return the status */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>data</name> <operator>&amp;</operator> <name>NAND_ERROR</name><operator>)</operator> <operator>==</operator> <name>NAND_ERROR</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>NAND_ERROR</name></expr>;</return>
  </block_content>}</block></if> 
  <if type="elseif">else if<condition>(<expr><operator>(</operator><name>data</name> <operator>&amp;</operator> <name>NAND_READY</name><operator>)</operator> <operator>==</operator> <name>NAND_READY</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>NAND_READY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>NAND_BUSY</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Increment the NAND memory address
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param pAddress pointer to NAND address structure
  * @retval The new status of the increment address operation. It can be:
  *           - NAND_VALID_ADDRESS: When the new address is valid address
  *           - NAND_INVALID_ADDRESS: When the new address is invalid address
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_NAND_Address_Inc</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>NAND_AddressTypeDef</name> <modifier>*</modifier></type><name>pAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>status</name> <init>= <expr><name>NAND_VALID_ADDRESS</name></expr></init></decl>;</decl_stmt>
 
  <comment type="block">/* Increment page address */</comment>
  <expr_stmt><expr><name><name>pAddress</name><operator>-&gt;</operator><name>Page</name></name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* Check NAND address is valid */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>pAddress</name><operator>-&gt;</operator><name>Page</name></name> <operator>==</operator> <name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>BlockSize</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>pAddress</name><operator>-&gt;</operator><name>Page</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAddress</name><operator>-&gt;</operator><name>Block</name></name><operator>++</operator></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>pAddress</name><operator>-&gt;</operator><name>Block</name></name> <operator>==</operator> <name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PlaneSize</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>pAddress</name><operator>-&gt;</operator><name>Block</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pAddress</name><operator>-&gt;</operator><name>Plane</name></name><operator>++</operator></expr>;</expr_stmt>

      <if_stmt><if>if<condition>(<expr><name><name>pAddress</name><operator>-&gt;</operator><name>Plane</name></name> <operator>==</operator> <operator>(</operator><name><name>hnand</name><operator>-&gt;</operator><name>Config</name><operator>.</operator><name>PlaneNbr</name></name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>NAND_INVALID_ADDRESS</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt> 
  
  <return>return <expr><operator>(</operator><name>status</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_NAND_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User NAND Callback
  *         To be used instead of the weak (surcharged) predefined callback
  * @param hnand : NAND handle
  * @param CallbackId : ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_NAND_MSP_INIT_CB_ID       NAND MspInit callback ID
  *          @arg @ref HAL_NAND_MSP_DEINIT_CB_ID     NAND MspDeInit callback ID
  *          @arg @ref HAL_NAND_IT_CB_ID             NAND IT callback ID
  * @param pCallback : pointer to the Callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_RegisterCallback</name> <parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>HAL_NAND_CallbackIDTypeDef</name></type> <name>CallbackId</name></decl></parameter>, <parameter><decl><type><name>pNAND_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_NAND_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_NAND_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_NAND_IT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>ItCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_NAND_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_NAND_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* update return status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a User NAND Callback
  *         NAND Callback is redirected to the weak (surcharged) predefined callback
  * @param hnand : NAND handle
  * @param CallbackId : ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_NAND_MSP_INIT_CB_ID       NAND MspInit callback ID
  *          @arg @ref HAL_NAND_MSP_DEINIT_CB_ID     NAND MspDeInit callback ID
  *          @arg @ref HAL_NAND_IT_CB_ID             NAND IT callback ID
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_NAND_UnRegisterCallback</name> <parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>HAL_NAND_CallbackIDTypeDef</name></type> <name>CallbackId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_NAND_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_NAND_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_NAND_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_NAND_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_NAND_IT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>ItCallback</name></name> <operator>=</operator> <name>HAL_NAND_ITCallback</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackId</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>HAL_NAND_MSP_INIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_NAND_MspInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>HAL_NAND_MSP_DEINIT_CB_ID</name></expr> :</case>
      <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_NAND_MspDeInit</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default :</default>
      <comment type="block">/* update return status */</comment>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* update return status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hnand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup NAND_Exported_Functions_Group3 Peripheral Control functions 
 *  @brief   management functions 
 *
@verbatim   
  ==============================================================================
                         ##### NAND Control functions #####
  ==============================================================================  
  [..]
    This subsection provides a set of functions allowing to control dynamically
    the NAND interface.

@endverbatim
  * @{
  */</comment> 

    
<comment type="block" format="doxygen">/**
  * @brief  Enables dynamically NAND ECC feature.
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval HAL status
  */</comment>    
<function><type><name>HAL_StatusTypeDef</name></type>  <name>HAL_NAND_ECC_Enable</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the NAND state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
   
  <comment type="block">/* Enable ECC feature */</comment>
  <expr_stmt><expr><call><name>FMC_NAND_ECC_Enable</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the NAND state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables dynamically FMC_NAND ECC feature.
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval HAL status
  */</comment>  
<function><type><name>HAL_StatusTypeDef</name></type>  <name>HAL_NAND_ECC_Disable</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the NAND state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>
    
  <comment type="block">/* Disable ECC feature */</comment>
  <expr_stmt><expr><call><name>FMC_NAND_ECC_Disable</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the NAND state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>
  
  <return>return <expr><name>HAL_OK</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables dynamically NAND ECC feature.
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @param  ECCval pointer to ECC value 
  * @param  Timeout maximum timeout to wait    
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type>  <name>HAL_NAND_GetECC</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>ECCval</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the NAND controller state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_NAND_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
     <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Update the NAND state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_BUSY</name></expr>;</expr_stmt>  
   
  <comment type="block">/* Get NAND ECC value */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FMC_NAND_GetECC</name><argument_list>(<argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>ECCval</name></expr></argument>, <argument><expr><name><name>hnand</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NandBank</name></name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update the NAND state */</comment>
  <expr_stmt><expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_NAND_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
    
<comment type="block" format="doxygen">/** @defgroup NAND_Exported_Functions_Group4 Peripheral State functions 
 *  @brief   Peripheral State functions 
 *
@verbatim   
  ==============================================================================
                         ##### NAND State functions #####
  ==============================================================================  
  [..]
    This subsection permits to get in run-time the status of the NAND controller 
    and the data flow.

@endverbatim
  * @{
  */</comment>
  
<comment type="block" format="doxygen">/**
  * @brief  return the NAND state
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_NAND_StateTypeDef</name></type> <name>HAL_NAND_GetState</name><parameter_list>(<parameter><decl><type><name>NAND_HandleTypeDef</name> <modifier>*</modifier></type><name>hnand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hnand</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>  

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx ||\
          STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||\
          STM32F446xx || STM32F469xx || STM32F479xx */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_NAND_MODULE_ENABLED  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
