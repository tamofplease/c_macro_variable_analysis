<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dsi.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_dsi.c
  * @author  MCD Application Team
  * @brief   DSI HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the DSI peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State and Errors functions
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
    [..]
    (#) Use @ref HAL_DSI_Init() function to initialize the DSI Host IP and program the required
        PLL parameters, number of lanes and TX Escape clock divider.
    (#) Use @ref HAL_DSI_ConfigAdaptedCommandMode() function to configure the DSI host in adapted
        command mode.
    (#) When operating in video mode , use @ref HAL_DSI_ConfigVideoMode() to configure the DSI host.
    (#) Function @ref HAL_DSI_ConfigCommand() is used to configure the DSI commands behavior in low power mode.
    (#) To configure the DSI PHY timings parameters, use function @ref HAL_DSI_ConfigPhyTimer().
    (#) The DSI Host can be started/stopped using respectively functions @ref HAL_DSI_Start() and @ref HAL_DSI_Stop().
        Functions @ref HAL_DSI_ShortWrite(), @ref HAL_DSI_LongWrite() and @ref HAL_DSI_Read() allows respectively
        to write DSI short packets, long packets and to read DSI packets.

    (#) The DSI Host Offers two Low power modes :
        (+) Low Power Mode on data lanes only: Only DSI data lanes are shut down.
            It is possible to enter/exit from this mode using respectively functions @ref HAL_DSI_EnterULPMData()
            and @ref HAL_DSI_ExitULPMData()

        (+) Low Power Mode on data and clock lanes : All DSI lanes are shut down including data and clock lanes.
            It is possible to enter/exit from this mode using respectively functions @ref HAL_DSI_EnterULPM()
            and @ref HAL_DSI_ExitULPM()

    (#) User can select the DSI errors to be reported/monitored using function @ref HAL_DSI_ConfigErrorMonitor()
        When an error occurs, the callback @ref HAL_DSI_ErrorCallback() is asserted and then user can retrieve
        the error code by calling function @ref HAL_DSI_GetError()

    (#) To control DSI state you can use the following function: HAL_DSI_GetState()

     *** DSI HAL driver macros list ***
     =============================================
     [..]
       Below the list of most used macros in DSI HAL driver.

      (+) __HAL_DSI_ENABLE: Enable the DSI Host.
      (+) __HAL_DSI_DISABLE: Disable the DSI Host.
      (+) __HAL_DSI_WRAPPER_ENABLE: Enables the DSI wrapper.
      (+) __HAL_DSI_WRAPPER_DISABLE: Disable the DSI wrapper.
      (+) __HAL_DSI_PLL_ENABLE: Enables the DSI PLL.
      (+) __HAL_DSI_PLL_DISABLE: Disables the DSI PLL.
      (+) __HAL_DSI_REG_ENABLE: Enables the DSI regulator.
      (+) __HAL_DSI_REG_DISABLE: Disables the DSI regulator.
      (+) __HAL_DSI_GET_FLAG: Get the DSI pending flags.
      (+) __HAL_DSI_CLEAR_FLAG: Clears the DSI pending flags.
      (+) __HAL_DSI_ENABLE_IT: Enables the specified DSI interrupts.
      (+) __HAL_DSI_DISABLE_IT: Disables the specified DSI interrupts.
      (+) __HAL_DSI_GET_IT_SOURCE: Checks whether the specified DSI interrupt source is enabled or not.



  *** Callback registration ***
  =============================================

  The compilation define  USE_HAL_DSI_REGISTER_CALLBACKS when set to 1
  allows the user to configure dynamically the driver callbacks.
  Use Function @ref HAL_DSI_RegisterCallback() to register a callback.

  Function @ref HAL_DSI_RegisterCallback() allows to register following callbacks:
    (+) TearingEffectCallback : DSI Tearing Effect Callback.
    (+) EndOfRefreshCallback  : DSI End Of Refresh Callback.
    (+) ErrorCallback         : DSI Error Callback
    (+) MspInitCallback       : DSI MspInit.
    (+) MspDeInitCallback     : DSI MspDeInit.
  This function takes as parameters the HAL peripheral handle, the Callback ID
  and a pointer to the user callback function.

  Use function @ref HAL_DSI_UnRegisterCallback() to reset a callback to the default
  weak function.
  @ref HAL_DSI_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.
  This function allows to reset following callbacks:
    (+) TearingEffectCallback : DSI Tearing Effect Callback.
    (+) EndOfRefreshCallback  : DSI End Of Refresh Callback.
    (+) ErrorCallback         : DSI Error Callback
    (+) MspInitCallback       : DSI MspInit.
    (+) MspDeInitCallback     : DSI MspDeInit.

  By default, after the HAL_DSI_Init and when the state is HAL_DSI_STATE_RESET
  all callbacks are set to the corresponding weak functions:
  examples @ref HAL_DSI_TearingEffectCallback(), @ref HAL_DSI_EndOfRefreshCallback().
  Exception done for MspInit and MspDeInit functions that are
  reset to the legacy weak function in the HAL_DSI_Init/ @ref HAL_DSI_DeInit only when
  these callbacks are null (not registered beforehand).
  if not, MspInit or MspDeInit are not null, the @ref HAL_DSI_Init/ @ref HAL_DSI_DeInit
  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

  Callbacks can be registered/unregistered in HAL_DSI_STATE_READY state only.
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_DSI_STATE_READY or HAL_DSI_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using @ref HAL_DSI_RegisterCallback() before calling @ref HAL_DSI_DeInit
  or HAL_DSI_Init function.

  When The compilation define USE_HAL_DSI_REGISTER_CALLBACKS is set to 0 or
  not defined, the callback registration feature is not available and all callbacks
  are set to the corresponding weak functions.

     [..]
       (@) You can refer to the DSI HAL driver header file for more useful macros

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_DSI_MODULE_ENABLED</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DSI</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block" format="doxygen">/** @addtogroup DSI
  * @{
  */</comment>

<comment type="block">/* Private types -------------------------------------------------------------*/</comment>
<comment type="block">/* Private defines -----------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup DSI_Private_Constants
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_TIMEOUT_VALUE</name></cpp:macro> <cpp:value>((uint32_t)1000U)</cpp:value></cpp:define>  <comment type="block">/* 1s */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_ACK_MASK</name></cpp:macro> <cpp:value>(DSI_ISR0_AE0 | DSI_ISR0_AE1 | DSI_ISR0_AE2 | DSI_ISR0_AE3 | \
                            DSI_ISR0_AE4 | DSI_ISR0_AE5 | DSI_ISR0_AE6 | DSI_ISR0_AE7 | \
                            DSI_ISR0_AE8 | DSI_ISR0_AE9 | DSI_ISR0_AE10 | DSI_ISR0_AE11 | \
                            DSI_ISR0_AE12 | DSI_ISR0_AE13 | DSI_ISR0_AE14 | DSI_ISR0_AE15)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_PHY_MASK</name></cpp:macro> <cpp:value>(DSI_ISR0_PE0 | DSI_ISR0_PE1 | DSI_ISR0_PE2 | DSI_ISR0_PE3 | DSI_ISR0_PE4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_TX_MASK</name></cpp:macro>  <cpp:value>DSI_ISR1_TOHSTX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_RX_MASK</name></cpp:macro>  <cpp:value>DSI_ISR1_TOLPRX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_ECC_MASK</name></cpp:macro> <cpp:value>(DSI_ISR1_ECCSE | DSI_ISR1_ECCME)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_CRC_MASK</name></cpp:macro> <cpp:value>DSI_ISR1_CRCE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_PSE_MASK</name></cpp:macro> <cpp:value>DSI_ISR1_PSE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_EOT_MASK</name></cpp:macro> <cpp:value>DSI_ISR1_EOTPE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_OVF_MASK</name></cpp:macro> <cpp:value>DSI_ISR1_LPWRE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSI_ERROR_GEN_MASK</name></cpp:macro> <cpp:value>(DSI_ISR1_GCWRE | DSI_ISR1_GPWRE | DSI_ISR1_GPTXE | DSI_ISR1_GPRDE | DSI_ISR1_GPRXE)</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private constants ---------------------------------------------------------*/</comment>
<comment type="block">/* Private macros ------------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DSI_ConfigPacketHeader</name><parameter_list>(<parameter><decl><type><name>DSI_TypeDef</name> <modifier>*</modifier></type><name>DSIx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ChannelID</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DataType</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Data0</name></decl></parameter>,
                                   <parameter><decl><type><name>uint32_t</name></type> <name>Data1</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>DSI_ShortWrite</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>ChannelID</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>Mode</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>Param1</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>Param2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/**
  * @brief  Generic DSI packet header configuration
  * @param  DSIx  Pointer to DSI register base
  * @param  ChannelID Virtual channel ID of the header packet
  * @param  DataType  Packet data type of the header packet
  *                   This parameter can be any value of :
  *                      @ref DSI_SHORT_WRITE_PKT_Data_Type
  *                   or @ref DSI_LONG_WRITE_PKT_Data_Type
  *                   or @ref DSI_SHORT_READ_PKT_Data_Type
  *                   or DSI_MAX_RETURN_PKT_SIZE
  * @param  Data0  Word count LSB
  * @param  Data1  Word count MSB
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DSI_ConfigPacketHeader</name><parameter_list>(<parameter><decl><type><name>DSI_TypeDef</name> <modifier>*</modifier></type><name>DSIx</name></decl></parameter>,
                                   <parameter><decl><type><name>uint32_t</name></type> <name>ChannelID</name></decl></parameter>,
                                   <parameter><decl><type><name>uint32_t</name></type> <name>DataType</name></decl></parameter>,
                                   <parameter><decl><type><name>uint32_t</name></type> <name>Data0</name></decl></parameter>,
                                   <parameter><decl><type><name>uint32_t</name></type> <name>Data1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Update the DSI packet header with new information */</comment>
  <expr_stmt><expr><name><name>DSIx</name><operator>-&gt;</operator><name>GHCR</name></name> <operator>=</operator> <operator>(</operator><name>DataType</name> <operator>|</operator> <operator>(</operator><name>ChannelID</name> <operator>&lt;&lt;</operator> <literal type="number">6U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>Data0</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>Data1</name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  write short DCS or short Generic command
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ChannelID  Virtual channel ID.
  * @param  Mode  DSI short packet data type.
  *               This parameter can be any value of @ref DSI_SHORT_WRITE_PKT_Data_Type.
  * @param  Param1  DSC command or first generic parameter.
  *                 This parameter can be any value of @ref DSI_DCS_Command or a
  *                 generic command code.
  * @param  Param2  DSC parameter or second generic parameter.
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>DSI_ShortWrite</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>,
                                        <parameter><decl><type><name>uint32_t</name></type> <name>ChannelID</name></decl></parameter>,
                                        <parameter><decl><type><name>uint32_t</name></type> <name>Mode</name></decl></parameter>,
                                        <parameter><decl><type><name>uint32_t</name></type> <name>Param1</name></decl></parameter>,
                                        <parameter><decl><type><name>uint32_t</name></type> <name>Param2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for Command FIFO Empty */</comment>
  <while>while<condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GPSR</name></name> <operator>&amp;</operator> <name>DSI_GPSR_CMDFE</name><operator>)</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Configure the packet to send a short DCS command with 0 or 1 parameter */</comment>
  <comment type="block">/* Update the DSI packet header with new information */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GHCR</name></name> <operator>=</operator> <operator>(</operator><name>Mode</name> <operator>|</operator> <operator>(</operator><name>ChannelID</name> <operator>&lt;&lt;</operator> <literal type="number">6U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>Param1</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>Param2</name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup DSI_Exported_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DSI_Group1 Initialization and Configuration functions
  *  @brief   Initialization and Configuration functions
  *
@verbatim
 ===============================================================================
                ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the DSI
      (+) De-initialize the DSI

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the DSI according to the specified
  *         parameters in the DSI_InitTypeDef and create the associated handle.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  PLLInit  pointer to a DSI_PLLInitTypeDef structure that contains
  *                  the PLL Clock structure definition for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_Init</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>DSI_PLLInitTypeDef</name> <modifier>*</modifier></type><name>PLLInit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>unitIntervalx4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tempIDF</name></decl>;</decl_stmt>

  <comment type="block">/* Check the DSI handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hdsi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_PLL_NDIV</name><argument_list>(<argument><expr><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLNDIV</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_PLL_IDF</name><argument_list>(<argument><expr><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLIDF</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_PLL_ODF</name><argument_list>(<argument><expr><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLODF</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_AUTO_CLKLANE_CONTROL</name><argument_list>(<argument><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutomaticClockLaneControl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_NUMBER_OF_LANES</name><argument_list>(<argument><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NumberOfLanes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DSI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DSI_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Reset the DSI callback to the legacy weak callbacks */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>TearingEffectCallback</name></name> <operator>=</operator> <name>HAL_DSI_TearingEffectCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TearingEffectCallback */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>EndOfRefreshCallback</name></name>  <operator>=</operator> <name>HAL_DSI_EndOfRefreshCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak EndOfRefreshCallback  */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCallback</name></name>         <operator>=</operator> <name>HAL_DSI_ErrorCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak ErrorCallback         */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_DSI_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Initialize the low level hardware */</comment>
    <expr_stmt><expr><call><name><name>hdsi</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DSI_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Initialize the low level hardware */</comment>
    <expr_stmt><expr><call><name>HAL_DSI_MspInit</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DSI_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change DSI peripheral state */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DSI_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block" format="doxygen">/**************** Turn on the regulator and enable the DSI PLL ****************/</comment>

  <comment type="block">/* Enable the regulator */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_REG_ENABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until the regulator is ready */</comment>
  <while>while <condition>(<expr><call><name>__HAL_DSI_GET_FLAG</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_FLAG_RRS</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Set the PLL division factors */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WRPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_WRPCR_PLL_NDIV</name> <operator>|</operator> <name>DSI_WRPCR_PLL_IDF</name> <operator>|</operator> <name>DSI_WRPCR_PLL_ODF</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WRPCR</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLNDIV</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLIDF</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">11U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLODF</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Enable the DSI PLL */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_PLL_ENABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for the lock of the PLL */</comment>
  <while>while <condition>(<expr><call><name>__HAL_DSI_GET_FLAG</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_FLAG_PLLLS</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block" format="doxygen">/*************************** Set the PHY parameters ***************************/</comment>

  <comment type="block">/* D-PHY clock and digital enable*/</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCTLR</name></name> <operator>|=</operator> <operator>(</operator><name>DSI_PCTLR_CKE</name> <operator>|</operator> <name>DSI_PCTLR_DEN</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Clock lane configuration */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CLCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_CLCR_DPCC</name> <operator>|</operator> <name>DSI_CLCR_ACR</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CLCR</name></name> <operator>|=</operator> <operator>(</operator><name>DSI_CLCR_DPCC</name> <operator>|</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutomaticClockLaneControl</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Configure the number of active data lanes */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_PCONFR_NL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>|=</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NumberOfLanes</name></name></expr>;</expr_stmt>

  <comment type="block" format="doxygen">/************************ Set the DSI clock parameters ************************/</comment>

  <comment type="block">/* Set the TX escape clock division factor */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_CCR_TXECKDIV</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TXEscapeCkdiv</name></name></expr>;</expr_stmt>

  <comment type="block">/* Calculate the bit period in high-speed mode in unit of 0.25 ns (UIX4) */</comment>
  <comment type="block">/* The equation is : UIX4 = IntegerPart( (1000/F_PHY_Mhz) * 4 )          */</comment>
  <comment type="block">/* Where : F_PHY_Mhz = (NDIV * HSE_Mhz) / (IDF * ODF)                    */</comment>
  <expr_stmt><expr><name>tempIDF</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLIDF</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>PLLInit</name><operator>-&gt;</operator><name>PLLIDF</name></name></expr> </then><else>: <expr><literal type="number">1U</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>unitIntervalx4</name> <operator>=</operator> <operator>(</operator><literal type="number">4000000U</literal> <operator>*</operator> <name>tempIDF</name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">1UL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">0x3U</literal> <operator>&amp;</operator> <name><name>PLLInit</name><operator>-&gt;</operator><name>PLLODF</name></name><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>HSE_VALUE</name> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator> <operator>*</operator> <name><name>PLLInit</name><operator>-&gt;</operator><name>PLLNDIV</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set the bit period in high-speed mode */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_UIX4</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <name>unitIntervalx4</name></expr>;</expr_stmt>

  <comment type="block" format="doxygen">/****************************** Error management *****************************/</comment>

  <comment type="block">/* Disable all error interrupts and reset the Error Mask */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorMsk</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Initialise the error code */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DSI_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize the DSI state*/</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DSI_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  De-initializes the DSI peripheral registers to their default reset
  *         values.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_DeInit</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the DSI handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hdsi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change DSI peripheral state */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DSI_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the DSI wrapper */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_WRAPPER_DISABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the DSI host */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_DISABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* D-PHY clock and digital disable */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCTLR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_PCTLR_CKE</name> <operator>|</operator> <name>DSI_PCTLR_DEN</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Turn off the DSI PLL */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_PLL_DISABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the regulator */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_REG_DISABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DSI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_DSI_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>hdsi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name>HAL_DSI_MspDeInit</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DSI_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Initialise the error code */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DSI_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize the DSI state*/</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DSI_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable the error monitor flags
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ActiveErrors  indicates which error interrupts will be enabled.
  *                      This parameter can be any combination of @ref DSI_Error_Data_Type.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ConfigErrorMonitor</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ActiveErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Store active errors to the handle */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorMsk</name></name> <operator>=</operator> <name>ActiveErrors</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_ACK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_ACK_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_PHY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_PHY_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_TX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_TX_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_RX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_RX_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_ECC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_ECC_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_CRC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_CRC_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_PSE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_PSE_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_EOT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_EOT_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_OVF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_OVF_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ActiveErrors</name> <operator>&amp;</operator> <name>HAL_DSI_ERROR_GEN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the interrupt generation on selected errors */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>DSI_ERROR_GEN_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the DSI MSP.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DSI_MspInit</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  De-initializes the DSI MSP.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DSI_MspDeInit</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DSI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User DSI Callback
  *         To be used instead of the weak predefined callback
  * @param hdsi dsi handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_DSI_TEARING_EFFECT_CB_ID Tearing Effect Callback ID
  *          @arg @ref HAL_DSI_ENDOF_REFRESH_CB_ID End Of Refresh Callback ID
  *          @arg @ref HAL_DSI_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_DSI_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_DSI_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param pCallback pointer to the Callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>HAL_DSI_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>,
                                           <parameter><decl><type><name>pDSI_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DSI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_DSI_TEARING_EFFECT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>TearingEffectCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_ENDOF_REFRESH_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>EndOfRefreshCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DSI_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_DSI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a DSI Callback
  *         DSI callabck is redirected to the weak predefined callback
  * @param hdsi dsi handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_DSI_TEARING_EFFECT_CB_ID Tearing Effect Callback ID
  *          @arg @ref HAL_DSI_ENDOF_REFRESH_CB_ID End Of Refresh Callback ID
  *          @arg @ref HAL_DSI_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_DSI_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_DSI_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>HAL_DSI_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DSI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_DSI_TEARING_EFFECT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>TearingEffectCallback</name></name> <operator>=</operator> <name>HAL_DSI_TearingEffectCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TearingEffectCallback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_ENDOF_REFRESH_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>EndOfRefreshCallback</name></name> <operator>=</operator> <name>HAL_DSI_EndOfRefreshCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak EndOfRefreshCallback  */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCallback</name></name>        <operator>=</operator> <name>HAL_DSI_ErrorCallback</name></expr>;</expr_stmt>          <comment type="block">/* Legacy weak ErrorCallback        */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_DSI_MspInit</name></expr>;</expr_stmt>                     <comment type="block">/* Legcay weak MspInit Callback     */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_DSI_MspDeInit</name></expr>;</expr_stmt>                 <comment type="block">/* Legcay weak MspDeInit Callback   */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DSI_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_DSI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_DSI_MspInit</name></expr>;</expr_stmt>                  <comment type="block">/* Legcay weak MspInit Callback   */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_DSI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_DSI_MspDeInit</name></expr>;</expr_stmt>              <comment type="block">/* Legcay weak MspDeInit Callback */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DSI_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DSI_Group2 IO operation functions
  *  @brief    IO operation functions
  *
@verbatim
 ===============================================================================
                      #####  IO operation functions  #####
 ===============================================================================
    [..]  This section provides function allowing to:
      (+) Handle DSI interrupt request

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Handles DSI interrupt request.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>void</name></type> <name>HAL_DSI_IRQHandler</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ErrorStatus0</name></decl>, <decl><type ref="prev"/><name>ErrorStatus1</name></decl>;</decl_stmt>

  <comment type="block">/* Tearing Effect Interrupt management ***************************************/</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_DSI_GET_FLAG</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_FLAG_TE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_DSI_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_IT_TE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the Tearing Effect Interrupt Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_DSI_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_FLAG_TE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Tearing Effect Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DSI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <comment type="block">/*Call registered Tearing Effect callback */</comment>
      <expr_stmt><expr><call><name><name>hdsi</name><operator>-&gt;</operator><name>TearingEffectCallback</name></name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/*Call legacy Tearing Effect callback*/</comment>
      <expr_stmt><expr><call><name>HAL_DSI_TearingEffectCallback</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DSI_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* End of Refresh Interrupt management ***************************************/</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_DSI_GET_FLAG</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_FLAG_ER</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_DSI_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_IT_ER</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the End of Refresh Interrupt Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_DSI_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_FLAG_ER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* End of Refresh Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DSI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <comment type="block">/*Call registered End of refresh callback */</comment>
      <expr_stmt><expr><call><name><name>hdsi</name><operator>-&gt;</operator><name>EndOfRefreshCallback</name></name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/*Call Legacy End of refresh callback */</comment>
      <expr_stmt><expr><call><name>HAL_DSI_EndOfRefreshCallback</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DSI_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Error Interrupts management ***********************************************/</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorMsk</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>ErrorStatus0</name> <operator>=</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ISR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ErrorStatus0</name> <operator>&amp;=</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ErrorStatus1</name> <operator>=</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ISR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ErrorStatus1</name> <operator>&amp;=</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus0</name> <operator>&amp;</operator> <name>DSI_ERROR_ACK_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_ACK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus0</name> <operator>&amp;</operator> <name>DSI_ERROR_PHY_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_PHY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_TX_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_TX</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_RX_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_RX</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_ECC_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_ECC</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_CRC_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_CRC</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_PSE_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_PSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_EOT_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_EOT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_OVF_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_OVF</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ErrorStatus1</name> <operator>&amp;</operator> <name>DSI_ERROR_GEN_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DSI_ERROR_GEN</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check only selected errors */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_DSI_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* DSI error interrupt callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_DSI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <comment type="block">/*Call registered Error callback */</comment>
      <expr_stmt><expr><call><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/*Call Legacy Error callback */</comment>
      <expr_stmt><expr><call><name>HAL_DSI_ErrorCallback</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_DSI_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Tearing Effect DSI callback.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DSI_TearingEffectCallback</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_TearingEffectCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  End of Refresh DSI callback.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DSI_EndOfRefreshCallback</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_EndOfRefreshCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Operation Error DSI callback.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_DSI_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_ErrorCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DSI_Group3 Peripheral Control functions
  *  @brief    Peripheral Control functions
  *
@verbatim
 ===============================================================================
                    ##### Peripheral Control functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure the Generic interface read-back Virtual Channel ID
      (+) Select video mode and configure the corresponding parameters
      (+) Configure command transmission mode: High-speed or Low-power
      (+) Configure the flow control
      (+) Configure the DSI PHY timer
      (+) Configure the DSI HOST timeout
      (+) Configure the DSI HOST timeout
      (+) Start/Stop the DSI module
      (+) Refresh the display in command mode
      (+) Controls the display color mode in Video mode
      (+) Control the display shutdown in Video mode
      (+) write short DCS or short Generic command
      (+) write long DCS or long Generic command
      (+) Read command (DCS or generic)
      (+) Enter/Exit the Ultra Low Power Mode on data only (D-PHY PLL running)
      (+) Enter/Exit the Ultra Low Power Mode on data only and clock (D-PHY PLL turned off)
      (+) Start/Stop test pattern generation
      (+) Slew-Rate And Delay Tuning
      (+) Low-Power Reception Filter Tuning
      (+) Activate an additional current path on all lanes to meet the SDDTx parameter
      (+) Custom lane pins configuration
      (+) Set custom timing for the PHY
      (+) Force the Clock/Data Lane in TX Stop Mode
      (+) Force LP Receiver in Low-Power Mode
      (+) Force Data Lanes in RX Mode after a BTA
      (+) Enable a pull-down on the lanes to prevent from floating states when unused
      (+) Switch off the contention detection on data lanes

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Configure the Generic interface read-back Virtual Channel ID.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  VirtualChannelID  Virtual channel ID
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetGenericVCID</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>VirtualChannelID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the GVCID register */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GVCIDR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_GVCIDR_VCID</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GVCIDR</name></name> <operator>|=</operator> <name>VirtualChannelID</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Select video mode and configure the corresponding parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  VidCfg pointer to a DSI_VidCfgTypeDef structure that contains
  *                the DSI video mode configuration parameters
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ConfigVideoMode</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>DSI_VidCfgTypeDef</name> <modifier>*</modifier></type><name>VidCfg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_COLOR_CODING</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_VIDEO_MODE_TYPE</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_COMMAND</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LPCommandEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_HFP</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LPHorizontalFrontPorchEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_HBP</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LPHorizontalBackPorchEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_VACTIVE</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalActiveEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_VFP</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalFrontPorchEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_VBP</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalBackPorchEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_VSYNC</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalSyncActiveEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_FBTAA</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>FrameBTAAcknowledgeEnable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_DE_POLARITY</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>DEPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_VSYNC_POLARITY</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>VSPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_HSYNC_POLARITY</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>HSPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Check the LooselyPacked variant only in 18-bit mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>VidCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name> <operator>==</operator> <name>DSI_RGB666</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LOOSELY_PACKED</name><argument_list>(<argument><expr><name><name>VidCfg</name><operator>-&gt;</operator><name>LooselyPacked</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Select video mode by resetting CMDM and DSIM bits */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_MCR_CMDM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WCFGR_DSIM</name></expr>;</expr_stmt>

  <comment type="block">/* Configure the video mode transmission type */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_VMT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>Mode</name></name></expr>;</expr_stmt>

  <comment type="block">/* Configure the video packet size */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VPCR_VPSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VPCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>PacketSize</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the chunks number to be transmitted through the DSI link */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VCCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VCCR_NUMC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VCCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>NumberOfChunks</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the size of the null packet */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VNPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VNPCR_NPSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VNPCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>NullPacketSize</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the virtual channel for the LTDC interface traffic */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LVCIDR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LVCIDR_VCID</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LVCIDR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>VirtualChannelID</name></name></expr>;</expr_stmt>

  <comment type="block">/* Configure the polarity of control signals */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_LPCR_DEP</name> <operator>|</operator> <name>DSI_LPCR_VSP</name> <operator>|</operator> <name>DSI_LPCR_HSP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPCR</name></name> <operator>|=</operator> <operator>(</operator><name><name>VidCfg</name><operator>-&gt;</operator><name>DEPolarity</name></name> <operator>|</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>VSPolarity</name></name> <operator>|</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>HSPolarity</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the color coding for the host */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCOLCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LCOLCR_COLC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCOLCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the color coding for the wrapper */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WCFGR_COLMUX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>VidCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Enable/disable the loosely packed variant to 18-bit configuration */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>VidCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name> <operator>==</operator> <name>DSI_RGB666</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCOLCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LCOLCR_LPE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCOLCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LooselyPacked</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the Horizontal Synchronization Active (HSA) in lane byte clock cycles */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VHSACR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VHSACR_HSA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VHSACR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>HorizontalSyncActive</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the Horizontal Back Porch (HBP) in lane byte clock cycles */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VHBPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VHBPCR_HBP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VHBPCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>HorizontalBackPorch</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the total line time (HLINE=HSA+HBP+HACT+HFP) in lane byte clock cycles */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VLCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VLCR_HLINE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VLCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>HorizontalLine</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the Vertical Synchronization Active (VSA) */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVSACR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VVSACR_VSA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVSACR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>VerticalSyncActive</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the Vertical Back Porch (VBP)*/</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVBPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VVBPCR_VBP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVBPCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>VerticalBackPorch</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the Vertical Front Porch (VFP)*/</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVFPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VVFPCR_VFP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVFPCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>VerticalFrontPorch</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the Vertical Active period*/</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVACR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VVACR_VA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VVACR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>VerticalActive</name></name></expr>;</expr_stmt>

  <comment type="block">/* Configure the command transmission mode */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_LPCE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPCommandEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Low power largest packet size */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LPMCR_LPSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPMCR</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>VidCfg</name><operator>-&gt;</operator><name>LPLargestPacketSize</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Low power VACT largest packet size */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LPMCR_VLPSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPVACTLargestPacketSize</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable LP transition in HFP period */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_LPHFPE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPHorizontalFrontPorchEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable LP transition in HBP period */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_LPHBPE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPHorizontalBackPorchEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable LP transition in VACT period */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_LPVAE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalActiveEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable LP transition in VFP period */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_LPVFPE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalFrontPorchEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable LP transition in VBP period */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_LPVBPE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalBackPorchEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable LP transition in vertical sync period */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_LPVSAE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>LPVerticalSyncActiveEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable the request for an acknowledge response at the end of a frame */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_FBTAAE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name><name>VidCfg</name><operator>-&gt;</operator><name>FrameBTAAcknowledgeEnable</name></name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Select adapted command mode and configure the corresponding parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  CmdCfg  pointer to a DSI_CmdCfgTypeDef structure that contains
  *                 the DSI command mode configuration parameters
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ConfigAdaptedCommandMode</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>DSI_CmdCfgTypeDef</name> <modifier>*</modifier></type><name>CmdCfg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_COLOR_CODING</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_TE_SOURCE</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>TearingEffectSource</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_TE_POLARITY</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>TearingEffectPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_AUTOMATIC_REFRESH</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>AutomaticRefresh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_VS_POLARITY</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>VSyncPol</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_TE_ACK_REQUEST</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>TEAcknowledgeRequest</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_DE_POLARITY</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>DEPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_VSYNC_POLARITY</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>VSPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_HSYNC_POLARITY</name><argument_list>(<argument><expr><name><name>CmdCfg</name><operator>-&gt;</operator><name>HSPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Select command mode by setting CMDM and DSIM bits */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name> <operator>|=</operator> <name>DSI_MCR_CMDM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WCFGR_DSIM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>|=</operator> <name>DSI_WCFGR_DSIM</name></expr>;</expr_stmt>

  <comment type="block">/* Select the virtual channel for the LTDC interface traffic */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LVCIDR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LVCIDR_VCID</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LVCIDR</name></name> <operator>|=</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>VirtualChannelID</name></name></expr>;</expr_stmt>

  <comment type="block">/* Configure the polarity of control signals */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_LPCR_DEP</name> <operator>|</operator> <name>DSI_LPCR_VSP</name> <operator>|</operator> <name>DSI_LPCR_HSP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LPCR</name></name> <operator>|=</operator> <operator>(</operator><name><name>CmdCfg</name><operator>-&gt;</operator><name>DEPolarity</name></name> <operator>|</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>VSPolarity</name></name> <operator>|</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>HSPolarity</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the color coding for the host */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCOLCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LCOLCR_COLC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCOLCR</name></name> <operator>|=</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the color coding for the wrapper */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WCFGR_COLMUX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>CmdCfg</name><operator>-&gt;</operator><name>ColorCoding</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Configure the maximum allowed size for write memory command */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_LCCR_CMDSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>LCCR</name></name> <operator>|=</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>CommandSize</name></name></expr>;</expr_stmt>

  <comment type="block">/* Configure the tearing effect source and polarity and select the refresh mode */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_WCFGR_TESRC</name> <operator>|</operator> <name>DSI_WCFGR_TEPOL</name> <operator>|</operator> <name>DSI_WCFGR_AR</name> <operator>|</operator> <name>DSI_WCFGR_VSPOL</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCFGR</name></name> <operator>|=</operator> <operator>(</operator><name><name>CmdCfg</name><operator>-&gt;</operator><name>TearingEffectSource</name></name> <operator>|</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>TearingEffectPolarity</name></name> <operator>|</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>AutomaticRefresh</name></name> <operator>|</operator>
                            <name><name>CmdCfg</name><operator>-&gt;</operator><name>VSyncPol</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Configure the tearing effect acknowledge request */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_CMCR_TEARE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMCR</name></name> <operator>|=</operator> <name><name>CmdCfg</name><operator>-&gt;</operator><name>TEAcknowledgeRequest</name></name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Tearing Effect interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_ENABLE_IT</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_IT_TE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the End of Refresh interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_ENABLE_IT</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_IT_ER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure command transmission mode: High-speed or Low-power
  *         and enable/disable acknowledge request after packet transmission
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  LPCmd  pointer to a DSI_LPCmdTypeDef structure that contains
  *                the DSI command transmission mode configuration parameters
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ConfigCommand</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>DSI_LPCmdTypeDef</name> <modifier>*</modifier></type><name>LPCmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_GSW0P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortWriteNoP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_GSW1P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortWriteOneP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_GSW2P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortWriteTwoP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_GSR0P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortReadNoP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_GSR1P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortReadOneP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_GSR2P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortReadTwoP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_GLW</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenLongWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_DSW0P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsShortWriteNoP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_DSW1P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsShortWriteOneP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_DSR0P</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsShortReadNoP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_DLW</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsLongWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LP_MRDP</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>LPMaxReadPacket</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_ACK_REQUEST</name><argument_list>(<argument><expr><name><name>LPCmd</name><operator>-&gt;</operator><name>AcknowledgeRequest</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Select High-speed or Low-power for command transmission */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_CMCR_GSW0TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_GSW1TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_GSW2TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_GSR0TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_GSR1TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_GSR2TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_GLWTX</name>  <operator>|</operator> \
                            <name>DSI_CMCR_DSW0TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_DSW1TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_DSR0TX</name> <operator>|</operator> \
                            <name>DSI_CMCR_DLWTX</name>  <operator>|</operator> \
                            <name>DSI_CMCR_MRDPS</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMCR</name></name> <operator>|=</operator> <operator>(</operator><name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortWriteNoP</name></name>  <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortWriteOneP</name></name> <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortWriteTwoP</name></name> <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortReadNoP</name></name>   <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortReadOneP</name></name>  <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenShortReadTwoP</name></name>  <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPGenLongWrite</name></name>      <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsShortWriteNoP</name></name>  <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsShortWriteOneP</name></name> <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsShortReadNoP</name></name>   <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPDcsLongWrite</name></name>      <operator>|</operator> \
                           <name><name>LPCmd</name><operator>-&gt;</operator><name>LPMaxReadPacket</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Configure the acknowledge request after each packet transmission */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_CMCR_ARE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMCR</name></name> <operator>|=</operator> <name><name>LPCmd</name><operator>-&gt;</operator><name>AcknowledgeRequest</name></name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the flow control parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  FlowControl  flow control feature(s) to be enabled.
  *                      This parameter can be any combination of @ref DSI_FlowControl.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ConfigFlowControl</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>FlowControl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_FLOW_CONTROL</name><argument_list>(<argument><expr><name>FlowControl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the DSI Host Protocol Configuration Register */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_FLOW_CONTROL_ALL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCR</name></name> <operator>|=</operator> <name>FlowControl</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the DSI PHY timer parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  PhyTimers  DSI_PHY_TimerTypeDef structure that contains
  *                    the DSI PHY timing parameters
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ConfigPhyTimer</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>DSI_PHY_TimerTypeDef</name> <modifier>*</modifier></type><name>PhyTimers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>maxTime</name></decl>;</decl_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>maxTime</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>PhyTimers</name><operator>-&gt;</operator><name>ClockLaneLP2HSTime</name></name> <operator>&gt;</operator> <name><name>PhyTimers</name><operator>-&gt;</operator><name>ClockLaneHS2LPTime</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>PhyTimers</name><operator>-&gt;</operator><name>ClockLaneLP2HSTime</name></name></expr> </then><else>:
            <expr><name><name>PhyTimers</name><operator>-&gt;</operator><name>ClockLaneHS2LPTime</name></name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Clock lane timer configuration */</comment>

  <comment type="block">/* In Automatic Clock Lane control mode, the DSI Host can turn off the clock lane between two
     High-Speed transmission.
     To do so, the DSI Host calculates the time required for the clock lane to change from HighSpeed
     to Low-Power and from Low-Power to High-Speed.
     This timings are configured by the HS2LP_TIME and LP2HS_TIME in the DSI Host Clock Lane Timer Configuration Register (DSI_CLTCR).
     But the DSI Host is not calculating LP2HS_TIME + HS2LP_TIME but 2 x HS2LP_TIME.

     Workaround : Configure HS2LP_TIME and LP2HS_TIME with the same value being the max of HS2LP_TIME or LP2HS_TIME.
    */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CLTCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_CLTCR_LP2HS_TIME</name> <operator>|</operator> <name>DSI_CLTCR_HS2LP_TIME</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CLTCR</name></name> <operator>|=</operator> <operator>(</operator><name>maxTime</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>maxTime</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Data lane timer configuration */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DLTCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_DLTCR_MRD_TIME</name> <operator>|</operator> <name>DSI_DLTCR_LP2HS_TIME</name> <operator>|</operator> <name>DSI_DLTCR_HS2LP_TIME</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DLTCR</name></name> <operator>|=</operator> <operator>(</operator><name><name>PhyTimers</name><operator>-&gt;</operator><name>DataLaneMaxReadTime</name></name> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>PhyTimers</name><operator>-&gt;</operator><name>DataLaneLP2HSTime</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator>
                              <name><name>PhyTimers</name><operator>-&gt;</operator><name>DataLaneHS2LPTime</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Configure the wait period to request HS transmission after a stop state */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_PCONFR_SW_TIME</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>PhyTimers</name><operator>-&gt;</operator><name>StopWaitTime</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the DSI HOST timeout parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  HostTimeouts  DSI_HOST_TimeoutTypeDef structure that contains
  *                       the DSI host timeout parameters
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ConfigHostTimeouts</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>DSI_HOST_TimeoutTypeDef</name> <modifier>*</modifier></type><name>HostTimeouts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the timeout clock division factor */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_CCR_TOCKDIV</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>HostTimeouts</name><operator>-&gt;</operator><name>TimeoutCkdiv</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* High-speed transmission timeout */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR0_HSTX_TOCNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>HostTimeouts</name><operator>-&gt;</operator><name>HighSpeedTransmissionTimeout</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Low-power reception timeout */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR0_LPRX_TOCNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <name><name>HostTimeouts</name><operator>-&gt;</operator><name>LowPowerReceptionTimeout</name></name></expr>;</expr_stmt>

  <comment type="block">/* High-speed read timeout */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR1_HSRD_TOCNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name><name>HostTimeouts</name><operator>-&gt;</operator><name>HighSpeedReadTimeout</name></name></expr>;</expr_stmt>

  <comment type="block">/* Low-power read timeout */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR2_LPRD_TOCNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>|=</operator> <name><name>HostTimeouts</name><operator>-&gt;</operator><name>LowPowerReadTimeout</name></name></expr>;</expr_stmt>

  <comment type="block">/* High-speed write timeout */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR3_HSWR_TOCNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>|=</operator> <name><name>HostTimeouts</name><operator>-&gt;</operator><name>HighSpeedWriteTimeout</name></name></expr>;</expr_stmt>

  <comment type="block">/* High-speed write presp mode */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR3_PM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>|=</operator> <name><name>HostTimeouts</name><operator>-&gt;</operator><name>HighSpeedWritePrespMode</name></name></expr>;</expr_stmt>

  <comment type="block">/* Low-speed write timeout */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">4U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR4_LPWR_TOCNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">4U</literal></expr>]</index></name> <operator>|=</operator> <name><name>HostTimeouts</name><operator>-&gt;</operator><name>LowPowerWriteTimeout</name></name></expr>;</expr_stmt>

  <comment type="block">/* BTA timeout */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">5U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_TCCR5_BTA_TOCNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TCCR</name><index>[<expr><literal type="number">5U</literal></expr>]</index></name> <operator>|=</operator> <name><name>HostTimeouts</name><operator>-&gt;</operator><name>BTATimeout</name></name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the DSI module
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_Start</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the DSI host */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_ENABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the DSI wrapper */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_WRAPPER_ENABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the DSI module
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_Stop</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the DSI host */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_DISABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the DSI wrapper */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_WRAPPER_DISABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Refresh the display in command mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_Refresh</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the display */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCR</name></name> <operator>|=</operator> <name>DSI_WCR_LTDCEN</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Controls the display color mode in Video mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ColorMode  Color mode (full or 8-colors).
  *                    This parameter can be any value of @ref DSI_Color_Mode
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ColorMode</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ColorMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_COLOR_MODE</name><argument_list>(<argument><expr><name>ColorMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the display color mode */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WCR_COLM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCR</name></name> <operator>|=</operator> <name>ColorMode</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Control the display shutdown in Video mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Shutdown  Shut-down (Display-ON or Display-OFF).
  *                   This parameter can be any value of @ref DSI_ShutDown
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_Shutdown</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_SHUT_DOWN</name><argument_list>(<argument><expr><name>Shutdown</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the display Shutdown */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WCR_SHTDN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WCR</name></name> <operator>|=</operator> <name>Shutdown</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  write short DCS or short Generic command
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ChannelID  Virtual channel ID.
  * @param  Mode  DSI short packet data type.
  *               This parameter can be any value of @ref DSI_SHORT_WRITE_PKT_Data_Type.
  * @param  Param1  DSC command or first generic parameter.
  *                 This parameter can be any value of @ref DSI_DCS_Command or a
  *                 generic command code.
  * @param  Param2  DSC parameter or second generic parameter.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ShortWrite</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>ChannelID</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>Mode</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>Param1</name></decl></parameter>,
                                     <parameter><decl><type><name>uint32_t</name></type> <name>Param2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name></decl>;</decl_stmt>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_SHORT_WRITE_PACKET_TYPE</name><argument_list>(<argument><expr><name>Mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>DSI_ShortWrite</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>ChannelID</name></expr></argument>, <argument><expr><name>Mode</name></expr></argument>, <argument><expr><name>Param1</name></expr></argument>, <argument><expr><name>Param2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  write long DCS or long Generic command
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ChannelID  Virtual channel ID.
  * @param  Mode  DSI long packet data type.
  *               This parameter can be any value of @ref DSI_LONG_WRITE_PKT_Data_Type.
  * @param  NbParams  Number of parameters.
  * @param  Param1  DSC command or first generic parameter.
  *                 This parameter can be any value of @ref DSI_DCS_Command or a
  *                 generic command code
  * @param  ParametersTable  Pointer to parameter values table.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_LongWrite</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>,
                                    <parameter><decl><type><name>uint32_t</name></type> <name>ChannelID</name></decl></parameter>,
                                    <parameter><decl><type><name>uint32_t</name></type> <name>Mode</name></decl></parameter>,
                                    <parameter><decl><type><name>uint32_t</name></type> <name>NbParams</name></decl></parameter>,
                                    <parameter><decl><type><name>uint32_t</name></type> <name>Param1</name></decl></parameter>,
                                    <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ParametersTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>uicounter</name></decl>, <decl><type ref="prev"/><name>nbBytes</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>fifoword</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pparams</name> <init>= <expr><name>ParametersTable</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LONG_WRITE_PACKET_TYPE</name><argument_list>(<argument><expr><name>Mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for Command FIFO Empty */</comment>
  <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GPSR</name></name> <operator>&amp;</operator> <name>DSI_GPSR_CMDFE</name><operator>)</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Set the DCS code on payload byte 1, and the other parameters on the write FIFO command*/</comment>
  <expr_stmt><expr><name>fifoword</name> <operator>=</operator> <name>Param1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nbBytes</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>NbParams</name> <operator>&lt;</operator> <literal type="number">3U</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NbParams</name></expr> </then><else>: <expr><literal type="number">3U</literal></expr></else></ternary></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>nbBytes</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><name>fifoword</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>pparams</name> <operator>+</operator> <name>count</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8U</literal> <operator>+</operator> <operator>(</operator><literal type="number">8U</literal> <operator>*</operator> <name>count</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GPDR</name></name> <operator>=</operator> <name>fifoword</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>uicounter</name> <operator>=</operator> <name>NbParams</name> <operator>-</operator> <name>nbBytes</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pparams</name> <operator>+=</operator> <name>nbBytes</name></expr>;</expr_stmt>
  <comment type="block">/* Set the Next parameters on the write FIFO command*/</comment>
  <while>while <condition>(<expr><name>uicounter</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>nbBytes</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>uicounter</name> <operator>&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr> ?</condition><then> <expr><name>uicounter</name></expr> </then><else>: <expr><literal type="number">4U</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>fifoword</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>nbBytes</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name>fifoword</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>pparams</name> <operator>+</operator> <name>count</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8U</literal> <operator>*</operator> <name>count</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GPDR</name></name> <operator>=</operator> <name>fifoword</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>uicounter</name> <operator>-=</operator> <name>nbBytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pparams</name> <operator>+=</operator> <name>nbBytes</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Configure the packet to send a long DCS command */</comment>
  <expr_stmt><expr><call><name>DSI_ConfigPacketHeader</name><argument_list>(<argument><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                         <argument><expr><name>ChannelID</name></expr></argument>,
                         <argument><expr><name>Mode</name></expr></argument>,
                         <argument><expr><operator>(</operator><operator>(</operator><name>NbParams</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FFU</literal><operator>)</operator></expr></argument>,
                         <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>NbParams</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF00U</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Read command (DCS or generic)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ChannelNbr  Virtual channel ID
  * @param  Array pointer to a buffer to store the payload of a read back operation.
  * @param  Size  Data size to be read (in byte).
  * @param  Mode  DSI read packet data type.
  *               This parameter can be any value of @ref DSI_SHORT_READ_PKT_Data_Type.
  * @param  DCSCmd  DCS get/read command.
  * @param  ParametersTable  Pointer to parameter values table.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_Read</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>,
                               <parameter><decl><type><name>uint32_t</name></type> <name>ChannelNbr</name></decl></parameter>,
                               <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>Array</name></decl></parameter>,
                               <parameter><decl><type><name>uint32_t</name></type> <name>Size</name></decl></parameter>,
                               <parameter><decl><type><name>uint32_t</name></type> <name>Mode</name></decl></parameter>,
                               <parameter><decl><type><name>uint32_t</name></type> <name>DCSCmd</name></decl></parameter>,
                               <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ParametersTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pdata</name> <init>= <expr><name>Array</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>datasize</name> <init>= <expr><name>Size</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>fifoword</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>nbbytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_READ_PACKET_TYPE</name><argument_list>(<argument><expr><name>Mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;</operator> <literal type="number">2U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* set max return packet size */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DSI_ShortWrite</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>ChannelNbr</name></expr></argument>, <argument><expr><name>DSI_MAX_RETURN_PKT_SIZE</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>datasize</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFU</literal><operator>)</operator></expr></argument>,
                           <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>datasize</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFU</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Configure the packet to read command */</comment>
  <if_stmt><if>if <condition>(<expr><name>Mode</name> <operator>==</operator> <name>DSI_DCS_SHORT_PKT_READ</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>DSI_ConfigPacketHeader</name><argument_list>(<argument><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>ChannelNbr</name></expr></argument>, <argument><expr><name>Mode</name></expr></argument>, <argument><expr><name>DCSCmd</name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Mode</name> <operator>==</operator> <name>DSI_GEN_SHORT_PKT_READ_P0</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>DSI_ConfigPacketHeader</name><argument_list>(<argument><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>ChannelNbr</name></expr></argument>, <argument><expr><name>Mode</name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Mode</name> <operator>==</operator> <name>DSI_GEN_SHORT_PKT_READ_P1</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>DSI_ConfigPacketHeader</name><argument_list>(<argument><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>ChannelNbr</name></expr></argument>, <argument><expr><name>Mode</name></expr></argument>, <argument><expr><name><name>ParametersTable</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Mode</name> <operator>==</operator> <name>DSI_GEN_SHORT_PKT_READ_P2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>DSI_ConfigPacketHeader</name><argument_list>(<argument><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>ChannelNbr</name></expr></argument>, <argument><expr><name>Mode</name></expr></argument>, <argument><expr><name><name>ParametersTable</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ParametersTable</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If DSI fifo is not empty, read requested bytes */</comment>
  <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>datasize</name><operator>)</operator><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GPSR</name></name> <operator>&amp;</operator> <name>DSI_GPSR_PRDFE</name><operator>)</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>fifoword</name> <operator>=</operator> <name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>GPDR</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nbbytes</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>datasize</name> <operator>&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr> ?</condition><then> <expr><name>datasize</name></expr> </then><else>: <expr><literal type="number">4U</literal></expr></else></ternary></expr>;</expr_stmt>

      <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>nbbytes</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pdata</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>fifoword</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">8U</literal> <operator>*</operator> <name>count</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>pdata</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>datasize</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enter the ULPM (Ultra Low Power Mode) with the D-PHY PLL running
  *         (only data lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_EnterULPMData</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ULPS Request on Data Lanes */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PUCR</name></name> <operator>|=</operator> <name>DSI_PUCR_URDL</name></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until the D-PHY active lanes enter into ULPM */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_ONE_DATA_LANE</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <name>DSI_PSR_UAN0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_TWO_DATA_LANES</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UAN1</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Exit the ULPM (Ultra Low Power Mode) with the D-PHY PLL running
  *         (only data lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ExitULPMData</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Exit ULPS on Data Lanes */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PUCR</name></name> <operator>|=</operator> <name>DSI_PUCR_UEDL</name></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until all active lanes exit ULPM */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_ONE_DATA_LANE</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <name>DSI_PSR_UAN0</name><operator>)</operator> <operator>!=</operator> <name>DSI_PSR_UAN0</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_TWO_DATA_LANES</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UAN1</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UAN1</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* wait for 1 ms*/</comment>
  <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><literal type="number">1U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* De-assert the ULPM requests and the ULPM exit bits */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PUCR</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enter the ULPM (Ultra Low Power Mode) with the D-PHY PLL turned off
  *         (both data and clock lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_EnterULPM</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clock lane configuration: no more HS request */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CLCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_CLCR_DPCC</name></expr>;</expr_stmt>

  <comment type="block">/* Use system PLL as byte lane clock source before stopping DSIPHY clock source */</comment>
  <expr_stmt><expr><call><name>__HAL_RCC_DSI_CONFIG</name><argument_list>(<argument><expr><name>RCC_DSICLKSOURCE_PLLR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ULPS Request on Clock and Data Lanes */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PUCR</name></name> <operator>|=</operator> <operator>(</operator><name>DSI_PUCR_URCL</name> <operator>|</operator> <name>DSI_PUCR_URDL</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until all active lanes exit ULPM */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_ONE_DATA_LANE</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UANC</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_TWO_DATA_LANES</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UAN1</name> <operator>|</operator> <name>DSI_PSR_UANC</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Turn off the DSI PLL */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_PLL_DISABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Exit the ULPM (Ultra Low Power Mode) with the D-PHY PLL turned off
  *         (both data and clock lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ExitULPM</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Turn on the DSI PLL */</comment>
  <expr_stmt><expr><call><name>__HAL_DSI_PLL_ENABLE</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for the lock of the PLL */</comment>
  <while>while <condition>(<expr><call><name>__HAL_DSI_GET_FLAG</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>, <argument><expr><name>DSI_FLAG_PLLLS</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Exit ULPS on Clock and Data Lanes */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PUCR</name></name> <operator>|=</operator> <operator>(</operator><name>DSI_PUCR_UECL</name> <operator>|</operator> <name>DSI_PUCR_UEDL</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until all active lanes exit ULPM */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_ONE_DATA_LANE</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UANC</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UANC</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PCONFR</name></name> <operator>&amp;</operator> <name>DSI_PCONFR_NL</name><operator>)</operator> <operator>==</operator> <name>DSI_TWO_DATA_LANES</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PSR</name></name> <operator>&amp;</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UAN1</name> <operator>|</operator> <name>DSI_PSR_UANC</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>DSI_PSR_UAN0</name> <operator>|</operator> <name>DSI_PSR_UAN1</name> <operator>|</operator>
                                                                                    <name>DSI_PSR_UANC</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>DSI_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* wait for 1 ms */</comment>
  <expr_stmt><expr><call><name>HAL_Delay</name><argument_list>(<argument><expr><literal type="number">1U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* De-assert the ULPM requests and the ULPM exit bits */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PUCR</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Switch the lanbyteclock source in the RCC from system PLL to D-PHY */</comment>
  <expr_stmt><expr><call><name>__HAL_RCC_DSI_CONFIG</name><argument_list>(<argument><expr><name>RCC_DSICLKSOURCE_DSIPHY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Restore clock lane configuration to HS */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CLCR</name></name> <operator>|=</operator> <name>DSI_CLCR_DPCC</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start test pattern generation
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Mode  Pattern generator mode
  *          This parameter can be one of the following values:
  *           0 : Color bars (horizontal or vertical)
  *           1 : BER pattern (vertical only)
  * @param  Orientation  Pattern generator orientation
  *          This parameter can be one of the following values:
  *           0 : Vertical color bars
  *           1 : Horizontal color bars
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_PatternGeneratorStart</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Mode</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Orientation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Configure pattern generator mode and orientation */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DSI_VMCR_PGM</name> <operator>|</operator> <name>DSI_VMCR_PGO</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>Mode</name> <operator>&lt;&lt;</operator> <literal type="number">20U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>Orientation</name> <operator>&lt;&lt;</operator> <literal type="number">24U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Enable pattern generator by setting PGE bit */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>|=</operator> <name>DSI_VMCR_PGE</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop test pattern generation
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_PatternGeneratorStop</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable pattern generator by clearing PGE bit */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>VMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_VMCR_PGE</name></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Set Slew-Rate And Delay Tuning
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  CommDelay  Communication delay to be adjusted.
  *                    This parameter can be any value of @ref DSI_Communication_Delay
  * @param  Lane  select between clock or data lanes.
  *               This parameter can be any value of @ref DSI_Lane_Group
  * @param  Value  Custom value of the slew-rate or delay
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetSlewRateAndDelayTuning</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>CommDelay</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Lane</name></decl></parameter>,
                                                    <parameter><decl><type><name>uint32_t</name></type> <name>Value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_COMMUNICATION_DELAY</name><argument_list>(<argument><expr><name>CommDelay</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LANE_GROUP</name><argument_list>(<argument><expr><name>Lane</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>CommDelay</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>DSI_SLEW_RATE_HSTX</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_CLOCK_LANE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* High-Speed Transmission Slew Rate Control on Clock Lane */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_HSTXSRCCL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANES</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* High-Speed Transmission Slew Rate Control on Data Lanes */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_HSTXSRCDL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">18U</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>DSI_SLEW_RATE_LPTX</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_CLOCK_LANE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Low-Power transmission Slew Rate Compensation on Clock Lane */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_LPSRCCL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">6U</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANES</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Low-Power transmission Slew Rate Compensation on Data Lanes */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_LPSRCDL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>DSI_HS_DELAY</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_CLOCK_LANE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* High-Speed Transmission Delay on Clock Lane */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_HSTXDCL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANES</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* High-Speed Transmission Delay on Data Lanes */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_HSTXDDL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">2U</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Low-Power Reception Filter Tuning
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Frequency  cutoff frequency of low-pass filter at the input of LPRX
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetLowPowerRXFilter</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Frequency</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Low-Power RX low-pass Filtering Tuning */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_LPRXFT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <name>Frequency</name> <operator>&lt;&lt;</operator> <literal type="number">25U</literal></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Activate an additional current path on all lanes to meet the SDDTx parameter
  *         defined in the MIPI D-PHY specification
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetSDD</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Activate/Disactivate additional current path on all lanes */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_SDDC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Custom lane pins configuration
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  CustomLane  Function to be applyed on selected lane.
  *                     This parameter can be any value of @ref DSI_CustomLane
  * @param  Lane  select between clock or data lane 0 or data lane 1.
  *               This parameter can be any value of @ref DSI_Lane_Select
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetLanePinsConfiguration</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>CustomLane</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Lane</name></decl></parameter>,
                                                   <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_CUSTOM_LANE</name><argument_list>(<argument><expr><name>CustomLane</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LANE</name><argument_list>(<argument><expr><name>Lane</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>CustomLane</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>DSI_SWAP_LANE_PINS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_CLK_LANE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Swap pins on clock lane */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_SWCL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">6U</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANE0</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Swap pins on data lane 0 */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_SWDL0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">7U</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANE1</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Swap pins on data lane 1 */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_SWDL1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>DSI_INVERT_HS_SIGNAL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_CLK_LANE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Invert HS signal on clock lane */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_HSICL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">9U</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANE0</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Invert HS signal on data lane 0 */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_HSIDL0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">10U</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANE1</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Invert HS signal on data lane 1 */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_HSIDL1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">11U</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Set custom timing for the PHY
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Timing  PHY timing to be adjusted.
  *                 This parameter can be any value of @ref DSI_PHY_Timing
  * @param  State  ENABLE or DISABLE
  * @param  Value  Custom value of the timing
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetPHYTimings</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timing</name></decl></parameter>, <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_PHY_TIMING</name><argument_list>(<argument><expr><name>Timing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Timing</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>DSI_TCLK_POST</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_TCLKPOSTEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">27U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">4U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR4_TCLKPOST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">4U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&amp;</operator> <name>DSI_WPCR4_TCLKPOST</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_TLPX_CLK</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_TLPXCEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">26U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR3_TLPXC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">24U</literal><operator>)</operator> <operator>&amp;</operator> <name>DSI_WPCR3_TLPXC</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_THS_EXIT</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_THSEXITEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">25U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR3_THSEXIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>&amp;</operator> <name>DSI_WPCR3_THSEXIT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_TLPX_DATA</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_TLPXDEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">24U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR3_TLPXD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>&amp;</operator> <name>DSI_WPCR3_TLPXD</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_THS_ZERO</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_THSZEROEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">23U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR3_THSZERO</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">3U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&amp;</operator> <name>DSI_WPCR3_THSZERO</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_THS_TRAIL</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_THSTRAILEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">22U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR2_THSTRAIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">24U</literal><operator>)</operator> <operator>&amp;</operator> <name>DSI_WPCR2_THSTRAIL</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_THS_PREPARE</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_THSPREPEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">21U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR2_THSPREP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>&amp;</operator> <name>DSI_WPCR2_THSPREP</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_TCLK_ZERO</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_TCLKZEROEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">20U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR2_TCLKZERO</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>Value</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>&amp;</operator> <name>DSI_WPCR2_TCLKZERO</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <case>case <expr><name>DSI_TCLK_PREPARE</name></expr>:</case>
      <comment type="block">/* Enable/Disable custom timing setting */</comment>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_TCLKPREPEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">19U</literal><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>State</name> <operator>!=</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set custom value */</comment>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR2_TCLKPREP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">2U</literal></expr>]</index></name> <operator>|=</operator> <name>Value</name> <operator>&amp;</operator> <name>DSI_WPCR2_TCLKPREP</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Force the Clock/Data Lane in TX Stop Mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Lane  select between clock or data lanes.
  *               This parameter can be any value of @ref DSI_Lane_Group
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ForceTXStopMode</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Lane</name></decl></parameter>, <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DSI_LANE_GROUP</name><argument_list>(<argument><expr><name>Lane</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_CLOCK_LANE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Force/Unforce the Clock Lane in TX Stop Mode */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_FTXSMCL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Lane</name> <operator>==</operator> <name>DSI_DATA_LANES</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Force/Unforce the Data Lanes in TX Stop Mode */</comment>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_FTXSMDL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">13U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Force LP Receiver in Low-Power Mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ForceRXLowPower</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Force/Unforce LP Receiver in Low-Power Mode */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR1_FLPRXLPM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">1U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">22U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Force Data Lanes in RX Mode after a BTA
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_ForceDataLanesInRX</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Force Data Lanes in RX Mode */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_TDDL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable a pull-down on the lanes to prevent from floating states when unused
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetPullDown</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable/Disable pull-down on lanes */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_PDEN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">18U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Switch off the contention detection on data lanes
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DSI_SetContentionDetectionOff</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>, <parameter><decl><type><name>FunctionalState</name></type> <name>State</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Contention Detection on Data Lanes OFF */</comment>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>DSI_WPCR0_CDOFFDL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdsi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>WPCR</name><index>[<expr><literal type="number">0U</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>State</name> <operator>&lt;&lt;</operator> <literal type="number">14U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DSI_Group4 Peripheral State and Errors functions
  *  @brief    Peripheral State and Errors functions
  *
@verbatim
 ===============================================================================
                  ##### Peripheral State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides functions allowing to
      (+) Check the DSI state.
      (+) Get error code.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the DSI state
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_DSI_StateTypeDef</name></type> <name>HAL_DSI_GetState</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hdsi</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the DSI error code
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval DSI Error Code
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_DSI_GetError</name><parameter_list>(<parameter><decl><type><name>DSI_HandleTypeDef</name> <modifier>*</modifier></type><name>hdsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Get the error code */</comment>
  <return>return <expr><name><name>hdsi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DSI */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_DSI_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
