<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_tim.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_tim.c
  * @author  MCD Application Team
  * @brief   TIM HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Timer (TIM) peripheral:
  *           + TIM Time Base Initialization
  *           + TIM Time Base Start
  *           + TIM Time Base Start Interruption
  *           + TIM Time Base Start DMA
  *           + TIM Output Compare/PWM Initialization
  *           + TIM Output Compare/PWM Channel Configuration
  *           + TIM Output Compare/PWM  Start
  *           + TIM Output Compare/PWM  Start Interruption
  *           + TIM Output Compare/PWM Start DMA
  *           + TIM Input Capture Initialization
  *           + TIM Input Capture Channel Configuration
  *           + TIM Input Capture Start
  *           + TIM Input Capture Start Interruption
  *           + TIM Input Capture Start DMA
  *           + TIM One Pulse Initialization
  *           + TIM One Pulse Channel Configuration
  *           + TIM One Pulse Start
  *           + TIM Encoder Interface Initialization
  *           + TIM Encoder Interface Start
  *           + TIM Encoder Interface Start Interruption
  *           + TIM Encoder Interface Start DMA
  *           + Commutation Event configuration with Interruption and DMA
  *           + TIM OCRef clear configuration
  *           + TIM External Clock configuration
  @verbatim
  ==============================================================================
                      ##### TIMER Generic features #####
  ==============================================================================
  [..] The Timer features include:
       (#) 16-bit up, down, up/down auto-reload counter.
       (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
           counter clock frequency either by any factor between 1 and 65536.
       (#) Up to 4 independent channels for:
           (++) Input Capture
           (++) Output Compare
           (++) PWM generation (Edge and Center-aligned Mode)
           (++) One-pulse mode output
       (#) Synchronization circuit to control the timer with external signals and to interconnect
            several timers together.
       (#) Supports incremental encoder for positioning purposes

            ##### How to use this driver #####
  ==============================================================================
    [..]
     (#) Initialize the TIM low level resources by implementing the following functions
         depending on the selected feature:
           (++) Time Base : HAL_TIM_Base_MspInit()
           (++) Input Capture : HAL_TIM_IC_MspInit()
           (++) Output Compare : HAL_TIM_OC_MspInit()
           (++) PWM generation : HAL_TIM_PWM_MspInit()
           (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
           (++) Encoder mode output : HAL_TIM_Encoder_MspInit()

     (#) Initialize the TIM low level resources :
        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
        (##) TIM pins configuration
            (+++) Enable the clock for the TIM GPIOs using the following function:
             __HAL_RCC_GPIOx_CLK_ENABLE();
            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();

     (#) The external Clock can be configured, if needed (the default clock is the
         internal clock from the APBx), using the following function:
         HAL_TIM_ConfigClockSource, the clock configuration should be done before
         any start function.

     (#) Configure the TIM in the desired functioning mode using one of the
       Initialization function of this driver:
       (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
       (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
            Output Compare signal.
       (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
            PWM signal.
       (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
            external signal.
       (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
            in One Pulse Mode.
       (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.

     (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
           (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
           (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
           (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
           (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
           (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
           (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().

     (#) The DMA Burst is managed with the two following functions:
         HAL_TIM_DMABurst_WriteStart()
         HAL_TIM_DMABurst_ReadStart()

    *** Callback registration ***
  =============================================

  The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
  allows the user to configure dynamically the driver callbacks.

  Use Function @ref HAL_TIM_RegisterCallback() to register a callback.
  @ref HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
  the Callback ID and a pointer to the user callback function.

  Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
  weak function.
  @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.

  These functions allow to register/unregister following callbacks:
    (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    (+) TriggerCallback                   : TIM Trigger Callback.
    (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    (+) IC_CaptureCallback                : TIM Input Capture Callback.
    (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    (+) ErrorCallback                     : TIM Error Callback.
    (+) CommutationCallback               : TIM Commutation Callback.
    (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    (+) BreakCallback                     : TIM Break Callback.

By default, after the Init and when the state is HAL_TIM_STATE_RESET
all interrupt callbacks are set to the corresponding weak functions:
  examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().

  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
  functionalities in the Init / DeInit only when these callbacks are null
  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    keep and use the user MspInit / MspDeInit callbacks(registered beforehand)

    Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    Exception done MspInit / MspDeInit that can be registered / unregistered
    in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.

      When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
      not defined, the callback registration feature is not available and all callbacks
      are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM TIM
  * @brief TIM HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_TIM_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup TIM_Private_Functions
  * @{
  */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_OC1_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>OC_Config</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_OC3_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>OC_Config</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_OC4_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>OC_Config</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI1_ConfigInputStage</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI2_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICSelection</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI2_ConfigInputStage</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI3_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICSelection</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI4_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICSelection</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_ITRx_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>InputTriggerSource</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMAPeriodElapsedCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMAPeriodElapsedHalfCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMATriggerCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMATriggerHalfCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>TIM_SlaveTimer_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,
                                     <parameter><decl><type><name>TIM_SlaveConfigTypeDef</name> <modifier>*</modifier></type><name>sSlaveConfig</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions TIM Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
 *  @brief    Time Base functions
 *
@verbatim
  ==============================================================================
              ##### Time Base functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM base.
    (+) De-initialize the TIM base.
    (+) Start the Time Base.
    (+) Stop the Time Base.
    (+) Start the Time Base and enable interrupt.
    (+) Stop the Time Base and disable interrupt.
    (+) Start the Time Base and enable DMA transfer.
    (+) Stop the Time Base and disable DMA transfer.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Time base Unit according to the specified
  *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_Init</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the TIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>htim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_COUNTER_MODE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKDIVISION_DIV</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockDivision</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_AUTORELOAD_PRELOAD</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoReloadPreload</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Reset interrupt callbacks to legacy weak callbacks */</comment>
    <expr_stmt><expr><call><name>TIM_ResetCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_Base_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>Base_MspInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name>HAL_TIM_Base_MspInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Set the Time Base configuration */</comment>
  <expr_stmt><expr><call><name>TIM_Base_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the TIM Base peripheral
  * @param  htim TIM Base handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_DeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_Base_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>Base_MspDeInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name>HAL_TIM_Base_MspDeInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_Base_MspInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_Base_MspDeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_Start</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_Stop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_Start_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the TIM Update interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_Stop_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Disable the TIM Update interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Base generation in DMA mode.
  * @param  htim TIM Base handle
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to peripheral.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_Start_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_BUSY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Length</name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the DMA Period elapsed callbacks */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMAPeriodElapsedCplt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMAPeriodElapsedHalfCplt</name></expr>;</expr_stmt>

  <comment type="block">/* Set the DMA error callback */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

  <comment type="block">/* Enable the DMA stream */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ARR</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the TIM Update DMA request */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Base generation in DMA mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Base_Stop_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Update DMA request */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the htim state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
 *  @brief    TIM Output Compare functions
 *
@verbatim
  ==============================================================================
                  ##### TIM Output Compare functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM Output Compare.
    (+) De-initialize the TIM Output Compare.
    (+) Start the TIM Output Compare.
    (+) Stop the TIM Output Compare.
    (+) Start the TIM Output Compare and enable interrupt.
    (+) Stop the TIM Output Compare and disable interrupt.
    (+) Start the TIM Output Compare and enable DMA transfer.
    (+) Stop the TIM Output Compare and disable DMA transfer.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Output Compare according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_Init</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the TIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>htim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_COUNTER_MODE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKDIVISION_DIV</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockDivision</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_AUTORELOAD_PRELOAD</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoReloadPreload</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Reset interrupt callbacks to legacy weak callbacks */</comment>
    <expr_stmt><expr><call><name>TIM_ResetCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_OC_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OC_MspInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */</comment>
    <expr_stmt><expr><call><name>HAL_TIM_OC_MspInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Init the base time for the Output Compare */</comment>
  <expr_stmt><expr><call><name>TIM_Base_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_DeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_OC_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OC_MspDeInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */</comment>
  <expr_stmt><expr><call><name>HAL_TIM_OC_MspDeInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_OC_MspInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_OC_MspDeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Output Compare signal generation.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_Start</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Output compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Output Compare signal generation.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_Stop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Output compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_Start_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 1 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 2 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 3 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Enable the Output compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_Stop_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 1 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 2 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 3 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Disable the Output compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Output Compare signal generation in DMA mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_Start_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_BUSY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Length</name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR1</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Enable the TIM Capture/Compare 1 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR2</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Enable the TIM Capture/Compare 2 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR3</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 3 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR4</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 4 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Enable the Output compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Output Compare signal generation in DMA mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_Stop_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 1 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 2 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 3 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Disable the Output compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the htim state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
 *  @brief    TIM PWM functions
 *
@verbatim
  ==============================================================================
                          ##### TIM PWM functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM PWM.
    (+) De-initialize the TIM PWM.
    (+) Start the TIM PWM.
    (+) Stop the TIM PWM.
    (+) Start the TIM PWM and enable interrupt.
    (+) Stop the TIM PWM and disable interrupt.
    (+) Start the TIM PWM and enable DMA transfer.
    (+) Stop the TIM PWM and disable DMA transfer.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM PWM Time Base according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_Init</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the TIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>htim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_COUNTER_MODE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKDIVISION_DIV</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockDivision</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_AUTORELOAD_PRELOAD</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoReloadPreload</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Reset interrupt callbacks to legacy weak callbacks */</comment>
    <expr_stmt><expr><call><name>TIM_ResetCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_PWM_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */</comment>
    <expr_stmt><expr><call><name>HAL_TIM_PWM_MspInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Init the base time for the PWM */</comment>
  <expr_stmt><expr><call><name>TIM_Base_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM PWM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_DeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_PWM_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspDeInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */</comment>
  <expr_stmt><expr><call><name>HAL_TIM_PWM_MspDeInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_PWM_MspInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_PWM_MspDeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the PWM signal generation.
  * @param  htim TIM handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_Start</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Capture compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the PWM signal generation.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_Stop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Capture compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the htim state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the PWM signal generation in interrupt mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_Start_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 1 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 2 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 3 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Enable the Capture compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the PWM signal generation in interrupt mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_Stop_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 1 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 2 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 3 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Disable the Capture compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM PWM signal generation in DMA mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_Start_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_BUSY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Length</name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR1</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Enable the TIM Capture/Compare 1 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR2</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 2 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR3</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Output Capture/Compare 3 request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR4</name></name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 4 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Enable the Capture compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM PWM signal generation in DMA mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_Stop_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 1 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 2 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 3 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Disable the Capture compare channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the htim state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
 *  @brief    TIM Input Capture functions
 *
@verbatim
  ==============================================================================
              ##### TIM Input Capture functions #####
  ==============================================================================
 [..]
   This section provides functions allowing to:
   (+) Initialize and configure the TIM Input Capture.
   (+) De-initialize the TIM Input Capture.
   (+) Start the TIM Input Capture.
   (+) Stop the TIM Input Capture.
   (+) Start the TIM Input Capture and enable interrupt.
   (+) Stop the TIM Input Capture and disable interrupt.
   (+) Start the TIM Input Capture and enable DMA transfer.
   (+) Stop the TIM Input Capture and disable DMA transfer.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Input Capture Time base according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
  * @param  htim TIM Input Capture handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_Init</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the TIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>htim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_COUNTER_MODE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKDIVISION_DIV</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockDivision</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_AUTORELOAD_PRELOAD</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoReloadPreload</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Reset interrupt callbacks to legacy weak callbacks */</comment>
    <expr_stmt><expr><call><name>TIM_ResetCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_IC_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_MspInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */</comment>
    <expr_stmt><expr><call><name>HAL_TIM_IC_MspInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Init the base time for the input capture */</comment>
  <expr_stmt><expr><call><name>TIM_Base_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Input Capture handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_DeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_IC_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_MspDeInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */</comment>
  <expr_stmt><expr><call><name>HAL_TIM_IC_MspDeInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Input Capture MSP.
  * @param  htim TIM Input Capture handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_IC_MspInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes TIM Input Capture MSP.
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_IC_MspDeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Input Capture measurement.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_Start</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Input Capture channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Input Capture measurement.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_Stop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Input Capture channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Input Capture measurement in interrupt mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_Start_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 1 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 2 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 3 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Enable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <comment type="block">/* Enable the Input Capture channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Input Capture measurement in interrupt mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_Stop_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 1 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 2 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 3 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 4 interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Disable the Input Capture channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Input Capture measurement in DMA mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  pData The destination Buffer address.
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_Start_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_CC_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_BUSY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Length</name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 1 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 2  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR3</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 3  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR4</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Capture/Compare 4  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Enable the Input Capture channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;</operator> <name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIM_SLAVEMODE_TRIGGER_ENABLED</name><argument_list>(<argument><expr><name>tmpsmcr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Input Capture measurement in DMA mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_Stop_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CCX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_CC_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 1 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 2 DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 3  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Disable the TIM Capture/Compare 4  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Disable the Input Capture channel */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>Channel</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the htim state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
 *  @brief    TIM One Pulse functions
 *
@verbatim
  ==============================================================================
                        ##### TIM One Pulse functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM One Pulse.
    (+) De-initialize the TIM One Pulse.
    (+) Start the TIM One Pulse.
    (+) Stop the TIM One Pulse.
    (+) Start the TIM One Pulse and enable interrupt.
    (+) Stop the TIM One Pulse and disable interrupt.
    (+) Start the TIM One Pulse and enable DMA transfer.
    (+) Stop the TIM One Pulse and disable DMA transfer.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM One Pulse Time Base according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
  * @param  htim TIM One Pulse handle
  * @param  OnePulseMode Select the One pulse mode.
  *         This parameter can be one of the following values:
  *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
  *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OnePulse_Init</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>OnePulseMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the TIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>htim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_COUNTER_MODE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKDIVISION_DIV</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockDivision</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OPM_MODE</name><argument_list>(<argument><expr><name>OnePulseMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_AUTORELOAD_PRELOAD</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoReloadPreload</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Reset interrupt callbacks to legacy weak callbacks */</comment>
    <expr_stmt><expr><call><name>TIM_ResetCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_OnePulse_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */</comment>
    <expr_stmt><expr><call><name>HAL_TIM_OnePulse_MspInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Configure the Time base in the One Pulse Mode */</comment>
  <expr_stmt><expr><call><name>TIM_Base_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the OPM Bit */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR1_OPM</name></expr>;</expr_stmt>

  <comment type="block">/* Configure the OPM Mode */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>|=</operator> <name>OnePulseMode</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the TIM One Pulse
  * @param  htim TIM One Pulse handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OnePulse_DeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_OnePulse_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspDeInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name>HAL_TIM_OnePulse_MspDeInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM One Pulse MSP.
  * @param  htim TIM One Pulse handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_OnePulse_MspInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes TIM One Pulse MSP.
  * @param  htim TIM One Pulse handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_OnePulse_MspDeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM One Pulse signal generation.
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OnePulse_Start</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>OutputChannel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>OutputChannel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Capture compare and the Input Capture channels
    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
    in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together

    No need to enable the counter, it's enabled automatically by hardware
    (the counter starts in response to a stimulus and generate a pulse */</comment>

  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM One Pulse signal generation.
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel TIM Channels to be disable
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OnePulse_Stop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>OutputChannel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>OutputChannel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Capture compare and the Input Capture channels
  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
  in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */</comment>

  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OnePulse_Start_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>OutputChannel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>OutputChannel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Capture compare and the Input Capture channels
    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
    in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together

    No need to enable the counter, it's enabled automatically by hardware
    (the counter starts in response to a stimulus and generate a pulse */</comment>

  <comment type="block">/* Enable the TIM Capture/Compare 1 interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the TIM Capture/Compare 2 interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the main output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OnePulse_Stop_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>OutputChannel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>OutputChannel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Capture/Compare 1 interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Capture/Compare 2 interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Capture compare and the Input Capture channels
  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
  in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */</comment>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the Main Output */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_MOE_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
 *  @brief    TIM Encoder functions
 *
@verbatim
  ==============================================================================
                          ##### TIM Encoder functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM Encoder.
    (+) De-initialize the TIM Encoder.
    (+) Start the TIM Encoder.
    (+) Stop the TIM Encoder.
    (+) Start the TIM Encoder and enable interrupt.
    (+) Stop the TIM Encoder and disable interrupt.
    (+) Start the TIM Encoder and enable DMA transfer.
    (+) Stop the TIM Encoder and disable DMA transfer.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
  * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
  *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
  *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
  * @param  htim TIM Encoder Interface handle
  * @param  sConfig TIM Encoder Interface configuration structure
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_Init</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,  <parameter><decl><type><name>TIM_Encoder_InitTypeDef</name> <modifier>*</modifier></type><name>sConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Check the TIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>htim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_COUNTER_MODE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKDIVISION_DIV</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockDivision</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_AUTORELOAD_PRELOAD</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoReloadPreload</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_ENCODER_MODE</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>EncoderMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_SELECTION</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC1Selection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_SELECTION</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Selection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_POLARITY</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC1Polarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_POLARITY</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Polarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_PRESCALER</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC1Prescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_PRESCALER</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Prescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_FILTER</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC1Filter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_FILTER</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Filter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Reset interrupt callbacks to legacy weak callbacks */</comment>
    <expr_stmt><expr><call><name>TIM_ResetCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_Encoder_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */</comment>
    <expr_stmt><expr><call><name>HAL_TIM_Encoder_MspInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Reset the SMS and ECE bits */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_SMCR_SMS</name> <operator>|</operator> <name>TIM_SMCR_ECE</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Configure the Time base in the Encoder Mode */</comment>
  <expr_stmt><expr><call><name>TIM_Base_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx SMCR register value */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCMR1 register value */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCER register value */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the encoder Mode */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>EncoderMode</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the Capture Compare 1 and the Capture Compare 2 as input */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCMR1_CC1S</name> <operator>|</operator> <name>TIM_CCMR1_CC2S</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>IC1Selection</name></name> <operator>|</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Selection</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCMR1_IC1PSC</name> <operator>|</operator> <name>TIM_CCMR1_IC2PSC</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCMR1_IC1F</name> <operator>|</operator> <name>TIM_CCMR1_IC2F</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>IC1Prescaler</name></name> <operator>|</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Prescaler</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>IC1Filter</name></name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Filter</name></name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set the TI1 and the TI2 Polarities */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC1P</name> <operator>|</operator> <name>TIM_CCER_CC2P</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC1NP</name> <operator>|</operator> <name>TIM_CCER_CC2NP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>IC1Polarity</name></name> <operator>|</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>IC2Polarity</name></name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx SMCR */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>=</operator> <name>tmpsmcr</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR1 */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmr1</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCER */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize the TIM state*/</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the TIM Encoder interface
  * @param  htim TIM Encoder Interface handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_DeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the TIM Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_TIM_Encoder_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DeInit the low level hardware */</comment>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspDeInitCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name>HAL_TIM_Encoder_MspDeInit</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Encoder Interface MSP.
  * @param  htim TIM Encoder Interface handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_Encoder_MspInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Encoder_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes TIM Encoder Interface MSP.
  * @param  htim TIM Encoder Interface handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_Encoder_MspDeInit</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Encoder Interface.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_Start</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the encoder interface channels */</comment>
  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default :</default>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Encoder Interface.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_Stop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Input Capture channels 1 and 2
    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */</comment>
  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default :</default>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Encoder Interface in interrupt mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_Start_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the encoder interface channels */</comment>
  <comment type="block">/* Enable the capture compare Interrupts 1 and/or 2 */</comment>
  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default :</default>
    <block>{<block_content>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Encoder Interface in interrupt mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_Stop_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Input Capture channels 1 and 2
    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */</comment>
  <if_stmt><if>if <condition>(<expr><name>Channel</name> <operator>==</operator> <name>TIM_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable the capture compare Interrupts 1 */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Channel</name> <operator>==</operator> <name>TIM_CHANNEL_2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable the capture compare Interrupts 2 */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable the capture compare Interrupts 1 and 2 */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the htim state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Starts the TIM Encoder Interface in DMA mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @param  pData1 The destination Buffer address for IC1.
  * @param  pData2 The destination Buffer address for IC2.
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_Start_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pData1</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pData2</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_CC_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_BUSY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>pData1</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pData2</name> <operator>==</operator> <name>NULL</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Length</name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData1</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Input Capture DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable the Peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable the Capture compare channel */</comment>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr>;</expr_stmt>
      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData2</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the TIM Input Capture  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable the Peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable the Capture compare channel */</comment>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_ALL</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData1</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData2</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Enable the Peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable the Capture compare channel */</comment>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable the TIM Input Capture  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Enable the TIM Input Capture  DMA request */</comment>
      <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM Encoder Interface in DMA mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_Encoder_Stop_DMA</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_CC_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Input Capture channels 1 and 2
    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */</comment>
  <if_stmt><if>if <condition>(<expr><name>Channel</name> <operator>==</operator> <name>TIM_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable the capture compare DMA Request 1 */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Channel</name> <operator>==</operator> <name>TIM_CHANNEL_2</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable the capture compare DMA Request 2 */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TIM_CCxChannelCmd</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>, <argument><expr><name>TIM_CCx_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable the capture compare DMA Request 1 and 2 */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the htim state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
 *  @brief    TIM IRQ handler management
 *
@verbatim
  ==============================================================================
                        ##### IRQ handler management #####
  ==============================================================================
  [..]
    This section provides Timer IRQ handler function.

@endverbatim
  * @{
  */</comment>
<comment type="block" format="doxygen">/**
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_TIM_IRQHandler</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Capture compare 1 event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_CC1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <block>{<block_content>
        <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_1</name></expr>;</expr_stmt>

        <comment type="block">/* Input capture event */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;</operator> <name>TIM_CCMR1_CC1S</name><operator>)</operator> <operator>!=</operator> <literal type="number">0x00U</literal></expr>)</condition>
        <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
          <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>HAL_TIM_IC_CaptureCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
        </block_content>}</block></if>
        <comment type="block">/* Output compare event */</comment>
        <else>else
        <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
          <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OC_DelayElapsedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>HAL_TIM_OC_DelayElapsedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>HAL_TIM_PWM_PulseFinishedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
      </block_content>}</block>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Capture compare 2 event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_CC2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_2</name></expr>;</expr_stmt>
      <comment type="block">/* Input capture event */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;</operator> <name>TIM_CCMR1_CC2S</name><operator>)</operator> <operator>!=</operator> <literal type="number">0x00U</literal></expr>)</condition>
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_TIM_IC_CaptureCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <comment type="block">/* Output compare event */</comment>
      <else>else
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OC_DelayElapsedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_TIM_OC_DelayElapsedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HAL_TIM_PWM_PulseFinishedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Capture compare 3 event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_CC3</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_3</name></expr>;</expr_stmt>
      <comment type="block">/* Input capture event */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>&amp;</operator> <name>TIM_CCMR2_CC3S</name><operator>)</operator> <operator>!=</operator> <literal type="number">0x00U</literal></expr>)</condition>
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_TIM_IC_CaptureCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <comment type="block">/* Output compare event */</comment>
      <else>else
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OC_DelayElapsedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_TIM_OC_DelayElapsedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HAL_TIM_PWM_PulseFinishedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Capture compare 4 event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_CC4</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_CC4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_4</name></expr>;</expr_stmt>
      <comment type="block">/* Input capture event */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>&amp;</operator> <name>TIM_CCMR2_CC4S</name><operator>)</operator> <operator>!=</operator> <literal type="number">0x00U</literal></expr>)</condition>
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_TIM_IC_CaptureCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <comment type="block">/* Output compare event */</comment>
      <else>else
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>OC_DelayElapsedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_TIM_OC_DelayElapsedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HAL_TIM_PWM_PulseFinishedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* TIM Update event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_UPDATE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_UPDATE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_TIM_PeriodElapsedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* TIM Break input event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_BREAK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_BREAK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_BREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>BreakCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_TIMEx_BreakCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* TIM Trigger detection event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_TRIGGER</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_TRIGGER</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>TriggerCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_TIM_TriggerCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* TIM commutation event */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_FLAG</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_COM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_TIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_COM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_TIM_CLEAR_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_FLAG_COM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>CommutationCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_TIMEx_CommutCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
 *  @brief    TIM Peripheral Control functions
 *
@verbatim
  ==============================================================================
                   ##### Peripheral Control functions #####
  ==============================================================================
 [..]
   This section provides functions allowing to:
      (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
      (+) Configure External Clock source.
      (+) Configure Complementary channels, break features and dead time.
      (+) Configure Master and the Slave synchronization.
      (+) Configure the DMA Burst Mode.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Output Compare Channels according to the specified
  *         parameters in the TIM_OC_InitTypeDef.
  * @param  htim TIM Output Compare handle
  * @param  sConfig TIM Output Compare configuration structure
  * @param  Channel TIM Channels to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OC_ConfigChannel</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,
                                           <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>sConfig</name></decl></parameter>,
                                           <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CHANNELS</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OC_MODE</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>OCMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OC_POLARITY</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>OCPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the TIM Channel 1 in Output Compare */</comment>
      <expr_stmt><expr><call><name>TIM_OC1_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the TIM Channel 2 in Output Compare */</comment>
      <expr_stmt><expr><call><name>TIM_OC2_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC3_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the TIM Channel 3 in Output Compare */</comment>
      <expr_stmt><expr><call><name>TIM_OC3_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC4_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the TIM Channel 4 in Output Compare */</comment>
      <expr_stmt><expr><call><name>TIM_OC4_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM Input Capture Channels according to the specified
  *         parameters in the TIM_IC_InitTypeDef.
  * @param  htim TIM IC handle
  * @param  sConfig TIM Input Capture configuration structure
  * @param  Channel TIM Channel to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_IC_ConfigChannel</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>TIM_IC_InitTypeDef</name> <modifier>*</modifier></type><name>sConfig</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_POLARITY</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_SELECTION</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICSelection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_PRESCALER</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPrescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_IC_FILTER</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>Channel</name> <operator>==</operator> <name>TIM_CHANNEL_1</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* TI1 Configuration */</comment>
    <expr_stmt><expr><call><name>TIM_TI1_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPolarity</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICSelection</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the IC1PSC Bits */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC1PSC</name></expr>;</expr_stmt>

    <comment type="block">/* Set the IC1PSC value */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>ICPrescaler</name></name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Channel</name> <operator>==</operator> <name>TIM_CHANNEL_2</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* TI2 Configuration */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TIM_TI2_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPolarity</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICSelection</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the IC2PSC Bits */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC2PSC</name></expr>;</expr_stmt>

    <comment type="block">/* Set the IC2PSC value */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>|=</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>ICPrescaler</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>Channel</name> <operator>==</operator> <name>TIM_CHANNEL_3</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* TI3 Configuration */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC3_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TIM_TI3_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPolarity</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICSelection</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the IC3PSC Bits */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_IC3PSC</name></expr>;</expr_stmt>

    <comment type="block">/* Set the IC3PSC value */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>ICPrescaler</name></name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* TI4 Configuration */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC4_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TIM_TI4_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPolarity</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICSelection</name></name></expr></argument>,
                      <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the IC4PSC Bits */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_IC4PSC</name></expr>;</expr_stmt>

    <comment type="block">/* Set the IC4PSC value */</comment>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>|=</operator> <operator>(</operator><name><name>sConfig</name><operator>-&gt;</operator><name>ICPrescaler</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM PWM  channels according to the specified
  *         parameters in the TIM_OC_InitTypeDef.
  * @param  htim TIM PWM handle
  * @param  sConfig TIM PWM configuration structure
  * @param  Channel TIM Channels to be configured
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_PWM_ConfigChannel</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,
                                            <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>sConfig</name></decl></parameter>,
                                            <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CHANNELS</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_PWM_MODE</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>OCMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OC_POLARITY</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>OCPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_FAST_STATE</name><argument_list>(<argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>OCFastMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the Channel 1 in PWM mode */</comment>
      <expr_stmt><expr><call><name>TIM_OC1_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the Preload enable bit for channel1 */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>|=</operator> <name>TIM_CCMR1_OC1PE</name></expr>;</expr_stmt>

      <comment type="block">/* Configure the Output Fast mode */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_OC1FE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCFastMode</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the Channel 2 in PWM mode */</comment>
      <expr_stmt><expr><call><name>TIM_OC2_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the Preload enable bit for channel2 */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>|=</operator> <name>TIM_CCMR1_OC2PE</name></expr>;</expr_stmt>

      <comment type="block">/* Configure the Output Fast mode */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_OC2FE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCFastMode</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC3_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the Channel 3 in PWM mode */</comment>
      <expr_stmt><expr><call><name>TIM_OC3_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the Preload enable bit for channel3 */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>|=</operator> <name>TIM_CCMR2_OC3PE</name></expr>;</expr_stmt>

      <comment type="block">/* Configure the Output Fast mode */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_OC3FE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCFastMode</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC4_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the Channel 4 in PWM mode */</comment>
      <expr_stmt><expr><call><name>TIM_OC4_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>sConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the Preload enable bit for channel4 */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>|=</operator> <name>TIM_CCMR2_OC4PE</name></expr>;</expr_stmt>

      <comment type="block">/* Configure the Output Fast mode */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_OC4FE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>|=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCFastMode</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the TIM One Pulse Channels according to the specified
  *         parameters in the TIM_OnePulse_InitTypeDef.
  * @param  htim TIM One Pulse handle
  * @param  sConfig TIM One Pulse configuration structure
  * @param  OutputChannel TIM output channel to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @param  InputChannel TIM input Channel to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_OnePulse_ConfigChannel</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,  <parameter><decl><type><name>TIM_OnePulse_InitTypeDef</name> <modifier>*</modifier></type><name>sConfig</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>OutputChannel</name></decl></parameter>,  <parameter><decl><type><name>uint32_t</name></type> <name>InputChannel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_OC_InitTypeDef</name></type> <name>temp1</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OPM_CHANNELS</name><argument_list>(<argument><expr><name>OutputChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OPM_CHANNELS</name><argument_list>(<argument><expr><name>InputChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>OutputChannel</name> <operator>!=</operator> <name>InputChannel</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

    <comment type="block">/* Extract the Output compare configuration from sConfig structure */</comment>
    <expr_stmt><expr><name><name>temp1</name><operator>.</operator><name>OCMode</name></name> <operator>=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCMode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp1</name><operator>.</operator><name>Pulse</name></name> <operator>=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>Pulse</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp1</name><operator>.</operator><name>OCPolarity</name></name> <operator>=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCPolarity</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp1</name><operator>.</operator><name>OCNPolarity</name></name> <operator>=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCNPolarity</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp1</name><operator>.</operator><name>OCIdleState</name></name> <operator>=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCIdleState</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp1</name><operator>.</operator><name>OCNIdleState</name></name> <operator>=</operator> <name><name>sConfig</name><operator>-&gt;</operator><name>OCNIdleState</name></name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>OutputChannel</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
      <block>{<block_content>
        <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TIM_OC1_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
      <block>{<block_content>
        <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TIM_OC2_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default>
        <break>break;</break>
    </block_content>}</block></switch>

    <switch>switch <condition>(<expr><name>InputChannel</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
      <block>{<block_content>
        <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TIM_TI1_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPolarity</name></name></expr></argument>,
                          <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICSelection</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Reset the IC1PSC Bits */</comment>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC1PSC</name></expr>;</expr_stmt>

        <comment type="block">/* Select the Trigger source */</comment>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_SMCR_TS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>|=</operator> <name>TIM_TS_TI1FP1</name></expr>;</expr_stmt>

        <comment type="block">/* Select the Slave Mode */</comment>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>|=</operator> <name>TIM_SLAVEMODE_TRIGGER</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
      <block>{<block_content>
        <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TIM_TI2_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICPolarity</name></name></expr></argument>,
                          <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICSelection</name></name></expr></argument>, <argument><expr><name><name>sConfig</name><operator>-&gt;</operator><name>ICFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Reset the IC2PSC Bits */</comment>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC2PSC</name></expr>;</expr_stmt>

        <comment type="block">/* Select the Trigger source */</comment>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_SMCR_TS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>|=</operator> <name>TIM_TS_TI2FP2</name></expr>;</expr_stmt>

        <comment type="block">/* Select the Slave Mode */</comment>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>|=</operator> <name>TIM_SLAVEMODE_TRIGGER</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <default>default:</default>
        <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
  * @param  htim TIM handle
  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
  *         This parameter can be one of the following values:
  *            @arg TIM_DMABASE_CR1
  *            @arg TIM_DMABASE_CR2
  *            @arg TIM_DMABASE_SMCR
  *            @arg TIM_DMABASE_DIER
  *            @arg TIM_DMABASE_SR
  *            @arg TIM_DMABASE_EGR
  *            @arg TIM_DMABASE_CCMR1
  *            @arg TIM_DMABASE_CCMR2
  *            @arg TIM_DMABASE_CCER
  *            @arg TIM_DMABASE_CNT
  *            @arg TIM_DMABASE_PSC
  *            @arg TIM_DMABASE_ARR
  *            @arg TIM_DMABASE_RCR
  *            @arg TIM_DMABASE_CCR1
  *            @arg TIM_DMABASE_CCR2
  *            @arg TIM_DMABASE_CCR3
  *            @arg TIM_DMABASE_CCR4
  *            @arg TIM_DMABASE_BDTR
  * @param  BurstRequestSrc TIM DMA Request sources
  *         This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
  *            @arg TIM_DMA_COM: TIM Commutation DMA source
  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
  * @param  BurstBuffer The Buffer address.
  * @param  BurstLength DMA Burst length. This parameter can be one value
  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_DMABurst_WriteStart</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BurstBaseAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BurstRequestSrc</name></decl></parameter>,
                                              <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>BurstBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type>  <name>BurstLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMABURST_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_BASE</name><argument_list>(<argument><expr><name>BurstBaseAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_SOURCE</name><argument_list>(<argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_LENGTH</name><argument_list>(<argument><expr><name>BurstLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_BUSY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>BurstBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>BurstLength</name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>
  <switch>switch <condition>(<expr><name>BurstRequestSrc</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_DMA_UPDATE</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA Period elapsed callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMAPeriodElapsedCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMAPeriodElapsedHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMADelayPulseHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_COM</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA commutation callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator>  <name>TIMEx_DMACommutationCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator>  <name>TIMEx_DMACommutationHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_TRIGGER</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA trigger callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMATriggerCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMATriggerHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <comment type="block">/* configure the DMA Burst Mode */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DCR</name></name> <operator>=</operator> <operator>(</operator><name>BurstBaseAddress</name> <operator>|</operator> <name>BurstLength</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Enable the TIM DMA Request */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stops the TIM DMA Burst mode
  * @param  htim TIM handle
  * @param  BurstRequestSrc TIM DMA Request sources to disable
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_DMABurst_WriteStop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BurstRequestSrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_SOURCE</name><argument_list>(<argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Abort the DMA transfer (at least disable the DMA stream) */</comment>
  <switch>switch <condition>(<expr><name>BurstRequestSrc</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_DMA_UPDATE</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC1</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC2</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC3</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator>  <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC4</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_COM</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_TRIGGER</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>==</operator> <name>status</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the TIM Update DMA request */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
  * @param  htim TIM handle
  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
  *         This parameter can be one of the following values:
  *            @arg TIM_DMABASE_CR1
  *            @arg TIM_DMABASE_CR2
  *            @arg TIM_DMABASE_SMCR
  *            @arg TIM_DMABASE_DIER
  *            @arg TIM_DMABASE_SR
  *            @arg TIM_DMABASE_EGR
  *            @arg TIM_DMABASE_CCMR1
  *            @arg TIM_DMABASE_CCMR2
  *            @arg TIM_DMABASE_CCER
  *            @arg TIM_DMABASE_CNT
  *            @arg TIM_DMABASE_PSC
  *            @arg TIM_DMABASE_ARR
  *            @arg TIM_DMABASE_RCR
  *            @arg TIM_DMABASE_CCR1
  *            @arg TIM_DMABASE_CCR2
  *            @arg TIM_DMABASE_CCR3
  *            @arg TIM_DMABASE_CCR4
  *            @arg TIM_DMABASE_BDTR
  * @param  BurstRequestSrc TIM DMA Request sources
  *         This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
  *            @arg TIM_DMA_COM: TIM Commutation DMA source
  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
  * @param  BurstBuffer The Buffer address.
  * @param  BurstLength DMA Burst length. This parameter can be one value
  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_DMABurst_ReadStart</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BurstBaseAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BurstRequestSrc</name></decl></parameter>,
                                             <parameter><decl><type><name>uint32_t</name>  <modifier>*</modifier></type><name>BurstBuffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type>  <name>BurstLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMABURST_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_BASE</name><argument_list>(<argument><expr><name>BurstBaseAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_SOURCE</name><argument_list>(<argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_LENGTH</name><argument_list>(<argument><expr><name>BurstLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_BUSY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>BurstBuffer</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>BurstLength</name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>
  <switch>switch <condition>(<expr><name>BurstRequestSrc</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_DMA_UPDATE</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA Period elapsed callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMAPeriodElapsedCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMAPeriodElapsedHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture/compare callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA capture callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMACaptureHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_COM</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA commutation callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator>  <name>TIMEx_DMACommutationCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator>  <name>TIMEx_DMACommutationHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_TRIGGER</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Set the DMA trigger callbacks */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name><operator>-&gt;</operator><name>XferCpltCallback</name> <operator>=</operator> <name>TIM_DMATriggerCplt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name><operator>-&gt;</operator><name>XferHalfCpltCallback</name> <operator>=</operator> <name>TIM_DMATriggerHalfCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name><operator>-&gt;</operator><name>XferErrorCallback</name> <operator>=</operator> <name>TIM_DMAError</name></expr> ;</expr_stmt>

      <comment type="block">/* Enable the DMA stream */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DMAR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>BurstBuffer</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BurstLength</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>+</operator> <literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* configure the DMA Burst Mode */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DCR</name></name> <operator>=</operator> <operator>(</operator><name>BurstBaseAddress</name> <operator>|</operator> <name>BurstLength</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Enable the TIM DMA Request */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the DMA burst reading
  * @param  htim TIM handle
  * @param  BurstRequestSrc TIM DMA Request sources to disable.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_DMABurst_ReadStop</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>BurstRequestSrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_DMA_SOURCE</name><argument_list>(<argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Abort the DMA transfer (at least disable the DMA stream) */</comment>
  <switch>switch <condition>(<expr><name>BurstRequestSrc</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_DMA_UPDATE</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_UPDATE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC1</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC2</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC3</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_CC4</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_COM</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_COMMUTATION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_DMA_TRIGGER</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_TRIGGER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>==</operator> <name>status</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the TIM Update DMA request */</comment>
    <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>BurstRequestSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Generate a software event
  * @param  htim TIM handle
  * @param  EventSource specifies the event source.
  *          This parameter can be one of the following values:
  *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
  *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
  *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
  *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
  *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
  *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
  *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
  *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
  * @note   Basic timers can only generate an update event.
  * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
  * @note   TIM_EVENTSOURCE_BREAK are relevant only for timer instances
  *         supporting a break input.
  * @retval HAL status
  */</comment>

<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_GenerateEvent</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>EventSource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_EVENT_SOURCE</name><argument_list>(<argument><expr><name>EventSource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Set the event sources */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>EGR</name></name> <operator>=</operator> <name>EventSource</name></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures the OCRef clear feature
  * @param  htim TIM handle
  * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
  *         contains the OCREF clear feature and parameters for the TIM peripheral.
  * @param  Channel specifies the TIM Channel
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  *            @arg TIM_CHANNEL_4: TIM Channel 4
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_ConfigOCrefClear</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,
                                           <parameter><decl><type><name>TIM_ClearInputConfigTypeDef</name> <modifier>*</modifier></type><name>sClearInputConfig</name></decl></parameter>,
                                           <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCXREF_CLEAR_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLEARINPUT_SOURCE</name><argument_list>(<argument><expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputSource</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputSource</name></name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CLEARINPUTSOURCE_NONE</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Clear the OCREF clear selection bit and the the ETR Bits */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>TIM_SMCR_ETF</name> <operator>|</operator> <name>TIM_SMCR_ETPS</name> <operator>|</operator> <name>TIM_SMCR_ECE</name> <operator>|</operator> <name>TIM_SMCR_ETP</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CLEARINPUTSOURCE_ETR</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLEARINPUT_POLARITY</name><argument_list>(<argument><expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLEARINPUT_PRESCALER</name><argument_list>(<argument><expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputPrescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLEARINPUT_FILTER</name><argument_list>(<argument><expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* When OCRef clear feature is used with ETR source, ETR prescaler must be off */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputPrescaler</name></name> <operator>!=</operator> <name>TIM_CLEARINPUTPRESCALER_DIV1</name></expr>)</condition>
      <block>{<block_content>
          <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>TIM_ETR_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                        <argument><expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputPrescaler</name></name></expr></argument>,
                        <argument><expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputPolarity</name></name></expr></argument>,
                        <argument><expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputState</name></name> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable the OCREF clear feature for Channel 1 */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name></expr></argument>, <argument><expr><name>TIM_CCMR1_OC1CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Disable the OCREF clear feature for Channel 1 */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name></expr></argument>, <argument><expr><name>TIM_CCMR1_OC1CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputState</name></name> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable the OCREF clear feature for Channel 2 */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name></expr></argument>, <argument><expr><name>TIM_CCMR1_OC2CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Disable the OCREF clear feature for Channel 2 */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name></expr></argument>, <argument><expr><name>TIM_CCMR1_OC2CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputState</name></name> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable the OCREF clear feature for Channel 3 */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name></expr></argument>, <argument><expr><name>TIM_CCMR2_OC3CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Disable the OCREF clear feature for Channel 3 */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name></expr></argument>, <argument><expr><name>TIM_CCMR2_OC3CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>sClearInputConfig</name><operator>-&gt;</operator><name>ClearInputState</name></name> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable the OCREF clear feature for Channel 4 */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name></expr></argument>, <argument><expr><name>TIM_CCMR2_OC4CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Disable the OCREF clear feature for Channel 4 */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR2</name></name></expr></argument>, <argument><expr><name>TIM_CCMR2_OC4CE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief   Configures the clock source to be used
  * @param  htim TIM handle
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_ConfigClockSource</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>TIM_ClockConfigTypeDef</name> <modifier>*</modifier></type><name>sClockSourceConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockSource</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the SMS, TS, ECE, ETPS and ETRF bits */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_SMCR_SMS</name> <operator>|</operator> <name>TIM_SMCR_TS</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_SMCR_ETF</name> <operator>|</operator> <name>TIM_SMCR_ETPS</name> <operator>|</operator> <name>TIM_SMCR_ECE</name> <operator>|</operator> <name>TIM_SMCR_ETP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>=</operator> <name>tmpsmcr</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockSource</name></name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CLOCKSOURCE_INTERNAL</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CLOCKSOURCE_ETRMODE1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check ETR input conditioning related parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKPRESCALER</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPrescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKPOLARITY</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKFILTER</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the ETR Clock source */</comment>
      <expr_stmt><expr><call><name>TIM_ETR_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                        <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPrescaler</name></name></expr></argument>,
                        <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>,
                        <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Select the External clock mode1 and the ETRF trigger */</comment>
      <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmpsmcr</name> <operator>|=</operator> <operator>(</operator><name>TIM_SLAVEMODE_EXTERNAL1</name> <operator>|</operator> <name>TIM_CLOCKSOURCE_ETRMODE1</name><operator>)</operator></expr>;</expr_stmt>
      <comment type="block">/* Write to TIMx SMCR */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>=</operator> <name>tmpsmcr</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CLOCKSOURCE_ETRMODE2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check ETR input conditioning related parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKPRESCALER</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPrescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKPOLARITY</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKFILTER</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure the ETR Clock source */</comment>
      <expr_stmt><expr><call><name>TIM_ETR_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                        <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPrescaler</name></name></expr></argument>,
                        <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>,
                        <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Enable the External clock mode2 */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>|=</operator> <name>TIM_SMCR_ECE</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CLOCKSOURCE_TI1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check whether or not the timer instance supports external clock mode 1 */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE_TIX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check TI1 input conditioning related parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKPOLARITY</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKFILTER</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>TIM_TI1_ConfigInputStage</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                               <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>,
                               <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TIM_ITRx_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CLOCKSOURCE_TI1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CLOCKSOURCE_TI2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE_TIX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check TI2 input conditioning related parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKPOLARITY</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKFILTER</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>TIM_TI2_ConfigInputStage</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                               <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>,
                               <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TIM_ITRx_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CLOCKSOURCE_TI2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CLOCKSOURCE_TI1ED</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check whether or not the timer instance supports external clock mode 1 */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE_TIX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check TI1 input conditioning related parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKPOLARITY</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKFILTER</name><argument_list>(<argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>TIM_TI1_ConfigInputStage</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                               <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockPolarity</name></name></expr></argument>,
                               <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TIM_ITRx_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name>TIM_CLOCKSOURCE_TI1ED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CLOCKSOURCE_ITR0</name></expr>:</case>
    <case>case <expr><name>TIM_CLOCKSOURCE_ITR1</name></expr>:</case>
    <case>case <expr><name>TIM_CLOCKSOURCE_ITR2</name></expr>:</case>
    <case>case <expr><name>TIM_CLOCKSOURCE_ITR3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check whether or not the timer instance supports internal trigger input */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE_ITRX_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>TIM_ITRx_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>, <argument><expr><name><name>sClockSourceConfig</name><operator>-&gt;</operator><name>ClockSource</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
  *         or a XOR combination between CH1_input, CH2_input &amp; CH3_input
  * @param  htim TIM handle.
  * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
  *         output of a XOR gate.
  *          This parameter can be one of the following values:
  *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
  *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
  *            pins are connected to the TI1 input (XOR combination)
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_ConfigTI1Input</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TI1_Selection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpcr2</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_XOR_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TI1SELECTION</name><argument_list>(<argument><expr><name>TI1_Selection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CR2 register value */</comment>
  <expr_stmt><expr><name>tmpcr2</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the TI1 selection */</comment>
  <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_TI1S</name></expr>;</expr_stmt>

  <comment type="block">/* Set the TI1 selection */</comment>
  <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <name>TI1_Selection</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMxCR2 */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>=</operator> <name>tmpcr2</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures the TIM in Slave mode
  * @param  htim TIM handle.
  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
  *         contains the selected trigger (internal trigger input, filtered
  *         timer input or external trigger input) and the Slave mode
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_SlaveConfigSynchro</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>TIM_SlaveConfigTypeDef</name> <modifier>*</modifier></type><name>sSlaveConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_SLAVE_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_SLAVE_MODE</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>SlaveMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGER_SELECTION</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>InputTrigger</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><call><name>TIM_SlaveTimer_SetConfig</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>sSlaveConfig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable Trigger Interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Trigger DMA request */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures the TIM in Slave mode in interrupt mode
  * @param  htim TIM handle.
  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
  *         contains the selected trigger (internal trigger input, filtered
  *         timer input or external trigger input) and the Slave mode
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_SlaveConfigSynchro_IT</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,
                                                        <parameter><decl><type><name>TIM_SlaveConfigTypeDef</name> <modifier>*</modifier></type><name>sSlaveConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_SLAVE_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_SLAVE_MODE</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>SlaveMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGER_SELECTION</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>InputTrigger</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_BUSY</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><call><name>TIM_SlaveTimer_SetConfig</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>sSlaveConfig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable Trigger Interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_ENABLE_IT</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_IT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Trigger DMA request */</comment>
  <expr_stmt><expr><call><name>__HAL_TIM_DISABLE_DMA</name><argument_list>(<argument><expr><name>htim</name></expr></argument>, <argument><expr><name>TIM_DMA_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Read the captured value from Capture Compare unit
  * @param  htim TIM handle.
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval Captured value
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_TIM_ReadCapturedValue</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpreg</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>Channel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_CHANNEL_1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Return the capture 1 value */</comment>
      <expr_stmt><expr><name>tmpreg</name> <operator>=</operator>  <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR1</name></name></expr>;</expr_stmt>

      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TIM_CHANNEL_2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Return the capture 2 value */</comment>
      <expr_stmt><expr><name>tmpreg</name> <operator>=</operator>   <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR2</name></name></expr>;</expr_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC3_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Return the capture 3 value */</comment>
      <expr_stmt><expr><name>tmpreg</name> <operator>=</operator>   <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR3</name></name></expr>;</expr_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_CHANNEL_4</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC4_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Return the capture 4 value */</comment>
      <expr_stmt><expr><name>tmpreg</name> <operator>=</operator>   <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR4</name></name></expr>;</expr_stmt>

      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>tmpreg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
 *  @brief    TIM Callbacks functions
 *
@verbatim
  ==============================================================================
                        ##### TIM Callbacks functions #####
  ==============================================================================
 [..]
   This section provides TIM callback functions:
   (+) TIM Period elapsed callback
   (+) TIM Output Compare callback
   (+) TIM Input capture callback
   (+) TIM Trigger callback
   (+) TIM Error callback

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_PeriodElapsedCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Period elapsed half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_PeriodElapsedHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_OC_DelayElapsedCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_IC_CaptureCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Input Capture half complete callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_IC_CaptureHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_PWM_PulseFinishedCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  PWM Pulse finished half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_PWM_PulseFinishedHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_TriggerCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Hall Trigger detection half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_TriggerHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Timer error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_TIM_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_ErrorCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User TIM callback to be used instead of the weak predefined callback
  * @param htim tim handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
  *          @param pCallback pointer to the callback function
  *          @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>HAL_TIM_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pTIM_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_TIM_BASE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspInitCallback</name></name>                 <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_BASE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspDeInitCallback</name></name>               <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspInitCallback</name></name>                   <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspDeInitCallback</name></name>                 <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspInitCallback</name></name>                   <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspDeInitCallback</name></name>                 <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspInitCallback</name></name>                  <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspDeInitCallback</name></name>                <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspInitCallback</name></name>             <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspDeInitCallback</name></name>           <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspInitCallback</name></name>              <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspDeInitCallback</name></name>            <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspInitCallback</name></name>           <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspDeInitCallback</name></name>         <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PERIOD_ELAPSED_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedCallback</name></name>                <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedHalfCpltCallback</name></name>        <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_TRIGGER_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>TriggerCallback</name></name>                      <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_TRIGGER_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>TriggerHalfCpltCallback</name></name>              <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_CAPTURE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name>                   <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_CAPTURE_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureHalfCpltCallback</name></name>           <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_DELAY_ELAPSED_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_DelayElapsedCallback</name></name>              <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_PULSE_FINISHED_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name>            <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedHalfCpltCallback</name></name>    <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>ErrorCallback</name></name>                        <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_COMMUTATION_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>CommutationCallback</name></name>                  <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_COMMUTATION_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>CommutationHalfCpltCallback</name></name>          <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_BREAK_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>BreakCallback</name></name>                        <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_TIM_BASE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspInitCallback</name></name>         <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_BASE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspDeInitCallback</name></name>       <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspInitCallback</name></name>           <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspDeInitCallback</name></name>         <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspInitCallback</name></name>           <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspDeInitCallback</name></name>         <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspInitCallback</name></name>          <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspDeInitCallback</name></name>        <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspInitCallback</name></name>     <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspDeInitCallback</name></name>   <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspInitCallback</name></name>      <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspDeInitCallback</name></name>    <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspInitCallback</name></name>   <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a TIM callback
  *         TIM callback is redirected to the weak predefined callback
  * @param htim tim handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
  *          @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_TIM_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>, <parameter><decl><type><name>HAL_TIM_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_TIM_BASE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspInitCallback</name></name>              <operator>=</operator> <name>HAL_TIM_Base_MspInit</name></expr>;</expr_stmt>                      <comment type="block">/* Legacy weak Base MspInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_BASE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspDeInitCallback</name></name>            <operator>=</operator> <name>HAL_TIM_Base_MspDeInit</name></expr>;</expr_stmt>                    <comment type="block">/* Legacy weak Base Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspInitCallback</name></name>                <operator>=</operator> <name>HAL_TIM_IC_MspInit</name></expr>;</expr_stmt>                        <comment type="block">/* Legacy weak IC Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspDeInitCallback</name></name>              <operator>=</operator> <name>HAL_TIM_IC_MspDeInit</name></expr>;</expr_stmt>                      <comment type="block">/* Legacy weak IC Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspInitCallback</name></name>                <operator>=</operator> <name>HAL_TIM_OC_MspInit</name></expr>;</expr_stmt>                        <comment type="block">/* Legacy weak OC Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspDeInitCallback</name></name>              <operator>=</operator> <name>HAL_TIM_OC_MspDeInit</name></expr>;</expr_stmt>                      <comment type="block">/* Legacy weak OC Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspInitCallback</name></name>               <operator>=</operator> <name>HAL_TIM_PWM_MspInit</name></expr>;</expr_stmt>                       <comment type="block">/* Legacy weak PWM Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspDeInitCallback</name></name>             <operator>=</operator> <name>HAL_TIM_PWM_MspDeInit</name></expr>;</expr_stmt>                     <comment type="block">/* Legacy weak PWM Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspInitCallback</name></name>          <operator>=</operator> <name>HAL_TIM_OnePulse_MspInit</name></expr>;</expr_stmt>                  <comment type="block">/* Legacy weak One Pulse Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspDeInitCallback</name></name>        <operator>=</operator> <name>HAL_TIM_OnePulse_MspDeInit</name></expr>;</expr_stmt>                <comment type="block">/* Legacy weak One Pulse Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspInitCallback</name></name>           <operator>=</operator> <name>HAL_TIM_Encoder_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak Encoder Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspDeInitCallback</name></name>         <operator>=</operator> <name>HAL_TIM_Encoder_MspDeInit</name></expr>;</expr_stmt>                 <comment type="block">/* Legacy weak Encoder Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspInitCallback</name></name>        <operator>=</operator> <name>HAL_TIMEx_HallSensor_MspInit</name></expr>;</expr_stmt>              <comment type="block">/* Legacy weak Hall Sensor Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspDeInitCallback</name></name>      <operator>=</operator> <name>HAL_TIMEx_HallSensor_MspDeInit</name></expr>;</expr_stmt>            <comment type="block">/* Legacy weak Hall Sensor Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PERIOD_ELAPSED_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedCallback</name></name>             <operator>=</operator> <name>HAL_TIM_PeriodElapsedCallback</name></expr>;</expr_stmt>             <comment type="block">/* Legacy weak Period Elapsed Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedHalfCpltCallback</name></name>     <operator>=</operator> <name>HAL_TIM_PeriodElapsedHalfCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak Period Elapsed half complete Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_TRIGGER_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>TriggerCallback</name></name>                   <operator>=</operator> <name>HAL_TIM_TriggerCallback</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak Trigger Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_TRIGGER_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>TriggerHalfCpltCallback</name></name>           <operator>=</operator> <name>HAL_TIM_TriggerHalfCpltCallback</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak Trigger half complete Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_CAPTURE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name>                <operator>=</operator> <name>HAL_TIM_IC_CaptureCallback</name></expr>;</expr_stmt>                <comment type="block">/* Legacy weak IC Capture Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_CAPTURE_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureHalfCpltCallback</name></name>        <operator>=</operator> <name>HAL_TIM_IC_CaptureHalfCpltCallback</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak IC Capture half complete Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_DELAY_ELAPSED_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_DelayElapsedCallback</name></name>           <operator>=</operator> <name>HAL_TIM_OC_DelayElapsedCallback</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak OC Delay Elapsed Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_PULSE_FINISHED_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name>         <operator>=</operator> <name>HAL_TIM_PWM_PulseFinishedCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak PWM Pulse Finished Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedHalfCpltCallback</name></name> <operator>=</operator> <name>HAL_TIM_PWM_PulseFinishedHalfCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak PWM Pulse Finished half complete Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>ErrorCallback</name></name>                     <operator>=</operator> <name>HAL_TIM_ErrorCallback</name></expr>;</expr_stmt>                     <comment type="block">/* Legacy weak Error Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_COMMUTATION_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>CommutationCallback</name></name>               <operator>=</operator> <name>HAL_TIMEx_CommutCallback</name></expr>;</expr_stmt>                  <comment type="block">/* Legacy weak Commutation Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_COMMUTATION_HALF_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>CommutationHalfCpltCallback</name></name>       <operator>=</operator> <name>HAL_TIMEx_CommutHalfCpltCallback</name></expr>;</expr_stmt>          <comment type="block">/* Legacy weak Commutation half complete Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_BREAK_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>BreakCallback</name></name>                     <operator>=</operator> <name>HAL_TIMEx_BreakCallback</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak Break Callback */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_TIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_TIM_BASE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspInitCallback</name></name>         <operator>=</operator> <name>HAL_TIM_Base_MspInit</name></expr>;</expr_stmt>              <comment type="block">/* Legacy weak Base MspInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_BASE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Base_MspDeInitCallback</name></name>       <operator>=</operator> <name>HAL_TIM_Base_MspDeInit</name></expr>;</expr_stmt>            <comment type="block">/* Legacy weak Base Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspInitCallback</name></name>           <operator>=</operator> <name>HAL_TIM_IC_MspInit</name></expr>;</expr_stmt>                <comment type="block">/* Legacy weak IC Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_IC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_MspDeInitCallback</name></name>         <operator>=</operator> <name>HAL_TIM_IC_MspDeInit</name></expr>;</expr_stmt>              <comment type="block">/* Legacy weak IC Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspInitCallback</name></name>           <operator>=</operator> <name>HAL_TIM_OC_MspInit</name></expr>;</expr_stmt>                <comment type="block">/* Legacy weak OC Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_OC_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_MspDeInitCallback</name></name>         <operator>=</operator> <name>HAL_TIM_OC_MspDeInit</name></expr>;</expr_stmt>              <comment type="block">/* Legacy weak OC Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspInitCallback</name></name>          <operator>=</operator> <name>HAL_TIM_PWM_MspInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak PWM Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_PWM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_MspDeInitCallback</name></name>        <operator>=</operator> <name>HAL_TIM_PWM_MspDeInit</name></expr>;</expr_stmt>             <comment type="block">/* Legacy weak PWM Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspInitCallback</name></name>     <operator>=</operator> <name>HAL_TIM_OnePulse_MspInit</name></expr>;</expr_stmt>          <comment type="block">/* Legacy weak One Pulse Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OnePulse_MspDeInitCallback</name></name>   <operator>=</operator> <name>HAL_TIM_OnePulse_MspDeInit</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak One Pulse Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspInitCallback</name></name>      <operator>=</operator> <name>HAL_TIM_Encoder_MspInit</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak Encoder Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_ENCODER_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Encoder_MspDeInitCallback</name></name>    <operator>=</operator> <name>HAL_TIM_Encoder_MspDeInit</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak Encoder Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspInitCallback</name></name>   <operator>=</operator> <name>HAL_TIMEx_HallSensor_MspInit</name></expr>;</expr_stmt>      <comment type="block">/* Legacy weak Hall Sensor Msp Init Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>HallSensor_MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_TIMEx_HallSensor_MspDeInit</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak Hall Sensor Msp DeInit Callback */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
 *  @brief   TIM Peripheral State functions
 *
@verbatim
  ==============================================================================
                        ##### Peripheral State functions #####
  ==============================================================================
    [..]
    This subsection permits to get in run-time the status of the peripheral
    and the data flow.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the TIM Base handle state.
  * @param  htim TIM Base handle
  * @retval HAL state
  */</comment>
<function><type><name>HAL_TIM_StateTypeDef</name></type> <name>HAL_TIM_Base_GetState</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the TIM OC handle state.
  * @param  htim TIM Output Compare handle
  * @retval HAL state
  */</comment>
<function><type><name>HAL_TIM_StateTypeDef</name></type> <name>HAL_TIM_OC_GetState</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the TIM PWM handle state.
  * @param  htim TIM handle
  * @retval HAL state
  */</comment>
<function><type><name>HAL_TIM_StateTypeDef</name></type> <name>HAL_TIM_PWM_GetState</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the TIM Input Capture handle state.
  * @param  htim TIM IC handle
  * @retval HAL state
  */</comment>
<function><type><name>HAL_TIM_StateTypeDef</name></type> <name>HAL_TIM_IC_GetState</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the TIM One Pulse Mode handle state.
  * @param  htim TIM OPM handle
  * @retval HAL state
  */</comment>
<function><type><name>HAL_TIM_StateTypeDef</name></type> <name>HAL_TIM_OnePulse_GetState</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the TIM Encoder Mode handle state.
  * @param  htim TIM Encoder Interface handle
  * @retval HAL state
  */</comment>
<function><type><name>HAL_TIM_StateTypeDef</name></type> <name>HAL_TIM_Encoder_GetState</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup TIM_Private_Functions TIM Private Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA error callback
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_ErrorCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Delay Pulse complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_DMADelayPulseCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_3</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_4</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_PWM_PulseFinishedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Delay Pulse half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_DMADelayPulseHalfCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_3</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_4</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedHalfCpltCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_PWM_PulseFinishedHalfCpltCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Capture complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_DMACaptureCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_3</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_4</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_IC_CaptureCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Capture half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_DMACaptureHalfCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC1</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_1</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC2</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC3</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_3</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>hdma</name> <operator>==</operator> <name><name>htim</name><operator>-&gt;</operator><name>hdma</name><index>[<expr><name>TIM_DMA_ID_CC4</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_4</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* nothing to do */</comment>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureHalfCpltCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_IC_CaptureHalfCpltCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Channel</name></name> <operator>=</operator> <name>HAL_TIM_ACTIVE_CHANNEL_CLEARED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Period Elapse complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMAPeriodElapsedCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_PeriodElapsedCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Period Elapse half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMAPeriodElapsedHalfCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedHalfCpltCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_PeriodElapsedHalfCpltCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Trigger callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMATriggerCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>TriggerCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_TriggerCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  TIM DMA Trigger half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_DMATriggerHalfCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name> <init>= <expr><operator>(</operator><name>TIM_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_TIM_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>htim</name><operator>-&gt;</operator><name>TriggerHalfCpltCallback</name></name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_TIM_TriggerHalfCpltCallback</name><argument_list>(<argument><expr><name>htim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Time Base configuration
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_Base_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_Base_InitTypeDef</name> <modifier>*</modifier></type><name>Structure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpcr1</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>tmpcr1</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CR1</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set TIM Time Base Unit parameters ---------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_COUNTER_MODE_SELECT_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Select the Counter Mode */</comment>
    <expr_stmt><expr><name>tmpcr1</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CR1_DIR</name> <operator>|</operator> <name>TIM_CR1_CMS</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpcr1</name> <operator>|=</operator> <name><name>Structure</name><operator>-&gt;</operator><name>CounterMode</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_CLOCK_DIVISION_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set the clock division */</comment>
    <expr_stmt><expr><name>tmpcr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR1_CKD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpcr1</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>Structure</name><operator>-&gt;</operator><name>ClockDivision</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the auto-reload preload */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name>tmpcr1</name></expr></argument>, <argument><expr><name>TIM_CR1_ARPE</name></expr></argument>, <argument><expr><name><name>Structure</name><operator>-&gt;</operator><name>AutoReloadPreload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CR1</name></name> <operator>=</operator> <name>tmpcr1</name></expr>;</expr_stmt>

  <comment type="block">/* Set the Autoreload value */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>ARR</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>Structure</name><operator>-&gt;</operator><name>Period</name></name></expr> ;</expr_stmt>

  <comment type="block">/* Set the Prescaler value */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>PSC</name></name> <operator>=</operator> <name><name>Structure</name><operator>-&gt;</operator><name>Prescaler</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_REPETITION_COUNTER_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set the Repetition Counter value */</comment>
    <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>RCR</name></name> <operator>=</operator> <name><name>Structure</name><operator>-&gt;</operator><name>RepetitionCounter</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>EGR</name></name> <operator>=</operator> <name>TIM_EGR_UG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Timer Output Compare 1 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_OC1_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>OC_Config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmrx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpcr2</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 1: Reset the CC1E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC1E</name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCER register value */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>
  <comment type="block">/* Get the TIMx CR2 register value */</comment>
  <expr_stmt><expr><name>tmpcr2</name> <operator>=</operator>  <name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCMR1 register value */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Compare Mode Bits */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_OC1M</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_CC1S</name></expr>;</expr_stmt>
  <comment type="block">/* Select the Output Compare Mode */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>|=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>OCMode</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Polarity level */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC1P</name></expr>;</expr_stmt>
  <comment type="block">/* Set the Output Compare Polarity */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>OCPolarity</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_CCXN_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>, <argument><expr><name>TIM_CHANNEL_1</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCN_POLARITY</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the Output N Polarity level */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC1NP</name></expr>;</expr_stmt>
    <comment type="block">/* Set the Output N Polarity */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>OCNPolarity</name></name></expr>;</expr_stmt>
    <comment type="block">/* Reset the Output N State */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC1NE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCNIDLE_STATE</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNIdleState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCIDLE_STATE</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the Output Compare and Output Compare N IDLE State */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_OIS1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_OIS1N</name></expr>;</expr_stmt>
    <comment type="block">/* Set the Output Idle state */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name></expr>;</expr_stmt>
    <comment type="block">/* Set the Output N Idle state */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>OCNIdleState</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write to TIMx CR2 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name> <operator>=</operator> <name>tmpcr2</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR1 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmrx</name></expr>;</expr_stmt>

  <comment type="block">/* Set the Capture Compare Register value */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCR1</name></name> <operator>=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>Pulse</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCER */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Timer Output Compare 2 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_OC2_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>OC_Config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmrx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpcr2</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 2: Reset the CC2E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC2E</name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCER register value */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>
  <comment type="block">/* Get the TIMx CR2 register value */</comment>
  <expr_stmt><expr><name>tmpcr2</name> <operator>=</operator>  <name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCMR1 register value */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Compare mode and Capture/Compare selection Bits */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_OC2M</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_CC2S</name></expr>;</expr_stmt>

  <comment type="block">/* Select the Output Compare Mode */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCMode</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Polarity level */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC2P</name></expr>;</expr_stmt>
  <comment type="block">/* Set the Output Compare Polarity */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCPolarity</name></name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_CCXN_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>, <argument><expr><name>TIM_CHANNEL_2</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCN_POLARITY</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the Output N Polarity level */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC2NP</name></expr>;</expr_stmt>
    <comment type="block">/* Set the Output N Polarity */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNPolarity</name></name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* Reset the Output N State */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC2NE</name></expr>;</expr_stmt>

  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCNIDLE_STATE</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNIdleState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCIDLE_STATE</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the Output Compare and Output Compare N IDLE State */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_OIS2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_OIS2N</name></expr>;</expr_stmt>
    <comment type="block">/* Set the Output Idle state */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name> <operator>&lt;&lt;</operator> <literal type="number">2U</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* Set the Output N Idle state */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNIdleState</name></name> <operator>&lt;&lt;</operator> <literal type="number">2U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write to TIMx CR2 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name> <operator>=</operator> <name>tmpcr2</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR1 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmrx</name></expr>;</expr_stmt>

  <comment type="block">/* Set the Capture Compare Register value */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCR2</name></name> <operator>=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>Pulse</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCER */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Timer Output Compare 3 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_OC3_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>OC_Config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmrx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpcr2</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 3: Reset the CC2E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC3E</name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCER register value */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>
  <comment type="block">/* Get the TIMx CR2 register value */</comment>
  <expr_stmt><expr><name>tmpcr2</name> <operator>=</operator>  <name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCMR2 register value */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Compare mode and Capture/Compare selection Bits */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_OC3M</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_CC3S</name></expr>;</expr_stmt>
  <comment type="block">/* Select the Output Compare Mode */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>|=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>OCMode</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Polarity level */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC3P</name></expr>;</expr_stmt>
  <comment type="block">/* Set the Output Compare Polarity */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCPolarity</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_CCXN_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>, <argument><expr><name>TIM_CHANNEL_3</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCN_POLARITY</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the Output N Polarity level */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC3NP</name></expr>;</expr_stmt>
    <comment type="block">/* Set the Output N Polarity */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNPolarity</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* Reset the Output N State */</comment>
    <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC3NE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCNIDLE_STATE</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNIdleState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCIDLE_STATE</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the Output Compare and Output Compare N IDLE State */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_OIS3</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_OIS3N</name></expr>;</expr_stmt>
    <comment type="block">/* Set the Output Idle state */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* Set the Output N Idle state */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCNIdleState</name></name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write to TIMx CR2 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name> <operator>=</operator> <name>tmpcr2</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR2 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>=</operator> <name>tmpccmrx</name></expr>;</expr_stmt>

  <comment type="block">/* Set the Capture Compare Register value */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCR3</name></name> <operator>=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>Pulse</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCER */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Timer Output Compare 4 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_OC4_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>TIM_OC_InitTypeDef</name> <modifier>*</modifier></type><name>OC_Config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmrx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpcr2</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 4: Reset the CC4E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC4E</name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCER register value */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>
  <comment type="block">/* Get the TIMx CR2 register value */</comment>
  <expr_stmt><expr><name>tmpcr2</name> <operator>=</operator>  <name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get the TIMx CCMR2 register value */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Compare mode and Capture/Compare selection Bits */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_OC4M</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_CC4S</name></expr>;</expr_stmt>

  <comment type="block">/* Select the Output Compare Mode */</comment>
  <expr_stmt><expr><name>tmpccmrx</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCMode</name></name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Reset the Output Polarity level */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC4P</name></expr>;</expr_stmt>
  <comment type="block">/* Set the Output Compare Polarity */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCPolarity</name></name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_BREAK_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_OCIDLE_STATE</name><argument_list>(<argument><expr><name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the Output Compare IDLE State */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CR2_OIS4</name></expr>;</expr_stmt>

    <comment type="block">/* Set the Output Idle state */</comment>
    <expr_stmt><expr><name>tmpcr2</name> <operator>|=</operator> <operator>(</operator><name><name>OC_Config</name><operator>-&gt;</operator><name>OCIdleState</name></name> <operator>&lt;&lt;</operator> <literal type="number">6U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write to TIMx CR2 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CR2</name></name> <operator>=</operator> <name>tmpcr2</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR2 */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>=</operator> <name>tmpccmrx</name></expr>;</expr_stmt>

  <comment type="block">/* Set the Capture Compare Register value */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCR4</name></name> <operator>=</operator> <name><name>OC_Config</name><operator>-&gt;</operator><name>Pulse</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCER */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Slave Timer configuration function
  * @param  htim TIM handle
  * @param  sSlaveConfig Slave timer configuration
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>TIM_SlaveTimer_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>,
                                     <parameter><decl><type><name>TIM_SlaveConfigTypeDef</name> <modifier>*</modifier></type><name>sSlaveConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Get the TIMx SMCR register value */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the Trigger Selection Bits */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_SMCR_TS</name></expr>;</expr_stmt>
  <comment type="block">/* Set the Input Trigger source */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>|=</operator> <name><name>sSlaveConfig</name><operator>-&gt;</operator><name>InputTrigger</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the slave mode Bits */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_SMCR_SMS</name></expr>;</expr_stmt>
  <comment type="block">/* Set the slave mode */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>|=</operator> <name><name>sSlaveConfig</name><operator>-&gt;</operator><name>SlaveMode</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx SMCR */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>=</operator> <name>tmpsmcr</name></expr>;</expr_stmt>

  <comment type="block">/* Configure the trigger prescaler, filter, and polarity */</comment>
  <switch>switch <condition>(<expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>InputTrigger</name></name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>TIM_TS_ETRF</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERPRESCALER</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPrescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERPOLARITY</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERFILTER</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Configure the ETR Trigger source */</comment>
      <expr_stmt><expr><call><name>TIM_ETR_SetConfig</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                        <argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPrescaler</name></name></expr></argument>,
                        <argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPolarity</name></name></expr></argument>,
                        <argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_TS_TI1F_ED</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERFILTER</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>(<expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>SlaveMode</name></name> <operator>==</operator> <name>TIM_SLAVEMODE_GATED</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Disable the Channel 1: Reset the CC1E Bit */</comment>
      <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC1E</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmpccmr1</name> <operator>=</operator> <name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>

      <comment type="block">/* Set the filter */</comment>
      <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC1F</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>

      <comment type="block">/* Write to TIMx CCMR1 and CCER registers */</comment>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmr1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_TS_TI1FP1</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERPOLARITY</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERFILTER</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure TI1 Filter and Polarity */</comment>
      <expr_stmt><expr><call><name>TIM_TI1_ConfigInputStage</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                               <argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPolarity</name></name></expr></argument>,
                               <argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_TS_TI2FP2</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERPOLARITY</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_TRIGGERFILTER</name><argument_list>(<argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Configure TI2 Filter and Polarity */</comment>
      <expr_stmt><expr><call><name>TIM_TI2_ConfigInputStage</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>,
                               <argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerPolarity</name></name></expr></argument>,
                               <argument><expr><name><name>sSlaveConfig</name><operator>-&gt;</operator><name>TriggerFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TIM_TS_ITR0</name></expr>:</case>
    <case>case <expr><name>TIM_TS_ITR1</name></expr>:</case>
    <case>case <expr><name>TIM_TS_ITR2</name></expr>:</case>
    <case>case <expr><name>TIM_TS_ITR3</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* Check the parameter */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name><name>htim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the TI1 as Input.
  * @param  TIMx to select the TIM peripheral.
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
  *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  */</comment>
<function><type><name>void</name></type> <name>TIM_TI1_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICSelection</name></decl></parameter>,
                       <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 1: Reset the CC1E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC1E</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the Input */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IS_TIM_CC2_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_CC1S</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <name>TIM_ICSelection</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <name>TIM_CCMR1_CC1S_0</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the filter */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC1F</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>TIM_ICFilter</name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator> <operator>&amp;</operator> <name>TIM_CCMR1_IC1F</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the Polarity and set the CC1E Bit */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC1P</name> <operator>|</operator> <name>TIM_CCER_CC1NP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><name>TIM_ICPolarity</name> <operator>&amp;</operator> <operator>(</operator><name>TIM_CCER_CC1P</name> <operator>|</operator> <name>TIM_CCER_CC1NP</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR1 and CCER registers */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmr1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the Polarity and Filter for TI1.
  * @param  TIMx to select the TIM peripheral.
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI1_ConfigInputStage</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 1: Reset the CC1E Bit */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC1E</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the filter */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC1F</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><name>TIM_ICFilter</name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the Polarity and set the CC1E Bit */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC1P</name> <operator>|</operator> <name>TIM_CCER_CC1NP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <name>TIM_ICPolarity</name></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR1 and CCER registers */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmr1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the TI2 as Input.
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI2_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICSelection</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 2: Reset the CC2E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC2E</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the Input */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_CC2S</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><name>TIM_ICSelection</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set the filter */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC2F</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>TIM_ICFilter</name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator> <operator>&amp;</operator> <name>TIM_CCMR1_IC2F</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the Polarity and set the CC2E Bit */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC2P</name> <operator>|</operator> <name>TIM_CCER_CC2NP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>TIM_ICPolarity</name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>TIM_CCER_CC2P</name> <operator>|</operator> <name>TIM_CCER_CC2NP</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR1 and CCER registers */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmr1</name></expr> ;</expr_stmt>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the Polarity and Filter for TI2.
  * @param  TIMx to select the TIM peripheral.
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI2_ConfigInputStage</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 2: Reset the CC2E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC2E</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set the filter */</comment>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR1_IC2F</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr1</name> <operator>|=</operator> <operator>(</operator><name>TIM_ICFilter</name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the Polarity and set the CC2E Bit */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC2P</name> <operator>|</operator> <name>TIM_CCER_CC2NP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><name>TIM_ICPolarity</name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR1 and CCER registers */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR1</name></name> <operator>=</operator> <name>tmpccmr1</name></expr> ;</expr_stmt>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the TI3 as Input.
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
  *        protected against un-initialized filter and polarity values.
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI3_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICSelection</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 3: Reset the CC3E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC3E</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the Input */</comment>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_CC3S</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>|=</operator> <name>TIM_ICSelection</name></expr>;</expr_stmt>

  <comment type="block">/* Set the filter */</comment>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_IC3F</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>TIM_ICFilter</name> <operator>&lt;&lt;</operator> <literal type="number">4U</literal><operator>)</operator> <operator>&amp;</operator> <name>TIM_CCMR2_IC3F</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the Polarity and set the CC3E Bit */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC3P</name> <operator>|</operator> <name>TIM_CCER_CC3NP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>TIM_ICPolarity</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>TIM_CCER_CC3P</name> <operator>|</operator> <name>TIM_CCER_CC3NP</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR2 and CCER registers */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>=</operator> <name>tmpccmr2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configure the TI4 as Input.
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
  *        protected against un-initialized filter and polarity values.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_TI4_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICSelection</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ICFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccmr2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpccer</name></decl>;</decl_stmt>

  <comment type="block">/* Disable the Channel 4: Reset the CC4E Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCER_CC4E</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name></expr>;</expr_stmt>

  <comment type="block">/* Select the Input */</comment>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_CC4S</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>|=</operator> <operator>(</operator><name>TIM_ICSelection</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set the filter */</comment>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_CCMR2_IC4F</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccmr2</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>TIM_ICFilter</name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator> <operator>&amp;</operator> <name>TIM_CCMR2_IC4F</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Select the Polarity and set the CC4E Bit */</comment>
  <expr_stmt><expr><name>tmpccer</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_CCER_CC4P</name> <operator>|</operator> <name>TIM_CCER_CC4NP</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpccer</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>TIM_ICPolarity</name> <operator>&lt;&lt;</operator> <literal type="number">12U</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>TIM_CCER_CC4P</name> <operator>|</operator> <name>TIM_CCER_CC4NP</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx CCMR2 and CCER registers */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCMR2</name></name> <operator>=</operator> <name>tmpccmr2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>=</operator> <name>tmpccer</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Selects the Input Trigger source
  * @param  TIMx to select the TIM peripheral
  * @param  InputTriggerSource The Input Trigger source.
  *          This parameter can be one of the following values:
  *            @arg TIM_TS_ITR0: Internal Trigger 0
  *            @arg TIM_TS_ITR1: Internal Trigger 1
  *            @arg TIM_TS_ITR2: Internal Trigger 2
  *            @arg TIM_TS_ITR3: Internal Trigger 3
  *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
  *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TIM_ITRx_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>InputTriggerSource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <comment type="block">/* Get the TIMx SMCR register value */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>SMCR</name></name></expr>;</expr_stmt>
  <comment type="block">/* Reset the TS Bits */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>&amp;=</operator> <operator>~</operator><name>TIM_SMCR_TS</name></expr>;</expr_stmt>
  <comment type="block">/* Set the Input Trigger source and the slave mode*/</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>|=</operator> <operator>(</operator><name>InputTriggerSource</name> <operator>|</operator> <name>TIM_SLAVEMODE_EXTERNAL1</name><operator>)</operator></expr>;</expr_stmt>
  <comment type="block">/* Write to TIMx SMCR */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>=</operator> <name>tmpsmcr</name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @brief  Configures the TIMx External Trigger (ETR).
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
  *          This parameter can be one of the following values:
  *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
  *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
  *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
  *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
  * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
  *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
  * @param  ExtTRGFilter External Trigger Filter.
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_ETR_SetConfig</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ExtTRGPrescaler</name></decl></parameter>,
                       <parameter><decl><type><name>uint32_t</name></type> <name>TIM_ExtTRGPolarity</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ExtTRGFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpsmcr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>tmpsmcr</name> <operator>=</operator> <name><name>TIMx</name><operator>-&gt;</operator><name>SMCR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the ETR Bits */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TIM_SMCR_ETF</name> <operator>|</operator> <name>TIM_SMCR_ETPS</name> <operator>|</operator> <name>TIM_SMCR_ECE</name> <operator>|</operator> <name>TIM_SMCR_ETP</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set the Prescaler, the Filter value and the Polarity */</comment>
  <expr_stmt><expr><name>tmpsmcr</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>TIM_ExtTRGPrescaler</name> <operator>|</operator> <operator>(</operator><name>TIM_ExtTRGPolarity</name> <operator>|</operator> <operator>(</operator><name>ExtTRGFilter</name> <operator>&lt;&lt;</operator> <literal type="number">8U</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Write to TIMx SMCR */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>SMCR</name></name> <operator>=</operator> <name>tmpsmcr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables or disables the TIM Capture Compare Channel x.
  * @param  TIMx to select the TIM peripheral
  * @param  Channel specifies the TIM Channel
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  *            @arg TIM_CHANNEL_4: TIM Channel 4
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_CCxChannelCmd</name><parameter_list>(<parameter><decl><type><name>TIM_TypeDef</name> <modifier>*</modifier></type><name>TIMx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Channel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ChannelState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CC1_INSTANCE</name><argument_list>(<argument><expr><name>TIMx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_TIM_CHANNELS</name><argument_list>(<argument><expr><name>Channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>TIM_CCER_CC1E</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>Channel</name> <operator>&amp;</operator> <literal type="number">0x1FU</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* 0x1FU = 31 bits max shift */</comment>

  <comment type="block">/* Reset the CCxE Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>&amp;=</operator> <operator>~</operator><name>tmp</name></expr>;</expr_stmt>

  <comment type="block">/* Set or reset the CCxE Bit */</comment>
  <expr_stmt><expr><name><name>TIMx</name><operator>-&gt;</operator><name>CCER</name></name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ChannelState</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>Channel</name> <operator>&amp;</operator> <literal type="number">0x1FU</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* 0x1FU = 31 bits max shift */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_TIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Reset interrupt callbacks to the legacy weak callbacks.
  * @param  htim pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>TIM_ResetCallback</name><parameter_list>(<parameter><decl><type><name>TIM_HandleTypeDef</name> <modifier>*</modifier></type><name>htim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Reset the TIM callback to the legacy weak callbacks */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedCallback</name></name>             <operator>=</operator> <name>HAL_TIM_PeriodElapsedCallback</name></expr>;</expr_stmt>             <comment type="block">/* Legacy weak PeriodElapsedCallback             */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PeriodElapsedHalfCpltCallback</name></name>     <operator>=</operator> <name>HAL_TIM_PeriodElapsedHalfCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak PeriodElapsedHalfCpltCallback     */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>TriggerCallback</name></name>                   <operator>=</operator> <name>HAL_TIM_TriggerCallback</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak TriggerCallback                   */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>TriggerHalfCpltCallback</name></name>           <operator>=</operator> <name>HAL_TIM_TriggerHalfCpltCallback</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak TriggerHalfCpltCallback           */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureCallback</name></name>                <operator>=</operator> <name>HAL_TIM_IC_CaptureCallback</name></expr>;</expr_stmt>                <comment type="block">/* Legacy weak IC_CaptureCallback                */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>IC_CaptureHalfCpltCallback</name></name>        <operator>=</operator> <name>HAL_TIM_IC_CaptureHalfCpltCallback</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak IC_CaptureHalfCpltCallback        */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>OC_DelayElapsedCallback</name></name>           <operator>=</operator> <name>HAL_TIM_OC_DelayElapsedCallback</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak OC_DelayElapsedCallback           */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedCallback</name></name>         <operator>=</operator> <name>HAL_TIM_PWM_PulseFinishedCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak PWM_PulseFinishedCallback         */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>PWM_PulseFinishedHalfCpltCallback</name></name> <operator>=</operator> <name>HAL_TIM_PWM_PulseFinishedHalfCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak PWM_PulseFinishedHalfCpltCallback */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>ErrorCallback</name></name>                     <operator>=</operator> <name>HAL_TIM_ErrorCallback</name></expr>;</expr_stmt>                     <comment type="block">/* Legacy weak ErrorCallback                     */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>CommutationCallback</name></name>               <operator>=</operator> <name>HAL_TIMEx_CommutCallback</name></expr>;</expr_stmt>                  <comment type="block">/* Legacy weak CommutationCallback               */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>CommutationHalfCpltCallback</name></name>       <operator>=</operator> <name>HAL_TIMEx_CommutHalfCpltCallback</name></expr>;</expr_stmt>          <comment type="block">/* Legacy weak CommutationHalfCpltCallback       */</comment>
  <expr_stmt><expr><name><name>htim</name><operator>-&gt;</operator><name>BreakCallback</name></name>                     <operator>=</operator> <name>HAL_TIMEx_BreakCallback</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak BreakCallback                     */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_TIM_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_TIM_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
