<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_spi.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_spi.c
  * @author  MCD Application Team
  * @brief   SPI HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State functions
  *
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
    [..]
      The SPI HAL driver can be used as follows:

      (#) Declare a SPI_HandleTypeDef handle structure, for example:
          SPI_HandleTypeDef  hspi;

      (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API:
          (##) Enable the SPIx interface clock
          (##) SPI pins configuration
              (+++) Enable the clock for the SPI GPIOs
              (+++) Configure these SPI pins as alternate function push-pull
          (##) NVIC configuration if you need to use interrupt process
              (+++) Configure the SPIx interrupt priority
              (+++) Enable the NVIC SPI IRQ handle
          (##) DMA Configuration if you need to use DMA process
              (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive Stream/Channel
              (+++) Enable the DMAx clock
              (+++) Configure the DMA handle parameters
              (+++) Configure the DMA Tx or Rx Stream/Channel
              (+++) Associate the initialized hdma_tx(or _rx)  handle to the hspi DMA Tx or Rx handle
              (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream/Channel

      (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
          management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.

      (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
          (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
              by calling the customized HAL_SPI_MspInit() API.
     [..]
       Circular mode restriction:
      (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
          (##) Master 2Lines RxOnly
          (##) Master 1Line Rx
      (#) The CRC feature is not managed when the DMA circular mode is enabled
      (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
          the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     [..]
       Master Receive mode restriction:
      (#) In Master unidirectional receive-only mode (MSTR =1, BIDIMODE=0, RXONLY=1) or
          bidirectional receive mode (MSTR=1, BIDIMODE=1, BIDIOE=0), to ensure that the SPI
          does not initiate a new transfer the following procedure has to be respected:
          (##) HAL_SPI_DeInit()
          (##) HAL_SPI_Init()
     [..]
       Callback registration:

      (#) The compilation flag USE_HAL_SPI_REGISTER_CALLBACKS when set to 1U
          allows the user to configure dynamically the driver callbacks.
          Use Functions HAL_SPI_RegisterCallback() to register an interrupt callback.

          Function HAL_SPI_RegisterCallback() allows to register following callbacks:
            (+) TxCpltCallback        : SPI Tx Completed callback
            (+) RxCpltCallback        : SPI Rx Completed callback
            (+) TxRxCpltCallback      : SPI TxRx Completed callback
            (+) TxHalfCpltCallback    : SPI Tx Half Completed callback
            (+) RxHalfCpltCallback    : SPI Rx Half Completed callback
            (+) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
            (+) ErrorCallback         : SPI Error callback
            (+) AbortCpltCallback     : SPI Abort callback
            (+) MspInitCallback       : SPI Msp Init callback
            (+) MspDeInitCallback     : SPI Msp DeInit callback
          This function takes as parameters the HAL peripheral handle, the Callback ID
          and a pointer to the user callback function.


      (#) Use function HAL_SPI_UnRegisterCallback to reset a callback to the default
          weak function.
          HAL_SPI_UnRegisterCallback takes as parameters the HAL peripheral handle,
          and the Callback ID.
          This function allows to reset following callbacks:
            (+) TxCpltCallback        : SPI Tx Completed callback
            (+) RxCpltCallback        : SPI Rx Completed callback
            (+) TxRxCpltCallback      : SPI TxRx Completed callback
            (+) TxHalfCpltCallback    : SPI Tx Half Completed callback
            (+) RxHalfCpltCallback    : SPI Rx Half Completed callback
            (+) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
            (+) ErrorCallback         : SPI Error callback
            (+) AbortCpltCallback     : SPI Abort callback
            (+) MspInitCallback       : SPI Msp Init callback
            (+) MspDeInitCallback     : SPI Msp DeInit callback

       By default, after the HAL_SPI_Init() and when the state is HAL_SPI_STATE_RESET
       all callbacks are set to the corresponding weak functions:
       examples HAL_SPI_MasterTxCpltCallback(), HAL_SPI_MasterRxCpltCallback().
       Exception done for MspInit and MspDeInit functions that are
       reset to the legacy weak functions in the HAL_SPI_Init()/ HAL_SPI_DeInit() only when
       these callbacks are null (not registered beforehand).
       If MspInit or MspDeInit are not null, the HAL_SPI_Init()/ HAL_SPI_DeInit()
       keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.

       Callbacks can be registered/unregistered in HAL_SPI_STATE_READY state only.
       Exception done MspInit/MspDeInit functions that can be registered/unregistered
       in HAL_SPI_STATE_READY or HAL_SPI_STATE_RESET state,
       thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
       Then, the user first registers the MspInit/MspDeInit user callbacks
       using HAL_SPI_RegisterCallback() before calling HAL_SPI_DeInit()
       or HAL_SPI_Init() function.

       When The compilation define USE_HAL_PPP_REGISTER_CALLBACKS is set to 0 or
       not defined, the callback registering feature is not available
       and weak (surcharged) callbacks are used.

     [..]
       Using the HAL it is not possible to reach all supported SPI frequency with the different SPI Modes,
       the following table resume the max SPI frequency reached with data size 8bits/16bits,
         according to frequency of the APBx Peripheral Clock (fPCLK) used by the SPI instance.

  @endverbatim

  Additional table :

       DataSize = SPI_DATASIZE_8BIT:
       +----------------------------------------------------------------------------------------------+
       |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
       | Process | Tranfert mode  |---------------------|----------------------|----------------------|
       |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
       |==============================================================================================|
       |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
       |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
       |    /    |     Interrupt  | Fpclk/4  | Fpclk/8  |    NA     |    NA    |    NA     |   NA     |
       |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
       |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
       |=========|================|==========|==========|===========|==========|===========|==========|
       |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
       |         |----------------|----------|----------|-----------|----------|-----------|----------|
       |    R    |     Interrupt  | Fpclk/8  | Fpclk/8  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
       |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
       |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
       |=========|================|==========|==========|===========|==========|===========|==========|
       |         |     Polling    | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
       |         |----------------|----------|----------|-----------|----------|-----------|----------|
       |    T    |     Interrupt  | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
       |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
       |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
       +----------------------------------------------------------------------------------------------+

       DataSize = SPI_DATASIZE_16BIT:
       +----------------------------------------------------------------------------------------------+
       |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
       | Process | Tranfert mode  |---------------------|----------------------|----------------------|
       |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
       |==============================================================================================|
       |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
       |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
       |    /    |     Interrupt  | Fpclk/4  | Fpclk/4  |    NA     |    NA    |    NA     |   NA     |
       |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
       |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
       |=========|================|==========|==========|===========|==========|===========|==========|
       |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/32  | Fpclk/2  |
       |         |----------------|----------|----------|-----------|----------|-----------|----------|
       |    R    |     Interrupt  | Fpclk/4  | Fpclk/4  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
       |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
       |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
       |=========|================|==========|==========|===========|==========|===========|==========|
       |         |     Polling    | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/32 |
       |         |----------------|----------|----------|-----------|----------|-----------|----------|
       |    T    |     Interrupt  | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
       |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
       |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
       +----------------------------------------------------------------------------------------------+
       @note The max SPI frequency depend on SPI data size (8bits, 16bits),
             SPI mode(2 Lines fullduplex, 2 lines RxOnly, 1 line TX/RX) and Process mode (Polling, IT, DMA).
       @note
            (#) TX/RX processes are HAL_SPI_TransmitReceive(), HAL_SPI_TransmitReceive_IT() and HAL_SPI_TransmitReceive_DMA()
            (#) RX processes are HAL_SPI_Receive(), HAL_SPI_Receive_IT() and HAL_SPI_Receive_DMA()
            (#) TX processes are HAL_SPI_Transmit(), HAL_SPI_Transmit_IT() and HAL_SPI_Transmit_DMA()

  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SPI SPI
  * @brief SPI HAL module driver
  * @{
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_SPI_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private defines -----------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup SPI_Private_Constants SPI Private Constants
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPI_DEFAULT_TIMEOUT</name></cpp:macro> <cpp:value>100U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPI_BSY_FLAG_WORKAROUND_TIMEOUT</name></cpp:macro> <cpp:value>1000U</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; Timeout 1000 Âµs             */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private macros ------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup SPI_Private_Functions SPI Private Functions
  * @{
  */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMATransmitCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMATransmitReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAHalfTransmitCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAHalfReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAHalfTransmitReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAAbortOnError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMATxAbortCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMARxAbortCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SPI_WaitFlagStateUntilTimeout</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>State</name></decl></parameter>,
                                                       <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_TxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_TxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesTxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesTxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_8BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_16BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_8BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_16BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_AbortRx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_AbortTx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_CloseRxTx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_CloseRx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_CloseTx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SPI_EndRxTransaction</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SPI_EndRxTxTransaction</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup SPI_Exported_Functions SPI Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization and Configuration functions
 *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]  This subsection provides a set of functions allowing to initialize and
          de-initialize the SPIx peripheral:

      (+) User must implement HAL_SPI_MspInit() function in which he configures
          all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).

      (+) Call the function HAL_SPI_Init() to configure the selected device with
          the selected configuration:
        (++) Mode
        (++) Direction
        (++) Data Size
        (++) Clock Polarity and Phase
        (++) NSS Management
        (++) BaudRate Prescaler
        (++) FirstBit
        (++) TIMode
        (++) CRC Calculation
        (++) CRC Polynomial if CRC enabled

      (+) Call the function HAL_SPI_DeInit() to restore the default configuration
          of the selected SPIx peripheral.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the SPI according to the specified parameters
  *         in the SPI_InitTypeDef and initialize the associated handle.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Init</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the SPI handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hspi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_MODE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DIRECTION</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DATASIZE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_NSS</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NSS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_BAUDRATE_PRESCALER</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>BaudRatePrescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_FIRST_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FirstBit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_TIMODE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TIMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TIMode</name></name> <operator>==</operator> <name>SPI_TIMODE_DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_CPOL</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CLKPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_CPHA</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CLKPhase</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_CRC_CALCULATION</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_CRC_POLYNOMIAL</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCPolynomial</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>=</operator> <name>SPI_CRCCALCULATION_DISABLE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SPI_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Init the SPI Callback settings */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxCpltCallback</name></name>       <operator>=</operator> <name>HAL_SPI_TxCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak TxCpltCallback       */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxCpltCallback</name></name>       <operator>=</operator> <name>HAL_SPI_RxCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak RxCpltCallback       */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxRxCpltCallback</name></name>     <operator>=</operator> <name>HAL_SPI_TxRxCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak TxRxCpltCallback     */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxHalfCpltCallback</name></name>   <operator>=</operator> <name>HAL_SPI_TxHalfCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak TxHalfCpltCallback   */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxHalfCpltCallback</name></name>   <operator>=</operator> <name>HAL_SPI_RxHalfCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak RxHalfCpltCallback   */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxRxHalfCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_TxRxHalfCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TxRxHalfCpltCallback */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name>        <operator>=</operator> <name>HAL_SPI_ErrorCallback</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak ErrorCallback        */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name>    <operator>=</operator> <name>HAL_SPI_AbortCpltCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak AbortCpltCallback    */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SPI_MspInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspInit  */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC... */</comment>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC... */</comment>
    <expr_stmt><expr><call><name>HAL_SPI_MspInit</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the selected SPI peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*----------------------- SPIx CR1 &amp; CR2 Configuration ---------------------*/</comment>
  <comment type="block">/* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>|</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>|</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>|</operator>
                                  <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CLKPolarity</name></name> <operator>|</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CLKPhase</name></name> <operator>|</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NSS</name></name> <operator>&amp;</operator> <name>SPI_CR1_SSM</name><operator>)</operator> <operator>|</operator>
                                  <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>BaudRatePrescaler</name></name> <operator>|</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FirstBit</name></name>  <operator>|</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Configure : NSS management, TI Mode */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NSS</name></name> <operator>&gt;&gt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>&amp;</operator> <name>SPI_CR2_SSOE</name><operator>)</operator> <operator>|</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TIMode</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/*---------------------------- SPIx CRCPOLY Configuration ------------------*/</comment>
  <comment type="block">/* Configure : CRC Polynomial */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CRCPR</name></name></expr></argument>, <argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCPolynomial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPI_I2SCFGR_I2SMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>I2SCFGR</name></name></expr></argument>, <argument><expr><name>SPI_I2SCFGR_I2SMOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SPI_I2SCFGR_I2SMOD */</comment>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  De-Initialize the SPI peripheral.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_DeInit</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the SPI handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hspi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check SPI Instance parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the SPI Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SPI_MspDeInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspDeInit  */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC... */</comment>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC... */</comment>
  <expr_stmt><expr><call><name>HAL_SPI_MspDeInit</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the SPI MSP.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_MspInit</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_MspInit should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  De-Initialize the SPI MSP.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_MspDeInit</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_MspDeInit should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User SPI Callback
  *         To be used instead of the weak predefined callback
  * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for the specified SPI.
  * @param  CallbackID ID of the callback to be registered
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>HAL_SPI_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pSPI_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SPI_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_SPI_STATE_READY</name> <operator>==</operator> <name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SPI_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_TX_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxRxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_TX_HALF_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxHalfCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_RX_HALF_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxHalfCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxRxHalfCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_INVALID_CALLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_SPI_STATE_RESET</name> <operator>==</operator> <name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SPI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_INVALID_CALLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_INVALID_CALLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister an SPI Callback
  *         SPI callback is redirected to the weak predefined callback
  * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for the specified SPI.
  * @param  CallbackID ID of the callback to be unregistered
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>HAL_SPI_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_SPI_STATE_READY</name> <operator>==</operator> <name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SPI_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_TxCpltCallback</name></expr>;</expr_stmt>             <comment type="block">/* Legacy weak TxCpltCallback       */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_RxCpltCallback</name></expr>;</expr_stmt>             <comment type="block">/* Legacy weak RxCpltCallback       */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_TX_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxRxCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_TxRxCpltCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak TxRxCpltCallback     */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_TX_HALF_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxHalfCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_TxHalfCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak TxHalfCpltCallback   */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_RX_HALF_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxHalfCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_RxHalfCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak RxHalfCpltCallback   */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxRxHalfCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_TxRxHalfCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TxRxHalfCpltCallback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>HAL_SPI_ErrorCallback</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak ErrorCallback        */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name> <operator>=</operator> <name>HAL_SPI_AbortCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak AbortCpltCallback    */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SPI_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SPI_MspDeInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_INVALID_CALLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_SPI_STATE_RESET</name> <operator>==</operator> <name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SPI_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SPI_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SPI_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SPI_MspDeInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_INVALID_CALLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_INVALID_CALLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SPI_Exported_Functions_Group2 IO operation functions
 *  @brief   Data transfers functions
 *
@verbatim
  ==============================================================================
                      ##### IO operation functions #####
 ===============================================================================
 [..]
    This subsection provides a set of functions allowing to manage the SPI
    data transfers.

    [..] The SPI supports master and slave mode :

    (#) There are two modes of transfer:
       (++) Blocking mode: The communication is performed in polling mode.
            The HAL status of all data processing is returned by the same function
            after finishing transfer.
       (++) No-Blocking mode: The communication is performed using Interrupts
            or DMA, These APIs return the HAL status.
            The end of the data processing will be indicated through the
            dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
            using DMA mode.
            The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
            will be executed respectively at the end of the transmit or Receive process
            The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected

    (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
        exist for 1Line (simplex) and 2Lines (full duplex) modes.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Transmit an amount of data in blocking mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pData pointer to data buffer
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Transmit</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>initial_TxXferCount</name></decl>;</decl_stmt>

  <comment type="block">/* Check Direction parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DIRECTION_2LINES_OR_1LINE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>initial_TxXferCount</name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_SPI_STATE_BUSY_TX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/*Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Configure communication direction : 1Line */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_1LINE_TX</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Transmit data in 16 Bit mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>==</operator> <name>SPI_DATASIZE_16BIT</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_SLAVE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>initial_TxXferCount</name> <operator>==</operator> <literal type="number">0x01U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Transmit data in 16 Bit mode */</comment>
    <while>while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until TXE flag is set to send data */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_TXE</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Timeout management */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;=</operator>  <name>Timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
          <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <comment type="block">/* Transmit data in 8 Bit mode */</comment>
  <else>else
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_SLAVE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>initial_TxXferCount</name> <operator>==</operator> <literal type="number">0x01U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until TXE flag is set to send data */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_TXE</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Timeout management */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;=</operator>  <name>Timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
          <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Enable CRC Transmission */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Check the end of the transaction */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_FLAG</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear overrun flag in 2 Lines communication mode because received is not read */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error</name>:</label>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive an amount of data in blocking mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pData pointer to data buffer
  * @param  Size amount of data to be received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Receive</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <comment type="block">/* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */</comment>
    <return>return <expr><call><name>HAL_SPI_TransmitReceive</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/*Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* this is done to handle the CRCNEXT before the latest data */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Configure communication direction: 1Line */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_1LINE_RX</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Receive data in 8 Bit mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>==</operator> <name>SPI_DATASIZE_8BIT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Transfer loop */</comment>
    <while>while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check the RXNE flag */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* read the received data */</comment>
        <expr_stmt><expr><operator>(</operator><operator>*</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Timeout management */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;=</operator>  <name>Timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
          <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Transfer loop */</comment>
    <while>while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check the RXNE flag */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Timeout management */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;=</operator>  <name>Timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
          <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Handle the CRC Transmission */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* freeze the CRC before the latest data */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read the latest data */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* the latest data has not been received */</comment>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
      <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Receive last data in 16 Bit mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>==</operator> <name>SPI_DATASIZE_16BIT</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Receive last data in 8 Bit mode */</comment>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Wait the CRC data */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
      <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read CRC to Flush DR and RXNE flag */</comment>
    <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Check the end of the transaction */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_FLAG</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Check if CRC error occurred */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_CRCERR</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_CRCERRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error</name> :</label>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit and Receive an amount of data in blocking mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pTxData pointer to transmission data buffer
  * @param  pRxData pointer to reception data buffer
  * @param  Size amount of data to be sent and received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_TransmitReceive</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pTxData</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pRxData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>,
                                          <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type>             <name>initial_TxXferCount</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>             <name>tmp_mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_SPI_StateTypeDef</name></type> <name>tmp_state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>             <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Variable used to alternate Rx and Tx during transfer */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>             <name>txallowed</name> <init>= <expr><literal type="number">1U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type>    <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check Direction parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DIRECTION_2LINES</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Init temporary variables */</comment>
  <expr_stmt><expr><name>tmp_state</name>           <operator>=</operator> <name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp_mode</name>            <operator>=</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>initial_TxXferCount</name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>tmp_state</name> <operator>==</operator> <name>HAL_SPI_STATE_READY</name><operator>)</operator> <operator>||</operator> \
        <operator>(</operator><operator>(</operator><name>tmp_mode</name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp_state</name> <operator>==</operator> <name>HAL_SPI_STATE_BUSY_RX</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pTxData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pRxData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY_TX_RX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pRxData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pTxData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/*Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Transmit and Receive data in 16 Bit mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>==</operator> <name>SPI_DATASIZE_16BIT</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_SLAVE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>initial_TxXferCount</name> <operator>==</operator> <literal type="number">0x01U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check TXE flag */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_TXE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>txallowed</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        <comment type="block">/* Next Data is a reception (Rx). Tx not allowed */</comment>
        <expr_stmt><expr><name>txallowed</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
        <comment type="block">/* Enable CRC Transmission */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Check RXNE flag */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        <comment type="block">/* Next Data is a Transmission (Tx). Tx is allowed */</comment>
        <expr_stmt><expr><name>txallowed</name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;=</operator>  <name>Timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <comment type="block">/* Transmit and Receive data in 8 Bit mode */</comment>
  <else>else
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_SLAVE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>initial_TxXferCount</name> <operator>==</operator> <literal type="number">0x01U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check TXE flag */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_TXE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>txallowed</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        <comment type="block">/* Next Data is a reception (Rx). Tx not allowed */</comment>
        <expr_stmt><expr><name>txallowed</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
        <comment type="block">/* Enable CRC Transmission */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Wait until RXNE flag is reset */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>&gt;</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        <comment type="block">/* Next Data is a Transmission (Tx). Tx is allowed */</comment>
        <expr_stmt><expr><name>txallowed</name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;=</operator>  <name>Timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Read CRC from DR to close CRC calculation process */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until TXE flag */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Error on the CRC reception */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_TIMEOUT</name></expr>;</expr_stmt>
      <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Read CRC */</comment>
    <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if CRC error occurred */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_CRCERR</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Clear CRC Flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_CRCERRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Check the end of the transaction */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_FLAG</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear overrun flag in 2 Lines communication mode because received is not read */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error</name> :</label>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit an amount of data in non-blocking mode with Interrupt.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pData pointer to data buffer
  * @param  Size amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Transmit_IT</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check Direction parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DIRECTION_2LINES_OR_1LINE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_SPI_STATE_BUSY_TX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/* Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Set the function for IT treatment */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>&gt;</operator> <name>SPI_DATASIZE_8BIT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name> <operator>=</operator> <name>SPI_TxISR_16BIT</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name> <operator>=</operator> <name>SPI_TxISR_8BIT</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Configure communication direction : 1Line */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_1LINE_TX</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Enable TXE and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_ENABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_TXE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error</name> :</label>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive an amount of data in non-blocking mode with Interrupt.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pData pointer to data buffer
  * @param  Size amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Receive_IT</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <comment type="block">/* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */</comment>
    <return>return <expr><call><name>HAL_SPI_TransmitReceive_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/* Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Set the function for IT treatment */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>&gt;</operator> <name>SPI_DATASIZE_8BIT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator> <name>SPI_RxISR_16BIT</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator> <name>SPI_RxISR_8BIT</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Configure communication direction : 1Line */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_1LINE_RX</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Enable TXE and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_ENABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Note : The SPI must be enabled after unlocking current process
            to avoid the risk of SPI interrupt handle execution before current
            process unlock */</comment>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error</name> :</label>
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit and Receive an amount of data in non-blocking mode with Interrupt.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pTxData pointer to transmission data buffer
  * @param  pRxData pointer to reception data buffer
  * @param  Size amount of data to be sent and received
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_TransmitReceive_IT</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pTxData</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pRxData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type>             <name>tmp_mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_SPI_StateTypeDef</name></type> <name>tmp_state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type>    <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check Direction parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DIRECTION_2LINES</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Init temporary variables */</comment>
  <expr_stmt><expr><name>tmp_state</name>           <operator>=</operator> <name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp_mode</name>            <operator>=</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>tmp_state</name> <operator>==</operator> <name>HAL_SPI_STATE_READY</name><operator>)</operator> <operator>||</operator> \
        <operator>(</operator><operator>(</operator><name>tmp_mode</name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp_state</name> <operator>==</operator> <name>HAL_SPI_STATE_BUSY_RX</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pTxData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pRxData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY_TX_RX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pTxData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pRxData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/* Set the function for IT treatment */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DataSize</name></name> <operator>&gt;</operator> <name>SPI_DATASIZE_8BIT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>     <operator>=</operator> <name>SPI_2linesRxISR_16BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>     <operator>=</operator> <name>SPI_2linesTxISR_16BIT</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>     <operator>=</operator> <name>SPI_2linesRxISR_8BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>     <operator>=</operator> <name>SPI_2linesTxISR_8BIT</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Enable TXE, RXNE and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_ENABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_TXE</name> <operator>|</operator> <name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error</name> :</label>
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit an amount of data in non-blocking mode with DMA.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pData pointer to data buffer
  * @param  Size amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Transmit_DMA</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check tx dma handle */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DMA_HANDLE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check Direction parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DIRECTION_2LINES_OR_1LINE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_SPI_STATE_BUSY_TX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/* Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Configure communication direction : 1Line */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_1LINE_TX</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Set the SPI TxDMA Half transfer complete callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>SPI_DMAHalfTransmitCplt</name></expr>;</expr_stmt>

  <comment type="block">/* Set the SPI TxDMA transfer complete callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>SPI_DMATransmitCplt</name></expr>;</expr_stmt>

  <comment type="block">/* Set the DMA error callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>SPI_DMAError</name></expr>;</expr_stmt>

  <comment type="block">/* Set the DMA AbortCpltCallback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Tx DMA Stream/Channel */</comment>
  <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update SPI error code */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the SPI Error Interrupt Bit */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_ENABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Tx DMA Request */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>error</name> :</label>
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive an amount of data in non-blocking mode with DMA.
  * @note   In case of MASTER mode and SPI_DIRECTION_2LINES direction, hdmatx shall be defined.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pData pointer to data buffer
  * @note   When the CRC feature is enabled the pData Length must be Size + 1.
  * @param  Size amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Receive_DMA</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check rx dma handle */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DMA_HANDLE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>;</expr_stmt>

    <comment type="block">/* Check tx dma handle */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DMA_HANDLE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */</comment>
    <return>return <expr><call><name>HAL_SPI_TransmitReceive_DMA</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/*Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Configure communication direction : 1Line */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_1LINE_RX</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Set the SPI RxDMA Half transfer complete callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>SPI_DMAHalfReceiveCplt</name></expr>;</expr_stmt>

  <comment type="block">/* Set the SPI Rx DMA transfer complete callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>SPI_DMAReceiveCplt</name></expr>;</expr_stmt>

  <comment type="block">/* Set the DMA error callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>SPI_DMAError</name></expr>;</expr_stmt>

  <comment type="block">/* Set the DMA AbortCpltCallback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Rx DMA Stream/Channel  */</comment>
  <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update SPI error code */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the SPI Error Interrupt Bit */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_ENABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Rx DMA Request */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>error</name>:</label>
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit and Receive an amount of data in non-blocking mode with DMA.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pTxData pointer to transmission data buffer
  * @param  pRxData pointer to reception data buffer
  * @note   When the CRC feature is enabled the pRxData Length must be Size + 1
  * @param  Size amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_TransmitReceive_DMA</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pTxData</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pRxData</name></decl></parameter>,
                                              <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type>             <name>tmp_mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_SPI_StateTypeDef</name></type> <name>tmp_state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check rx &amp; tx dma handles */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DMA_HANDLE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DMA_HANDLE</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check Direction parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SPI_DIRECTION_2LINES</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Init temporary variables */</comment>
  <expr_stmt><expr><name>tmp_state</name>           <operator>=</operator> <name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp_mode</name>            <operator>=</operator> <name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>tmp_state</name> <operator>==</operator> <name>HAL_SPI_STATE_READY</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>tmp_mode</name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp_state</name> <operator>==</operator> <name>HAL_SPI_STATE_BUSY_RX</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pTxData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pRxData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_BUSY_TX_RX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the transaction information */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pTxData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name>  <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pRxData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferSize</name></name>  <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>

  <comment type="block">/* Init field not used in handle to zero */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Reset CRC Calculation */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <comment type="block">/* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set the SPI Rx DMA Half transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>SPI_DMAHalfReceiveCplt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name>     <operator>=</operator> <name>SPI_DMAReceiveCplt</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Set the SPI Tx/Rx DMA Half transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>SPI_DMAHalfTransmitReceiveCplt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name>     <operator>=</operator> <name>SPI_DMATransmitReceiveCplt</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the DMA error callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>SPI_DMAError</name></expr>;</expr_stmt>

  <comment type="block">/* Set the DMA AbortCpltCallback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Rx DMA Stream/Channel  */</comment>
  <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update SPI error code */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable Rx DMA Request */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
  is performed in DMA reception complete callback  */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name>     <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Tx DMA Stream/Channel  */</comment>
  <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update SPI error code */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if the SPI is already enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>SPI_CR1_SPE</name><operator>)</operator> <operator>!=</operator> <name>SPI_CR1_SPE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_ENABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Enable the SPI Error Interrupt Bit */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_ENABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Tx DMA Request */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>error</name> :</label>
  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Abort ongoing transfer (blocking mode).
  * @param  hspi SPI handle.
  * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
  *         started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable SPI Interrupts (depending of transfer direction)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
  *           - Set handle State to READY
  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
  * @retval HAL status
*/</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Abort</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>resetcount</name></decl>;</decl_stmt>

  <comment type="block">/* Initialized local variable  */</comment>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>resetcount</name> <operator>=</operator> <name>SPI_DEFAULT_TIMEOUT</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">24U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>count</name> <operator>=</operator> <name>resetcount</name></expr>;</expr_stmt>

  <comment type="block">/* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_ERRIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXEIE</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name> <operator>=</operator> <name>SPI_AbortTx_ISR</name></expr>;</expr_stmt>
    <comment type="block">/* Wait HAL_SPI_STATE_ABORT state */</comment>
    <do>do
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_ABORT</name></expr>)</condition>;</do>
    <comment type="block">/* Reset Timeout Counter */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>resetcount</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXNEIE</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator> <name>SPI_AbortRx_ISR</name></expr>;</expr_stmt>
    <comment type="block">/* Wait HAL_SPI_STATE_ABORT state */</comment>
    <do>do
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_ABORT</name></expr>)</condition>;</do>
    <comment type="block">/* Reset Timeout Counter */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>resetcount</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the SPI DMA Tx request if enabled */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the SPI DMA Abort callback :
      will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */</comment>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Abort DMA Tx Handle linked to SPI Peripheral */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Disable Tx DMA Request */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_CR2_TXDMAEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Wait until TXE flag is set */</comment>
      <do>do
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block>
      while <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name> <operator>&amp;</operator> <name>SPI_FLAG_TXE</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the SPI DMA Rx request if enabled */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the SPI DMA Abort callback :
      will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */</comment>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Abort DMA Rx Handle linked to SPI Peripheral */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Disable peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable Rx DMA Request */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_CR2_RXDMAEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Reset Tx and Rx transfer counters */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Check error during Abort procedure */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* return HAL_Error in case of error during Abort procedure */</comment>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Reset errorCode */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Clear the Error flags in the SR register */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_FREFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Restore hspi-&gt;state to ready */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Abort ongoing transfer (Interrupt mode).
  * @param  hspi SPI handle.
  * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
  *         started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable SPI Interrupts (depending of transfer direction)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
  *           - Set handle State to READY
  *           - At abort completion, call user abort complete callback
  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
  *         considered as completed only when user abort complete callback is executed (not when exiting function).
  * @retval HAL status
*/</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_Abort_IT</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>abortcplt</name></decl> ;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>resetcount</name></decl>;</decl_stmt>

  <comment type="block">/* Initialized local variable  */</comment>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>abortcplt</name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>resetcount</name> <operator>=</operator> <name>SPI_DEFAULT_TIMEOUT</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">24U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>count</name> <operator>=</operator> <name>resetcount</name></expr>;</expr_stmt>

  <comment type="block">/* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_ERRIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXEIE</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name> <operator>=</operator> <name>SPI_AbortTx_ISR</name></expr>;</expr_stmt>
    <comment type="block">/* Wait HAL_SPI_STATE_ABORT state */</comment>
    <do>do
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_ABORT</name></expr>)</condition>;</do>
    <comment type="block">/* Reset Timeout Counter */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>resetcount</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXNEIE</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator> <name>SPI_AbortRx_ISR</name></expr>;</expr_stmt>
    <comment type="block">/* Wait HAL_SPI_STATE_ABORT state */</comment>
    <do>do
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_ABORT</name></expr>)</condition>;</do>
    <comment type="block">/* Reset Timeout Counter */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>resetcount</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
     before any call to DMA Abort functions */</comment>
  <comment type="block">/* DMA Tx Handle is valid */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
       Otherwise, set it to NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>SPI_DMATxAbortCallback</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* DMA Rx Handle is valid */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
       Otherwise, set it to NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>SPI_DMARxAbortCallback</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the SPI DMA Tx request if enabled */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Abort the SPI DMA Tx Stream/Channel */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Abort DMA Tx Handle linked to SPI Peripheral */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name>abortcplt</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Disable the SPI DMA Rx request if enabled */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Abort the SPI DMA Rx Stream/Channel */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Abort DMA Rx Handle linked to SPI Peripheral */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>  <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name>abortcplt</name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>abortcplt</name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Reset Tx and Rx transfer counters */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

    <comment type="block">/* Check error during Abort procedure */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* return HAL_Error in case of error during Abort procedure */</comment>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Reset errorCode */</comment>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Clear the Error flags in the SR register */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_FREFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore hspi-&gt;State to Ready */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

    <comment type="block">/* As no DMA to be aborted, call directly user Abort complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SPI_AbortCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Pause the DMA Transfer.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_DMAPause</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the SPI DMA Tx &amp; Rx requests */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name> <operator>|</operator> <name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Resume the DMA Transfer.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_DMAResume</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Process Locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the SPI DMA Tx &amp; Rx requests */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name> <operator>|</operator> <name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process Unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the DMA Transfer.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SPI_DMAStop</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>errorcode</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* The Lock is not implemented on this API to allow the user application
     to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
     when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
     and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
     */</comment>

  <comment type="block">/* Abort the SPI DMA tx Stream/Channel  */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Abort the SPI DMA rx Stream/Channel  */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Disable the SPI DMA Tx &amp; Rx requests */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name> <operator>|</operator> <name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
  <return>return <expr><name>errorcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle SPI interrupt request.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_SPI_IRQHandler</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>itsource</name> <init>= <expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>itflag</name>   <init>= <expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* SPI in mode Receiver ----------------------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_OVR</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator>
      <operator>(</operator><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SPI_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsource</name></expr></argument>, <argument><expr><name>SPI_IT_RXNE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SPI in mode Transmitter -------------------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_TXE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SPI_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsource</name></expr></argument>, <argument><expr><name>SPI_IT_TXE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>TxISR</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SPI in Error Treatment --------------------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_MODF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_OVR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_FRE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SPI_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsource</name></expr></argument>, <argument><expr><name>SPI_IT_ERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* SPI Overrun error interrupt occurred ----------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_OVR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SPI_STATE_BUSY_TX</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_OVR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* SPI Mode Fault error interrupt occurred -------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_MODF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_MODF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_MODFFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* SPI Frame error interrupt occurred ------------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_CHECK_FLAG</name><argument_list>(<argument><expr><name>itflag</name></expr></argument>, <argument><expr><name>SPI_FLAG_FRE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FRE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_FREFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable all interrupts */</comment>
      <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_TXE</name> <operator>|</operator> <name>SPI_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
      <comment type="block">/* Disable the SPI DMA requests if enabled */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name>itsource</name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name>itsource</name></expr></argument>, <argument><expr><name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_CR2_TXDMAEN</name> <operator>|</operator> <name>SPI_CR2_RXDMAEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Abort the SPI DMA Rx channel */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */</comment>
          <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>SPI_DMAAbortOnError</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Abort the SPI DMA Tx channel */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */</comment>
          <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>SPI_DMAAbortOnError</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>HAL_OK</name> <operator>!=</operator> <call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Tx Transfer completed callback.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_TxCpltCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxCpltCallback should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx Transfer completed callback.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_RxCpltCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxCpltCallback should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Tx and Rx Transfer completed callback.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_TxRxCpltCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Tx Half Transfer completed callback.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_TxHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx Half Transfer completed callback.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_RxHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Tx and Rx Half Transfer callback.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_TxRxHalfCpltCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  SPI error callback.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_ErrorCallback should be implemented in the user file
   */</comment>
  <comment type="block">/* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
            and user can use HAL_SPI_GetError() API to check the latest error occurred
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  SPI Abort Complete callback.
  * @param  hspi SPI handle.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SPI_AbortCpltCallback</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_AbortCpltCallback can be implemented in the user file.
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
  * @brief   SPI control functions
  *
@verbatim
 ===============================================================================
                      ##### Peripheral State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to control the SPI.
     (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
     (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the SPI handle state.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval SPI state
  */</comment>
<function><type><name>HAL_SPI_StateTypeDef</name></type> <name>HAL_SPI_GetState</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return SPI handle state */</comment>
  <return>return <expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the SPI error code.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval SPI error code in bitmap format
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_SPI_GetError</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return SPI ErrorCode */</comment>
  <return>return <expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup SPI_Private_Functions
  * @brief   Private functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI transmit process complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMATransmitCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* DMA Normal Mode */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CIRC</name><operator>)</operator> <operator>!=</operator> <name>DMA_SxCR_CIRC</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Tx DMA Request */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check the end of the transaction */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear overrun flag in 2 Lines communication mode because received data is not read */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Call user Tx complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>TxCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_TxCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI receive process complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* DMA Normal Mode */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CIRC</name><operator>)</operator> <operator>!=</operator> <name>DMA_SxCR_CIRC</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* CRC handling */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until RXNE flag */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Error on the CRC reception */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Read CRC */</comment>
      <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <comment type="block">/* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name> <operator>|</operator> <name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check the end of the transaction */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_FLAG</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Check if CRC error occurred */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_CRCERR</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_CRCERRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Call user Rx complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>RxCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_RxCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI transmit receive process complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMATransmitReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* DMA Normal Mode */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CIRC</name><operator>)</operator> <operator>!=</operator> <name>DMA_SxCR_CIRC</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* CRC handling */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait the CRC data */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Read CRC to Flush DR and RXNE flag */</comment>
      <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <comment type="block">/* Check the end of the transaction */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Rx/Tx DMA Request */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name> <operator>|</operator> <name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Check if CRC error occurred */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_CRCERR</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_CRCERRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Call user TxRx complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>TxRxCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_TxRxCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI half transmit process complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAHalfTransmitCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Call user Tx half complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>TxHalfCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_TxHalfCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI half receive process complete callback
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAHalfReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Call user Rx half complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>RxHalfCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_RxHalfCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI half transmit receive process complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAHalfTransmitReceiveCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Call user TxRx half complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>TxRxHalfCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_TxRxHalfCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI communication error callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Stop the disable DMA transfer on SPI side */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name> <operator>|</operator> <name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
  <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI communication abort callback, when initiated by HAL services on Error
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMAAbortOnError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI Tx communication abort callback, when initiated by user
  *         (To be called at end of DMA Tx Abort procedure following user abort request).
  * @note   When this callback is executed, User Abort complete call back is called only if no
  *         Abort still ongoing for Rx DMA Handle.
  * @param  hdma DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMATxAbortCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>count</name> <operator>=</operator> <name>SPI_DEFAULT_TIMEOUT</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">24U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Disable Tx DMA Request */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_TXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until TXE flag is set */</comment>
  <do>do
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block>
  while <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name> <operator>&amp;</operator> <name>SPI_FLAG_TXE</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>;</do>

  <comment type="block">/* Check if an Abort process is still ongoing */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Check no error during Abort procedure */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Reset errorCode */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear the Error flags in the SR register */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_FREFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Restore hspi-&gt;State to Ready */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>  <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Call user Abort complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_AbortCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA SPI Rx communication abort callback, when initiated by user
  *         (To be called at end of DMA Rx Abort procedure following user abort request).
  * @note   When this callback is executed, User Abort complete call back is called only if no
  *         Abort still ongoing for Tx DMA Handle.
  * @param  hdma DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_DMARxAbortCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name> <init>= <expr><operator>(</operator><name>SPI_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Disable SPI Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Disable Rx DMA Request */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>SPI_CR2_RXDMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check Busy flag */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if an Abort process is still ongoing */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Check no error during Abort procedure */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_ABORT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Reset errorCode */</comment>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear the Error flags in the SR register */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_FREFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Restore hspi-&gt;State to Ready */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name>  <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Call user Abort complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SPI_AbortCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Receive data in 8bit mode */</comment>
  <expr_stmt><expr><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

  <comment type="block">/* Check end of the reception */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator>  <name>SPI_2linesRxISR_8BITCRC</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <comment type="block">/* Disable RXNE  and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SPI_CloseRxTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_8BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Read 8bit CRC to flush Data Regsiter */</comment>
  <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable RXNE and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SPI_CloseRxTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Tx 8-bit handler for Transmit and Receive in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesTxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

  <comment type="block">/* Check the end of the transmission */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set CRC Next Bit to send CRC */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Disable TXE interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_TXE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <comment type="block">/* Disable TXE interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_TXE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SPI_CloseRxTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx 16-bit handler for Transmit and Receive in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Receive data in 16 Bit mode */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator>  <name>SPI_2linesRxISR_16BITCRC</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <comment type="block">/* Disable RXNE interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_RXNE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SPI_CloseRxTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Manage the CRC 16-bit receive for Transmit and Receive in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesRxISR_16BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Read 16bit CRC to flush Data Regsiter */</comment>
  <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable RXNE interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_RXNE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SPI_CloseRxTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Tx 16-bit handler for Transmit and Receive in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_2linesTxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Transmit data in 16 Bit mode */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

  <comment type="block">/* Enable CRC Transmission */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set CRC Next Bit to send CRC */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Disable TXE interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_TXE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

    <comment type="block">/* Disable TXE interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_TXE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SPI_CloseRxTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Manage the CRC 8-bit receive in Interrupt context.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_8BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Read 8bit CRC to flush Data Register */</comment>
  <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SPI_CloseRx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Manage the receive 8-bit in Interrupt context.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Enable CRC Transmission */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator>  <name>SPI_RxISR_8BITCRC</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
    <expr_stmt><expr><call><name>SPI_CloseRx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Manage the CRC 16-bit receive in Interrupt context.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_16BITCRC</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Read 16bit CRC to flush Data Register */</comment>
  <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable RXNE and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SPI_CloseRx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Manage the 16-bit receive in Interrupt context.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_RxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pRxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Enable CRC Transmission */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>RxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>RxISR</name></name> <operator>=</operator> <name>SPI_RxISR_16BITCRC</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
    <expr_stmt><expr><call><name>SPI_CloseRx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle the data 8-bit transmit in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_TxISR_8BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable CRC Transmission */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
    <expr_stmt><expr><call><name>SPI_CloseTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle the data 16-bit transmit in Interrupt mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_TxISR_16BIT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>__SPI_HandleTypeDef</name></name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Transmit data in 16 Bit mode */</comment>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>pTxBuffPtr</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name><operator>--</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>TxXferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable CRC Transmission */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>SPI_CR1_CRCNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
    <expr_stmt><expr><call><name>SPI_CloseTx_ISR</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle SPI Communication Timeout.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *              the configuration information for SPI module.
  * @param  Flag SPI flag to check
  * @param  State flag state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SPI_WaitFlagStateUntilTimeout</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>State</name></decl></parameter>,
                                                       <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><operator>(</operator><ternary><condition><expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>Flag</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>SET</name></expr> </then><else>: <expr><name>RESET</name></expr></else></ternary><operator>)</operator> <operator>!=</operator> <name>State</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;=</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */</comment>

        <comment type="block">/* Disable TXE, RXNE and ERR interrupts for the interrupt process */</comment>
        <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_TXE</name> <operator>|</operator> <name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name><operator>)</operator>
                                                     <operator>||</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES_RXONLY</name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable SPI peripheral */</comment>
          <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Reset CRC Calculation */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CRCCalculation</name></name> <operator>==</operator> <name>SPI_CRCCALCULATION_ENABLE</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SPI_RESET_CRC</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle the check of the RX transaction complete.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SPI_EndRxTransaction</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>,  <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_1LINE</name><operator>)</operator>
                                               <operator>||</operator> <operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES_RXONLY</name><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable SPI peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_MASTER</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>!=</operator> <name>SPI_DIRECTION_2LINES_RXONLY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Control the BSY flag */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_BSY</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Wait the RXNE reset */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Wait the RXNE reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_RXNE</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle the check of the RXTX or TX transaction complete.
  * @param  hspi SPI handle
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SPI_EndRxTxTransaction</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Timeout in Âµs */</comment>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><name>SPI_BSY_FLAG_WORKAROUND_TIMEOUT</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">24U</literal> <operator>/</operator> <literal type="number">1000000U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name> <operator>==</operator> <name>SPI_MODE_MASTER</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Control the BSY flag */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_WaitFlagStateUntilTimeout</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_BSY</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Wait BSY flag during 1 Byte time transfer in case of Full-Duplex and Tx transfer
    * If Timeout is reached, the transfer is considered as finish.
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */</comment>
    <do>do
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_BSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle the end of the RXTX transaction.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_CloseRxTx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><name>SPI_DEFAULT_TIMEOUT</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">24U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Init tickstart for timeout managment*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until TXE flag is set */</comment>
  <do>do
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block>
  while <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name> <operator>&amp;</operator> <name>SPI_FLAG_TXE</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>;</do>

  <comment type="block">/* Check the end of the transaction */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear overrun flag in 2 Lines communication mode because received is not read */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Check if CRC error occurred */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_CRCERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_CRCERRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SPI_STATE_BUSY_RX</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
        <comment type="block">/* Call user Rx complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>RxCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_SPI_RxCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
        <comment type="block">/* Call user TxRx complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>TxRxCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_SPI_TxRxCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
      <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle the end of the RX transaction.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_CloseRx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Disable RXNE and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_RXNE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the end of the transaction */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear overrun flag in 2 Lines communication mode because received is not read */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  <comment type="block">/* Check if CRC error occurred */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_SPI_GET_FLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_FLAG_CRCERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_CRCERRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Call user Rx complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>RxCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SPI_RxCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_SPI_CRC</name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr></cpp:if>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SPI_CRC */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle the end of the TX transaction.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_CloseTx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><name>SPI_DEFAULT_TIMEOUT</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">24U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until TXE flag is set */</comment>
  <do>do
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block>
  while <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name> <operator>&amp;</operator> <name>SPI_FLAG_TXE</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>;</do>

  <comment type="block">/* Disable TXE and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE_IT</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_IT_TXE</name> <operator>|</operator> <name>SPI_IT_ERR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the end of the transaction */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>SPI_EndRxTxTransaction</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>, <argument><expr><name>SPI_DEFAULT_TIMEOUT</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear overrun flag in 2 Lines communication mode because received is not read */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name> <operator>==</operator> <name>SPI_DIRECTION_2LINES</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_SPI_CLEAR_OVRFLAG</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_READY</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SPI_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SPI_ErrorCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Call user Rx complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SPI_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hspi</name><operator>-&gt;</operator><name>TxCpltCallback</name></name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SPI_TxCpltCallback</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SPI_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle abort a Rx transaction.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_AbortRx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><name>SPI_DEFAULT_TIMEOUT</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">24U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Wait until TXE flag is set */</comment>
  <do>do
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr></argument>, <argument><expr><name>HAL_SPI_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block>
  while <condition>(<expr><operator>(</operator><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name> <operator>&amp;</operator> <name>SPI_FLAG_TXE</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>;</do>

  <comment type="block">/* Disable SPI Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_CR2_TXEIE</name> <operator>|</operator> <name>SPI_CR2_RXNEIE</name> <operator>|</operator> <name>SPI_CR2_ERRIE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read CRC to flush Data Register */</comment>
  <expr_stmt><expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_ABORT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle abort a Tx or Rx/Tx transaction.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SPI_AbortTx_ISR</name><parameter_list>(<parameter><decl><type><name>SPI_HandleTypeDef</name> <modifier>*</modifier></type><name>hspi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Disable TXEIE interrupt */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hspi</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_CR2_TXEIE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable SPI Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_SPI_DISABLE</name><argument_list>(<argument><expr><name>hspi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hspi</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SPI_STATE_ABORT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_SPI_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
