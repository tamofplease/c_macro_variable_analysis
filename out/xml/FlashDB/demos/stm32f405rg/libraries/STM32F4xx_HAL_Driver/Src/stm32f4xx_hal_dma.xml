<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dma.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_dma.c
  * @author  MCD Application Team
  * @brief   DMA HAL module driver.
  *    
  *          This file provides firmware functions to manage the following 
  *          functionalities of the Direct Memory Access (DMA) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral State and errors functions
  @verbatim     
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
  [..]
   (#) Enable and configure the peripheral to be connected to the DMA Stream
       (except for internal SRAM/FLASH memories: no initialization is 
       necessary) please refer to Reference manual for connection between peripherals
       and DMA requests.

   (#) For a given Stream, program the required configuration through the following parameters:
       Transfer Direction, Source and Destination data formats, 
       Circular, Normal or peripheral flow control mode, Stream Priority level, 
       Source and Destination Increment mode, FIFO mode and its Threshold (if needed), 
       Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.

   -@-   Prior to HAL_DMA_Init() the clock must be enabled for DMA through the following macros:
         __HAL_RCC_DMA1_CLK_ENABLE() or __HAL_RCC_DMA2_CLK_ENABLE().

     *** Polling mode IO operation ***
     =================================
    [..]
          (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
              address and destination address and the Length of data to be transferred.
          (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
              case a fixed Timeout can be configured by User depending from his application.
          (+) Use HAL_DMA_Abort() function to abort the current transfer.

     *** Interrupt mode IO operation ***
     ===================================
    [..]
          (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
          (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() 
          (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
              Source address and destination address and the Length of data to be transferred. In this 
              case the DMA interrupt is configured 
          (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
          (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
              add his own function by customization of function pointer XferCpltCallback and 
              XferErrorCallback (i.e a member of DMA handle structure).
    [..]
     (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
         detection.

     (#) Use HAL_DMA_Abort_IT() function to abort the current transfer

     -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.

     -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
           possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
           Half-Word data size for the peripheral to access its data register and set Word data size
           for the Memory to gain in access time. Each two half words will be packed and written in
           a single access to a Word in the Memory).

     -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
           and Destination. In this case the Peripheral Data Size will be applied to both Source
           and Destination.

     *** DMA HAL driver macros list ***
     =============================================
     [..]
       Below the list of most used macros in DMA HAL driver.
       
      (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.
      (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.
      (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. 

     [..]
      (@) You can refer to the DMA HAL driver header file for more useful macros

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment> 

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup DMA DMA
  * @brief DMA HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_DMA_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private types -------------------------------------------------------------*/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>ISR</name></decl>;</decl_stmt>   <comment type="block" format="doxygen">/*!&lt; DMA interrupt status register */</comment>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Reserved0</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>IFCR</name></decl>;</decl_stmt>  <comment type="block" format="doxygen">/*!&lt; DMA interrupt flag clear register */</comment>
}</block></struct></type> <name>DMA_Base_Registers</name>;</typedef>

<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private constants ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup DMA_Private_Constants
 * @{
 */</comment>
 <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAL_TIMEOUT_DMA_ABORT</name></cpp:macro>    <cpp:value>5U</cpp:value></cpp:define>  <comment type="block">/* 5 ms */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block">/* Private macros ------------------------------------------------------------*/</comment>
<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup DMA_Private_Functions
  * @{
  */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DMA_SetConfig</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SrcAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DstAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DataLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>DMA_CalcBaseAndBitshift</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>DMA_CheckFifoParam</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>  

<comment type="block">/* Exported functions ---------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup DMA_Exported_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup DMA_Exported_Functions_Group1
  *
@verbatim
 ===============================================================================
             ##### Initialization and de-initialization functions  #####
 ===============================================================================
    [..]
    This section provides functions allowing to initialize the DMA Stream source
    and destination addresses, incrementation and data sizes, transfer direction, 
    circular/normal mode selection, memory-to-memory mode selection and Stream priority value.
    [..]
    The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    reference manual.

@endverbatim
  * @{
  */</comment>
  
<comment type="block" format="doxygen">/**
  * @brief  Initialize the DMA according to the specified
  *         parameters in the DMA_InitTypeDef and create the associated handle.
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_Init</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DMA_Base_Registers</name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

  <comment type="block">/* Check the DMA peripheral state */</comment>
  <if_stmt><if>if<condition>(<expr><name>hdma</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_STREAM_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_CHANNEL</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Channel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_DIRECTION</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_PERIPHERAL_INC_STATE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeriphInc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_MEMORY_INC_STATE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemInc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_PERIPHERAL_DATA_SIZE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeriphDataAlignment</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_MEMORY_DATA_SIZE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemDataAlignment</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_MODE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_PRIORITY</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Priority</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_FIFO_MODE_STATE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Check the memory burst, peripheral burst and FIFO threshold parameters only
     when FIFO mode is enabled */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOMode</name></name> <operator>!=</operator> <name>DMA_FIFOMODE_DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_FIFO_THRESHOLD</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOThreshold</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_MEMORY_BURST</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_PERIPHERAL_BURST</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeriphBurst</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Allocate lock resource */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change DMA peripheral state */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_BUSY</name></expr>;</expr_stmt>
  
  <comment type="block">/* Disable the peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_DMA_DISABLE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if the DMA Stream is effectively disabled */</comment>
  <while>while<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_EN</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>HAL_TIMEOUT_DMA_ABORT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_TIMEOUT</name></expr>;</expr_stmt>
      
      <comment type="block">/* Change the DMA state */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_TIMEOUT</name></expr>;</expr_stmt>
      
      <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <comment type="block">/* Get the CR register value */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>&amp;=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>~</operator><operator>(</operator><name>DMA_SxCR_CHSEL</name> <operator>|</operator> <name>DMA_SxCR_MBURST</name> <operator>|</operator> <name>DMA_SxCR_PBURST</name> <operator>|</operator> \
                      <name>DMA_SxCR_PL</name>    <operator>|</operator> <name>DMA_SxCR_MSIZE</name>  <operator>|</operator> <name>DMA_SxCR_PSIZE</name>  <operator>|</operator> \
                      <name>DMA_SxCR_MINC</name>  <operator>|</operator> <name>DMA_SxCR_PINC</name>   <operator>|</operator> <name>DMA_SxCR_CIRC</name>   <operator>|</operator> \
                      <name>DMA_SxCR_DIR</name>   <operator>|</operator> <name>DMA_SxCR_CT</name>     <operator>|</operator> <name>DMA_SxCR_DBM</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Prepare the DMA Stream configuration */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>|=</operator>  <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Channel</name></name>             <operator>|</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name>        <operator>|</operator>
          <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeriphInc</name></name>           <operator>|</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemInc</name></name>           <operator>|</operator>
          <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeriphDataAlignment</name></name> <operator>|</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemDataAlignment</name></name> <operator>|</operator>
          <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name>                <operator>|</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Priority</name></name></expr>;</expr_stmt>

  <comment type="block">/* the Memory burst and peripheral burst are not used when the FIFO is disabled */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOMode</name></name> <operator>==</operator> <name>DMA_FIFOMODE_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Get memory burst and peripheral burst */</comment>
    <expr_stmt><expr><name>tmp</name> <operator>|=</operator>  <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name> <operator>|</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeriphBurst</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Write to DMA Stream CR register */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>  

  <comment type="block">/* Get the FCR register value */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FCR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Clear Direct mode and FIFO threshold bits */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>~</operator><operator>(</operator><name>DMA_SxFCR_DMDIS</name> <operator>|</operator> <name>DMA_SxFCR_FTH</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Prepare the DMA Stream FIFO configuration */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>|=</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOMode</name></name></expr>;</expr_stmt>

  <comment type="block">/* The FIFO threshold is not used when the FIFO mode is disabled */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOMode</name></name> <operator>==</operator> <name>DMA_FIFOMODE_ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Get the FIFO threshold */</comment>
    <expr_stmt><expr><name>tmp</name> <operator>|=</operator> <name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOThreshold</name></name></expr>;</expr_stmt>
    
    <comment type="block">/* Check compatibility between FIFO threshold level and size of the memory burst */</comment>
    <comment type="block">/* for INCR4, INCR8, INCR16 bursts */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name> <operator>!=</operator> <name>DMA_MBURST_SINGLE</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>DMA_CheckFifoParam</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_PARAM</name></expr>;</expr_stmt>
        
        <comment type="block">/* Change the DMA state */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>
        
        <return>return <expr><name>HAL_ERROR</name></expr>;</return> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Write to DMA Stream FCR */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FCR</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */</comment>
  <expr_stmt><expr><name>regs</name> <operator>=</operator> <operator>(</operator><name>DMA_Base_Registers</name> <operator>*</operator><operator>)</operator><call><name>DMA_CalcBaseAndBitshift</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Clear all interrupt flags */</comment>
  <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <literal type="number">0x3FU</literal> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>

  <comment type="block">/* Initialize the error code */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NONE</name></expr>;</expr_stmt>
                                                                                     
  <comment type="block">/* Initialize the DMA state */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the DMA peripheral 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_DeInit</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>DMA_Base_Registers</name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

  <comment type="block">/* Check the DMA peripheral state */</comment>
  <if_stmt><if>if<condition>(<expr><name>hdma</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Check the DMA peripheral state */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_DMA_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_STREAM_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the selected DMA Streamx */</comment>
  <expr_stmt><expr><call><name>__HAL_DMA_DISABLE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset DMA Streamx control register */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>   <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Reset DMA Streamx number of data to transfer register */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>NDTR</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Reset DMA Streamx peripheral address register */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PAR</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Reset DMA Streamx memory 0 address register */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>M0AR</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  
  <comment type="block">/* Reset DMA Streamx memory 1 address register */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>M1AR</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  
  <comment type="block">/* Reset DMA Streamx FIFO control register */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FCR</name></name>  <operator>=</operator> <literal type="number">0x00000021U</literal></expr>;</expr_stmt>
  
  <comment type="block">/* Get DMA steam Base Address */</comment>  
  <expr_stmt><expr><name>regs</name> <operator>=</operator> <operator>(</operator><name>DMA_Base_Registers</name> <operator>*</operator><operator>)</operator><call><name>DMA_CalcBaseAndBitshift</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Clean all callbacks */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1CpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Clear all interrupt flags at correct offset within the register */</comment>
  <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <literal type="number">0x3FU</literal> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>

  <comment type="block">/* Reset the error code */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Reset the DMA state */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup DMA_Exported_Functions_Group2
  *
@verbatim   
 ===============================================================================
                      #####  IO operation functions  #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure the source, destination address and data length and Start DMA transfer
      (+) Configure the source, destination address and data length and 
          Start DMA transfer with interrupt
      (+) Abort DMA transfer
      (+) Poll for transfer complete
      (+) Handle DMA interrupt request  

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Starts the DMA Transfer.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_Start</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SrcAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DstAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DataLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_BUFFER_SIZE</name><argument_list>(<argument><expr><name>DataLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>HAL_DMA_STATE_READY</name> <operator>==</operator> <name><name>hdma</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Change DMA peripheral state */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_BUSY</name></expr>;</expr_stmt>
    
    <comment type="block">/* Initialize the error code */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NONE</name></expr>;</expr_stmt>
    
    <comment type="block">/* Configure the source, destination address and the data length */</comment>
    <expr_stmt><expr><call><name>DMA_SetConfig</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>, <argument><expr><name>SrcAddress</name></expr></argument>, <argument><expr><name>DstAddress</name></expr></argument>, <argument><expr><name>DataLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable the Peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_DMA_ENABLE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt> 
  <return>return <expr><name>status</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the DMA Transfer with interrupt enabled.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.  
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_Start_IT</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SrcAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DstAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DataLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* calculate DMA base and stream number */</comment>
  <decl_stmt><decl><type><name>DMA_Base_Registers</name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><operator>(</operator><name>DMA_Base_Registers</name> <operator>*</operator><operator>)</operator><name><name>hdma</name><operator>-&gt;</operator><name>StreamBaseAddress</name></name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_DMA_BUFFER_SIZE</name><argument_list>(<argument><expr><name>DataLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>HAL_DMA_STATE_READY</name> <operator>==</operator> <name><name>hdma</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Change DMA peripheral state */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_BUSY</name></expr>;</expr_stmt>
    
    <comment type="block">/* Initialize the error code */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NONE</name></expr>;</expr_stmt>
    
    <comment type="block">/* Configure the source, destination address and the data length */</comment>
    <expr_stmt><expr><call><name>DMA_SetConfig</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>, <argument><expr><name>SrcAddress</name></expr></argument>, <argument><expr><name>DstAddress</name></expr></argument>, <argument><expr><name>DataLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Clear all interrupt flags at correct offset within the register */</comment>
    <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <literal type="number">0x3FU</literal> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
    
    <comment type="block">/* Enable Common interrupts*/</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>|=</operator> <name>DMA_IT_TC</name> <operator>|</operator> <name>DMA_IT_TE</name> <operator>|</operator> <name>DMA_IT_DME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FCR</name></name> <operator>|=</operator> <name>DMA_IT_FE</name></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>|=</operator> <name>DMA_IT_HT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Enable the Peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_DMA_ENABLE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	  
    
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Aborts the DMA Transfer.
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  *                   
  * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is 
  *        effectively disabled is added. If a Stream is disabled 
  *        while a data transfer is ongoing, the current data will be transferred
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_Abort</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* calculate DMA base and stream number */</comment>
  <decl_stmt><decl><type><name>DMA_Base_Registers</name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><operator>(</operator><name>DMA_Base_Registers</name> <operator>*</operator><operator>)</operator><name><name>hdma</name><operator>-&gt;</operator><name>StreamBaseAddress</name></name></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_DMA_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NO_XFER</name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Disable all the transfer interrupts */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_TC</name> <operator>|</operator> <name>DMA_IT_TE</name> <operator>|</operator> <name>DMA_IT_DME</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_FE</name><operator>)</operator></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_HT</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Disable the stream */</comment>
    <expr_stmt><expr><call><name>__HAL_DMA_DISABLE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if the DMA Stream is effectively disabled */</comment>
    <while>while<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_EN</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>HAL_TIMEOUT_DMA_ABORT</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_TIMEOUT</name></expr>;</expr_stmt>
        
        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Change the DMA state */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_TIMEOUT</name></expr>;</expr_stmt>
        
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    
    <comment type="block">/* Clear all interrupt flags at correct offset within the register */</comment>
    <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <literal type="number">0x3FU</literal> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Change the DMA state*/</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Aborts the DMA Transfer in Interrupt mode.
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_Abort_IT</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_DMA_STATE_BUSY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NO_XFER</name></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Set Abort State  */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_ABORT</name></expr>;</expr_stmt>
    
    <comment type="block">/* Disable the stream */</comment>
    <expr_stmt><expr><call><name>__HAL_DMA_DISABLE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Polling for transfer complete.
  * @param  hdma          pointer to a DMA_HandleTypeDef structure that contains
  *                        the configuration information for the specified DMA Stream.
  * @param  CompleteLevel Specifies the DMA level complete.
  * @note   The polling mode is kept in this version for legacy. it is recommanded to use the IT model instead.
  *         This model could be used for debug purpose.
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). 
  * @param  Timeout       Timeout duration.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_PollForTransfer</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>, <parameter><decl><type><name>HAL_DMA_LevelCompleteTypeDef</name></type> <name>CompleteLevel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>mask_cpltlevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpisr</name></decl>;</decl_stmt>
  
  <comment type="block">/* calculate DMA base and stream number */</comment>
  <decl_stmt><decl><type><name>DMA_Base_Registers</name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><name>HAL_DMA_STATE_BUSY</name> <operator>!=</operator> <name><name>hdma</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* No transfer ongoing */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NO_XFER</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Polling mode not supported in circular mode and double buffering mode */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CIRC</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_NOT_SUPPORTED</name></expr>;</expr_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Get the level transfer complete flag */</comment>
  <if_stmt><if>if<condition>(<expr><name>CompleteLevel</name> <operator>==</operator> <name>HAL_DMA_FULL_TRANSFER</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Transfer Complete flag */</comment>
    <expr_stmt><expr><name>mask_cpltlevel</name> <operator>=</operator> <name>DMA_FLAG_TCIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Half Transfer Complete flag */</comment>
    <expr_stmt><expr><name>mask_cpltlevel</name> <operator>=</operator> <name>DMA_FLAG_HTIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <expr_stmt><expr><name>regs</name> <operator>=</operator> <operator>(</operator><name>DMA_Base_Registers</name> <operator>*</operator><operator>)</operator><name><name>hdma</name><operator>-&gt;</operator><name>StreamBaseAddress</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpisr</name> <operator>=</operator> <name><name>regs</name><operator>-&gt;</operator><name>ISR</name></name></expr>;</expr_stmt>
  
  <while>while<condition>(<expr><operator>(</operator><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <name>mask_cpltlevel</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>&amp;</operator> <name>HAL_DMA_ERROR_TE</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout (Not applicable in circular mode)*/</comment>
    <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator><operator>||</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_DMA_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Change the DMA state */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>
        
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the ISR register value */</comment>
    <expr_stmt><expr><name>tmpisr</name> <operator>=</operator> <name><name>regs</name><operator>-&gt;</operator><name>ISR</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_TEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DMA_ERROR_TE</name></expr>;</expr_stmt>
      
      <comment type="block">/* Clear the transfer error flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_TEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_FEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DMA_ERROR_FE</name></expr>;</expr_stmt>
      
      <comment type="block">/* Clear the FIFO error flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_FEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_DMEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DMA_ERROR_DME</name></expr>;</expr_stmt>
      
      <comment type="block">/* Clear the Direct Mode error flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_DMEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_DMA_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>&amp;</operator> <name>HAL_DMA_ERROR_TE</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
      <comment type="block">/* Clear the half transfer and transfer complete flags */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <operator>(</operator><name>DMA_FLAG_HTIF0_4</name> <operator>|</operator> <name>DMA_FLAG_TCIF0_4</name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
    
      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Change the DMA state */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name><operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
   </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Get the level transfer complete flag */</comment>
  <if_stmt><if>if<condition>(<expr><name>CompleteLevel</name> <operator>==</operator> <name>HAL_DMA_FULL_TRANSFER</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Clear the half transfer and transfer complete flags */</comment>
    <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <operator>(</operator><name>DMA_FLAG_HTIF0_4</name> <operator>|</operator> <name>DMA_FLAG_TCIF0_4</name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
    
    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Clear the half transfer and transfer complete flags */</comment>
    <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <operator>(</operator><name>DMA_FLAG_HTIF0_4</name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handles DMA interrupt request.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_DMA_IRQHandler</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpisr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>timeout</name> <init>= <expr><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">9600U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* calculate DMA base and stream number */</comment>
  <decl_stmt><decl><type><name>DMA_Base_Registers</name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><operator>(</operator><name>DMA_Base_Registers</name> <operator>*</operator><operator>)</operator><name><name>hdma</name><operator>-&gt;</operator><name>StreamBaseAddress</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>tmpisr</name> <operator>=</operator> <name><name>regs</name><operator>-&gt;</operator><name>ISR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Transfer Error Interrupt management ***************************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_TEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_DMA_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>, <argument><expr><name>DMA_IT_TE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable the transfer error interrupt */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_TE</name><operator>)</operator></expr>;</expr_stmt>
      
      <comment type="block">/* Clear the transfer error flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_TEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
      
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DMA_ERROR_TE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* FIFO Error Interrupt management ******************************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_FEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_DMA_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>, <argument><expr><name>DMA_IT_FE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the FIFO error flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_FEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>

      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DMA_ERROR_FE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Direct Mode Error Interrupt management ***********************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_DMEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_DMA_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>, <argument><expr><name>DMA_IT_DME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the direct mode error flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_DMEIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>

      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_DMA_ERROR_DME</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Half Transfer Complete Interrupt management ******************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_HTIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_DMA_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>, <argument><expr><name>DMA_IT_HT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the half transfer complete flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_HTIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
      
      <comment type="block">/* Multi_Buffering mode enabled */</comment>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>DMA_SxCR_DBM</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Current memory buffer used is Memory 0 */</comment>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CT</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>
        <block>{<block_content>
          <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Half transfer callback */</comment>
            <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Current memory buffer used is Memory 1 */</comment>
        <else>else
        <block>{<block_content>
          <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Half transfer callback */</comment>
            <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */</comment>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CIRC</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable the half transfer interrupt */</comment>
          <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_HT</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Half transfer callback */</comment>
          <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Transfer Complete Interrupt management ***********************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpisr</name> <operator>&amp;</operator> <operator>(</operator><name>DMA_FLAG_TCIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>__HAL_DMA_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>, <argument><expr><name>DMA_IT_TC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the transfer complete flag */</comment>
      <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <name>DMA_FLAG_TCIF0_4</name> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>
      
      <if_stmt><if>if<condition>(<expr><name>HAL_DMA_STATE_ABORT</name> <operator>==</operator> <name><name>hdma</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable all the transfer interrupts */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_TC</name> <operator>|</operator> <name>DMA_IT_TE</name> <operator>|</operator> <name>DMA_IT_DME</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FCR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_FE</name><operator>)</operator></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_HT</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Clear all interrupt flags at correct offset within the register */</comment>
        <expr_stmt><expr><name><name>regs</name><operator>-&gt;</operator><name>IFCR</name></name> <operator>=</operator> <literal type="number">0x3FU</literal> <operator>&lt;&lt;</operator> <name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Change the DMA state */</comment>
        <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>DMA_SxCR_DBM</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Current memory buffer used is Memory 0 */</comment>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CT</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>
        <block>{<block_content>
          <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1CpltCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Transfer complete Callback for memory1 */</comment>
            <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferM1CpltCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Current memory buffer used is Memory 1 */</comment>
        <else>else
        <block>{<block_content>
          <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Transfer complete Callback for memory0 */</comment>
            <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <comment type="block">/* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */</comment>
      <else>else
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_CIRC</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable the transfer complete interrupt */</comment>
          <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name>  <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DMA_IT_TC</name><operator>)</operator></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Change the DMA state */</comment>
          <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Transfer complete callback */</comment>
          <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* manage error case */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_DMA_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>&amp;</operator> <name>HAL_DMA_ERROR_TE</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_ABORT</name></expr>;</expr_stmt>

      <comment type="block">/* Disable the stream */</comment>
      <expr_stmt><expr><call><name>__HAL_DMA_DISABLE</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <do>do
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;</operator> <name>timeout</name></expr>)</condition>
        <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;</operator> <name>DMA_SxCR_EN</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Change the DMA state */</comment>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_DMA_STATE_READY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Transfer error callback */</comment>
      <expr_stmt><expr><call><name><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Register callbacks
  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
  *                               the configuration information for the specified DMA Stream.
  * @param  CallbackID           User Callback identifer
  *                               a DMA_HandleTypeDef structure as parameter.
  * @param  pCallback            pointer to private callbacsk function which has pointer to 
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */</comment>                      
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>, <parameter><decl><type><name>HAL_DMA_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier> <name>pCallback</name>)<parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>_hdma</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>

  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>HAL_DMA_STATE_READY</name> <operator>==</operator> <name><name>hdma</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case  <expr><name>HAL_DMA_XFER_CPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case  <expr><name>HAL_DMA_XFER_HALFCPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case  <expr><name>HAL_DMA_XFER_M1CPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1CpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case  <expr><name>HAL_DMA_XFER_M1HALFCPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case  <expr><name>HAL_DMA_XFER_ERROR_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case  <expr><name>HAL_DMA_XFER_ABORT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default:</default>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  UnRegister callbacks
  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
  *                               the configuration information for the specified DMA Stream.
  * @param  CallbackID           User Callback identifer
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */</comment>              
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_DMA_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>, <parameter><decl><type><name>HAL_DMA_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name>HAL_DMA_STATE_READY</name> <operator>==</operator> <name><name>hdma</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
    <case>case  <expr><name>HAL_DMA_XFER_CPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
      
    <case>case  <expr><name>HAL_DMA_XFER_HALFCPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
      
    <case>case  <expr><name>HAL_DMA_XFER_M1CPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1CpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
      
    <case>case  <expr><name>HAL_DMA_XFER_M1HALFCPLT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
      
    <case>case  <expr><name>HAL_DMA_XFER_ERROR_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
      
    <case>case  <expr><name>HAL_DMA_XFER_ABORT_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break> 
      
    <case>case   <expr><name>HAL_DMA_XFER_ALL_CB_ID</name></expr>:</case>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1CpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferM1HalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break> 
      
    <default>default:</default>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hdma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup DMA_Exported_Functions_Group3
  *
@verbatim
 ===============================================================================
                    ##### State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides functions allowing to
      (+) Check the DMA state
      (+) Get error code

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Returns the DMA state.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_DMA_StateTypeDef</name></type> <name>HAL_DMA_GetState</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hdma</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the DMA error code
  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_DMA_GetError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hdma</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup DMA_Private_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Sets the DMA Transfer parameter.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DMA_SetConfig</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>SrcAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DstAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DataLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Clear DBM bit */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><name>DMA_SxCR_DBM</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Configure DMA Stream data length */</comment>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>NDTR</name></name> <operator>=</operator> <name>DataLength</name></expr>;</expr_stmt>

  <comment type="block">/* Memory to Peripheral */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Direction</name></name><operator>)</operator> <operator>==</operator> <name>DMA_MEMORY_TO_PERIPH</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Configure DMA Stream destination address */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PAR</name></name> <operator>=</operator> <name>DstAddress</name></expr>;</expr_stmt>

    <comment type="block">/* Configure DMA Stream source address */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>M0AR</name></name> <operator>=</operator> <name>SrcAddress</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* Peripheral to Memory */</comment>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Configure DMA Stream source address */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>PAR</name></name> <operator>=</operator> <name>SrcAddress</name></expr>;</expr_stmt>

    <comment type="block">/* Configure DMA Stream destination address */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>M0AR</name></name> <operator>=</operator> <name>DstAddress</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Returns the DMA Stream base address depending on stream number
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>DMA_CalcBaseAndBitshift</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>stream_number</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name></name> <operator>&amp;</operator> <literal type="number">0xFFU</literal><operator>)</operator> <operator>-</operator> <literal type="number">16U</literal><operator>)</operator> <operator>/</operator> <literal type="number">24U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* lookup table for necessary bitshift of flags within status registers */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>flagBitshiftOffset</name><index>[<expr><literal type="number">8U</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0U</literal></expr>, <expr><literal type="number">6U</literal></expr>, <expr><literal type="number">16U</literal></expr>, <expr><literal type="number">22U</literal></expr>, <expr><literal type="number">0U</literal></expr>, <expr><literal type="number">6U</literal></expr>, <expr><literal type="number">16U</literal></expr>, <expr><literal type="number">22U</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>StreamIndex</name></name> <operator>=</operator> <name><name>flagBitshiftOffset</name><index>[<expr><name>stream_number</name></expr>]</index></name></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>stream_number</name> <operator>&gt;</operator> <literal type="number">3U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* return pointer to HISR and HIFCR */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>StreamBaseAddress</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name></name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><literal type="number">0x3FFU</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">4U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* return pointer to LISR and LIFCR */</comment>
    <expr_stmt><expr><name><name>hdma</name><operator>-&gt;</operator><name>StreamBaseAddress</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hdma</name><operator>-&gt;</operator><name>Instance</name></name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><literal type="number">0x3FFU</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <return>return <expr><name><name>hdma</name><operator>-&gt;</operator><name>StreamBaseAddress</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Check compatibility between FIFO threshold level and size of the memory burst
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>DMA_CheckFifoParam</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>FIFOThreshold</name></name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Memory Data size equal to Byte */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemDataAlignment</name></name> <operator>==</operator> <name>DMA_MDATAALIGN_BYTE</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>tmp</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_1QUARTERFULL</name></expr>:</case>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_3QUARTERSFULL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name> <operator>&amp;</operator> <name>DMA_SxCR_MBURST_1</name><operator>)</operator> <operator>==</operator> <name>DMA_SxCR_MBURST_1</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_HALFFULL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name> <operator>==</operator> <name>DMA_MBURST_INC16</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_FULL</name></expr>:</case>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  
  <comment type="block">/* Memory Data size equal to Half-Word */</comment>
  <if type="elseif">else if <condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemDataAlignment</name></name> <operator>==</operator> <name>DMA_MDATAALIGN_HALFWORD</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>tmp</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_1QUARTERFULL</name></expr>:</case>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_3QUARTERSFULL</name></expr>:</case>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_HALFFULL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name> <operator>&amp;</operator> <name>DMA_SxCR_MBURST_1</name><operator>)</operator> <operator>==</operator> <name>DMA_SxCR_MBURST_1</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_FULL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name> <operator>==</operator> <name>DMA_MBURST_INC16</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>   
    <default>default:</default>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  
  <comment type="block">/* Memory Data size equal to Word */</comment>
  <else>else
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>tmp</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_1QUARTERFULL</name></expr>:</case>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_HALFFULL</name></expr>:</case>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_3QUARTERSFULL</name></expr>:</case>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>DMA_FIFO_THRESHOLD_FULL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdma</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>MemBurst</name></name> <operator>&amp;</operator> <name>DMA_SxCR_MBURST_1</name><operator>)</operator> <operator>==</operator> <name>DMA_SxCR_MBURST_1</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt> 
  
  <return>return <expr><name>status</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_DMA_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
