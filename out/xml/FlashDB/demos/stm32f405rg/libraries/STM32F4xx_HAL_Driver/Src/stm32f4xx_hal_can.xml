<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_can.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_can.c
  * @author  MCD Application Team
  * @brief   CAN HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Controller Area Network (CAN) peripheral:
  *           + Initialization and de-initialization functions
  *           + Configuration functions
  *           + Control functions
  *           + Interrupts management
  *           + Callbacks functions
  *           + Peripheral State and Error functions
  *
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
    [..]
      (#) Initialize the CAN low level resources by implementing the
          HAL_CAN_MspInit():
         (++) Enable the CAN interface clock using __HAL_RCC_CANx_CLK_ENABLE()
         (++) Configure CAN pins
             (+++) Enable the clock for the CAN GPIOs
             (+++) Configure CAN pins as alternate function open-drain
         (++) In case of using interrupts (e.g. HAL_CAN_ActivateNotification())
             (+++) Configure the CAN interrupt priority using
                   HAL_NVIC_SetPriority()
             (+++) Enable the CAN IRQ handler using HAL_NVIC_EnableIRQ()
             (+++) In CAN IRQ handler, call HAL_CAN_IRQHandler()

      (#) Initialize the CAN peripheral using HAL_CAN_Init() function. This
          function resorts to HAL_CAN_MspInit() for low-level initialization.

      (#) Configure the reception filters using the following configuration
          functions:
            (++) HAL_CAN_ConfigFilter()

      (#) Start the CAN module using HAL_CAN_Start() function. At this level
          the node is active on the bus: it receive messages, and can send
          messages.

      (#) To manage messages transmission, the following Tx control functions
          can be used:
            (++) HAL_CAN_AddTxMessage() to request transmission of a new
                 message.
            (++) HAL_CAN_AbortTxRequest() to abort transmission of a pending
                 message.
            (++) HAL_CAN_GetTxMailboxesFreeLevel() to get the number of free Tx
                 mailboxes.
            (++) HAL_CAN_IsTxMessagePending() to check if a message is pending
                 in a Tx mailbox.
            (++) HAL_CAN_GetTxTimestamp() to get the timestamp of Tx message
                 sent, if time triggered communication mode is enabled.

      (#) When a message is received into the CAN Rx FIFOs, it can be retrieved
          using the HAL_CAN_GetRxMessage() function. The function
          HAL_CAN_GetRxFifoFillLevel() allows to know how many Rx message are
          stored in the Rx Fifo.

      (#) Calling the HAL_CAN_Stop() function stops the CAN module.

      (#) The deinitialization is achieved with HAL_CAN_DeInit() function.


      *** Polling mode operation ***
      ==============================
    [..]
      (#) Reception:
            (++) Monitor reception of message using HAL_CAN_GetRxFifoFillLevel()
                 until at least one message is received.
            (++) Then get the message using HAL_CAN_GetRxMessage().

      (#) Transmission:
            (++) Monitor the Tx mailboxes availability until at least one Tx
                 mailbox is free, using HAL_CAN_GetTxMailboxesFreeLevel().
            (++) Then request transmission of a message using
                 HAL_CAN_AddTxMessage().


      *** Interrupt mode operation ***
      ================================
    [..]
      (#) Notifications are activated using HAL_CAN_ActivateNotification()
          function. Then, the process can be controlled through the
          available user callbacks: HAL_CAN_xxxCallback(), using same APIs
          HAL_CAN_GetRxMessage() and HAL_CAN_AddTxMessage().

      (#) Notifications can be deactivated using
          HAL_CAN_DeactivateNotification() function.

      (#) Special care should be taken for CAN_IT_RX_FIFO0_MSG_PENDING and
          CAN_IT_RX_FIFO1_MSG_PENDING notifications. These notifications trig
          the callbacks HAL_CAN_RxFIFO0MsgPendingCallback() and
          HAL_CAN_RxFIFO1MsgPendingCallback(). User has two possible options
          here.
            (++) Directly get the Rx message in the callback, using
                 HAL_CAN_GetRxMessage().
            (++) Or deactivate the notification in the callback without
                 getting the Rx message. The Rx message can then be got later
                 using HAL_CAN_GetRxMessage(). Once the Rx message have been
                 read, the notification can be activated again.


      *** Sleep mode ***
      ==================
    [..]
      (#) The CAN peripheral can be put in sleep mode (low power), using
          HAL_CAN_RequestSleep(). The sleep mode will be entered as soon as the
          current CAN activity (transmission or reception of a CAN frame) will
          be completed.

      (#) A notification can be activated to be informed when the sleep mode
          will be entered.

      (#) It can be checked if the sleep mode is entered using
          HAL_CAN_IsSleepActive().
          Note that the CAN state (accessible from the API HAL_CAN_GetState())
          is HAL_CAN_STATE_SLEEP_PENDING as soon as the sleep mode request is
          submitted (the sleep mode is not yet entered), and become
          HAL_CAN_STATE_SLEEP_ACTIVE when the sleep mode is effective.

      (#) The wake-up from sleep mode can be trigged by two ways:
            (++) Using HAL_CAN_WakeUp(). When returning from this function,
                 the sleep mode is exited (if return status is HAL_OK).
            (++) When a start of Rx CAN frame is detected by the CAN peripheral,
                 if automatic wake up mode is enabled.

  *** Callback registration ***
  =============================================

  The compilation define  USE_HAL_CAN_REGISTER_CALLBACKS when set to 1
  allows the user to configure dynamically the driver callbacks.
  Use Function @ref HAL_CAN_RegisterCallback() to register an interrupt callback.

  Function @ref HAL_CAN_RegisterCallback() allows to register following callbacks:
    (+) TxMailbox0CompleteCallback   : Tx Mailbox 0 Complete Callback.
    (+) TxMailbox1CompleteCallback   : Tx Mailbox 1 Complete Callback.
    (+) TxMailbox2CompleteCallback   : Tx Mailbox 2 Complete Callback.
    (+) TxMailbox0AbortCallback      : Tx Mailbox 0 Abort Callback.
    (+) TxMailbox1AbortCallback      : Tx Mailbox 1 Abort Callback.
    (+) TxMailbox2AbortCallback      : Tx Mailbox 2 Abort Callback.
    (+) RxFifo0MsgPendingCallback    : Rx Fifo 0 Message Pending Callback.
    (+) RxFifo0FullCallback          : Rx Fifo 0 Full Callback.
    (+) RxFifo1MsgPendingCallback    : Rx Fifo 1 Message Pending Callback.
    (+) RxFifo1FullCallback          : Rx Fifo 1 Full Callback.
    (+) SleepCallback                : Sleep Callback.
    (+) WakeUpFromRxMsgCallback      : Wake Up From Rx Message Callback.
    (+) ErrorCallback                : Error Callback.
    (+) MspInitCallback              : CAN MspInit.
    (+) MspDeInitCallback            : CAN MspDeInit.
  This function takes as parameters the HAL peripheral handle, the Callback ID
  and a pointer to the user callback function.

  Use function @ref HAL_CAN_UnRegisterCallback() to reset a callback to the default
  weak function.
  @ref HAL_CAN_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.
  This function allows to reset following callbacks:
    (+) TxMailbox0CompleteCallback   : Tx Mailbox 0 Complete Callback.
    (+) TxMailbox1CompleteCallback   : Tx Mailbox 1 Complete Callback.
    (+) TxMailbox2CompleteCallback   : Tx Mailbox 2 Complete Callback.
    (+) TxMailbox0AbortCallback      : Tx Mailbox 0 Abort Callback.
    (+) TxMailbox1AbortCallback      : Tx Mailbox 1 Abort Callback.
    (+) TxMailbox2AbortCallback      : Tx Mailbox 2 Abort Callback.
    (+) RxFifo0MsgPendingCallback    : Rx Fifo 0 Message Pending Callback.
    (+) RxFifo0FullCallback          : Rx Fifo 0 Full Callback.
    (+) RxFifo1MsgPendingCallback    : Rx Fifo 1 Message Pending Callback.
    (+) RxFifo1FullCallback          : Rx Fifo 1 Full Callback.
    (+) SleepCallback                : Sleep Callback.
    (+) WakeUpFromRxMsgCallback      : Wake Up From Rx Message Callback.
    (+) ErrorCallback                : Error Callback.
    (+) MspInitCallback              : CAN MspInit.
    (+) MspDeInitCallback            : CAN MspDeInit.

  By default, after the @ref HAL_CAN_Init() and when the state is HAL_CAN_STATE_RESET,
  all callbacks are set to the corresponding weak functions:
  example @ref HAL_CAN_ErrorCallback().
  Exception done for MspInit and MspDeInit functions that are
  reset to the legacy weak function in the @ref HAL_CAN_Init()/ @ref HAL_CAN_DeInit() only when
  these callbacks are null (not registered beforehand).
  if not, MspInit or MspDeInit are not null, the @ref HAL_CAN_Init()/ @ref HAL_CAN_DeInit()
  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

  Callbacks can be registered/unregistered in HAL_CAN_STATE_READY state only.
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_CAN_STATE_READY or HAL_CAN_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using @ref HAL_CAN_RegisterCallback() before calling @ref HAL_CAN_DeInit()
  or @ref HAL_CAN_Init() function.

  When The compilation define USE_HAL_CAN_REGISTER_CALLBACKS is set to 0 or
  not defined, the callback registration feature is not available and all callbacks
  are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CAN1</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block" format="doxygen">/** @defgroup CAN CAN
  * @brief CAN driver modules
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_CAN_MODULE_ENABLED</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_CAN_LEGACY_MODULE_ENABLED</name></cpp:ifdef>
  <cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"The CAN driver cannot be used with its legacy, Please enable only one CAN module at once"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup CAN_Private_Constants CAN Private Constants
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAN_TIMEOUT_VALUE</name></cpp:macro> <cpp:value>10U</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup CAN_Exported_Functions CAN Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup CAN_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization and Configuration functions
 *
@verbatim
  ==============================================================================
              ##### Initialization and de-initialization functions #####
  ==============================================================================
    [..]  This section provides functions allowing to:
      (+) HAL_CAN_Init                       : Initialize and configure the CAN.
      (+) HAL_CAN_DeInit                     : De-initialize the CAN.
      (+) HAL_CAN_MspInit                    : Initialize the CAN MSP.
      (+) HAL_CAN_MspDeInit                  : DeInitialize the CAN MSP.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the CAN peripheral according to the specified
  *         parameters in the CAN_InitStruct.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_Init</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Check CAN handle */</comment>
  <if_stmt><if>if <condition>(<expr><name>hcan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TimeTriggeredMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoBusOff</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoWakeUp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoRetransmission</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ReceiveFifoLocked</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TransmitFifoPriority</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_MODE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_SJW</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>SyncJumpWidth</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_BS1</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TimeSeg1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_BS2</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TimeSeg2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_PRESCALER</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Prescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Reset callbacks to legacy functions */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0MsgPendingCallback</name></name>  <operator>=</operator>  <name>HAL_CAN_RxFifo0MsgPendingCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak RxFifo0MsgPendingCallback  */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0FullCallback</name></name>        <operator>=</operator>  <name>HAL_CAN_RxFifo0FullCallback</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak RxFifo0FullCallback        */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1MsgPendingCallback</name></name>  <operator>=</operator>  <name>HAL_CAN_RxFifo1MsgPendingCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak RxFifo1MsgPendingCallback  */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1FullCallback</name></name>        <operator>=</operator>  <name>HAL_CAN_RxFifo1FullCallback</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak RxFifo1FullCallback        */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0CompleteCallback</name></name> <operator>=</operator>  <name>HAL_CAN_TxMailbox0CompleteCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TxMailbox0CompleteCallback */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1CompleteCallback</name></name> <operator>=</operator>  <name>HAL_CAN_TxMailbox1CompleteCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TxMailbox1CompleteCallback */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2CompleteCallback</name></name> <operator>=</operator>  <name>HAL_CAN_TxMailbox2CompleteCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak TxMailbox2CompleteCallback */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0AbortCallback</name></name>    <operator>=</operator>  <name>HAL_CAN_TxMailbox0AbortCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak TxMailbox0AbortCallback    */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1AbortCallback</name></name>    <operator>=</operator>  <name>HAL_CAN_TxMailbox1AbortCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak TxMailbox1AbortCallback    */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2AbortCallback</name></name>    <operator>=</operator>  <name>HAL_CAN_TxMailbox2AbortCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak TxMailbox2AbortCallback    */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>SleepCallback</name></name>              <operator>=</operator>  <name>HAL_CAN_SleepCallback</name></expr>;</expr_stmt>              <comment type="block">/* Legacy weak SleepCallback              */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>WakeUpFromRxMsgCallback</name></name>    <operator>=</operator>  <name>HAL_CAN_WakeUpFromRxMsgCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak WakeUpFromRxMsgCallback    */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCallback</name></name>              <operator>=</operator>  <name>HAL_CAN_ErrorCallback</name></expr>;</expr_stmt>              <comment type="block">/* Legacy weak ErrorCallback              */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_CAN_MspInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspInit */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Init the low level hardware: CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Init the low level hardware: CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name>HAL_CAN_MspInit</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* (USE_HAL_CAN_REGISTER_CALLBACKS) */</comment>

  <comment type="block">/* Exit from sleep mode */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check Sleep mode leave acknowledge */</comment>
  <while>while <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name> <operator>&amp;</operator> <name>CAN_MSR_SLAK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>CAN_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_TIMEOUT</name></expr>;</expr_stmt>

      <comment type="block">/* Change CAN state */</comment>
      <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_ERROR</name></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Request initialisation */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_INRQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait initialisation acknowledge */</comment>
  <while>while <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name> <operator>&amp;</operator> <name>CAN_MSR_INAK</name><operator>)</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>CAN_TIMEOUT_VALUE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_TIMEOUT</name></expr>;</expr_stmt>

      <comment type="block">/* Change CAN state */</comment>
      <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_ERROR</name></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Set the time triggered communication mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TimeTriggeredMode</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_TTCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_TTCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the automatic bus-off management */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoBusOff</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_ABOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_ABOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the automatic wake-up mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoWakeUp</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_AWUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_AWUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the automatic retransmission */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AutoRetransmission</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_NART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_NART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the receive FIFO locked mode */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ReceiveFifoLocked</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_RFLM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_RFLM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the transmit FIFO priority */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TransmitFifoPriority</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_TXFP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_TXFP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the bit timing register */</comment>
  <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>BTR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Mode</name></name>           <operator>|</operator>
                                            <name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>SyncJumpWidth</name></name>  <operator>|</operator>
                                            <name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TimeSeg1</name></name>       <operator>|</operator>
                                            <name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>TimeSeg2</name></name>       <operator>|</operator>
                                            <operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Prescaler</name></name> <operator>-</operator> <literal type="number">1U</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the error code */</comment>
  <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_CAN_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize the CAN state */</comment>
  <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Deinitializes the CAN peripheral registers to their default
  *         reset values.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_DeInit</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check CAN handle */</comment>
  <if_stmt><if>if <condition>(<expr><name>hcan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Stop the CAN module */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>HAL_CAN_Stop</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_CAN_MspDeInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspDeInit */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* DeInit the low level hardware: CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name>HAL_CAN_MspDeInit</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* (USE_HAL_CAN_REGISTER_CALLBACKS) */</comment>

  <comment type="block">/* Reset the CAN peripheral */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the CAN ErrorCode */</comment>
  <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_CAN_ERROR_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Change CAN state */</comment>
  <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the CAN MSP.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_MspInit</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the CAN MSP.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_MspDeInit</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a CAN CallBack.
  *         To be used instead of the weak predefined callback
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for CAN module
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *           @arg @ref HAL_CAN_TX_MAILBOX0_COMPLETE_CALLBACK_CB_ID Tx Mailbox 0 Complete callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX1_COMPLETE_CALLBACK_CB_ID Tx Mailbox 1 Complete callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX2_COMPLETE_CALLBACK_CB_ID Tx Mailbox 2 Complete callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX0_ABORT_CALLBACK_CB_ID Tx Mailbox 0 Abort callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX1_ABORT_CALLBACK_CB_ID Tx Mailbox 1 Abort callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX2_ABORT_CALLBACK_CB_ID Tx Mailbox 2 Abort callback ID
  *           @arg @ref HAL_CAN_RX_FIFO0_MSG_PENDING_CALLBACK_CB_ID Rx Fifo 0 message pending callback ID
  *           @arg @ref HAL_CAN_RX_FIFO0_FULL_CALLBACK_CB_ID Rx Fifo 0 full callback ID
  *           @arg @ref HAL_CAN_RX_FIFO1_MSGPENDING_CALLBACK_CB_ID Rx Fifo 1 message pending callback ID
  *           @arg @ref HAL_CAN_RX_FIFO1_FULL_CALLBACK_CB_ID Rx Fifo 1 full callback ID
  *           @arg @ref HAL_CAN_SLEEP_CALLBACK_CB_ID Sleep callback ID
  *           @arg @ref HAL_CAN_WAKEUP_FROM_RX_MSG_CALLBACK_CB_ID Wake Up from Rx message callback ID
  *           @arg @ref HAL_CAN_ERROR_CALLBACK_CB_ID Error callback ID
  *           @arg @ref HAL_CAN_MSPINIT_CB_ID MspInit callback ID
  *           @arg @ref HAL_CAN_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>HAL_CAN_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier> <name>pCallback</name>)<parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>_hcan</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0CompleteCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1CompleteCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2CompleteCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX0_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0AbortCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX1_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1AbortCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX2_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2AbortCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0MsgPendingCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO0_FULL_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0FullCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1MsgPendingCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO1_FULL_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1FullCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_SLEEP_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>SleepCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>WakeUpFromRxMsgCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_CAN_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a CAN CallBack.
  *         CAN callabck is redirected to the weak predefined callback
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for CAN module
  * @param  CallbackID ID of the callback to be unregistered
  *         This parameter can be one of the following values:
  *           @arg @ref HAL_CAN_TX_MAILBOX0_COMPLETE_CALLBACK_CB_ID Tx Mailbox 0 Complete callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX1_COMPLETE_CALLBACK_CB_ID Tx Mailbox 1 Complete callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX2_COMPLETE_CALLBACK_CB_ID Tx Mailbox 2 Complete callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX0_ABORT_CALLBACK_CB_ID Tx Mailbox 0 Abort callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX1_ABORT_CALLBACK_CB_ID Tx Mailbox 1 Abort callback ID
  *           @arg @ref HAL_CAN_TX_MAILBOX2_ABORT_CALLBACK_CB_ID Tx Mailbox 2 Abort callback ID
  *           @arg @ref HAL_CAN_RX_FIFO0_MSG_PENDING_CALLBACK_CB_ID Rx Fifo 0 message pending callback ID
  *           @arg @ref HAL_CAN_RX_FIFO0_FULL_CALLBACK_CB_ID Rx Fifo 0 full callback ID
  *           @arg @ref HAL_CAN_RX_FIFO1_MSGPENDING_CALLBACK_CB_ID Rx Fifo 1 message pending callback ID
  *           @arg @ref HAL_CAN_RX_FIFO1_FULL_CALLBACK_CB_ID Rx Fifo 1 full callback ID
  *           @arg @ref HAL_CAN_SLEEP_CALLBACK_CB_ID Sleep callback ID
  *           @arg @ref HAL_CAN_WAKEUP_FROM_RX_MSG_CALLBACK_CB_ID Wake Up from Rx message callback ID
  *           @arg @ref HAL_CAN_ERROR_CALLBACK_CB_ID Error callback ID
  *           @arg @ref HAL_CAN_MSPINIT_CB_ID MspInit callback ID
  *           @arg @ref HAL_CAN_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>HAL_CAN_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0CompleteCallback</name></name> <operator>=</operator> <name>HAL_CAN_TxMailbox0CompleteCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1CompleteCallback</name></name> <operator>=</operator> <name>HAL_CAN_TxMailbox1CompleteCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2CompleteCallback</name></name> <operator>=</operator> <name>HAL_CAN_TxMailbox2CompleteCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX0_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0AbortCallback</name></name> <operator>=</operator> <name>HAL_CAN_TxMailbox0AbortCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX1_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1AbortCallback</name></name> <operator>=</operator> <name>HAL_CAN_TxMailbox1AbortCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_TX_MAILBOX2_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2AbortCallback</name></name> <operator>=</operator> <name>HAL_CAN_TxMailbox2AbortCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0MsgPendingCallback</name></name> <operator>=</operator> <name>HAL_CAN_RxFifo0MsgPendingCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO0_FULL_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0FullCallback</name></name> <operator>=</operator> <name>HAL_CAN_RxFifo0FullCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1MsgPendingCallback</name></name> <operator>=</operator> <name>HAL_CAN_RxFifo1MsgPendingCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_RX_FIFO1_FULL_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1FullCallback</name></name> <operator>=</operator> <name>HAL_CAN_RxFifo1FullCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_SLEEP_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>SleepCallback</name></name> <operator>=</operator> <name>HAL_CAN_SleepCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>WakeUpFromRxMsgCallback</name></name> <operator>=</operator> <name>HAL_CAN_WakeUpFromRxMsgCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>HAL_CAN_ErrorCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_CAN_MspInit</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_CAN_MspDeInit</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_CAN_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_CAN_MspInit</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_CAN_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_CAN_MspDeInit</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup CAN_Exported_Functions_Group2 Configuration functions
 *  @brief    Configuration functions.
 *
@verbatim
  ==============================================================================
              ##### Configuration functions #####
  ==============================================================================
    [..]  This section provides functions allowing to:
      (+) HAL_CAN_ConfigFilter            : Configure the CAN reception filters

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Configures the CAN reception filter according to the specified
  *         parameters in the CAN_FilterInitStruct.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  sFilterConfig pointer to a CAN_FilterTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_ConfigFilter</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>CAN_FilterTypeDef</name> <modifier>*</modifier></type><name>sFilterConfig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>filternbrbitpos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CAN_TypeDef</name> <modifier>*</modifier></type><name>can_ip</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check the parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_ID_HALFWORD</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterIdHigh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_ID_HALFWORD</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterIdLow</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_ID_HALFWORD</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMaskIdHigh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_ID_HALFWORD</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMaskIdLow</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_MODE</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_SCALE</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterScale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_FIFO</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterFIFOAssignment</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_ACTIVATION</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterActivation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CAN3</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Check the CAN instance */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name></name> <operator>==</operator> <name>CAN3</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* CAN3 is single instance with 14 dedicated filters banks */</comment>

      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_BANK_SINGLE</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* CAN1 and CAN2 are dual instances with 28 common filters banks */</comment>
      <comment type="block">/* Select master instance to access the filter banks */</comment>
      <expr_stmt><expr><name>can_ip</name> <operator>=</operator> <name>CAN1</name></expr>;</expr_stmt>

      <comment type="block">/* Check the parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_BANK_DUAL</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_BANK_DUAL</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>SlaveStartFilterBank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CAN2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <comment type="block">/* CAN1 and CAN2 are dual instances with 28 common filters banks */</comment>
    <comment type="block">/* Select master instance to access the filter banks */</comment>
    <expr_stmt><expr><name>can_ip</name> <operator>=</operator> <name>CAN1</name></expr>;</expr_stmt>

    <comment type="block">/* Check the parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_BANK_DUAL</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_BANK_DUAL</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>SlaveStartFilterBank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* CAN1 is single instance with 14 dedicated filters banks */</comment>

    <comment type="block">/* Check the parameters */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_FILTER_BANK_SINGLE</name><argument_list>(<argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initialisation mode for the filter */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FMR</name></name></expr></argument>, <argument><expr><name>CAN_FMR_FINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CAN3</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Check the CAN instance */</comment>
    <if_stmt><if>if <condition>(<expr><name>can_ip</name> <operator>==</operator> <name>CAN1</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Select the start filter number of CAN2 slave instance */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FMR</name></name></expr></argument>, <argument><expr><name>CAN_FMR_CAN2SB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FMR</name></name></expr></argument>, <argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>SlaveStartFilterBank</name></name> <operator>&lt;&lt;</operator> <name>CAN_FMR_CAN2SB_Pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CAN2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <comment type="block">/* Select the start filter number of CAN2 slave instance */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FMR</name></name></expr></argument>, <argument><expr><name>CAN_FMR_CAN2SB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FMR</name></name></expr></argument>, <argument><expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>SlaveStartFilterBank</name></name> <operator>&lt;&lt;</operator> <name>CAN_FMR_CAN2SB_Pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Convert filter number into bit position */</comment>
    <expr_stmt><expr><name>filternbrbitpos</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name> <operator>&amp;</operator> <literal type="number">0x1FU</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Filter Deactivation */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FA1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Filter Scale */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterScale</name></name> <operator>==</operator> <name>CAN_FILTERSCALE_16BIT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* 16-bit scale for the filter */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FS1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* First 16-bit identifier and First 16-bit mask */</comment>
      <comment type="block">/* Or First 16-bit identifier and Second 16-bit identifier */</comment>
      <expr_stmt><expr><name><name>can_ip</name><operator>-&gt;</operator><name>sFilterRegister</name><index>[<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr>]</index></name><operator>.</operator><name>FR1</name> <operator>=</operator>
        <operator>(</operator><operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMaskIdLow</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator>
        <operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterIdLow</name></name><operator>)</operator></expr>;</expr_stmt>

      <comment type="block">/* Second 16-bit identifier and Second 16-bit mask */</comment>
      <comment type="block">/* Or Third 16-bit identifier and Fourth 16-bit identifier */</comment>
      <expr_stmt><expr><name><name>can_ip</name><operator>-&gt;</operator><name>sFilterRegister</name><index>[<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr>]</index></name><operator>.</operator><name>FR2</name> <operator>=</operator>
        <operator>(</operator><operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMaskIdHigh</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator>
        <operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterIdHigh</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterScale</name></name> <operator>==</operator> <name>CAN_FILTERSCALE_32BIT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* 32-bit scale for the filter */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FS1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* 32-bit identifier or First 32-bit identifier */</comment>
      <expr_stmt><expr><name><name>can_ip</name><operator>-&gt;</operator><name>sFilterRegister</name><index>[<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr>]</index></name><operator>.</operator><name>FR1</name> <operator>=</operator>
        <operator>(</operator><operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterIdHigh</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator>
        <operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterIdLow</name></name><operator>)</operator></expr>;</expr_stmt>

      <comment type="block">/* 32-bit mask or Second 32-bit identifier */</comment>
      <expr_stmt><expr><name><name>can_ip</name><operator>-&gt;</operator><name>sFilterRegister</name><index>[<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterBank</name></name></expr>]</index></name><operator>.</operator><name>FR2</name> <operator>=</operator>
        <operator>(</operator><operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMaskIdHigh</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator> <operator>|</operator>
        <operator>(</operator><literal type="number">0x0000FFFFU</literal> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMaskIdLow</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Filter Mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterMode</name></name> <operator>==</operator> <name>CAN_FILTERMODE_IDMASK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Id/Mask mode for the filter*/</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FM1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdList */</comment>
    <block>{<block_content>
      <comment type="block">/* Identifier list mode for the filter*/</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FM1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Filter FIFO assignment */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterFIFOAssignment</name></name> <operator>==</operator> <name>CAN_FILTER_FIFO0</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* FIFO 0 assignation for the filter */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FFA1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* FIFO 1 assignation for the filter */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FFA1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Filter activation */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sFilterConfig</name><operator>-&gt;</operator><name>FilterActivation</name></name> <operator>==</operator> <name>CAN_FILTER_ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FA1R</name></name></expr></argument>, <argument><expr><name>filternbrbitpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Leave the initialisation mode for the filter */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>can_ip</name><operator>-&gt;</operator><name>FMR</name></name></expr></argument>, <argument><expr><name>CAN_FMR_FINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup CAN_Exported_Functions_Group3 Control functions
 *  @brief    Control functions
 *
@verbatim
  ==============================================================================
                      ##### Control functions #####
  ==============================================================================
    [..]  This section provides functions allowing to:
      (+) HAL_CAN_Start                    : Start the CAN module
      (+) HAL_CAN_Stop                     : Stop the CAN module
      (+) HAL_CAN_RequestSleep             : Request sleep mode entry.
      (+) HAL_CAN_WakeUp                   : Wake up from sleep mode.
      (+) HAL_CAN_IsSleepActive            : Check is sleep mode is active.
      (+) HAL_CAN_AddTxMessage             : Add a message to the Tx mailboxes
                                             and activate the corresponding
                                             transmission request
      (+) HAL_CAN_AbortTxRequest           : Abort transmission request
      (+) HAL_CAN_GetTxMailboxesFreeLevel  : Return Tx mailboxes free level
      (+) HAL_CAN_IsTxMessagePending       : Check if a transmission request is
                                             pending on the selected Tx mailbox
      (+) HAL_CAN_GetRxMessage             : Get a CAN frame from the Rx FIFO
      (+) HAL_CAN_GetRxFifoFillLevel       : Return Rx FIFO fill level

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Start the CAN module.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_Start</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Change CAN peripheral state */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_LISTENING</name></expr>;</expr_stmt>

    <comment type="block">/* Request leave initialisation */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_INRQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait the acknowledge */</comment>
    <while>while <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name> <operator>&amp;</operator> <name>CAN_MSR_INAK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>CAN_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Change CAN state */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_ERROR</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Reset the CAN ErrorCode */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_CAN_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_READY</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the CAN module and enable access to configuration registers.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_Stop</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Request initialisation */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_INRQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get tick */</comment>
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait the acknowledge */</comment>
    <while>while <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name> <operator>&amp;</operator> <name>CAN_MSR_INAK</name><operator>)</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>CAN_TIMEOUT_VALUE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Change CAN state */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_ERROR</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Exit from sleep mode */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change CAN peripheral state */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_CAN_STATE_READY</name></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_STARTED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Request the sleep mode (low power) entry.
  *         When returning from this function, Sleep mode will be entered
  *         as soon as the current CAN activity (transmission or reception
  *         of a CAN frame) has been completed.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_RequestSleep</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Request Sleep mode */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Wake up from sleep mode.
  *         When returning with HAL_OK status from this function, Sleep mode
  *         is exited.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_WakeUp</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>timeout</name> <init>= <expr><literal type="number">1000000U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wake up request */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name></expr></argument>, <argument><expr><name>CAN_MCR_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait sleep mode is exited */</comment>
    <do>do
    <block>{<block_content>
      <comment type="block">/* Increment counter */</comment>
      <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Check if timeout is reached */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>timeout</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name> <operator>&amp;</operator> <name>CAN_MSR_SLAK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>;</do>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Check is sleep mode is active.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval Status
  *          - 0 : Sleep mode is not active.
  *          - 1 : Sleep mode is active.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_CAN_IsSleepActive</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>status</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Sleep mode */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name> <operator>&amp;</operator> <name>CAN_MSR_SLAK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Add a message to the first free Tx mailbox and activate the
  *         corresponding transmission request.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  pHeader pointer to a CAN_TxHeaderTypeDef structure.
  * @param  aData array containing the payload of the Tx frame.
  * @param  pTxMailbox pointer to a variable where the function will return
  *         the TxMailbox used to store the Tx message.
  *         This parameter can be a value of @arg CAN_Tx_Mailboxes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_AddTxMessage</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>CAN_TxHeaderTypeDef</name> <modifier>*</modifier></type><name>pHeader</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name><name>aData</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pTxMailbox</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>transmitmailbox</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tsr</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_IDTYPE</name><argument_list>(<argument><expr><name><name>pHeader</name><operator>-&gt;</operator><name>IDE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_RTR</name><argument_list>(<argument><expr><name><name>pHeader</name><operator>-&gt;</operator><name>RTR</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_DLC</name><argument_list>(<argument><expr><name><name>pHeader</name><operator>-&gt;</operator><name>DLC</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pHeader</name><operator>-&gt;</operator><name>IDE</name></name> <operator>==</operator> <name>CAN_ID_STD</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_STDID</name><argument_list>(<argument><expr><name><name>pHeader</name><operator>-&gt;</operator><name>StdId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_EXTID</name><argument_list>(<argument><expr><name><name>pHeader</name><operator>-&gt;</operator><name>ExtId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>pHeader</name><operator>-&gt;</operator><name>TransmitGlobalTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check that all the Tx mailboxes are not full */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>tsr</name> <operator>&amp;</operator> <name>CAN_TSR_TME0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>tsr</name> <operator>&amp;</operator> <name>CAN_TSR_TME1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>tsr</name> <operator>&amp;</operator> <name>CAN_TSR_TME2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Select an empty transmit mailbox */</comment>
      <expr_stmt><expr><name>transmitmailbox</name> <operator>=</operator> <operator>(</operator><name>tsr</name> <operator>&amp;</operator> <name>CAN_TSR_CODE</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_TSR_CODE_Pos</name></expr>;</expr_stmt>

      <comment type="block">/* Check transmit mailbox value */</comment>
      <if_stmt><if>if <condition>(<expr><name>transmitmailbox</name> <operator>&gt;</operator> <literal type="number">2U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_INTERNAL</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Store the Tx mailbox */</comment>
      <expr_stmt><expr><operator>*</operator><name>pTxMailbox</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>transmitmailbox</name></expr>;</expr_stmt>

      <comment type="block">/* Set up the Id */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pHeader</name><operator>-&gt;</operator><name>IDE</name></name> <operator>==</operator> <name>CAN_ID_STD</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TIR</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pHeader</name><operator>-&gt;</operator><name>StdId</name></name> <operator>&lt;&lt;</operator> <name>CAN_TI0R_STID_Pos</name><operator>)</operator> <operator>|</operator>
                                                           <name><name>pHeader</name><operator>-&gt;</operator><name>RTR</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TIR</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pHeader</name><operator>-&gt;</operator><name>ExtId</name></name> <operator>&lt;&lt;</operator> <name>CAN_TI0R_EXID_Pos</name><operator>)</operator> <operator>|</operator>
                                                           <name><name>pHeader</name><operator>-&gt;</operator><name>IDE</name></name> <operator>|</operator>
                                                           <name><name>pHeader</name><operator>-&gt;</operator><name>RTR</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Set up the DLC */</comment>
      <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TDTR</name> <operator>=</operator> <operator>(</operator><name><name>pHeader</name><operator>-&gt;</operator><name>DLC</name></name><operator>)</operator></expr>;</expr_stmt>

      <comment type="block">/* Set up the Transmit Global Time mode */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pHeader</name><operator>-&gt;</operator><name>TransmitGlobalTime</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TDTR</name></expr></argument>, <argument><expr><name>CAN_TDT0R_TGT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Set up the data field */</comment>
      <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TDHR</name></expr></argument>,
                <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDH0R_DATA7_Pos</name><operator>)</operator> <operator>|</operator>
                <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDH0R_DATA6_Pos</name><operator>)</operator> <operator>|</operator>
                <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDH0R_DATA5_Pos</name><operator>)</operator> <operator>|</operator>
                <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDH0R_DATA4_Pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TDLR</name></expr></argument>,
                <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDL0R_DATA3_Pos</name><operator>)</operator> <operator>|</operator>
                <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDL0R_DATA2_Pos</name><operator>)</operator> <operator>|</operator>
                <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDL0R_DATA1_Pos</name><operator>)</operator> <operator>|</operator>
                <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>CAN_TDL0R_DATA0_Pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Request transmission */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TIR</name></expr></argument>, <argument><expr><name>CAN_TI0R_TXRQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Return function status */</comment>
      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update error code */</comment>
      <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_PARAM</name></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Abort transmission requests
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  TxMailboxes List of the Tx Mailboxes to abort.
  *         This parameter can be any combination of @arg CAN_Tx_Mailboxes.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_AbortTxRequest</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TxMailboxes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_TX_MAILBOX_LIST</name><argument_list>(<argument><expr><name>TxMailboxes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Tx Mailbox 0 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>TxMailboxes</name> <operator>&amp;</operator> <name>CAN_TX_MAILBOX0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Add cancellation request for Tx Mailbox 0 */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name></expr></argument>, <argument><expr><name>CAN_TSR_ABRQ0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check Tx Mailbox 1 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>TxMailboxes</name> <operator>&amp;</operator> <name>CAN_TX_MAILBOX1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Add cancellation request for Tx Mailbox 1 */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name></expr></argument>, <argument><expr><name>CAN_TSR_ABRQ1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check Tx Mailbox 2 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>TxMailboxes</name> <operator>&amp;</operator> <name>CAN_TX_MAILBOX2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Add cancellation request for Tx Mailbox 2 */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name></expr></argument>, <argument><expr><name>CAN_TSR_ABRQ2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return Tx Mailboxes free level: number of free Tx Mailboxes.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval Number of free Tx Mailboxes.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_CAN_GetTxMailboxesFreeLevel</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>freelevel</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Tx Mailbox 0 status */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name> <operator>&amp;</operator> <name>CAN_TSR_TME0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>freelevel</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check Tx Mailbox 1 status */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name> <operator>&amp;</operator> <name>CAN_TSR_TME1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>freelevel</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check Tx Mailbox 2 status */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name> <operator>&amp;</operator> <name>CAN_TSR_TME2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>freelevel</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return Tx Mailboxes free level */</comment>
  <return>return <expr><name>freelevel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Check if a transmission request is pending on the selected Tx
  *         Mailboxes.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  TxMailboxes List of Tx Mailboxes to check.
  *         This parameter can be any combination of @arg CAN_Tx_Mailboxes.
  * @retval Status
  *          - 0 : No pending transmission request on any selected Tx Mailboxes.
  *          - 1 : Pending transmission request on at least one of the selected
  *                Tx Mailbox.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_CAN_IsTxMessagePending</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TxMailboxes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>status</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_TX_MAILBOX_LIST</name><argument_list>(<argument><expr><name>TxMailboxes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check pending transmission request on the selected Tx Mailboxes */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name> <operator>&amp;</operator> <operator>(</operator><name>TxMailboxes</name> <operator>&lt;&lt;</operator> <name>CAN_TSR_TME0_Pos</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>TxMailboxes</name> <operator>&lt;&lt;</operator> <name>CAN_TSR_TME0_Pos</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="number">1U</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return status */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return timestamp of Tx message sent, if time triggered communication
            mode is enabled.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  TxMailbox Tx Mailbox where the timestamp of message sent will be
  *         read.
  *         This parameter can be one value of @arg CAN_Tx_Mailboxes.
  * @retval Timestamp of message sent from Tx Mailbox.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_CAN_GetTxTimestamp</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>TxMailbox</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>timestamp</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>transmitmailbox</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_TX_MAILBOX</name><argument_list>(<argument><expr><name>TxMailbox</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Select the Tx mailbox */</comment>
    <expr_stmt><expr><name>transmitmailbox</name> <operator>=</operator> <call><name>POSITION_VAL</name><argument_list>(<argument><expr><name>TxMailbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get timestamp */</comment>
    <expr_stmt><expr><name>timestamp</name> <operator>=</operator> <operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sTxMailBox</name><index>[<expr><name>transmitmailbox</name></expr>]</index></name><operator>.</operator><name>TDTR</name> <operator>&amp;</operator> <name>CAN_TDT0R_TIME</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_TDT0R_TIME_Pos</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return the timestamp */</comment>
  <return>return <expr><name>timestamp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Get an CAN frame from the Rx FIFO zone into the message RAM.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  RxFifo Fifo number of the received message to be read.
  *         This parameter can be a value of @arg CAN_receive_FIFO_number.
  * @param  pHeader pointer to a CAN_RxHeaderTypeDef structure where the header
  *         of the Rx frame will be stored.
  * @param  aData array where the payload of the Rx frame will be stored.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_GetRxMessage</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>RxFifo</name></decl></parameter>, <parameter><decl><type><name>CAN_RxHeaderTypeDef</name> <modifier>*</modifier></type><name>pHeader</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name><name>aData</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_RX_FIFO</name><argument_list>(<argument><expr><name>RxFifo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check the Rx FIFO */</comment>
    <if_stmt><if>if <condition>(<expr><name>RxFifo</name> <operator>==</operator> <name>CAN_RX_FIFO0</name></expr>)</condition> <comment type="block">/* Rx element is assigned to Rx FIFO 0 */</comment>
    <block>{<block_content>
      <comment type="block">/* Check that the Rx FIFO 0 is not empty */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF0R</name></name> <operator>&amp;</operator> <name>CAN_RF0R_FMP0</name><operator>)</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_PARAM</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* Rx element is assigned to Rx FIFO 1 */</comment>
    <block>{<block_content>
      <comment type="block">/* Check that the Rx FIFO 1 is not empty */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF1R</name></name> <operator>&amp;</operator> <name>CAN_RF1R_FMP1</name><operator>)</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update error code */</comment>
        <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_PARAM</name></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Get the header */</comment>
    <expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>IDE</name></name> <operator>=</operator> <name>CAN_RI0R_IDE</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RIR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pHeader</name><operator>-&gt;</operator><name>IDE</name></name> <operator>==</operator> <name>CAN_ID_STD</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>StdId</name></name> <operator>=</operator> <operator>(</operator><name>CAN_RI0R_STID</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RIR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_TI0R_STID_Pos</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>ExtId</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CAN_RI0R_EXID</name> <operator>|</operator> <name>CAN_RI0R_STID</name><operator>)</operator> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RIR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RI0R_EXID_Pos</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>RTR</name></name> <operator>=</operator> <operator>(</operator><name>CAN_RI0R_RTR</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RIR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RI0R_RTR_Pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>DLC</name></name> <operator>=</operator> <operator>(</operator><name>CAN_RDT0R_DLC</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDTR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDT0R_DLC_Pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>FilterMatchIndex</name></name> <operator>=</operator> <operator>(</operator><name>CAN_RDT0R_FMI</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDTR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDT0R_FMI_Pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>Timestamp</name></name> <operator>=</operator> <operator>(</operator><name>CAN_RDT0R_TIME</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDTR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDT0R_TIME_Pos</name></expr>;</expr_stmt>

    <comment type="block">/* Get the data */</comment>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDL0R_DATA0</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDLR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDL0R_DATA0_Pos</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDL0R_DATA1</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDLR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDL0R_DATA1_Pos</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDL0R_DATA2</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDLR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDL0R_DATA2_Pos</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDL0R_DATA3</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDLR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDL0R_DATA3_Pos</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDH0R_DATA4</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDHR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDH0R_DATA4_Pos</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDH0R_DATA5</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDHR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDH0R_DATA5_Pos</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDH0R_DATA6</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDHR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDH0R_DATA6_Pos</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>CAN_RDH0R_DATA7</name> <operator>&amp;</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>sFIFOMailBox</name><index>[<expr><name>RxFifo</name></expr>]</index></name><operator>.</operator><name>RDHR</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CAN_RDH0R_DATA7_Pos</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Release the FIFO */</comment>
    <if_stmt><if>if <condition>(<expr><name>RxFifo</name> <operator>==</operator> <name>CAN_RX_FIFO0</name></expr>)</condition> <comment type="block">/* Rx element is assigned to Rx FIFO 0 */</comment>
    <block>{<block_content>
      <comment type="block">/* Release RX FIFO 0 */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF0R</name></name></expr></argument>, <argument><expr><name>CAN_RF0R_RFOM0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* Rx element is assigned to Rx FIFO 1 */</comment>
    <block>{<block_content>
      <comment type="block">/* Release RX FIFO 1 */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF1R</name></name></expr></argument>, <argument><expr><name>CAN_RF1R_RFOM1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return Rx FIFO fill level.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  RxFifo Rx FIFO.
  *         This parameter can be a value of @arg CAN_receive_FIFO_number.
  * @retval Number of messages available in Rx FIFO.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_CAN_GetRxFifoFillLevel</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>RxFifo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>filllevel</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_RX_FIFO</name><argument_list>(<argument><expr><name>RxFifo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>RxFifo</name> <operator>==</operator> <name>CAN_RX_FIFO0</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>filllevel</name> <operator>=</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF0R</name></name> <operator>&amp;</operator> <name>CAN_RF0R_FMP0</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <comment type="block">/* RxFifo == CAN_RX_FIFO1 */</comment>
    <block>{<block_content>
      <expr_stmt><expr><name>filllevel</name> <operator>=</operator> <name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF1R</name></name> <operator>&amp;</operator> <name>CAN_RF1R_FMP1</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return Rx FIFO fill level */</comment>
  <return>return <expr><name>filllevel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup CAN_Exported_Functions_Group4 Interrupts management
 *  @brief    Interrupts management
 *
@verbatim
  ==============================================================================
                       ##### Interrupts management #####
  ==============================================================================
    [..]  This section provides functions allowing to:
      (+) HAL_CAN_ActivateNotification      : Enable interrupts
      (+) HAL_CAN_DeactivateNotification    : Disable interrupts
      (+) HAL_CAN_IRQHandler                : Handles CAN interrupt request

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Enable interrupts.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  ActiveITs indicates which interrupts will be enabled.
  *         This parameter can be any combination of @arg CAN_Interrupts.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_ActivateNotification</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ActiveITs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_IT</name><argument_list>(<argument><expr><name>ActiveITs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable the selected interrupts */</comment>
    <expr_stmt><expr><call><name>__HAL_CAN_ENABLE_IT</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>ActiveITs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disable interrupts.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @param  InactiveITs indicates which interrupts will be disabled.
  *         This parameter can be any combination of @arg CAN_Interrupts.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_DeactivateNotification</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>InactiveITs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check function parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_CAN_IT</name><argument_list>(<argument><expr><name>InactiveITs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the selected interrupts */</comment>
    <expr_stmt><expr><call><name>__HAL_CAN_DISABLE_IT</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>InactiveITs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return function status */</comment>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handles CAN interrupt request
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_CAN_IRQHandler</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>errorcode</name> <init>= <expr><name>HAL_CAN_ERROR_NONE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>interrupts</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>msrflags</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tsrflags</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TSR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>rf0rflags</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF0R</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>rf1rflags</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF1R</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>esrflags</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ESR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Transmit Mailbox empty interrupt management *****************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_TX_MAILBOX_EMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Transmit Mailbox 0 management *****************************************/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_RQCP0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the Transmission Complete flag (and TXOK0,ALST0,TERR0 bits) */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_RQCP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_TXOK0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Transmission Mailbox 0 complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
        <comment type="block">/* Call registered callback*/</comment>
        <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0CompleteCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* Call weak (surcharged) callback */</comment>
        <expr_stmt><expr><call><name>HAL_CAN_TxMailbox0CompleteCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_ALST0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update error code */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_TX_ALST0</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_TERR0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update error code */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_TX_TERR0</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Transmission Mailbox 0 abort callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
          <comment type="block">/* Call registered callback*/</comment>
          <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox0AbortCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <comment type="block">/* Call weak (surcharged) callback */</comment>
          <expr_stmt><expr><call><name>HAL_CAN_TxMailbox0AbortCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Transmit Mailbox 1 management *****************************************/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_RQCP1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_RQCP1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_TXOK1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Transmission Mailbox 1 complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
        <comment type="block">/* Call registered callback*/</comment>
        <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1CompleteCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* Call weak (surcharged) callback */</comment>
        <expr_stmt><expr><call><name>HAL_CAN_TxMailbox1CompleteCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_ALST1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update error code */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_TX_ALST1</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_TERR1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update error code */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_TX_TERR1</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Transmission Mailbox 1 abort callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
          <comment type="block">/* Call registered callback*/</comment>
          <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox1AbortCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <comment type="block">/* Call weak (surcharged) callback */</comment>
          <expr_stmt><expr><call><name>HAL_CAN_TxMailbox1AbortCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Transmit Mailbox 2 management *****************************************/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_RQCP2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_RQCP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_TXOK2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Transmission Mailbox 2 complete callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
        <comment type="block">/* Call registered callback*/</comment>
        <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2CompleteCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* Call weak (surcharged) callback */</comment>
        <expr_stmt><expr><call><name>HAL_CAN_TxMailbox2CompleteCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_ALST2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update error code */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_TX_ALST2</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>tsrflags</name> <operator>&amp;</operator> <name>CAN_TSR_TERR2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update error code */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_TX_TERR2</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Transmission Mailbox 2 abort callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
          <comment type="block">/* Call registered callback*/</comment>
          <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>TxMailbox2AbortCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <comment type="block">/* Call weak (surcharged) callback */</comment>
          <expr_stmt><expr><call><name>HAL_CAN_TxMailbox2AbortCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Receive FIFO 0 overrun interrupt management *****************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_RX_FIFO0_OVERRUN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rf0rflags</name> <operator>&amp;</operator> <name>CAN_RF0R_FOVR0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set CAN error code to Rx Fifo 0 overrun error */</comment>
      <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_RX_FOV0</name></expr>;</expr_stmt>

      <comment type="block">/* Clear FIFO0 Overrun Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_FOV0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Receive FIFO 0 full interrupt management ********************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_RX_FIFO0_FULL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rf0rflags</name> <operator>&amp;</operator> <name>CAN_RF0R_FULL0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear FIFO 0 full Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_FF0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Receive FIFO 0 full Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
      <comment type="block">/* Call registered callback*/</comment>
      <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0FullCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Call weak (surcharged) callback */</comment>
      <expr_stmt><expr><call><name>HAL_CAN_RxFifo0FullCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Receive FIFO 0 message pending interrupt management *********************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_RX_FIFO0_MSG_PENDING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if message is still pending */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF0R</name></name> <operator>&amp;</operator> <name>CAN_RF0R_FMP0</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Receive FIFO 0 mesage pending Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
      <comment type="block">/* Call registered callback*/</comment>
      <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo0MsgPendingCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Call weak (surcharged) callback */</comment>
      <expr_stmt><expr><call><name>HAL_CAN_RxFifo0MsgPendingCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Receive FIFO 1 overrun interrupt management *****************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_RX_FIFO1_OVERRUN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rf1rflags</name> <operator>&amp;</operator> <name>CAN_RF1R_FOVR1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set CAN error code to Rx Fifo 1 overrun error */</comment>
      <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_RX_FOV1</name></expr>;</expr_stmt>

      <comment type="block">/* Clear FIFO1 Overrun Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_FOV1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Receive FIFO 1 full interrupt management ********************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_RX_FIFO1_FULL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rf1rflags</name> <operator>&amp;</operator> <name>CAN_RF1R_FULL1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear FIFO 1 full Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_FF1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Receive FIFO 1 full Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
      <comment type="block">/* Call registered callback*/</comment>
      <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1FullCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Call weak (surcharged) callback */</comment>
      <expr_stmt><expr><call><name>HAL_CAN_RxFifo1FullCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Receive FIFO 1 message pending interrupt management *********************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_RX_FIFO1_MSG_PENDING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if message is still pending */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>RF1R</name></name> <operator>&amp;</operator> <name>CAN_RF1R_FMP1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Receive FIFO 1 mesage pending Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
      <comment type="block">/* Call registered callback*/</comment>
      <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>RxFifo1MsgPendingCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Call weak (surcharged) callback */</comment>
      <expr_stmt><expr><call><name>HAL_CAN_RxFifo1MsgPendingCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Sleep interrupt management *********************************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_SLEEP_ACK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>msrflags</name> <operator>&amp;</operator> <name>CAN_MSR_SLAKI</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Sleep interrupt Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_SLAKI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Sleep Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
      <comment type="block">/* Call registered callback*/</comment>
      <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>SleepCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Call weak (surcharged) callback */</comment>
      <expr_stmt><expr><call><name>HAL_CAN_SleepCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* WakeUp interrupt management *********************************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_WAKEUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>msrflags</name> <operator>&amp;</operator> <name>CAN_MSR_WKUI</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear WakeUp Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_WKU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* WakeUp Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
      <comment type="block">/* Call registered callback*/</comment>
      <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>WakeUpFromRxMsgCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Call weak (surcharged) callback */</comment>
      <expr_stmt><expr><call><name>HAL_CAN_WakeUpFromRxMsgCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Error interrupts management *********************************************/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_ERROR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>msrflags</name> <operator>&amp;</operator> <name>CAN_MSR_ERRI</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check Error Warning Flag */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_ERROR_WARNING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator>
          <operator>(</operator><operator>(</operator><name>esrflags</name> <operator>&amp;</operator> <name>CAN_ESR_EWGF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set CAN error code to Error Warning */</comment>
        <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_EWG</name></expr>;</expr_stmt>

        <comment type="block">/* No need for clear of Error Warning Flag as read-only */</comment>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Check Error Passive Flag */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_ERROR_PASSIVE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator>
          <operator>(</operator><operator>(</operator><name>esrflags</name> <operator>&amp;</operator> <name>CAN_ESR_EPVF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set CAN error code to Error Passive */</comment>
        <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_EPV</name></expr>;</expr_stmt>

        <comment type="block">/* No need for clear of Error Passive Flag as read-only */</comment>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Check Bus-off Flag */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_BUSOFF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator>
          <operator>(</operator><operator>(</operator><name>esrflags</name> <operator>&amp;</operator> <name>CAN_ESR_BOFF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set CAN error code to Bus-Off */</comment>
        <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_BOF</name></expr>;</expr_stmt>

        <comment type="block">/* No need for clear of Error Bus-Off as read-only */</comment>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Check Last Error Code Flag */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>interrupts</name> <operator>&amp;</operator> <name>CAN_IT_LAST_ERROR_CODE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator>
          <operator>(</operator><operator>(</operator><name>esrflags</name> <operator>&amp;</operator> <name>CAN_ESR_LEC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <switch>switch <condition>(<expr><name>esrflags</name> <operator>&amp;</operator> <name>CAN_ESR_LEC</name></expr>)</condition>
        <block>{<block_content>
          <case>case <expr><operator>(</operator><name>CAN_ESR_LEC_0</name><operator>)</operator></expr>:</case>
            <comment type="block">/* Set CAN error code to Stuff error */</comment>
            <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_STF</name></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><operator>(</operator><name>CAN_ESR_LEC_1</name><operator>)</operator></expr>:</case>
            <comment type="block">/* Set CAN error code to Form error */</comment>
            <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_FOR</name></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><operator>(</operator><name>CAN_ESR_LEC_1</name> <operator>|</operator> <name>CAN_ESR_LEC_0</name><operator>)</operator></expr>:</case>
            <comment type="block">/* Set CAN error code to Acknowledgement error */</comment>
            <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_ACK</name></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><operator>(</operator><name>CAN_ESR_LEC_2</name><operator>)</operator></expr>:</case>
            <comment type="block">/* Set CAN error code to Bit recessive error */</comment>
            <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_BR</name></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><operator>(</operator><name>CAN_ESR_LEC_2</name> <operator>|</operator> <name>CAN_ESR_LEC_0</name><operator>)</operator></expr>:</case>
            <comment type="block">/* Set CAN error code to Bit Dominant error */</comment>
            <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_BD</name></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><operator>(</operator><name>CAN_ESR_LEC_2</name> <operator>|</operator> <name>CAN_ESR_LEC_1</name><operator>)</operator></expr>:</case>
            <comment type="block">/* Set CAN error code to CRC error */</comment>
            <expr_stmt><expr><name>errorcode</name> <operator>|=</operator> <name>HAL_CAN_ERROR_CRC</name></expr>;</expr_stmt>
            <break>break;</break>
          <default>default:</default>
            <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/* Clear Last error code Flag */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ESR</name></name></expr></argument>, <argument><expr><name>CAN_ESR_LEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear ERRI Flag */</comment>
    <expr_stmt><expr><call><name>__HAL_CAN_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>, <argument><expr><name>CAN_FLAG_ERRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Call the Error call Back in case of Errors */</comment>
  <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <name>HAL_CAN_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update error code in handle */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>errorcode</name></expr>;</expr_stmt>

    <comment type="block">/* Call Error callback function */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HAL_CAN_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
    <comment type="block">/* Call registered callback*/</comment>
    <expr_stmt><expr><call><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Call weak (surcharged) callback */</comment>
    <expr_stmt><expr><call><name>HAL_CAN_ErrorCallback</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_CAN_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup CAN_Exported_Functions_Group5 Callback functions
 *  @brief   CAN Callback functions
 *
@verbatim
  ==============================================================================
                          ##### Callback functions #####
  ==============================================================================
    [..]
    This subsection provides the following callback functions:
      (+) HAL_CAN_TxMailbox0CompleteCallback
      (+) HAL_CAN_TxMailbox1CompleteCallback
      (+) HAL_CAN_TxMailbox2CompleteCallback
      (+) HAL_CAN_TxMailbox0AbortCallback
      (+) HAL_CAN_TxMailbox1AbortCallback
      (+) HAL_CAN_TxMailbox2AbortCallback
      (+) HAL_CAN_RxFifo0MsgPendingCallback
      (+) HAL_CAN_RxFifo0FullCallback
      (+) HAL_CAN_RxFifo1MsgPendingCallback
      (+) HAL_CAN_RxFifo1FullCallback
      (+) HAL_CAN_SleepCallback
      (+) HAL_CAN_WakeUpFromRxMsgCallback
      (+) HAL_CAN_ErrorCallback

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Transmission Mailbox 0 complete callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_TxMailbox0CompleteCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox0CompleteCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmission Mailbox 1 complete callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_TxMailbox1CompleteCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox1CompleteCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmission Mailbox 2 complete callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_TxMailbox2CompleteCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox2CompleteCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmission Mailbox 0 Cancellation callback.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_TxMailbox0AbortCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox0AbortCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmission Mailbox 1 Cancellation callback.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_TxMailbox1AbortCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox1AbortCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmission Mailbox 2 Cancellation callback.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_TxMailbox2AbortCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox2AbortCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx FIFO 0 message pending callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_RxFifo0MsgPendingCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo0MsgPendingCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx FIFO 0 full callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_RxFifo0FullCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo0FullCallback could be implemented in the user
            file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx FIFO 1 message pending callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_RxFifo1MsgPendingCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo1MsgPendingCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Rx FIFO 1 full callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_RxFifo1FullCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo1FullCallback could be implemented in the user
            file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sleep callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_SleepCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_SleepCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  WakeUp from Rx message callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_WakeUpFromRxMsgCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_WakeUpFromRxMsgCallback could be implemented in the
            user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Error CAN callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_CAN_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hcan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_ErrorCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup CAN_Exported_Functions_Group6 Peripheral State and Error functions
 *  @brief   CAN Peripheral State functions
 *
@verbatim
  ==============================================================================
            ##### Peripheral State and Error functions #####
  ==============================================================================
    [..]
    This subsection provides functions allowing to :
      (+) HAL_CAN_GetState()  : Return the CAN state.
      (+) HAL_CAN_GetError()  : Return the CAN error codes if any.
      (+) HAL_CAN_ResetError(): Reset the CAN error codes if any.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the CAN state.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_CAN_StateTypeDef</name></type> <name>HAL_CAN_GetState</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check sleep mode acknowledge flag */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MSR</name></name> <operator>&amp;</operator> <name>CAN_MSR_SLAK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Sleep mode is active */</comment>
      <expr_stmt><expr><name>state</name> <operator>=</operator> <name>HAL_CAN_STATE_SLEEP_ACTIVE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Check sleep mode request flag */</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hcan</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>MCR</name></name> <operator>&amp;</operator> <name>CAN_MCR_SLEEP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Sleep mode request is pending */</comment>
      <expr_stmt><expr><name>state</name> <operator>=</operator> <name>HAL_CAN_STATE_SLEEP_PENDING</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Neither sleep mode request nor sleep mode acknowledge */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return CAN state */</comment>
  <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the CAN error code.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval CAN Error Code
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_CAN_GetError</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return CAN error code */</comment>
  <return>return <expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Reset the CAN error code.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_CAN_ResetError</name><parameter_list>(<parameter><decl><type><name>CAN_HandleTypeDef</name> <modifier>*</modifier></type><name>hcan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_CAN_StateTypeDef</name></type> <name>state</name> <init>= <expr><name><name>hcan</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_READY</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>state</name> <operator>==</operator> <name>HAL_CAN_STATE_LISTENING</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Reset CAN error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update error code */</comment>
    <expr_stmt><expr><name><name>hcan</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_CAN_ERROR_NOT_INITIALIZED</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Return the status */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_CAN_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* CAN1 */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
