<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_lptim.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_lptim.c
  * @author  MCD Application Team
  * @brief   LPTIM HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Low Power Timer (LPTIM) peripheral:
  *           + Initialization and de-initialization functions.
  *           + Start/Stop operation functions in polling mode.
  *           + Start/Stop operation functions in interrupt mode.
  *           + Reading operation functions.
  *           + Peripheral State functions.
  *
  @verbatim
  ==============================================================================
                     ##### How to use this driver #####
  ==============================================================================
    [..]
      The LPTIM HAL driver can be used as follows:

      (#)Initialize the LPTIM low level resources by implementing the
        HAL_LPTIM_MspInit():
         (++) Enable the LPTIM interface clock using __HAL_RCC_LPTIMx_CLK_ENABLE().
         (++) In case of using interrupts (e.g. HAL_LPTIM_PWM_Start_IT()):
             (+++) Configure the LPTIM interrupt priority using HAL_NVIC_SetPriority().
             (+++) Enable the LPTIM IRQ handler using HAL_NVIC_EnableIRQ().
             (+++) In LPTIM IRQ handler, call HAL_LPTIM_IRQHandler().

      (#)Initialize the LPTIM HAL using HAL_LPTIM_Init(). This function
         configures mainly:
         (++) The instance: LPTIM1.
         (++) Clock: the counter clock.
             (+++) Source   : it can be either the ULPTIM input (IN1) or one of
                              the internal clock; (APB, LSE or LSI).
             (+++) Prescaler: select the clock divider.
         (++)  UltraLowPowerClock : To be used only if the ULPTIM is selected
               as counter clock source.
             (+++) Polarity:   polarity of the active edge for the counter unit
                               if the ULPTIM input is selected.
             (+++) SampleTime: clock sampling time to configure the clock glitch
                               filter.
         (++) Trigger: How the counter start.
             (+++) Source: trigger can be software or one of the hardware triggers.
             (+++) ActiveEdge : only for hardware trigger.
             (+++) SampleTime : trigger sampling time to configure the trigger
                                glitch filter.
         (++) OutputPolarity : 2 opposite polarities are possible.
         (++) UpdateMode: specifies whether the update of the autoreload and
              the compare values is done immediately or after the end of current
              period.

      (#)Six modes are available:

         (++) PWM Mode: To generate a PWM signal with specified period and pulse,
         call HAL_LPTIM_PWM_Start() or HAL_LPTIM_PWM_Start_IT() for interruption
         mode.

         (++) One Pulse Mode: To generate pulse with specified width in response
         to a stimulus, call HAL_LPTIM_OnePulse_Start() or
         HAL_LPTIM_OnePulse_Start_IT() for interruption mode.

         (++) Set once Mode: In this mode, the output changes the level (from
         low level to high level if the output polarity is configured high, else
         the opposite) when a compare match occurs. To start this mode, call
         HAL_LPTIM_SetOnce_Start() or HAL_LPTIM_SetOnce_Start_IT() for
         interruption mode.

         (++) Encoder Mode: To use the encoder interface call
         HAL_LPTIM_Encoder_Start() or HAL_LPTIM_Encoder_Start_IT() for
         interruption mode. Only available for LPTIM1 instance.

         (++) Time out Mode: an active edge on one selected trigger input rests
         the counter. The first trigger event will start the timer, any
         successive trigger event will reset the counter and the timer will
         restart. To start this mode call HAL_LPTIM_TimeOut_Start_IT() or
         HAL_LPTIM_TimeOut_Start_IT() for interruption mode.

         (++) Counter Mode: counter can be used to count external events on
         the LPTIM Input1 or it can be used to count internal clock cycles.
         To start this mode, call HAL_LPTIM_Counter_Start() or
         HAL_LPTIM_Counter_Start_IT() for interruption mode.


      (#) User can stop any process by calling the corresponding API:
          HAL_LPTIM_Xxx_Stop() or HAL_LPTIM_Xxx_Stop_IT() if the process is
          already started in interruption mode.

      (#) De-initialize the LPTIM peripheral using HAL_LPTIM_DeInit().

    *** Callback registration ***
  =============================================

  The compilation define  USE_HAL_LPTIM_REGISTER_CALLBACKS when set to 1
  allows the user to configure dynamically the driver callbacks.

  Use Function @ref HAL_LPTIM_RegisterCallback() to register a callback.
  @ref HAL_LPTIM_RegisterCallback() takes as parameters the HAL peripheral handle,
  the Callback ID and a pointer to the user callback function.

  Use function @ref HAL_LPTIM_UnRegisterCallback() to reset a callback to the
  default weak function.
  @ref HAL_LPTIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.

  These functions allow to register/unregister following callbacks:

    (+) MspInitCallback         : LPTIM Base Msp Init Callback.
    (+) MspDeInitCallback       : LPTIM Base Msp DeInit Callback.
    (+) CompareMatchCallback    : Compare match Callback.
    (+) AutoReloadMatchCallback : Auto-reload match Callback.
    (+) TriggerCallback         : External trigger event detection Callback.
    (+) CompareWriteCallback    : Compare register write complete Callback.
    (+) AutoReloadWriteCallback : Auto-reload register write complete Callback.
    (+) DirectionUpCallback     : Up-counting direction change Callback.
    (+) DirectionDownCallback   : Down-counting direction change Callback.

  By default, after the Init and when the state is HAL_LPTIM_STATE_RESET
  all interrupt callbacks are set to the corresponding weak functions:
  examples @ref HAL_LPTIM_TriggerCallback(), @ref HAL_LPTIM_CompareMatchCallback().

  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
  functionalities in the Init/DeInit only when these callbacks are null
  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init/DeInit
  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

  Callbacks can be registered/unregistered in HAL_LPTIM_STATE_READY state only.
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_LPTIM_STATE_READY or HAL_LPTIM_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using @ref HAL_LPTIM_RegisterCallback() before calling DeInit or Init function.

  When The compilation define USE_HAL_LPTIM_REGISTER_CALLBACKS is set to 0 or
  not defined, the callback registration feature is not available and all callbacks
  are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
    * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM LPTIM
  * @brief LPTIM HAL module driver.
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_LPTIM_MODULE_ENABLED</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>LPTIM1</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMEOUT</name></cpp:macro>                                     <cpp:value>1000UL</cpp:value></cpp:define> <comment type="block">/* Timeout is 1s */</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LPTIM_ResetCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>lptim</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM_Exported_Functions LPTIM Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM_Exported_Functions_Group1 Initialization/de-initialization functions
 *  @brief    Initialization and Configuration functions.
 *
@verbatim
  ==============================================================================
              ##### Initialization and de-initialization functions #####
  ==============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize the LPTIM according to the specified parameters in the
          LPTIM_InitTypeDef and initialize the associated handle.
      (+) DeInitialize the LPTIM peripheral.
      (+) Initialize the LPTIM MSP.
      (+) DeInitialize the LPTIM MSP.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the LPTIM according to the specified parameters in the
  *         LPTIM_InitTypeDef and initialize the associated handle.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Init</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpcfgr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the LPTIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hlptim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_SOURCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_PRESCALER</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Prescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>==</operator> <name>LPTIM_CLOCKSOURCE_ULPTIM</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_POLARITY</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>Polarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_SAMPLE_TIME</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>SampleTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_TRG_SOURCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_TRIG_SAMPLE_TIME</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>SampleTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_EXT_TRG_POLARITY</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>ActiveEdge</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_OUTPUT_POLARITY</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OutputPolarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_UPDATE_MODE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UpdateMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_COUNTER_SOURCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterSource</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_LPTIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Reset interrupt callbacks to legacy weak callbacks */</comment>
    <expr_stmt><expr><call><name>LPTIM_ResetCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_MspInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name>HAL_LPTIM_MspInit</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Get the LPTIMx CFGR value */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>=</operator> <name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>==</operator> <name>LPTIM_CLOCKSOURCE_ULPTIM</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterSource</name></name><operator>)</operator> <operator>==</operator> <name>LPTIM_COUNTERSOURCE_EXTERNAL</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmpcfgr</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>LPTIM_CFGR_CKPOL</name> <operator>|</operator> <name>LPTIM_CFGR_CKFLT</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmpcfgr</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>LPTIM_CFGR_TRGFLT</name> <operator>|</operator> <name>LPTIM_CFGR_TRIGSEL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear CKSEL, CKPOL, PRESC, TRIGEN, TRGFLT, WAVPOL, PRELOAD &amp; COUNTMODE bits */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>LPTIM_CFGR_CKSEL</name> <operator>|</operator> <name>LPTIM_CFGR_CKPOL</name> <operator>|</operator> <name>LPTIM_CFGR_TRIGEN</name> <operator>|</operator> <name>LPTIM_CFGR_PRELOAD</name> <operator>|</operator>
                          <name>LPTIM_CFGR_WAVPOL</name> <operator>|</operator> <name>LPTIM_CFGR_PRESC</name> <operator>|</operator> <name>LPTIM_CFGR_COUNTMODE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set initialization parameters */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>|=</operator> <operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name>    <operator>|</operator>
              <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Prescaler</name></name> <operator>|</operator>
              <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OutputPolarity</name></name>  <operator>|</operator>
              <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UpdateMode</name></name>      <operator>|</operator>
              <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterSource</name></name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>==</operator> <name>LPTIM_CLOCKSOURCE_ULPTIM</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterSource</name></name><operator>)</operator> <operator>==</operator> <name>LPTIM_COUNTERSOURCE_EXTERNAL</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmpcfgr</name> <operator>|=</operator> <operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>Polarity</name></name> <operator>|</operator>
                <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>SampleTime</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable External trigger and set the trigger source */</comment>
    <expr_stmt><expr><name>tmpcfgr</name> <operator>|=</operator> <operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name>     <operator>|</operator>
                <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>ActiveEdge</name></name> <operator>|</operator>
                <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>SampleTime</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write to LPTIMx CFGR */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>=</operator> <name>tmpcfgr</name></expr>;</expr_stmt>

  <comment type="block">/* Change the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitialize the LPTIM peripheral.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_DeInit</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the LPTIM handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hlptim</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the LPTIM Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_MspDeInit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* DeInit the low level hardware: CLOCK, NVIC.*/</comment>
  <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: CLOCK, NVIC.*/</comment>
  <expr_stmt><expr><call><name>HAL_LPTIM_MspDeInit</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>

  <comment type="block">/* Change the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_RESET</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the LPTIM MSP.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_MspInit</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitialize LPTIM MSP.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_MspDeInit</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM_Exported_Functions_Group2 LPTIM Start-Stop operation functions
 *  @brief   Start-Stop operation functions.
 *
@verbatim
  ==============================================================================
                ##### LPTIM Start Stop operation functions #####
  ==============================================================================
    [..]  This section provides functions allowing to:
      (+) Start the PWM mode.
      (+) Stop the PWM mode.
      (+) Start the One pulse mode.
      (+) Stop the One pulse mode.
      (+) Start the Set once mode.
      (+) Stop the Set once mode.
      (+) Start the Encoder mode.
      (+) Stop the Encoder mode.
      (+) Start the Timeout mode.
      (+) Stop the Timeout mode.
      (+) Start the Counter mode.
      (+) Stop the Counter mode.


@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Start the LPTIM PWM generation.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Pulse Specifies the compare value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_PWM_Start</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Pulse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Reset WAVE bit to set PWM mode */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_WAVE</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the pulse value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the LPTIM PWM generation.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_PWM_Stop</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the LPTIM PWM generation in interrupt mode.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF
  * @param  Pulse Specifies the compare value.
  *         This parameter must be a value between 0x0000 and 0xFFFF
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_PWM_Start_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Pulse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Reset WAVE bit to set PWM mode */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_WAVE</name></expr>;</expr_stmt>

  <comment type="block">/* Enable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Compare write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If external trigger source is used, then enable external trigger interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable external trigger interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the pulse value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the LPTIM PWM generation in interrupt mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_PWM_Stop_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Compare write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If external trigger source is used, then disable external trigger interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable external trigger interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the LPTIM One pulse generation.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Pulse Specifies the compare value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_OnePulse_Start</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Pulse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Reset WAVE bit to set one pulse mode */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_WAVE</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the pulse value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in single (one shot) mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_SINGLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the LPTIM One pulse generation.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_OnePulse_Stop</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the LPTIM One pulse generation in interrupt mode.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Pulse Specifies the compare value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_OnePulse_Start_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Pulse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Reset WAVE bit to set one pulse mode */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_WAVE</name></expr>;</expr_stmt>

  <comment type="block">/* Enable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Compare write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If external trigger source is used, then enable external trigger interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable external trigger interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the pulse value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in single (one shot) mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_SINGLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the LPTIM One pulse generation in interrupt mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_OnePulse_Stop_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Compare write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If external trigger source is used, then disable external trigger interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable external trigger interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the LPTIM in Set once mode.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Pulse Specifies the compare value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_SetOnce_Start</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Pulse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Set WAVE bit to enable the set once mode */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>|=</operator> <name>LPTIM_CFGR_WAVE</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the pulse value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in single (one shot) mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_SINGLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the LPTIM Set once mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_SetOnce_Stop</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the LPTIM Set once mode in interrupt mode.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Pulse Specifies the compare value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_SetOnce_Start_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Pulse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Set WAVE bit to enable the set once mode */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>|=</operator> <name>LPTIM_CFGR_WAVE</name></expr>;</expr_stmt>

  <comment type="block">/* Enable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Compare write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If external trigger source is used, then enable external trigger interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Enable external trigger interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the pulse value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Pulse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in single (one shot) mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_SINGLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the LPTIM Set once mode in interrupt mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_SetOnce_Stop_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Compare write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If external trigger source is used, then disable external trigger interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Trigger</name><operator>.</operator><name>Source</name></name><operator>)</operator> <operator>!=</operator> <name>LPTIM_TRIGSOURCE_SOFTWARE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable external trigger interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the Encoder interface.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Encoder_Start</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type>          <name>tmpcfgr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name> <operator>==</operator> <name>LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Prescaler</name></name> <operator>==</operator> <name>LPTIM_PRESCALER_DIV1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_POLARITY</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>Polarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Get the LPTIMx CFGR value */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>=</operator> <name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Clear CKPOL bits */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><name>LPTIM_CFGR_CKPOL</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set Input polarity */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>|=</operator>  <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>Polarity</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write to LPTIMx CFGR */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>=</operator> <name>tmpcfgr</name></expr>;</expr_stmt>

  <comment type="block">/* Set ENC bit to enable the encoder interface */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>|=</operator> <name>LPTIM_CFGR_ENC</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the Encoder interface.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Encoder_Stop</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset ENC bit to disable the encoder interface */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_ENC</name></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the Encoder interface in interrupt mode.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Encoder_Start_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type>          <name>tmpcfgr</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name> <operator>==</operator> <name>LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Prescaler</name></name> <operator>==</operator> <name>LPTIM_PRESCALER_DIV1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_POLARITY</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>Polarity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Configure edge sensitivity for encoder mode */</comment>
  <comment type="block">/* Get the LPTIMx CFGR value */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>=</operator> <name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name></expr>;</expr_stmt>

  <comment type="block">/* Clear CKPOL bits */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>~</operator><name>LPTIM_CFGR_CKPOL</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Set Input polarity */</comment>
  <expr_stmt><expr><name>tmpcfgr</name> <operator>|=</operator>  <name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>UltraLowPowerClock</name><operator>.</operator><name>Polarity</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write to LPTIMx CFGR */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>=</operator> <name>tmpcfgr</name></expr>;</expr_stmt>

  <comment type="block">/* Set ENC bit to enable the encoder interface */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>|=</operator> <name>LPTIM_CFGR_ENC</name></expr>;</expr_stmt>

  <comment type="block">/* Enable "switch to down direction" interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_DOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable "switch to up direction" interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the Encoder interface in interrupt mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Encoder_Stop_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset ENC bit to disable the encoder interface */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_ENC</name></expr>;</expr_stmt>

  <comment type="block">/* Disable "switch to down direction" interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_DOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable "switch to up direction" interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the Timeout function.
  * @note   The first trigger event will start the timer, any successive
  *         trigger event will reset the counter and the timer restarts.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Timeout Specifies the TimeOut value to reset the counter.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_TimeOut_Start</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Set TIMOUT bit to enable the timeout function */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>|=</operator> <name>LPTIM_CFGR_TIMOUT</name></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the Timeout value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the Timeout function.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_TimeOut_Stop</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset TIMOUT bit to enable the timeout function */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_TIMOUT</name></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the Timeout function in interrupt mode.
  * @note   The first trigger event will start the timer, any successive
  *         trigger event will reset the counter and the timer restarts.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Timeout Specifies the TimeOut value to reset the counter.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_TimeOut_Start_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PULSE</name><argument_list>(<argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Enable EXTI Line interrupt on the LPTIM Wake-up Timer */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_IT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set TIMOUT bit to enable the timeout function */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>|=</operator> <name>LPTIM_CFGR_TIMOUT</name></expr>;</expr_stmt>

  <comment type="block">/* Enable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the Timeout value in the compare register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_COMPARE_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the Timeout function in interrupt mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_TimeOut_Stop_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable EXTI Line interrupt on the LPTIM Wake-up Timer */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_IT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset TIMOUT bit to enable the timeout function */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_TIMOUT</name></expr>;</expr_stmt>

  <comment type="block">/* Disable Compare match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the Counter mode.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Counter_Start</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* If clock source is not ULPTIM clock and counter source is external, then it must not be prescaled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name> <operator>!=</operator> <name>LPTIM_CLOCKSOURCE_ULPTIM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterSource</name></name> <operator>==</operator> <name>LPTIM_COUNTERSOURCE_EXTERNAL</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if clock is prescaled */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_PRESCALERDIV1</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Prescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Set clock prescaler to 0 */</comment>
    <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_PRESC</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the Counter mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Counter_Stop</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Start the Counter mode in interrupt mode.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Counter_Start_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Period</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_PERIOD</name><argument_list>(<argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Enable EXTI Line interrupt on the LPTIM Wake-up Timer */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_IT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If clock source is not ULPTIM clock and counter source is external, then it must not be prescaled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Source</name></name> <operator>!=</operator> <name>LPTIM_CLOCKSOURCE_ULPTIM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>CounterSource</name></name> <operator>==</operator> <name>LPTIM_COUNTERSOURCE_EXTERNAL</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if clock is prescaled */</comment>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_CLOCK_PRESCALERDIV1</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>Clock</name><operator>.</operator><name>Prescaler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Set clock prescaler to 0 */</comment>
    <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LPTIM_CFGR_PRESC</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Enable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_ENABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load the period value in the autoreload register */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_AUTORELOAD_SET</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>Period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start timer in continuous mode */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_START_CONTINUOUS</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop the Counter mode in interrupt mode.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_Counter_Stop_IT</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the LPTIM state */</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable EXTI Line interrupt on the LPTIM Wake-up Timer */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_IT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable the Peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload write complete interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Autoreload match interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_LPTIM_DISABLE_IT</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Change the TIM state*/</comment>
  <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_LPTIM_STATE_READY</name></expr>;</expr_stmt>

  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM_Exported_Functions_Group3 LPTIM Read operation functions
 *  @brief  Read operation functions.
 *
@verbatim
  ==============================================================================
                  ##### LPTIM Read operation functions #####
  ==============================================================================
[..]  This section provides LPTIM Reading functions.
      (+) Read the counter value.
      (+) Read the period (Auto-reload) value.
      (+) Read the pulse (Compare)value.
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the current counter value.
  * @param  hlptim LPTIM handle
  * @retval Counter value.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_LPTIM_ReadCounter</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CNT</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the current Autoreload (Period) value.
  * @param  hlptim LPTIM handle
  * @retval Autoreload value.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_LPTIM_ReadAutoReload</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ARR</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the current Compare (Pulse) value.
  * @param  hlptim LPTIM handle
  * @retval Compare value.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_LPTIM_ReadCompare</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_LPTIM_INSTANCE</name><argument_list>(<argument><expr><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name><name>hlptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMP</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM_Exported_Functions_Group4 LPTIM IRQ handler and callbacks
 *  @brief  LPTIM  IRQ handler.
 *
@verbatim
  ==============================================================================
                      ##### LPTIM IRQ handler and callbacks  #####
  ==============================================================================
[..]  This section provides LPTIM IRQ handler and callback functions called within
      the IRQ handler:
   (+) LPTIM interrupt request handler
   (+) Compare match Callback
   (+) Auto-reload match Callback
   (+) External trigger event detection Callback
   (+) Compare register write complete Callback
   (+) Auto-reload register write complete Callback
   (+) Up-counting direction change Callback
   (+) Down-counting direction change Callback

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Handle LPTIM interrupt request.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_LPTIM_IRQHandler</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Compare match interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_CMPM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Compare match flag */</comment>
      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_CMPM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Compare match Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>CompareMatchCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_LPTIM_CompareMatchCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Autoreload match interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_ARRM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARRM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Autoreload match flag */</comment>
      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_ARRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Autoreload match Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>AutoReloadMatchCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_LPTIM_AutoReloadMatchCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Trigger detected interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_EXTTRIG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_EXTTRIG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Trigger detected flag */</comment>
      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Trigger detected callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>TriggerCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_LPTIM_TriggerCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compare write interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_CMPOK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_CMPOK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Compare write flag */</comment>
      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Compare write Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>CompareWriteCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_LPTIM_CompareWriteCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Autoreload write interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_ARROK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_ARROK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Autoreload write flag */</comment>
      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Autoreload write Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>AutoReloadWriteCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_LPTIM_AutoReloadWriteCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Direction counter changed from Down to Up interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_UP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_UP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Direction counter changed from Down to Up flag */</comment>
      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Direction counter changed from Down to Up Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>DirectionUpCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_LPTIM_DirectionUpCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Direction counter changed from Up to Down interrupt */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_DOWN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_LPTIM_GET_IT_SOURCE</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_IT_DOWN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear Direction counter changed from Up to Down flag */</comment>
      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_DOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Direction counter changed from Up to Down Callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hlptim</name><operator>-&gt;</operator><name>DirectionDownCallback</name></name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_LPTIM_DirectionDownCallback</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Compare match callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_CompareMatchCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_CompareMatchCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Autoreload match callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_AutoReloadMatchCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_AutoReloadMatchCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Trigger detected callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_TriggerCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_TriggerCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Compare write callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_CompareWriteCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_CompareWriteCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Autoreload write callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_AutoReloadWriteCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_AutoReloadWriteCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Direction counter changed from Down to Up callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_DirectionUpCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_DirectionUpCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Direction counter changed from Up to Down callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_LPTIM_DirectionDownCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_DirectionDownCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User LPTIM callback to be used instead of the weak predefined callback
  * @param hlptim LPTIM handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_LPTIM_MSPINIT_CB_ID          LPTIM Base Msp Init Callback ID
  *          @arg @ref HAL_LPTIM_MSPDEINIT_CB_ID        LPTIM Base Msp DeInit Callback ID
  *          @arg @ref HAL_LPTIM_COMPARE_MATCH_CB_ID    Compare match Callback ID
  *          @arg @ref HAL_LPTIM_AUTORELOAD_MATCH_CB_ID Auto-reload match Callback ID
  *          @arg @ref HAL_LPTIM_TRIGGER_CB_ID          External trigger event detection Callback ID
  *          @arg @ref HAL_LPTIM_COMPARE_WRITE_CB_ID    Compare register write complete Callback ID
  *          @arg @ref HAL_LPTIM_AUTORELOAD_WRITE_CB_ID Auto-reload register write complete Callback ID
  *          @arg @ref HAL_LPTIM_DIRECTION_UP_CB_ID     Up-counting direction change Callback ID
  *          @arg @ref HAL_LPTIM_DIRECTION_DOWN_CB_ID   Down-counting direction change Callback ID
  * @param pCallback pointer to the callback function
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name>        <modifier>*</modifier></type><name>hlptim</name></decl></parameter>,
                                             <parameter><decl><type><name>HAL_LPTIM_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>,
                                             <parameter><decl><type><name>pLPTIM_CallbackTypeDef</name></type>      <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_LPTIM_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_LPTIM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_COMPARE_MATCH_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>CompareMatchCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_AUTORELOAD_MATCH_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>AutoReloadMatchCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_TRIGGER_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>TriggerCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_COMPARE_WRITE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>CompareWriteCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_AUTORELOAD_WRITE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>AutoReloadWriteCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_DIRECTION_UP_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>DirectionUpCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_DIRECTION_DOWN_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>DirectionDownCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_LPTIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_LPTIM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister a LPTIM callback
  *         LLPTIM callback is redirected to the weak predefined callback
  * @param hlptim LPTIM handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_LPTIM_MSPINIT_CB_ID          LPTIM Base Msp Init Callback ID
  *          @arg @ref HAL_LPTIM_MSPDEINIT_CB_ID        LPTIM Base Msp DeInit Callback ID
  *          @arg @ref HAL_LPTIM_COMPARE_MATCH_CB_ID    Compare match Callback ID
  *          @arg @ref HAL_LPTIM_AUTORELOAD_MATCH_CB_ID Auto-reload match Callback ID
  *          @arg @ref HAL_LPTIM_TRIGGER_CB_ID          External trigger event detection Callback ID
  *          @arg @ref HAL_LPTIM_COMPARE_WRITE_CB_ID    Compare register write complete Callback ID
  *          @arg @ref HAL_LPTIM_AUTORELOAD_WRITE_CB_ID Auto-reload register write complete Callback ID
  *          @arg @ref HAL_LPTIM_DIRECTION_UP_CB_ID     Up-counting direction change Callback ID
  *          @arg @ref HAL_LPTIM_DIRECTION_DOWN_CB_ID   Down-counting direction change Callback ID
  * @retval status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_LPTIM_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name>        <modifier>*</modifier></type><name>hlptim</name></decl></parameter>,
                                               <parameter><decl><type><name>HAL_LPTIM_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_LPTIM_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_LPTIM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_MspInit</name></expr>;</expr_stmt>                          <comment type="block">/* Legacy weak MspInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_MspDeInit</name></expr>;</expr_stmt>                       <comment type="block">/* Legacy weak Msp DeInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_COMPARE_MATCH_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>CompareMatchCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_CompareMatchCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak Compare match Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_AUTORELOAD_MATCH_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>AutoReloadMatchCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_AutoReloadMatchCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak Auto-reload match Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_TRIGGER_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>TriggerCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_TriggerCallback</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak External trigger event detection Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_COMPARE_WRITE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>CompareWriteCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_CompareWriteCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak Compare register write complete Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_AUTORELOAD_WRITE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>AutoReloadWriteCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_AutoReloadWriteCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak Auto-reload register write complete Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_DIRECTION_UP_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>DirectionUpCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_DirectionUpCallback</name></expr>;</expr_stmt>           <comment type="block">/* Legacy weak Up-counting direction change Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_DIRECTION_DOWN_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>DirectionDownCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_DirectionDownCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak Down-counting direction change Callback */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_LPTIM_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_LPTIM_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_MspInit</name></expr>;</expr_stmt>                           <comment type="block">/* Legacy weak MspInit Callback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_LPTIM_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hlptim</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_MspDeInit</name></expr>;</expr_stmt>                        <comment type="block">/* Legacy weak Msp DeInit Callback */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hlptim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM_Group5 Peripheral State functions
 *  @brief   Peripheral State functions.
 *
@verbatim
  ==============================================================================
                      ##### Peripheral State functions #####
  ==============================================================================
    [..]
    This subsection permits to get in run-time the status of the peripheral.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the LPTIM handle state.
  * @param  hlptim LPTIM handle
  * @retval HAL state
  */</comment>
<function><type><name>HAL_LPTIM_StateTypeDef</name></type> <name>HAL_LPTIM_GetState</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>hlptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return LPTIM handle state */</comment>
  <return>return <expr><name><name>hlptim</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>


<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup LPTIM_Private_Functions LPTIM Private Functions
  * @{
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_LPTIM_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Reset interrupt callbacks to the legacy weak callbacks.
  * @param  lptim pointer to a LPTIM_HandleTypeDef structure that contains
  *                the configuration information for LPTIM module.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LPTIM_ResetCallback</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>lptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Reset the LPTIM callback to the legacy weak callbacks */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>CompareMatchCallback</name></name>    <operator>=</operator> <name>HAL_LPTIM_CompareMatchCallback</name></expr>;</expr_stmt>    <comment type="block">/* Compare match Callback                       */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>AutoReloadMatchCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_AutoReloadMatchCallback</name></expr>;</expr_stmt> <comment type="block">/* Auto-reload match Callback                   */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>TriggerCallback</name></name>         <operator>=</operator> <name>HAL_LPTIM_TriggerCallback</name></expr>;</expr_stmt>         <comment type="block">/* External trigger event detection Callback    */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>CompareWriteCallback</name></name>    <operator>=</operator> <name>HAL_LPTIM_CompareWriteCallback</name></expr>;</expr_stmt>    <comment type="block">/* Compare register write complete Callback     */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>AutoReloadWriteCallback</name></name> <operator>=</operator> <name>HAL_LPTIM_AutoReloadWriteCallback</name></expr>;</expr_stmt> <comment type="block">/* Auto-reload register write complete Callback */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>DirectionUpCallback</name></name>     <operator>=</operator> <name>HAL_LPTIM_DirectionUpCallback</name></expr>;</expr_stmt>     <comment type="block">/* Up-counting direction change Callback        */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>DirectionDownCallback</name></name>   <operator>=</operator> <name>HAL_LPTIM_DirectionDownCallback</name></expr>;</expr_stmt>   <comment type="block">/* Down-counting direction change Callback      */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_LPTIM_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Disable LPTIM HW instance.
  * @param  lptim pointer to a LPTIM_HandleTypeDef structure that contains
  *                the configuration information for LPTIM module.
  * @note   The following sequence is required to solve LPTIM disable HW limitation.
  *         Please check Errata Sheet ES0335 for more details under "MCU may remain
  *         stuck in LPTIM interrupt when entering Stop mode" section.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>LPTIM_Disable</name><parameter_list>(<parameter><decl><type><name>LPTIM_HandleTypeDef</name> <modifier>*</modifier></type><name>lptim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpclksource</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpIER</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpCFGR</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpCMP</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpARR</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpOR</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block" format="doxygen">/*********** Save LPTIM Config ***********/</comment>
  <comment type="block">/* Save LPTIM source clock */</comment>
  <switch>switch <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name></name></expr>)</condition>
  <block>{<block_content>
     <case>case <expr><name>LPTIM1_BASE</name></expr>:</case>
       <expr_stmt><expr><name>tmpclksource</name> <operator>=</operator> <call><name>__HAL_RCC_GET_LPTIM1_SOURCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <break>break;</break>
     <default>default:</default>
       <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Save LPTIM configuration registers */</comment>
  <expr_stmt><expr><name>tmpIER</name> <operator>=</operator> <name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpCFGR</name> <operator>=</operator> <name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpCMP</name> <operator>=</operator> <name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMP</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpARR</name> <operator>=</operator> <name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ARR</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmpOR</name> <operator>=</operator> <name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>OR</name></name></expr>;</expr_stmt>

  <comment type="block" format="doxygen">/*********** Reset LPTIM ***********/</comment>
  <switch>switch <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name></name></expr>)</condition>
  <block>{<block_content>
     <case>case <expr><name>LPTIM1_BASE</name></expr>:</case>
       <expr_stmt><expr><call><name>__HAL_RCC_LPTIM1_FORCE_RESET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>__HAL_RCC_LPTIM1_RELEASE_RESET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <break>break;</break>
     <default>default:</default>
       <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block" format="doxygen">/*********** Restore LPTIM Config ***********/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Ref_Time</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Time_Elapsed</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpCMP</name> <operator>!=</operator> <literal type="number">0UL</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmpARR</name> <operator>!=</operator> <literal type="number">0UL</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Force LPTIM source kernel clock from APB */</comment>
    <switch>switch <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name></name></expr>)</condition>
    <block>{<block_content>
       <case>case <expr><name>LPTIM1_BASE</name></expr>:</case>
         <expr_stmt><expr><call><name>__HAL_RCC_LPTIM1_CONFIG</name><argument_list>(<argument><expr><name>RCC_LPTIM1CLKSOURCE_PCLK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <break>break;</break>
       <default>default:</default>
         <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>tmpCMP</name> <operator>!=</operator> <literal type="number">0UL</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Restore CMP register (LPTIM should be enabled first) */</comment>
      <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>LPTIM_CR_ENABLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CMP</name></name> <operator>=</operator> <name>tmpCMP</name></expr>;</expr_stmt>
      <comment type="block">/* Polling on CMP write ok status after above restore operation */</comment>
      <expr_stmt><expr><name>Ref_Time</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>Time_Elapsed</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Ref_Time</name></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><operator>(</operator><operator>!</operator><operator>(</operator><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>lptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_CMPOK</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Time_Elapsed</name> <operator>&lt;=</operator> <name>TIMEOUT</name><operator>)</operator></expr>)</condition>;</do>

      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>lptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_CMPOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>tmpARR</name> <operator>!=</operator> <literal type="number">0UL</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Restore ARR register (LPTIM should be enabled first) */</comment>
      <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>|=</operator> <name>LPTIM_CR_ENABLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>ARR</name></name> <operator>=</operator> <name>tmpARR</name></expr>;</expr_stmt>
      <comment type="block">/* Polling on ARR write ok status after above restore operation */</comment>
      <expr_stmt><expr><name>Ref_Time</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>Time_Elapsed</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Ref_Time</name></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><operator>(</operator><operator>!</operator><operator>(</operator><call><name>__HAL_LPTIM_GET_FLAG</name><argument_list>(<argument><expr><name>lptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_ARROK</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Time_Elapsed</name> <operator>&lt;=</operator> <name>TIMEOUT</name><operator>)</operator></expr>)</condition>;</do>

      <expr_stmt><expr><call><name>__HAL_LPTIM_CLEAR_FLAG</name><argument_list>(<argument><expr><name>lptim</name></expr></argument>, <argument><expr><name>LPTIM_FLAG_ARROK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Restore LPTIM source kernel clock */</comment>
    <switch>switch <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name></name></expr>)</condition>
    <block>{<block_content>
       <case>case <expr><name>LPTIM1_BASE</name></expr>:</case>
         <expr_stmt><expr><call><name>__HAL_RCC_LPTIM1_CONFIG</name><argument_list>(<argument><expr><name>tmpclksource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <break>break;</break>
       <default>default:</default>
         <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Restore configuration registers (LPTIM should be disabled first) */</comment>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>LPTIM_CR_ENABLE</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>IER</name></name> <operator>=</operator> <name>tmpIER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CFGR</name></name> <operator>=</operator> <name>tmpCFGR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lptim</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>OR</name></name> <operator>=</operator> <name>tmpOR</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* LPTIM1 */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_LPTIM_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
