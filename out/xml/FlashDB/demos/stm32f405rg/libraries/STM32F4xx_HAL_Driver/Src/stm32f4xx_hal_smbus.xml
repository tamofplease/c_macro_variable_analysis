<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f405rg/libraries/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_smbus.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f4xx_hal_smbus.c
  * @author  MCD Application Team
  * @brief   SMBUS HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the System Management Bus (SMBus) peripheral,
  *          based on SMBUS principals of operation :
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral State, Mode and Error functions
  *
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
  [..]
    The SMBUS HAL driver can be used as follows:

    (#) Declare a SMBUS_HandleTypeDef handle structure, for example:
        SMBUS_HandleTypeDef  hsmbus;

    (#)Initialize the SMBUS low level resources by implementing the @ref HAL_SMBUS_MspInit() API:
        (##) Enable the SMBUSx interface clock
        (##) SMBUS pins configuration
            (+++) Enable the clock for the SMBUS GPIOs
            (+++) Configure SMBUS pins as alternate function open-drain
        (##) NVIC configuration if you need to use interrupt process
            (+++) Configure the SMBUSx interrupt priority
            (+++) Enable the NVIC SMBUS IRQ Channel

    (#) Configure the Communication Speed, Duty cycle, Addressing mode, Own Address1,
        Dual Addressing mode, Own Address2, General call and Nostretch mode in the hsmbus Init structure.

    (#) Initialize the SMBUS registers by calling the @ref HAL_SMBUS_Init(), configures also the low level Hardware
        (GPIO, CLOCK, NVIC...etc) by calling the customized @ref HAL_SMBUS_MspInit(&amp;hsmbus) API.

    (#) To check if target device is ready for communication, use the function @ref HAL_SMBUS_IsDeviceReady()

    (#) For SMBUS IO operations, only one mode of operations is available within this driver :


    *** Interrupt mode IO operation ***
    ===================================

  [..]
      (+) Transmit in master/host SMBUS mode an amount of data in non blocking mode using @ref HAL_SMBUS_Master_Transmit_IT()
      (++) At transmission end of transfer @ref HAL_SMBUS_MasterTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_MasterTxCpltCallback()
      (+) Receive in master/host SMBUS mode an amount of data in non blocking mode using @ref HAL_SMBUS_Master_Receive_IT()
      (++) At reception end of transfer @ref HAL_SMBUS_MasterRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_MasterRxCpltCallback()
      (+) Abort a master/Host SMBUS process communication with Interrupt using @ref HAL_SMBUS_Master_Abort_IT()
      (++) End of abort process, @ref HAL_SMBUS_AbortCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_AbortCpltCallback()
      (+) Enable/disable the Address listen mode in slave/device or host/slave SMBUS mode
           using @ref HAL_SMBUS_EnableListen_IT() @ref HAL_SMBUS_DisableListen_IT()
      (++) When address slave/device SMBUS match, @ref HAL_SMBUS_AddrCallback() is executed and user can
           add his own code to check the Address Match Code and the transmission direction request by master/host (Write/Read).
      (++) At Listen mode end @ref HAL_SMBUS_ListenCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_ListenCpltCallback()
      (+) Transmit in slave/device SMBUS mode an amount of data in non blocking mode using @ref HAL_SMBUS_Slave_Transmit_IT()
      (++) At transmission end of transfer @ref HAL_SMBUS_SlaveTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_SlaveTxCpltCallback()
      (+) Receive in slave/device SMBUS mode an amount of data in non blocking mode using @ref HAL_SMBUS_Slave_Receive_IT()
      (++) At reception end of transfer @ref HAL_SMBUS_SlaveRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_SlaveRxCpltCallback()
      (+) Enable/Disable the SMBUS alert mode using @ref HAL_SMBUS_EnableAlert_IT() and @ref HAL_SMBUS_DisableAlert_IT()
      (++) When SMBUS Alert is generated @ref HAL_SMBUS_ErrorCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_ErrorCallback()
           to check the Alert Error Code using function @ref HAL_SMBUS_GetError()
      (+) Get HAL state machine or error values using @ref HAL_SMBUS_GetState() or HAL_SMBUS_GetError()
      (+) In case of transfer Error, @ref HAL_SMBUS_ErrorCallback() function is executed and user can
           add his own code by customization of function pointer @ref HAL_SMBUS_ErrorCallback()
           to check the Error Code using function @ref HAL_SMBUS_GetError()


     *** SMBUS HAL driver macros list ***
     ==================================
     [..]
       Below the list of most used macros in SMBUS HAL driver.

      (+) @ref __HAL_SMBUS_ENABLE    : Enable the SMBUS peripheral
      (+) @ref __HAL_SMBUS_DISABLE   : Disable the SMBUS peripheral
      (+) @ref __HAL_SMBUS_GET_FLAG  : Checks whether the specified SMBUS flag is set or not
      (+) @ref __HAL_SMBUS_CLEAR_FLAG: Clear the specified SMBUS pending flag
      (+) @ref __HAL_SMBUS_ENABLE_IT : Enable the specified SMBUS interrupt
      (+) @ref __HAL_SMBUS_DISABLE_IT: Disable the specified SMBUS interrupt

     [..]
       (@) You can refer to the SMBUS HAL driver header file for more useful macros

     *** Callback registration ***
     =============================================

     The compilation flag USE_HAL_SMBUS_REGISTER_CALLBACKS when set to 1
     allows the user to configure dynamically the driver callbacks.
     Use Functions @ref HAL_SMBUS_RegisterCallback() or @ref HAL_SMBUS_RegisterXXXCallback()
     to register an interrupt callback.

     Function @ref HAL_SMBUS_RegisterCallback() allows to register following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
       (+) ListenCpltCallback   : callback for end of listen mode.
       (+) ErrorCallback        : callback for error detection.
       (+) AbortCpltCallback    : callback for abort completion process.
       (+) MspInitCallback      : callback for Msp Init.
       (+) MspDeInitCallback    : callback for Msp DeInit.
     This function takes as parameters the HAL peripheral handle, the Callback ID
     and a pointer to the user callback function.

     For specific callback AddrCallback use dedicated register callbacks : @ref HAL_SMBUS_RegisterAddrCallback().

     Use function @ref HAL_SMBUS_UnRegisterCallback to reset a callback to the default
     weak function.
     @ref HAL_SMBUS_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
       (+) ListenCpltCallback   : callback for end of listen mode.
       (+) ErrorCallback        : callback for error detection.
       (+) AbortCpltCallback    : callback for abort completion process.
       (+) MspInitCallback      : callback for Msp Init.
       (+) MspDeInitCallback    : callback for Msp DeInit.

     For callback AddrCallback use dedicated register callbacks : @ref HAL_SMBUS_UnRegisterAddrCallback().

     By default, after the @ref HAL_SMBUS_Init() and when the state is @ref HAL_SMBUS_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_SMBUS_MasterTxCpltCallback(), @ref HAL_SMBUS_MasterRxCpltCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_SMBUS_Init()/ @ref HAL_SMBUS_DeInit() only when
     these callbacks are null (not registered beforehand).
     If MspInit or MspDeInit are not null, the @ref HAL_SMBUS_Init()/ @ref HAL_SMBUS_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.

     Callbacks can be registered/unregistered in @ref HAL_SMBUS_STATE_READY state only.
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_SMBUS_STATE_READY or @ref HAL_SMBUS_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
     Then, the user first registers the MspInit/MspDeInit user callbacks
     using @ref HAL_SMBUS_RegisterCallback() before calling @ref HAL_SMBUS_DeInit()
     or @ref HAL_SMBUS_Init() function.

     When the compilation flag USE_HAL_SMBUS_REGISTER_CALLBACKS is set to 0 or
     not defined, the callback registration feature is not available and all callbacks
     are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f4xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SMBUS SMBUS
  * @brief SMBUS HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_SMBUS_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup SMBUS_Private_Define
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_TIMEOUT_FLAG</name></cpp:macro>          <cpp:value>35U</cpp:value></cpp:define>         <comment type="block" format="doxygen">/*!&lt; Timeout 35 ms             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_TIMEOUT_BUSY_FLAG</name></cpp:macro>     <cpp:value>25U</cpp:value></cpp:define>         <comment type="block" format="doxygen">/*!&lt; Timeout 25 ms             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_NO_OPTION_FRAME</name></cpp:macro>       <cpp:value>0xFFFF0000U</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; XferOptions default value */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_SENDPEC_MODE</name></cpp:macro>          <cpp:value>I2C_CR1_PEC</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_GET_PEC</name><parameter_list>(<parameter><type><name>__HANDLE__</name></type></parameter>)</parameter_list></cpp:macro>             <cpp:value>(((__HANDLE__)-&gt;Instance-&gt;SR2 &amp; I2C_SR2_PEC) &gt;&gt; 8)</cpp:value></cpp:define>

<comment type="block">/* Private define for @ref PreviousState usage */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_STATE_MSK</name></cpp:macro>             <cpp:value>((uint32_t)((HAL_SMBUS_STATE_BUSY_TX | HAL_SMBUS_STATE_BUSY_RX) &amp; (~(uint32_t)HAL_SMBUS_STATE_READY)))</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; Mask State define, keep only RX and TX bits            */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_STATE_NONE</name></cpp:macro>            <cpp:value>((uint32_t)(HAL_SMBUS_MODE_NONE))</cpp:value></cpp:define>                                                                      <comment type="block" format="doxygen">/*!&lt; Default Value                                          */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_STATE_MASTER_BUSY_TX</name></cpp:macro>  <cpp:value>((uint32_t)((HAL_SMBUS_STATE_BUSY_TX &amp; SMBUS_STATE_MSK) | HAL_SMBUS_MODE_MASTER))</cpp:value></cpp:define>                      <comment type="block" format="doxygen">/*!&lt; Master Busy TX, combinaison of State LSB and Mode enum */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_STATE_MASTER_BUSY_RX</name></cpp:macro>  <cpp:value>((uint32_t)((HAL_SMBUS_STATE_BUSY_RX &amp; SMBUS_STATE_MSK) | HAL_SMBUS_MODE_MASTER))</cpp:value></cpp:define>                      <comment type="block" format="doxygen">/*!&lt; Master Busy RX, combinaison of State LSB and Mode enum */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_STATE_SLAVE_BUSY_TX</name></cpp:macro>   <cpp:value>((uint32_t)((HAL_SMBUS_STATE_BUSY_TX &amp; SMBUS_STATE_MSK) | HAL_SMBUS_MODE_SLAVE))</cpp:value></cpp:define>                       <comment type="block" format="doxygen">/*!&lt; Slave Busy TX, combinaison of State LSB and Mode enum  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMBUS_STATE_SLAVE_BUSY_RX</name></cpp:macro>   <cpp:value>((uint32_t)((HAL_SMBUS_STATE_BUSY_RX &amp; SMBUS_STATE_MSK) | HAL_SMBUS_MODE_SLAVE))</cpp:value></cpp:define>                       <comment type="block" format="doxygen">/*!&lt; Slave Busy RX, combinaison of State LSB and Mode enum  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @addtogroup SMBUS_Private_Functions
  * @{
  */</comment>

<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_WaitOnFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>Status</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SMBUS_ITError</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private functions for SMBUS transfer IRQ handler */</comment>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterReceive_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Master_SB</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Master_ADD10</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Master_ADDR</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveReceive_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Slave_ADDR</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Slave_STOPF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Slave_AF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup SMBUS_Exported_Functions SMBUS Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SMBUS_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization and Configuration functions
 *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]  This subsection provides a set of functions allowing to initialize and
          deinitialize the SMBUSx peripheral:

      (+) User must Implement HAL_SMBUS_MspInit() function in which he configures
          all related peripherals resources (CLOCK, GPIO, IT and NVIC).

      (+) Call the function HAL_SMBUS_Init() to configure the selected device with
          the selected configuration:
        (++) Communication Speed
        (++) Addressing mode
        (++) Own Address 1
        (++) Dual Addressing mode
        (++) Own Address 2
        (++) General call mode
        (++) Nostretch mode
        (++) Packet Error Check mode
        (++) Peripheral mode

      (+) Call the function HAL_SMBUS_DeInit() to restore the default configuration
          of the selected SMBUSx peripheral.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the SMBUS according to the specified parameters
  *         in the SMBUS_InitTypeDef and initialize the associated handle.
  * @param  hsmbus pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_Init</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>freqrange</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>pclk1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the SMBUS handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hsmbus</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive>  <expr><call><name>defined</name><argument_list>(<argument><expr><name>I2C_FLTR_ANOFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_ANALOG_FILTER</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AnalogFilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_CLOCK_SPEED</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockSpeed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_OWN_ADDRESS1</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_ADDRESSING_MODE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_DUAL_ADDRESS</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DualAddressMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_OWN_ADDRESS2</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_GENERAL_CALL</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>GeneralCallMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_NO_STRETCH</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NoStretchMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_PEC</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PacketErrorCheckMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_PERIPHERAL_MODE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeripheralMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Init the SMBUS Callback settings */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MasterTxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterTxCpltCallback */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MasterRxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterRxCpltCallback */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name>  <operator>=</operator> <name>HAL_SMBUS_SlaveTxCpltCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak SlaveTxCpltCallback  */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name>  <operator>=</operator> <name>HAL_SMBUS_SlaveRxCpltCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak SlaveRxCpltCallback  */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name>   <operator>=</operator> <name>HAL_SMBUS_ListenCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak ListenCpltCallback   */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCallback</name></name>        <operator>=</operator> <name>HAL_SMBUS_ErrorCallback</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak ErrorCallback        */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name>    <operator>=</operator> <name>HAL_SMBUS_AbortCpltCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak AbortCpltCallback    */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>AddrCallback</name></name>         <operator>=</operator> <name>HAL_SMBUS_AddrCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak AddrCallback         */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MspInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspInit  */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name>HAL_SMBUS_MspInit</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the selected SMBUS peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get PCLK1 frequency */</comment>
  <expr_stmt><expr><name>pclk1</name> <operator>=</operator> <call><name>HAL_RCC_GetPCLK1Freq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Calculate frequency range */</comment>
  <expr_stmt><expr><name>freqrange</name> <operator>=</operator> <call><name>SMBUS_FREQRANGE</name><argument_list>(<argument><expr><name>pclk1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- SMBUSx CR2 Configuration ----------------------*/</comment>
  <comment type="block">/* Configure SMBUSx: Frequency range */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_FREQ</name></expr></argument>, <argument><expr><name>freqrange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- SMBUSx TRISE Configuration --------------------*/</comment>
  <comment type="block">/* Configure SMBUSx: Rise Time */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TRISE</name></name></expr></argument>, <argument><expr><name>I2C_TRISE_TRISE</name></expr></argument>, <argument><expr><call><name>SMBUS_RISE_TIME</name><argument_list>(<argument><expr><name>freqrange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- SMBUSx CCR Configuration ----------------------*/</comment>
  <comment type="block">/* Configure SMBUSx: Speed */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_CCR_FS</name> <operator>|</operator> <name>I2C_CCR_DUTY</name> <operator>|</operator> <name>I2C_CCR_CCR</name><operator>)</operator></expr></argument>, <argument><expr><call><name>SMBUS_SPEED_STANDARD</name><argument_list>(<argument><expr><name>pclk1</name></expr></argument>, <argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockSpeed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- SMBUSx CR1 Configuration ----------------------*/</comment>
  <comment type="block">/* Configure SMBUSx: Generalcall , PEC , Peripheral mode and  NoStretch mode */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_CR1_NOSTRETCH</name> <operator>|</operator> <name>I2C_CR1_ENGC</name> <operator>|</operator> <name>I2C_CR1_PEC</name> <operator>|</operator> <name>I2C_CR1_ENARP</name> <operator>|</operator> <name>I2C_CR1_SMBTYPE</name> <operator>|</operator> <name>I2C_CR1_SMBUS</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NoStretchMode</name></name> <operator>|</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>GeneralCallMode</name></name> <operator>|</operator>  <name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PacketErrorCheckMode</name></name> <operator>|</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeripheralMode</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- SMBUSx OAR1 Configuration ---------------------*/</comment>
  <comment type="block">/* Configure SMBUSx: Own Address1 and addressing mode */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>OAR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_OAR1_ADDMODE</name> <operator>|</operator> <name>I2C_OAR1_ADD8_9</name> <operator>|</operator> <name>I2C_OAR1_ADD1_7</name> <operator>|</operator> <name>I2C_OAR1_ADD0</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>|</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- SMBUSx OAR2 Configuration ---------------------*/</comment>
  <comment type="block">/* Configure SMBUSx: Dual mode and Own Address2 */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>OAR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_OAR2_ENDUAL</name> <operator>|</operator> <name>I2C_OAR2_ADD2</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DualAddressMode</name></name> <operator>|</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive>  <expr><call><name>defined</name><argument_list>(<argument><expr><name>I2C_FLTR_ANOFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/*---------------------------- SMBUSx FLTR Configuration ------------------------*/</comment>
  <comment type="block">/* Configure SMBUSx: Analog noise filter */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FLTR</name></name></expr></argument>, <argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AnalogFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Enable the selected SMBUS peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferPEC</name></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitializes the SMBUS peripheral.
  * @param  hsmbus pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_DeInit</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the SMBUS handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hsmbus</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the SMBUS Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MspDeInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspDeInit  */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name>HAL_SMBUS_MspDeInit</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>

  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name>     <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name>         <operator>=</operator> <name>HAL_SMBUS_STATE_RESET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name>          <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the SMBUS MSP.
  * @param  hsmbus pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_MspInit</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SMBUS_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitialize the SMBUS MSP.
  * @param  hsmbus pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_MspDeInit</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SMBUS_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive>  <expr><call><name>defined</name><argument_list>(<argument><expr><name>I2C_FLTR_ANOFF</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><call><name>defined</name><argument_list>(<argument><expr><name>I2C_FLTR_DNF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Configures SMBUS Analog noise filter.
  * @param  hsmbus pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUSx peripheral.
  * @param  AnalogFilter new state of the Analog filter.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_ConfigAnalogFilter</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>AnalogFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_ANALOG_FILTER</name><argument_list>(<argument><expr><name>AnalogFilter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY</name></expr>;</expr_stmt>

    <comment type="block">/* Disable the selected SMBUS peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset SMBUSx ANOFF bit */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FLTR</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>I2C_FLTR_ANOFF</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Disable the analog filter */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FLTR</name></name> <operator>|=</operator> <name>AnalogFilter</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Configures SMBUS Digital noise filter.
  * @param  hsmbus pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUSx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between 0x00 and 0x0F.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_ConfigDigitalFilter</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>DigitalFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>tmpreg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_DIGITAL_FILTER</name><argument_list>(<argument><expr><name>DigitalFilter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY</name></expr>;</expr_stmt>

    <comment type="block">/* Disable the selected SMBUS peripheral */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the old register value */</comment>
    <expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FLTR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Reset SMBUSx DNF bit [3:0] */</comment>
    <expr_stmt><expr><name>tmpreg</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>I2C_FLTR_DNF</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Set SMBUSx DNF coefficient */</comment>
    <expr_stmt><expr><name>tmpreg</name> <operator>|=</operator> <name>DigitalFilter</name></expr>;</expr_stmt>

    <comment type="block">/* Store the new register value */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>FLTR</name></name> <operator>=</operator> <name>tmpreg</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User SMBUS Callback
  *         To be used instead of the weak predefined callback
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_SMBUS_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
  *          @arg @ref HAL_SMBUS_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_SMBUS_ABORT_CB_ID Abort callback ID
  *          @arg @ref HAL_SMBUS_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_SMBUS_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>HAL_SMBUS_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pSMBUS_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_SMBUS_STATE_READY</name> <operator>==</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SMBUS_MASTER_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MASTER_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_SLAVE_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_SLAVE_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_LISTEN_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_SMBUS_STATE_RESET</name> <operator>==</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SMBUS_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister an SMBUS Callback
  *         SMBUS callback is redirected to the weak predefined callback
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @param  CallbackID ID of the callback to be unregistered
  *         This parameter can be one of the following values:
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_SMBUS_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
  *          @arg @ref HAL_SMBUS_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
  *          @arg @ref HAL_SMBUS_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_SMBUS_ABORT_CB_ID Abort callback ID
  *          @arg @ref HAL_SMBUS_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_SMBUS_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>HAL_SMBUS_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_SMBUS_STATE_READY</name> <operator>==</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SMBUS_MASTER_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MasterTxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterTxCpltCallback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MASTER_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MasterRxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterRxCpltCallback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_SLAVE_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_SlaveTxCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak SlaveTxCpltCallback  */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_SLAVE_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_SlaveRxCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak SlaveRxCpltCallback  */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_LISTEN_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_ListenCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak ListenCpltCallback   */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_ErrorCallback</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak ErrorCallback        */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_AbortCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak AbortCpltCallback    */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MspDeInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_SMBUS_STATE_RESET</name> <operator>==</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_SMBUS_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_SMBUS_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_MspDeInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Register the Slave Address Match SMBUS Callback
  *         To be used instead of the weak HAL_SMBUS_AddrCallback() predefined callback
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @param  pCallback pointer to the Address Match Callback function
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_RegisterAddrCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>pSMBUS_AddrCallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_SMBUS_STATE_READY</name> <operator>==</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>AddrCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  UnRegister the Slave Address Match SMBUS Callback
  *         Info Ready SMBUS Callback is redirected to the weak HAL_SMBUS_AddrCallback() predefined callback
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_UnRegisterAddrCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_SMBUS_STATE_READY</name> <operator>==</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>AddrCallback</name></name> <operator>=</operator> <name>HAL_SMBUS_AddrCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak AddrCallback  */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup SMBUS_Exported_Functions_Group2 Input and Output operation functions
 *  @brief    Data transfers functions
 *
@verbatim
 ===============================================================================
                      ##### IO operation functions #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to manage the SMBUS data
    transfers.

    (#) Blocking mode function to check if device is ready for usage is :
        (++) HAL_SMBUS_IsDeviceReady()

    (#) There is only one mode of transfer:
       (++) Non Blocking mode : The communication is performed using Interrupts.
            These functions return the status of the transfer startup.
            The end of the data processing will be indicated through the
            dedicated SMBUS IRQ when using Interrupt mode.

    (#) Non Blocking mode functions with Interrupt are :
        (++) HAL_SMBUS_Master_Transmit_IT()
        (++) HAL_SMBUS_Master_Receive_IT()
        (++) HAL_SMBUS_Master_Abort_IT()
        (++) HAL_SMBUS_Slave_Transmit_IT()
        (++) HAL_SMBUS_Slave_Receive_IT()
        (++) HAL_SMBUS_EnableAlert_IT()
        (++) HAL_SMBUS_DisableAlert_IT()

    (#) A set of Transfer Complete Callbacks are provided in No_Blocking mode:
        (++) HAL_SMBUS_MasterTxCpltCallback()
        (++) HAL_SMBUS_MasterRxCpltCallback()
        (++) HAL_SMBUS_SlaveTxCpltCallback()
        (++) HAL_SMBUS_SlaveRxCpltCallback()
        (++) HAL_SMBUS_AddrCallback()
        (++) HAL_SMBUS_ListenCpltCallback()
        (++) HAL_SMBUS_ErrorCallback()
        (++) HAL_SMBUS_AbortCpltCallback()

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Transmits in master mode an amount of data in blocking mode.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @param  DevAddress Target device address The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_Master_Transmit_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name>      <init>= <expr><literal type="number">0x00U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Busy Flag only if FIRST call of Master interface */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until BUSY flag is reset */</comment>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name>SMBUS_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>count</name><operator>--</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the SMBUS is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable SMBUS peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_SMBUS_MODE_MASTER</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <comment type="block">/* Generate Start */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The SMBUS interrupts must be enabled after unlocking current process
    to avoid the risk of hsmbus interrupt handle execution before current
    process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @brief  Receive in master/host SMBUS mode an amount of data in non blocking mode with Interrupt.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @param  DevAddress Target device address The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref SMBUS_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_Master_Receive_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Busy Flag only if FIRST call of Master interface */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until BUSY flag is reset */</comment>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name>SMBUS_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>count</name><operator>--</operator> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the SMBUS is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable SMBUS peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_SMBUS_MODE_MASTER</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>==</operator> <name>SMBUS_STATE_MASTER_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>==</operator> <name>SMBUS_STATE_NONE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Start condition if first transfer */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_NEXT_FRAME</name><operator>)</operator>  <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_FRAME</name><operator>)</operator>  <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_NO_OPTION_FRAME</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Generate Start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>==</operator> <name>SMBUS_STATE_NONE</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable Acknowledge */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>==</operator> <name>SMBUS_STATE_MASTER_BUSY_TX</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable Acknowledge */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Generate Start */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>



    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The SMBUS interrupts must be enabled after unlocking current process
    to avoid the risk of SMBUS interrupt handle execution before current
    process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Abort a master/host SMBUS process communication with Interrupt.
  * @note   This abort can be called only if state is ready
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @param  DevAddress Target device address The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_Master_Abort_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>PeripheralMode</name></name> <operator>==</operator> <name>SMBUS_PERIPHERAL_MODE_SMBUS_HOST</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_ABORT</name></expr>;</expr_stmt>


    <comment type="block">/* Disable Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate Stop */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
    <expr_stmt><expr><call><name>SMBUS_ITError</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Transmit in slave/device SMBUS mode an amount of data in non blocking mode with Interrupt.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref SMBUS_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_Slave_Transmit_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the SMBUS is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable SMBUS peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY_TX_LISTEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_SMBUS_MODE_SLAVE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>

    <comment type="block">/* Clear ADDR flag after prepare the transfer parameters */</comment>
    <comment type="block">/* This action will generate an acknowledge to the HOST */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The SMBUS interrupts must be enabled after unlocking current process
              to avoid the risk of SMBUS interrupt handle execution before current
              process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable the Address listen mode with Interrupt.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref SMBUS_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_Slave_Receive_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_SMBUS_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the SMBUS is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable SMBUS peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY_RX_LISTEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_SMBUS_MODE_SLAVE</name></expr>;</expr_stmt>



    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The SMBUS interrupts must be enabled after unlocking current process
              to avoid the risk of SMBUS interrupt handle execution before current
              process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Enable the Address listen mode with Interrupt.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_EnableListen_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_LISTEN</name></expr>;</expr_stmt>

    <comment type="block">/* Check if the SMBUS is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable SMBUS peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Enable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable EVT and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disable the Address listen mode with Interrupt.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_DisableListen_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of tmp to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name></decl>;</decl_stmt>

  <comment type="block">/* Disable Address listen mode only if a transfer is not ongoing */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name><operator>)</operator> <operator>&amp;</operator> <name>SMBUS_STATE_MSK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>tmp</name> <operator>|</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Disable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable the SMBUS alert mode with Interrupt.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUSx peripheral.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_EnableAlert_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Enable SMBus alert */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ALERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear ALERT flag */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_SMBALERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable Alert Interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
  * @brief  Disable the SMBUS alert mode with Interrupt.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUSx peripheral.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_DisableAlert_IT</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Disable SMBus alert */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ALERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Alert Interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief  Check if target device is ready for communication.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for the specified SMBUS.
  * @param  DevAddress Target device address The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_SMBUS_IsDeviceReady</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Trials</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp2</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp3</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>SMBUS_Trials</name> <init>= <expr><literal type="number">1U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get tick */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SMBUS_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>SMBUS_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the SMBUS is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable SMBUS peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_ENABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_BUSY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>SMBUS_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
      <comment type="block">/* Generate Start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Wait until SB flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>SMBUS_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Send slave address */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>SMBUS_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Wait until ADDR or AF flag are set */</comment>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_ADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp3</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>(</operator><name>tmp1</name> <operator>==</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp2</name> <operator>==</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp3</name> <operator>!=</operator> <name>HAL_SMBUS_STATE_TIMEOUT</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_TIMEOUT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_ADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp3</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
      </block_content>}</block></while>

      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

      <comment type="block">/* Check if the ADDR flag has been set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_ADDR</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear ADDR Flag */</comment>
        <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Wait until BUSY flag is reset */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>SMBUS_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>SMBUS_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_OK</name></expr>;</return>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear AF Flag */</comment>
        <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Wait until BUSY flag is reset */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>SMBUS_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>SMBUS_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><name>SMBUS_Trials</name><operator>++</operator> <operator>&lt;</operator> <name>Trials</name></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles SMBUS event interrupt request.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_SMBUS_EV_IRQHandler</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sr2itflags</name>   <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sr1itflags</name>   <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>itsources</name>    <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentMode</name>  <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Master mode selected */</comment>
  <if_stmt><if>if <condition>(<expr><name>CurrentMode</name> <operator>==</operator> <name>HAL_SMBUS_MODE_MASTER</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* SB Set ----------------------------------------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_SB</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SMBUS_Master_SB</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* ADD10 Set -------------------------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_ADD10</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SMBUS_Master_ADD10</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* ADDR Set --------------------------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_ADDR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SMBUS_Master_ADDR</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* SMBUS in mode Transmitter -----------------------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sr2itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_TRA</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* TXE set and BTF reset -----------------------------------------------*/</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_TXE</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_BUF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_MasterTransmit_TXE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_MasterTransmit_BTF</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* SMBUS in mode Receiver --------------------------------------------------*/</comment>
    <else>else
    <block>{<block_content>
      <comment type="block">/* RXNE set and BTF reset -----------------------------------------------*/</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_RXNE</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_BUF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_MasterReceive_RXNE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_MasterReceive_BTF</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <comment type="block">/* Slave mode selected */</comment>
  <else>else
  <block>{<block_content>
    <comment type="block">/* ADDR set --------------------------------------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_ADDR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SMBUS_Slave_ADDR</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* STOPF set --------------------------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_STOPF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SMBUS_Slave_STOPF</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* SMBUS in mode Transmitter -----------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>sr2itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_TRA</name><operator>)</operator> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* TXE set and BTF reset -----------------------------------------------*/</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_TXE</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_BUF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_SlaveTransmit_TXE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_SlaveTransmit_BTF</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* SMBUS in mode Receiver --------------------------------------------------*/</comment>
    <else>else
    <block>{<block_content>
      <comment type="block">/* RXNE set and BTF reset ----------------------------------------------*/</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_RXNE</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_BUF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_SlaveReceive_RXNE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BTF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_EVT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SMBUS_SlaveReceive_BTF</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles SMBUS error interrupt request.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_SMBUS_ER_IRQHandler</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp1</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp2</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp3</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp4</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sr1itflags</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>itsources</name>  <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* SMBUS Bus error interrupt occurred ------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_BERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_ERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_BERR</name></expr>;</expr_stmt>

    <comment type="block">/* Clear BERR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_BERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SMBUS Over-Run/Under-Run interrupt occurred ----------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_OVR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_ERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_OVR</name></expr>;</expr_stmt>

    <comment type="block">/* Clear OVR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_OVR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SMBUS Arbitration Loss error interrupt occurred ------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_ARLO</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_ERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_ARLO</name></expr>;</expr_stmt>

    <comment type="block">/* Clear ARLO flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_ARLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SMBUS Acknowledge failure error interrupt occurred ------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_AF</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_ERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp3</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp4</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp1</name> <operator>==</operator> <name>HAL_SMBUS_MODE_SLAVE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp2</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> \
        <operator>(</operator><operator>(</operator><name>tmp3</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp3</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX_LISTEN</name><operator>)</operator> <operator>||</operator> \
         <operator>(</operator><operator>(</operator><name>tmp3</name> <operator>==</operator> <name>HAL_SMBUS_STATE_LISTEN</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp4</name> <operator>==</operator> <name>SMBUS_STATE_SLAVE_BUSY_TX</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SMBUS_Slave_AF</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_AF</name></expr>;</expr_stmt>

      <comment type="block">/* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_SMBUS_MODE_MASTER</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Clear AF flag */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SMBUS Timeout error interrupt occurred ---------------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_TIMEOUT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_ERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_TIMEOUT</name></expr>;</expr_stmt>

    <comment type="block">/* Clear TIMEOUT flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SMBUS Alert error interrupt occurred -----------------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_SMBALERT</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_ERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_SMBUS_ERROR_ALERT</name></expr>;</expr_stmt>

    <comment type="block">/* Clear ALERT flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_SMBALERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SMBUS Packet Error Check error interrupt occurred ----------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sr1itflags</name> <operator>&amp;</operator> <name>SMBUS_FLAG_PECERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>itsources</name> <operator>&amp;</operator> <name>SMBUS_IT_ERR</name><operator>)</operator> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>SMBUS_FLAG_PECERR</name></expr>;</expr_stmt>

    <comment type="block">/* Clear PEC error flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_PECERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Call the Error Callback in case of Error detected -----------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SMBUS_ITError</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Master Tx Transfer completed callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_MasterTxCpltCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SMBUS_MasterTxCpltCallback can be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Master Rx Transfer completed callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_MasterRxCpltCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SMBUS_MasterRxCpltCallback can be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** @brief  Slave Tx Transfer completed callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_SlaveTxCpltCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SMBUS_SlaveTxCpltCallback can be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Slave Rx Transfer completed callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_SlaveRxCpltCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SMBUS_SlaveRxCpltCallback can be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Slave Address Match callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref SMBUS_XferOptions_definition
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_AddrCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>TransferDirection</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>AddrMatchCode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>TransferDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>AddrMatchCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SMBUS_AddrCallback can be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Listen Complete callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_ListenCpltCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
          the HAL_SMBUS_ListenCpltCallback can be implemented in the user file
  */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  SMBUS error callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SMBUS_ErrorCallback can be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  SMBUS abort callback.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_SMBUS_AbortCpltCallback</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SMBUS_AbortCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup   SMBUS_Exported_Functions_Group3 Peripheral State, Mode and Error functions
  *  @brief   Peripheral State and Errors functions
  *
@verbatim
 ===============================================================================
            ##### Peripheral State, Mode and Error functions #####
 ===============================================================================
    [..]
    This subsection permits to get in run-time the status of the peripheral
    and the data flow.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the SMBUS handle state.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for the specified SMBUS.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_SMBUS_StateTypeDef</name></type> <name>HAL_SMBUS_GetState</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return SMBUS handle state */</comment>
  <return>return <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the SMBUS Master, Slave or no mode.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *                the configuration information for SMBUS module
  * @retval HAL mode
  */</comment>
<function><type><name>HAL_SMBUS_ModeTypeDef</name></type> <name>HAL_SMBUS_GetMode</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the SMBUS error code
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *              the configuration information for the specified SMBUS.
  * @retval SMBUS Error Code
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_SMBUS_GetError</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup SMBUS_Private_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Handle TXE flag for Master
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentState</name>       <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentMode</name>        <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Call TxCpltCallback() directly if no stop mode is set */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> \
        <operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_NO_OPTION_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_MASTER_BUSY_TX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SMBUS_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <else>else <comment type="block">/* Generate Stop condition then Call TxCpltCallback() */</comment>
    <block>{<block_content>
      <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SMBUS_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SMBUS_GET_PEC_MODE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SMBUS_PEC_ENABLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>

      <comment type="block">/* Disable BUF interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>SMBUS_GET_PEC_MODE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SMBUS_PEC_ENABLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_PEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Write data to DR */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Master transmitter
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Write data to DR */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Call TxCpltCallback() directly if no stop mode is set */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>SMBUS_NO_OPTION_FRAME</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_MASTER_BUSY_TX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_SMBUS_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else <comment type="block">/* Generate Stop condition then Call TxCpltCallback() */</comment>
      <block>{<block_content>
        <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_SMBUS_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle RXNE flag for Master
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&gt;</operator> <literal type="number">3U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable BUF interrupt, this help to treat correctly the last 4 bytes
        on BTF subroutine */</comment>
        <comment type="block">/* Disable BUF interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

    <if type="elseif">else if <condition>(<expr><name>tmp</name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
    <block>{<block_content>

      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* PEC of slave */</comment>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferPEC</name></name> <operator>=</operator> <call><name>SMBUS_GET_PEC</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SMBUS_MasterRxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Master receiver
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_MasterReceive_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">4U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable BUF interrupt, this help to treat correctly the last 2 bytes
       on BTF subroutine if there is a reception delay between N-1 and N byte */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferPEC</name></name> <operator>=</operator> <call><name>SMBUS_GET_PEC</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">3U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable BUF interrupt, this help to treat correctly the last 2 bytes
       on BTF subroutine if there is a reception delay between N-1 and N byte */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferPEC</name></name> <operator>=</operator> <call><name>SMBUS_GET_PEC</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Prepare next transfer or stop current transfer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>SMBUS_NEXT_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>SMBUS_FIRST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>SMBUS_LAST_FRAME_NO_PEC</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate ReStart */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SMBUS_MasterRxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle SB flag for Master
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Master_SB</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>==</operator> <name>SMBUS_ADDRESSINGMODE_7BIT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Send slave 7 Bits address */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>SMBUS_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>SMBUS_7BIT_ADD_READ</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send header of slave address */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>SMBUS_10BIT_HEADER_WRITE</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send header of slave address */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>SMBUS_10BIT_HEADER_READ</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle ADD10 flag for Master
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Master_ADD10</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Send slave address */</comment>
  <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>SMBUS_10BIT_ADDRESS</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle ADDR flag for Master
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Master_ADDR</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentMode</name>        <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Prev_State</name>         <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>==</operator> <name>SMBUS_ADDRESSINGMODE_10BIT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Restart */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>EventCount</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/*  In the case of the Quick Command, the ADDR flag is cleared and a stop is generated */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Clear ADDR flag */</comment>
        <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Prepare next transfer or stop current transfer */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_FIRST_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>SMBUS_STATE_MASTER_BUSY_RX</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Clear ADDR flag */</comment>
          <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_NEXT_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>SMBUS_STATE_MASTER_BUSY_RX</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable Acknowledge */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Clear ADDR flag */</comment>
          <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Clear ADDR flag */</comment>
          <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>!=</operator> <name>SMBUS_NEXT_FRAME</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Enable Pos */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Enable Acknowledge */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Clear ADDR flag */</comment>
        <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear ADDR flag */</comment>
        <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Reset Event counter  */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle TXE flag for Slave
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentState</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Write data to DR */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SMBUS_GET_PEC_MODE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SMBUS_PEC_ENABLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <operator>(</operator><name>HAL_SMBUS_STATE_BUSY_TX_LISTEN</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Last Byte is received, disable Interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set state at HAL_SMBUS_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_SLAVE_BUSY_TX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_LISTEN</name></expr>;</expr_stmt>

      <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SMBUS_SlaveTxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Slave transmitter
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Write data to DR */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if>



  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SMBUS_GET_PEC_MODE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SMBUS_PEC_ENABLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_PEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle RXNE flag for Slave
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentState</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SMBUS_GET_PEC_MODE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SMBUS_PEC_ENABLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_PEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferPEC</name></name> <operator>=</operator> <call><name>SMBUS_GET_PEC</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_RX_LISTEN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Last Byte is received, disable Interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set state at HAL_SMBUS_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_SLAVE_BUSY_RX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_LISTEN</name></expr>;</expr_stmt>

      <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SMBUS_SlaveRxCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Slave receiver
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_SlaveReceive_BTF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle ADD flag for Slave
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Slave_ADDR</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>TransferDirection</name> <init>= <expr><name>SMBUS_DIRECTION_RECEIVE</name></expr></init></decl> ;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>SlaveAddrCode</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Transfer Direction requested by Master */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_TRA</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>TransferDirection</name> <operator>=</operator> <name>SMBUS_DIRECTION_TRANSMIT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_DUALF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>SlaveAddrCode</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress1</name></name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>SlaveAddrCode</name> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress2</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Call Slave Addr callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>AddrCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>TransferDirection</name></expr></argument>, <argument><expr><name>SlaveAddrCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_SMBUS_AddrCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>TransferDirection</name></expr></argument>, <argument><expr><name>SlaveAddrCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle STOPF flag for Slave
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Slave_STOPF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentState</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear STOPF flag */</comment>
  <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_STOPFLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Acknowledge */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All data are not transferred, so set error code accordingly */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
    <expr_stmt><expr><call><name>SMBUS_ITError</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_LISTEN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_RX_LISTEN</name><operator>)</operator>  <operator>||</operator> \
        <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX_LISTEN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>SMBUS_NO_OPTION_FRAME</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_SMBUS_ListenCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_Slave_AF</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentState</name>       <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator>  <name>SMBUS_FIRST_AND_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator>  <name>SMBUS_FIRST_AND_LAST_FRAME_WITH_PEC</name><operator>)</operator> <operator>||</operator> \
       <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>SMBUS_LAST_FRAME_NO_PEC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator>  <name>SMBUS_LAST_FRAME_WITH_PEC</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> \
      <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_LISTEN</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>SMBUS_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE_IT</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_IT_EVT</name> <operator>|</operator> <name>SMBUS_IT_BUF</name> <operator>|</operator> <name>SMBUS_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear AF flag */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SMBUS_ListenCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/**
  * @brief SMBUS interrupts error process
  * @param  hsmbus SMBUS handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SMBUS_ITError</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentState</name> <init>= <expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_TX_LISTEN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_SMBUS_STATE_BUSY_RX_LISTEN</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* keep HAL_SMBUS_STATE_LISTEN */</comment>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_LISTEN</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* If state is an abort treatment on going, don't change state */</comment>
    <comment type="block">/* This change will be done later */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_SMBUS_STATE_ABORT</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Disable Pos bit in SMBUS CR1 when error occurred in Master/Mem Receive IT Process */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_ABORT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_SMBUS_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable SMBUS peripheral to prevent dummy data in buffer */</comment>
    <expr_stmt><expr><call><name>__HAL_SMBUS_DISABLE</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SMBUS_AbortCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>SMBUS_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hsmbus</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Call user error callback */</comment>
    <expr_stmt><expr><call><name>HAL_SMBUS_ErrorCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SMBUS_ErrorCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* STOP Flag is not set after a NACK reception */</comment>
  <comment type="block">/* So may inform upper layer that listen phase is stopped */</comment>
  <comment type="block">/* during NACK error treatment */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_SMBUS_STATE_LISTEN</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>hsmbus</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>&amp;</operator> <name>HAL_SMBUS_ERROR_AF</name><operator>)</operator> <operator>==</operator> <name>HAL_SMBUS_ERROR_AF</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>SMBUS_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_SMBUS_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hsmbus</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_SMBUS_ListenCpltCallback</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_SMBUS_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles SMBUS Communication Timeout.
  * @param  hsmbus Pointer to a SMBUS_HandleTypeDef structure that contains
  *         the configuration information for SMBUS module
  * @param  Flag specifies the SMBUS flag to check.
  * @param  Status The new Flag status (SET or RESET).
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>SMBUS_WaitOnFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>SMBUS_HandleTypeDef</name> <modifier>*</modifier></type><name>hsmbus</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>Status</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Wait until flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><name>Status</name> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <while>while <condition>(<expr><call><name>__HAL_SMBUS_GET_FLAG</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>, <argument><expr><name>Flag</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check for the Timeout */</comment>
      <if_stmt><if>if <condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>SMBUS_STATE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_SMBUS_STATE_READY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hsmbus</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_SMBUS_MODE_NONE</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hsmbus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_SMBUS_MODULE_ENABLED */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
