<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/pl/plpgsql/src/pl_exec.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pl_exec.c        - Executor for the PL/pgSQL
 *              procedural language
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/pl/plpgsql/src/pl_exec.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpgsql.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name></decl>;</decl_stmt>            <comment type="block">/* number of arguments */</comment>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>            <comment type="block">/* types of arguments */</comment>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>            <comment type="block">/* evaluated argument values */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>            <comment type="block">/* null markers (' '/'n' style) */</comment>
}</block></struct></type> <name>PreparedParamsData</name>;</typedef>

<comment type="block">/*
 * All plpgsql function executions within a single transaction share the same
 * executor EState for evaluating "simple" expressions.  Each function call
 * creates its own "eval_econtext" ExprContext within this estate for
 * per-evaluation workspace.  eval_econtext is freed at normal function exit,
 * and the EState is freed at transaction end (in case of error, we assume
 * that the abort mechanisms clean it all up).  Furthermore, any exception
 * block within a function has to have its own eval_econtext separate from
 * the containing function's, so that we can clean up ExprContext callbacks
 * properly at subtransaction exit.  We maintain a stack that tracks the
 * individual econtexts so that we can clean up correctly at subxact exit.
 *
 * This arrangement is a bit tedious to maintain, but it's worth the trouble
 * so that we don't have to re-prepare simple expressions on each trip through
 * a function.  (We assume the case to optimize is many repetitions of a
 * function within a transaction.)
 *
 * However, there's no value in trying to amortize simple expression setup
 * across multiple executions of a DO block (inline code block), since there
 * can never be any.  If we use the shared EState for a DO block, the expr
 * state trees are effectively leaked till end of transaction, and that can
 * add up if the user keeps on submitting DO blocks.  Therefore, each DO block
 * has its own simple-expression EState, which is cleaned up at exit from
 * plpgsql_inline_handler().  DO blocks still use the simple_econtext_stack,
 * though, so that subxact abort cleanup does the right thing.
 */</comment>
<typedef>typedef <type><struct>struct <name>SimpleEcontextStackEntry</name>
<block>{
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>stack_econtext</name></decl>;</decl_stmt>    <comment type="block">/* a stacked econtext */</comment>
    <decl_stmt><decl><type><name>SubTransactionId</name></type> <name>xact_subxid</name></decl>;</decl_stmt>    <comment type="block">/* ID for current subxact */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>SimpleEcontextStackEntry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>    <comment type="block">/* next stack entry up */</comment>
}</block></struct></type> <name>SimpleEcontextStackEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>EState</name> <modifier>*</modifier></type><name>shared_simple_eval_estate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>simple_econtext_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Memory management within a plpgsql function generally works with three
 * contexts:
 *
 * 1. Function-call-lifespan data, such as variable values, is kept in the
 * "main" context, a/k/a the "SPI Proc" context established by SPI_connect().
 * This is usually the CurrentMemoryContext while running code in this module
 * (which is not good, because careless coding can easily cause
 * function-lifespan memory leaks, but we live with it for now).
 *
 * 2. Some statement-execution routines need statement-lifespan workspace.
 * A suitable context is created on-demand by get_stmt_mcontext(), and must
 * be reset at the end of the requesting routine.  Error recovery will clean
 * it up automatically.  Nested statements requiring statement-lifespan
 * workspace will result in a stack of such contexts, see push_stmt_mcontext().
 *
 * 3. We use the eval_econtext's per-tuple memory context for expression
 * evaluation, and as a general-purpose workspace for short-lived allocations.
 * Such allocations usually aren't explicitly freed, but are left to be
 * cleaned up by a context reset, typically done by exec_eval_cleanup().
 *
 * These macros are for use in making short-lived allocations:
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_eval_mcontext</name><parameter_list>(<parameter><type><name>estate</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((estate)-&gt;eval_econtext-&gt;ecxt_per_tuple_memory)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eval_mcontext_alloc</name><parameter_list>(<parameter><type><name>estate</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>MemoryContextAlloc(get_eval_mcontext(estate), sz)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eval_mcontext_alloc0</name><parameter_list>(<parameter><type><name>estate</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>MemoryContextAllocZero(get_eval_mcontext(estate), sz)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name> <name>PGDLLIMPORT</name></type> <name>g_in_plpgsql_exec_fun</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name> <name>PGDLLIMPORT</name></type> <name>PlpgsqlDebugPrint</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * We use a session-wide hash table for caching cast information.
 *
 * Once built, the compiled expression trees (cast_expr fields) survive for
 * the life of the session.  At some point it might be worth invalidating
 * those after pg_cast changes, but for the moment we don't bother.
 *
 * The evaluation state trees (cast_exprstate) are managed in the same way as
 * simple expressions (i.e., we assume cast expressions are always simple).
 *
 * As with simple expressions, DO blocks don't use the shared hash table but
 * must have their own.  This isn't ideal, but we don't want to deal with
 * multiple simple_eval_estates within a DO block.
 */</comment>
<typedef>typedef <type><struct>struct                    <comment type="block">/* lookup key for cast info */</comment>
<block>{
    <comment type="block">/* NB: we assume this struct contains no padding bytes */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>srctype</name></decl>;</decl_stmt>        <comment type="block">/* source type for cast */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dsttype</name></decl>;</decl_stmt>        <comment type="block">/* destination type for cast */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>srctypmod</name></decl>;</decl_stmt>        <comment type="block">/* source typmod for cast */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>dsttypmod</name></decl>;</decl_stmt>        <comment type="block">/* destination typmod for cast */</comment>
}</block></struct></type> <name>plpgsql_CastHashKey</name>;</typedef>

<typedef>typedef <type><struct>struct                    <comment type="block">/* cast_hash table entry */</comment>
<block>{
    <decl_stmt><decl><type><name>plpgsql_CastHashKey</name></type> <name>key</name></decl>;</decl_stmt>    <comment type="block">/* hash key --- MUST BE FIRST */</comment>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>cast_expr</name></decl>;</decl_stmt>        <comment type="block">/* cast expression, or NULL if no-op cast */</comment>
    <comment type="block">/* ExprState is valid only when cast_lxid matches current LXID */</comment>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>cast_exprstate</name></decl>;</decl_stmt> <comment type="block">/* expression's eval tree */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>cast_in_use</name></decl>;</decl_stmt>    <comment type="block">/* true while we're executing eval tree */</comment>
    <decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>cast_lxid</name></decl>;</decl_stmt>
}</block></struct></type> <name>plpgsql_CastHashEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>shared_cast_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>shared_cast_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/************************************************************
 * Local function forward declarations
 ************************************************************/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>copy_plpgsql_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>get_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pop_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_block</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_stmt_block</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmts</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
           <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
          <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_assign</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                 <parameter><decl><type><name>PLpgSQL_stmt_assign</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_perform</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_stmt_perform</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_getdiag</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_stmt_getdiag</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_if</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
             <parameter><decl><type><name>PLpgSQL_stmt_if</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_case</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_stmt_case</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_loop</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_stmt_loop</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_while</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_stmt_while</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_fori</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_stmt_fori</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_fors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_stmt_fors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_forc</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_stmt_forc</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_foreach_a</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                    <parameter><decl><type><name>PLpgSQL_stmt_foreach_a</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_open</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_stmt_open</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_fetch</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_stmt_fetch</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_close</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_stmt_close</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_exit</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_stmt_exit</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_return</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                 <parameter><decl><type><name>PLpgSQL_stmt_return</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_return_next</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                      <parameter><decl><type><name>PLpgSQL_stmt_return_next</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_return_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                       <parameter><decl><type><name>PLpgSQL_stmt_return_query</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_raise</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_stmt_raise</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_assert</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                 <parameter><decl><type><name>PLpgSQL_stmt_assert</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_execsql</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_stmt_execsql</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_dynexecute</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                     <parameter><decl><type><name>PLpgSQL_stmt_dynexecute</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_stmt_dynfors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_stmt_dynfors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_estate_setup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                     <parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
                     <parameter><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl></parameter>,
                     <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>simple_eval_estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_eval_cleanup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_prepare_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>exec_simple_check_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_simple_check_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_simple_recheck_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_check_rw_parameter</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target_dno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contains_target_param</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>target_dno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>exec_eval_simple_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                      <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
                      <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
                      <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_assign_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                 <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                 <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_assign_c_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                     <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_assign_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
                  <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_eval_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeid</name></decl></parameter>,
                <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typetypmod</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_eval_integer</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>exec_eval_boolean</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>exec_eval_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
               <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
               <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_run_select</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>maxtuples</name></decl></parameter>, <parameter><decl><type><name>Portal</name> <modifier>*</modifier></type><name>portalP</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_for_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_forq</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
               <parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefetch_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParamListInfo</name></type> <name>setup_param_list</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                 <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParamListInfo</name></type> <name>setup_unshared_param_list</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                          <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_param_fetch</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paramid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_move_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
              <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
              <parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
              <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>make_tuple_from_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                    <parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
                    <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>get_tuple_from_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>get_tupdesc_from_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_move_row_from_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                         <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
                         <parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>convert_value_to_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                        <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>exec_cast_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name></type> <name>reqtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>reqtypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type><name>get_cast_hashentry</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>srctype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>srctypmod</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>dsttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dsttypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_init_tuple_store</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_set_found</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_create_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_destroy_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_simple_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name></type> <name>newvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>freeable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_text_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type><name>exec_eval_using_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Portal</name></type> <name>exec_dynquery_with_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                          <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>dynquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portalname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_expr_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_preparedparamsdata</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------
 * plpgsql_exec_function    Called by the call handler for
 *                function execution.
 *
 * This is also used to execute inline code blocks (DO blocks).  The only
 * difference that this code is aware of is that for a DO block, we want
 * to use a private simple_eval_estate, which is created and passed in by
 * the caller.  For regular functions, pass NULL, which implies using
 * shared_simple_eval_estate.  (When using a private simple_eval_estate,
 * we must also use a private cast hashtable, but that's taken care of
 * within plpgsql_estate_setup.)
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>plpgsql_exec_function</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                      <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>simple_eval_estate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_execstate</name></type> <name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>SetEnterPlpgsqlFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetTopXactNeedBeginTxn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>PlpgsqlDebugPrint</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] plpgsql_exec_function begin g_in_plpgsql_exec_fun:%d"</literal></expr></argument>, <argument><expr><name>g_in_plpgsql_exec_fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Setup the execution state
     */</comment>
    <expr_stmt><expr><call><name>plpgsql_estate_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>,
                         <argument><expr><name>simple_eval_estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup error traceback support for ereport()
     */</comment>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Make local execution copies of all the datums
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during initialization of execution state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>.</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>copy_plpgsql_datum</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Store the actual call argument values into the appropriate variables
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while storing call arguments into local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>n</name> <init>= <expr><name><name>func</name><operator>-&gt;</operator><name>fn_argvarnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                      <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Force any array-valued parameter to be stored in
                     * expanded form in our local variable, in hopes of
                     * improving efficiency of uses of the variable.  (This is
                     * a hack, really: why only arrays? Need more thought
                     * about which cases are likely to win.  See also
                     * typisarray-specific heuristic in exec_assign_value.)
                     *
                     * Special cases: If passed a R/W expanded pointer, assume
                     * we can commandeer the object rather than having to copy
                     * it.  If passed a R/O expanded pointer, just keep it as
                     * the value of the variable for the moment.  (We'll force
                     * it to R/W if the variable gets modified, but that may
                     * very well never happen.)
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typisarray</name></name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* take ownership of R/W object */</comment>
                            <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                              <argument><expr><call><name>TransferExpandedObject</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
                                                                     <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>false</name></expr></argument>,
                                              <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RO</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* R/O pointer, keep it as-is until assigned to */</comment>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* flat array, so force to expanded form */</comment>
                            <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                              <argument><expr><call><name>expand_array</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
                                                           <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>false</name></expr></argument>,
                                              <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Assign row value from composite datum */</comment>
                        <expr_stmt><expr><call><name>exec_move_row_from_datum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>row</name></expr></argument>,
                                                 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* If arg is null, treat it as an empty row */</comment>
                        <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <comment type="block">/* clean up after exec_move_row() */</comment>
                    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the magic variable FOUND to false
     */</comment>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the instrumentation plugin peek at this function
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now call the toplevel block of statements
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>action</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_block</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_FUNCTION_EXECUTED_NO_RETURN_STATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"control reached end of function without RETURN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We got a return value - process it
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while casting return value to function's return type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>estate</name><operator>.</operator><name>retisnull</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retisset</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>estate</name><operator>.</operator><name>rsi</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Check caller can handle a set result */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

        <comment type="block">/* If we produced any tuples, send back the result */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>tuple_store</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>estate</name><operator>.</operator><name>tuple_store</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>rettupdesc</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>tuple_store_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>rettupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>.</operator><name>retisnull</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retistuple</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We have to check that the returned tuple actually matches the
             * expected result type.  XXX would be better to cache the tupdesc
             * instead of repeating get_call_result_type()
             */</comment>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>rettup</name> <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>TYPEFUNC_COMPOSITE</name></expr>:</case>
                    <comment type="block">/* got the expected result rowtype, now check it */</comment>
                    <expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>rettupdesc</name></name></expr></argument>,
                                                        <argument><expr><name>tupdesc</name></expr></argument>,
                                                        <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned record type does not match expected record type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* it might need conversion */</comment>
                    <if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <comment type="block">/* no need to free map, we're about to return anyway */</comment>
                    <break>break;</break>
                <case>case <expr><name>TYPEFUNC_RECORD</name></expr>:</case>

                    <comment type="block">/*
                     * Failed to determine actual type of RECORD.  We could
                     * raise an error here, but what this means in practice is
                     * that the caller is expecting any old generic rowtype,
                     * so we don't really need to be restrictive. Pass back
                     * the generated result type, instead.
                     */</comment>
                    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>estate</name><operator>.</operator><name>rettupdesc</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <comment type="block">/* shouldn't get here if retistuple is true ... */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <comment type="block">/*
             * Copy tuple to upper executor memory, as a tuple Datum. Make
             * sure it is labeled with the caller-supplied tuple type.
             */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>SPI_returntuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Cast value to proper type */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>,
                                            <argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
                                            <argument><expr><name><name>estate</name><operator>.</operator><name>rettype</name></name></expr></argument>,
                                            <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                            <argument><expr><name><name>func</name><operator>-&gt;</operator><name>fn_rettype</name></name></expr></argument>,
                                            <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the function's return type isn't by value, copy the value
             * into upper executor memory context.  However, if we have a R/W
             * expanded datum, we can just transfer its ownership out to the
             * upper executor context.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>func</name><operator>-&gt;</operator><name>fn_retbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>SPI_datumTransfer</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>,
                                                  <argument><expr><name>false</name></expr></argument>,
                                                  <argument><expr><name><name>func</name><operator>-&gt;</operator><name>fn_rettyplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the instrumentation plugin peek at this function
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Clean up any leftover temporary memory */</comment>
    <expr_stmt><expr><call><name>plpgsql_destroy_econtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* stmt_mcontext will be destroyed when function's main context is */</comment>

    <comment type="block">/*
     * Pop the error context stack
     */</comment>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Return the function's result
     */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>SetExitPlpgsqlFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>PlpgsqlDebugPrint</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] plpgsql_exec_function end g_in_plpgsql_exec_fun:%d"</literal></expr></argument>, <argument><expr><name>g_in_plpgsql_exec_fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <return>return <expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_exec_trigger        Called by the call handler for
 *                trigger execution.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>plpgsql_exec_trigger</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
                     <parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_execstate</name></type> <name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec_new</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>rec_old</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>rettup</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Setup the execution state
     */</comment>
    <expr_stmt><expr><call><name>plpgsql_estate_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup error traceback support for ereport()
     */</comment>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Make local execution copies of all the datums
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during initialization of execution state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>.</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>copy_plpgsql_datum</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Put the OLD and NEW tuples into record variables
     *
     * We make the tupdescs available in both records even though only one may
     * have a value.  This allows parsing of record references to succeed in
     * functions that are used for multiple trigger types.  For example, we
     * might have a test like "if (TG_OP = 'INSERT' and NEW.foo = 'xyz')",
     * which should parse regardless of the current trigger type.
     */</comment>
    <expr_stmt><expr><name>rec_new</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>new_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>freetup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>freetupdesc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rec_old</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>old_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>freetup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>freetupdesc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Per-statement triggers don't use OLD/NEW variables
         */</comment>
        <expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger action: not INSERT, DELETE, or UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Make transition tables visible to this SPI connection */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_register_trigger_data</name><argument_list>(<argument><expr><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Assign the special tg_ variables
     */</comment>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_op_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_TRUNCATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger action: not INSERT, DELETE, UPDATE, or TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_name_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                      <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
                                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_when_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"BEFORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"AFTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_INSTEAD</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger execution time: not BEFORE, AFTER, or INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_level_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"ROW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_STATEMENT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"STATEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger event type: not ROW or STATEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_relid_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                      <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_relname_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                      <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
                                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_table_name_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                      <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
                                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_table_schema_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                      <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
                                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(
                                                                             <argument><expr><call><name>RelationGetNamespace</name><argument_list>(
                                                                                                  <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_nargs_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                      <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_argv_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For historical reasons, tg_argv[] subscripts start at zero not one.
         * So we can't use construct_array().
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name> <init>= <expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                             <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
                                                             <argument><expr><name>TEXTOID</name></expr></argument>,
                                                             <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the magic variable FOUND to false
     */</comment>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the instrumentation plugin peek at this function
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now call the toplevel block of statements
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>action</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_block</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_FUNCTION_EXECUTED_NO_RETURN_STATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"control reached end of trigger procedure without RETURN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger procedure cannot return a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the returned tuple structure has the same attributes, the
     * relation that fired the trigger has. A per-statement trigger always
     * needs to return NULL, so we ignore any return value the function itself
     * produces (XXX: is this a good idea?)
     *
     * XXX This way it is possible, that the trigger returns a tuple where
     * attributes don't have the correct atttypmod's length. It's up to the
     * trigger's programmer to ensure that this doesn't happen. Jan
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retisnull</name></name> <operator>||</operator> <operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rettup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rettup</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* check rowtype compatibility */</comment>
        <expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>rettupdesc</name></name></expr></argument>,
                                            <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
                                            <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned row structure does not match the structure of the triggering table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* it might need conversion */</comment>
        <if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* no need to free map, we're about to return anyway */</comment>

        <comment type="block">/* Copy tuple to upper executor memory */</comment>
        <expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>SPI_copytuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Let the instrumentation plugin peek at this function
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Clean up any leftover temporary memory */</comment>
    <expr_stmt><expr><call><name>plpgsql_destroy_econtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* stmt_mcontext will be destroyed when function's main context is */</comment>

    <comment type="block">/*
     * Pop the error context stack
     */</comment>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Return the trigger's result
     */</comment>
    <return>return <expr><name>rettup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_exec_event_trigger        Called by the call handler for
 *                event trigger execution.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_exec_event_trigger</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PLpgSQL_execstate</name></type> <name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Setup the execution state
     */</comment>
    <expr_stmt><expr><call><name>plpgsql_estate_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup error traceback support for ereport()
     */</comment>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Make local execution copies of all the datums
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during initialization of execution state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>.</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>copy_plpgsql_datum</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Assign the special tg_ variables
     */</comment>
    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_event_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>tg_tag_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the instrumentation plugin peek at this function
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now call the toplevel block of statements
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>action</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_block</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_FUNCTION_EXECUTED_NO_RETURN_STATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"control reached end of trigger procedure without RETURN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the instrumentation plugin peek at this function
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Clean up any leftover temporary memory */</comment>
    <expr_stmt><expr><call><name>plpgsql_destroy_econtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* stmt_mcontext will be destroyed when function's main context is */</comment>

    <comment type="block">/*
     * Pop the error context stack
     */</comment>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * error context callback to let us supply a call-stack traceback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We don't expend the cycles to run gettext() on err_text unless we
         * actually need it.  Therefore, places that set up err_text should
         * use gettext_noop() to ensure the strings get recorded in the
         * message dictionary.
         *
         * If both err_text and err_stmt are set, use the err_text as
         * description, but report the err_stmt's line number.  When err_stmt
         * is not set, we're in function entry/exit, or some such place not
         * attached to a specific line number.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * translator: last %s is a phrase such as "during statement block
             * local variable initialization"
             */</comment>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s line %d %s"</literal></expr></argument>,
                       <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>,
                       <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>,
                       <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * translator: last %s is a phrase such as "while storing call
             * arguments into local variables"
             */</comment>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s %s"</literal></expr></argument>,
                       <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>,
                       <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* translator: last %s is a plpgsql statement type name */</comment>
        <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s line %d at %s"</literal></expr></argument>,
                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>,
                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>,
                   <argument><expr><call><name>plpgsql_stmt_typename</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s"</literal></expr></argument>,
                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * Support function for initializing local execution variables
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>PLpgSQL_datum</name> <modifier>*</modifier></type>
<name>copy_plpgsql_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* should be preset to null/non-freeable */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>new</name><operator>-&gt;</operator><name>freeval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>new</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* should be preset to null/non-freeable */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>tup</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>new</name><operator>-&gt;</operator><name>freetup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>new</name><operator>-&gt;</operator><name>freetupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>new</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
        <case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
        <case>case <expr><name>PLPGSQL_DTYPE_ARRAYELEM</name></expr>:</case>

            <comment type="block">/*
             * These datum records are read-only at runtime, so no need to
             * copy them (well, ARRAYELEM contains some cached type data, but
             * we'd just as soon centralize the caching anyway)
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a memory context for statement-lifespan variables, if we don't
 * have one already.  It will be a child of stmt_mcontext_parent, which is
 * either the function's main context or a pushed-down outer stmt_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>get_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator>
            <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name></expr></argument>,
                                  <argument><expr><literal type="string">"PLpgSQL per-statement data"</literal></expr></argument>,
                                  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Push down the current stmt_mcontext so that called statements won't use it.
 * This is needed by statements that have statement-lifespan data and need to
 * preserve it across some inner statements.  The caller should eventually do
 * pop_stmt_mcontext().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Should have done get_stmt_mcontext() first */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Assert we've not messed up the stack linkage */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Push it down to become the parent of any nested stmt mcontext */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr>;</expr_stmt>
    <comment type="block">/* And make it not available for use directly */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Undo push_stmt_mcontext().  We assume this is done just before or after
 * resetting the caller's stmt_mcontext; since that action will also delete
 * any child contexts, there's no need to explicitly delete whatever context
 * might currently be estate-&gt;stmt_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pop_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* We need only pop the stack */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Subroutine for exec_stmt_block: does any condition in the condition list
 * match the current exception?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exception_matches_conditions</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_condition</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>cond</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cond</name> <operator>=</operator> <name><name>cond</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>sqlerrstate</name> <init>= <expr><name><name>cond</name><operator>-&gt;</operator><name>sqlerrstate</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * OTHERS matches everything *except* query-canceled and
         * assert-failure.  If you're foolish enough, you can match those
         * explicitly.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>sqlerrstate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>!=</operator> <name>ERRCODE_QUERY_CANCELED</name> <operator>&amp;&amp;</operator>
                <name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>!=</operator> <name>ERRCODE_ASSERT_FAILURE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Exact match? */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>sqlerrstate</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if>
        <comment type="block">/* Category match? */</comment>
        <if type="elseif">else if <condition>(<expr><call><name>ERRCODE_IS_CATEGORY</name><argument_list>(<argument><expr><name>sqlerrstate</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <call><name>ERRCODE_TO_CATEGORY</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>sqlerrstate</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_block            Execute a block of statements
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_block</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_block</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>

    <comment type="block">/*
     * First initialize all variables declared in this block
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during statement block local variable initialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>block</name><operator>-&gt;</operator><name>n_initvars</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>initvarnos</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Free any old value, in case re-entering block, and
                     * initialize to NULL
                     */</comment>
                    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>default_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * If needed, give the datatype a chance to reject
                         * NULLs, by assigning a NULL to the variable. We
                         * claim the value is of type UNKNOWN, not the var's
                         * datatype, else coercion will be skipped. (Do this
                         * before the notnull check to be consistent with
                         * exec_assign_value.)
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                                              <argument><expr><name>true</name></expr></argument>,
                                              <argument><expr><name>UNKNOWNOID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable \"%s\" declared NOT NULL cannot default to NULL"</literal></expr></argument>,
                                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>exec_assign_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                                         <argument><expr><name><name>var</name><operator>-&gt;</operator><name>default_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>freetup</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>freetup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>freetupdesc</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>freetupdesc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
            <case>case <expr><name>PLPGSQL_DTYPE_ARRAYELEM</name></expr>:</case>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>,
                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>exceptions</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Execute the statements in the block's body inside a sub-transaction
         */</comment>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>old_eval_econtext</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>save_cur_error</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during statement block entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We will need a stmt_mcontext to hold the error data if an error
         * occurs.  It seems best to force it to exist before entering the
         * subtransaction, so that we reduce the risk of out-of-memory during
         * error recovery, and because this greatly simplifies restoring the
         * stmt_mcontext stack to the correct state after an error.  We can
         * ameliorate the cost of this by allowing the called statements to
         * use this mcontext too; so we don't push it down here.
         */</comment>
        <expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetEnterPlpgsqlFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Want to run statements inside function's memory context */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>handle_exceptions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <comment type="block">/*
             * We need to run the block's statements with a new eval_econtext
             * that belongs to the current subtransaction; if we try to use
             * the outer econtext then ExprContext shutdown callbacks will be
             * called at the wrong times.
             */</comment>
            <expr_stmt><expr><call><name>plpgsql_create_econtext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <comment type="block">/* Run the block's statements */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during statement block exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the block ended with RETURN, we may need to copy the return
             * value out of the subtransaction eval_context.  This is
             * currently only needed for scalar result types --- rowtype
             * values will always exist in the function's main memory context,
             * cf. exec_stmt_return().  We can avoid a physical copy if the
             * value happens to be a R/W expanded object.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_RETURN</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name> <operator>&amp;&amp;</operator>
                <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>&amp;&amp;</operator>
                <name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int16</name></type>        <name>resTypLen</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>resTypByVal</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resTypLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>datumTransfer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>,
                                               <argument><expr><name>resTypByVal</name></expr></argument>, <argument><expr><name>resTypLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
            <expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

            <comment type="block">/* Assert that the stmt_mcontext stack is unchanged */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt_mcontext</name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Revert to outer eval_econtext.  (The inner one was
             * automatically cleaned up during subxact exit.)
             */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>old_eval_econtext</name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during exception cleanup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Save error info in our stmt_mcontext */</comment>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Mark handling exceptions */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>handle_exceptions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/* Abort the inner transaction */</comment>
            <expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Set up the stmt_mcontext stack as though we had restored our
             * previous state and then done push_stmt_mcontext().  The push is
             * needed so that statements in the exception handler won't
             * clobber the error data that's in our stmt_mcontext.
             */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <name>stmt_mcontext</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Now we can delete any nested stmt_mcontexts that might have
             * been created as children of ours.  (Note: we do not immediately
             * release any statement-lifespan data that might have been left
             * behind in stmt_mcontext itself.  We could attempt that by doing
             * a MemoryContextReset on it before collecting the error data
             * above, but it seems too risky to do any significant amount of
             * work before collecting the error.)
             */</comment>
            <expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Revert to outer eval_econtext */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>old_eval_econtext</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Must clean up the econtext too.  However, any tuple table made
             * in the subxact will have been thrown away by SPI during subxact
             * abort, so we don't need to (and mustn't try to) free the
             * eval_tuptable.
             */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Look for a matching exception handler */</comment>
            <macro><name>foreach</name><argument_list>(<argument>e</argument>, <argument>block-&gt;exceptions-&gt;exc_list</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_exception</name> <modifier>*</modifier></type><name>exception</name> <init>= <expr><operator>(</operator><name>PLpgSQL_exception</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>exception_matches_conditions</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><name><name>exception</name><operator>-&gt;</operator><name>conditions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Initialize the magic SQLSTATE and SQLERRM variables for
                     * the exception block; this also frees values from any
                     * prior use of the same exception. We needn't do this
                     * until we have found a matching exception.
                     */</comment>
                    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>state_var</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>errm_var</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>state_var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator>
                        <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>block</name><operator>-&gt;</operator><name>exceptions</name><operator>-&gt;</operator><name>sqlstate_varno</name></name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>errm_var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator>
                        <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>block</name><operator>-&gt;</operator><name>exceptions</name><operator>-&gt;</operator><name>sqlerrm_varno</name></name></expr>]</index></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>state_var</name></expr></argument>,
                                    <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>errm_var</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Also set up cur_error so the error data is accessible
                     * inside the handler.
                     */</comment>
                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>=</operator> <name>edata</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>exception</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>handle_exceptions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <comment type="block">/*
             * Restore previous state of cur_error, whether or not we executed
             * a handler.  This is needed in case an error got thrown from
             * some inner block's exception handler.
             */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>=</operator> <name>save_cur_error</name></expr>;</expr_stmt>

            <comment type="block">/* If no match found, re-throw the error */</comment>
            <if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>SetExitPlpgsqlFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
			 <else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Restore stmt_mcontext stack and release the error data */</comment>
            <expr_stmt><expr><call><name>pop_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetExitPlpgsqlFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>save_cur_error</name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Just execute the statements in the block's body
         */</comment>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Handle the return code.
     */</comment>
    <switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLPGSQL_RC_OK</name></expr>:</case>
        <case>case <expr><name>PLPGSQL_RC_RETURN</name></expr>:</case>
        <case>case <expr><name>PLPGSQL_RC_CONTINUE</name></expr>:</case>
            <return>return <expr><name>rc</name></expr>;</return>

        <case>case <expr><name>PLPGSQL_RC_EXIT</name></expr>:</case>

            <comment type="block">/*
             * This is intentionally different from the handling of RC_EXIT
             * for loops: to match a block, we require a match by label.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized rc: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmts            Iterate over a list of statements
 *                as long as their return code is OK
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmts</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>stmts</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Ensure we do a CHECK_FOR_INTERRUPTS() even though there is no
         * statement.  This prevents hangup in a tight loop if, for instance,
         * there is a LOOP construct with an empty body.
         */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>s</argument>, <argument>stmts</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>rc</name> <init>= <expr><call><name>exec_stmt</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt            Distribute one statement to the statements
 *                type specific execution function.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>save_estmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>save_estmt</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

    <comment type="block">/* Let the plugin know that we are about to execute this statement */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_beg</name></name><operator>)</operator> <operator>(</operator><name>estate</name><operator>,</operator> <name>stmt</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>cmd_type</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLPGSQL_STMT_BLOCK</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_block</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_block</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_ASSIGN</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_assign</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_assign</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_PERFORM</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_perform</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_perform</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_GETDIAG</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_getdiag</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_getdiag</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_IF</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_if</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_if</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_CASE</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_case</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_case</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_LOOP</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_loop</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_loop</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_WHILE</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_while</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_while</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_FORI</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_fori</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_fori</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_FORS</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_fors</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_fors</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_FORC</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_forc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forc</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_FOREACH_A</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_foreach_a</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_foreach_a</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_EXIT</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_exit</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_exit</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_RETURN</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_return</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_return</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_RETURN_NEXT</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_return_next</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_return_next</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_RETURN_QUERY</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_return_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_return_query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_RAISE</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_raise</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_raise</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_ASSERT</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_assert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_assert</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_EXECSQL</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_execsql</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_execsql</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_DYNEXECUTE</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_dynexecute</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_dynexecute</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_DYNFORS</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_dynfors</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_dynfors</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_OPEN</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_open</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_open</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_FETCH</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_fetch</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_fetch</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PLPGSQL_STMT_CLOSE</name></expr>:</case>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_close</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_close</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>save_estmt</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized cmdtype: %d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmd_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* Let the plugin know that we have finished executing this statement */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_end</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_end</name></name><operator>)</operator> <operator>(</operator><name>estate</name><operator>,</operator> <name>stmt</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>save_estmt</name></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_assign            Evaluate an expression and
 *                    put the result into a variable.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_assign</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_assign</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>exec_assign_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_perform        Evaluate query and discard result (but set
 *                            FOUND depending on whether at least one row
 *                            was returned).
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_perform</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_perform</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_getdiag                    Put internal PG information into
 *                                        specified variables.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_getdiag</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_getdiag</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * GET STACKED DIAGNOSTICS is only valid inside an exception handler.
     *
     * Note: we trust the grammar to have disallowed the relevant item kinds
     * if not is_stacked, otherwise we'd dump core below.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_stacked</name></name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GET STACKED DIAGNOSTICS cannot be used outside an exception handler"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;diag_items</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_diag_item</name> <modifier>*</modifier></type><name>diag_item</name> <init>= <expr><operator>(</operator><name>PLpgSQL_diag_item</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>diag_item</name><operator>-&gt;</operator><name>target</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>diag_item</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_GETDIAG_ROW_COUNT</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                  <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_RESULT_OID</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_lastoid</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_ERROR_CONTEXT</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_ERROR_DETAIL</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_ERROR_HINT</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_RETURNED_SQLSTATE</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_COLUMN_NAME</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_CONSTRAINT_NAME</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_DATATYPE_NAME</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_MESSAGE_TEXT</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_TABLE_NAME</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_SCHEMA_NAME</name></expr>:</case>
                <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_GETDIAG_CONTEXT</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>contextstackstr</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

                    <comment type="block">/* Use eval_mcontext for short-lived string */</comment>
                    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>contextstackstr</name> <operator>=</operator> <call><name>GetErrorContextStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>contextstackstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized diagnostic item kind: %d"</literal></expr></argument>,
                     <argument><expr><name><name>diag_item</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block>

    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_if                Evaluate a bool expression and
 *                    execute the true or false body
 *                    conditionally.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_if</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_if</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>then_body</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;elsif_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_if_elsif</name> <modifier>*</modifier></type><name>elif</name> <init>= <expr><operator>(</operator><name>PLpgSQL_if_elsif</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>elif</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>elif</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>else_body</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-----------
 * exec_stmt_case
 *-----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_case</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_case</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>t_var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>t_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* simple case */</comment>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>t_val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>t_typoid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>t_typmod</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>t_val</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>t_expr</name></name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_typoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>t_var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>t_varno</name></name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/*
         * When expected datatype is different from real, change it. Note that
         * what we're modifying here is an execution copy of the datum, so
         * this doesn't affect the originally stored function parse tree. (In
         * theory, if the expression datatype keeps changing during execution,
         * this could cause a function-lifespan memory leak.  Doesn't seem
         * worth worrying about though.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>t_var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name> <operator>!=</operator> <name>t_typoid</name> <operator>||</operator>
            <name><name>t_var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name>t_typmod</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>t_var</name><operator>-&gt;</operator><name>datatype</name></name> <operator>=</operator> <call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>t_typoid</name></expr></argument>,
                                                     <argument><expr><name>t_typmod</name></expr></argument>,
                                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* now we can assign to the variable */</comment>
        <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                          <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>t_var</name></expr></argument>,
                          <argument><expr><name>t_val</name></expr></argument>,
                          <argument><expr><name>isnull</name></expr></argument>,
                          <argument><expr><name>t_typoid</name></expr></argument>,
                          <argument><expr><name>t_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now search for a successful WHEN clause */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;case_when_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_case_when</name> <modifier>*</modifier></type><name>cwt</name> <init>= <expr><operator>(</operator><name>PLpgSQL_case_when</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>value</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>cwt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Found it */</comment>

            <comment type="block">/* We can now discard any value we had for the temp variable */</comment>
            <if_stmt><if>if <condition>(<expr><name>t_var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>t_var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Evaluate the statement(s), and we're done */</comment>
            <return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>cwt</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* We can now discard any value we had for the temp variable */</comment>
    <if_stmt><if>if <condition>(<expr><name>t_var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>t_var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* SQL2003 mandates this error if there was no ELSE clause */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>have_else</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CASE_NOT_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"case not found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"CASE statement is missing ELSE part."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Evaluate the ELSE statements, and we're done */</comment>
    <return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>else_stmts</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_loop            Loop over statements until
 *                    an exit occurs.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_loop</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_loop</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>rc</name> <init>= <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_RC_OK</name></expr>:</case>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_RC_EXIT</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>

            <case>case <expr><name>PLPGSQL_RC_CONTINUE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <comment type="block">/* anonymous continue, so re-run the loop */</comment>
                    <break>break;</break></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                         <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <comment type="block">/* label matches named continue, so re-run loop */</comment>
                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <comment type="block">/* label doesn't match named continue, so propagate upward */</comment>
                    <return>return <expr><name>PLPGSQL_RC_CONTINUE</name></expr>;</return></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_RC_RETURN</name></expr>:</case>
                <return>return <expr><name>rc</name></expr>;</return>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized rc: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_while            Loop over statements as long
 *                    as an expression evaluates to
 *                    true or an exit occurs.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_while</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_while</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_RC_OK</name></expr>:</case>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_RC_EXIT</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>

            <case>case <expr><name>PLPGSQL_RC_CONTINUE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <comment type="block">/* anonymous continue, so re-run loop */</comment>
                    <break>break;</break></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                         <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <comment type="block">/* label matches named continue, so re-run loop */</comment>
                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <comment type="block">/* label doesn't match named continue, propagate upward */</comment>
                    <return>return <expr><name>PLPGSQL_RC_CONTINUE</name></expr>;</return></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_RC_RETURN</name></expr>:</case>
                <return>return <expr><name>rc</name></expr>;</return>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized rc: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_fori            Iterate an integer variable
 *                    from a lower to an upper value
 *                    incrementing or decrementing by the BY value
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_fori</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_fori</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>valtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>valtypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>loop_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>end_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>step_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the value of the lower bound
     */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
                            <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lower bound of FOR loop cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>loop_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the value of the upper bound
     */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
                            <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"upper bound of FOR loop cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>end_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the step value
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>step</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>step</name></name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
                                <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
                                <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
                                <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BY value of FOR loop cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>step_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>step_value</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BY value of FOR loop must be greater than zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>step_value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Now do the loop
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Check against upper bound
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>loop_value</name> <operator>&lt;</operator> <name>end_value</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>loop_value</name> <operator>&gt;</operator> <name>end_value</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>            <comment type="block">/* looped at least once */</comment>

        <comment type="block">/*
         * Assign current value to loop var
         */</comment>
        <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>loop_value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Execute the statements
         */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if>                <comment type="block">/* break out of the loop */</comment>
        <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_EXIT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* unlabelled exit, finish the current loop */</comment>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                     <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* labelled exit, matches the current stmt's label */</comment>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * otherwise, this is a labelled exit that does not match the
             * current statement's label, if any: return RC_EXIT so that the
             * EXIT continues to propagate up the stack.
             */</comment>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_CONTINUE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* unlabelled continue, so re-run the current loop */</comment>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                     <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* label matches named continue, so re-run loop */</comment>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * otherwise, this is a named continue that does not match the
                 * current statement's label, if any: return RC_CONTINUE so
                 * that the CONTINUE will propagate up the stack.
                 */</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Increase/decrease loop value, unless it would overflow, in which
         * case exit the loop.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>loop_value</name> <operator>-</operator> <name>step_value</name><operator>)</operator> <operator>&gt;</operator> <name>loop_value</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>loop_value</name> <operator>-=</operator> <name>step_value</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>loop_value</name> <operator>+</operator> <name>step_value</name><operator>)</operator> <operator>&lt;</operator> <name>loop_value</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>loop_value</name> <operator>+=</operator> <name>step_value</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Set the FOUND variable to indicate the result of executing the loop
     * (namely, whether we looped one or more times). This must be set here so
     * that it does not interfere with the value of the FOUND variable inside
     * the loop processing itself.
     */</comment>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_fors            Execute a query, assign each
 *                    tuple to a record or row and
 *                    execute a group of statements
 *                    for it.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_fors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_fors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Open the implicit cursor for the statement using exec_run_select
     */</comment>
    <expr_stmt><expr><call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Execute the loop
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_for_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forq</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Close the implicit cursor
     */</comment>
    <expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_forc            Execute a loop for each row from a cursor.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_forc</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_forc</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/* ----------
     * Get the cursor variable and if it has an assigned name, check
     * that it's not in use currently.
     * ----------
     */</comment>
    <expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <comment type="block">/* We only need stmt_mcontext to hold the cursor name string */</comment>
        <expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" already in use"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ----------
     * Open the cursor just like an OPEN command
     *
     * Note: parser should already have checked that statement supplies
     * args iff cursor needs them, but we check again to be safe.
     * ----------
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* ----------
         * OPEN CURSOR with args.  We fake a SELECT ... INTO ...
         * statement to evaluate the args and put 'em into the
         * internal row.
         * ----------
         */</comment>
        <decl_stmt><decl><type><name>PLpgSQL_stmt_execsql</name></type> <name>set_args</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments given for cursor without arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>set_args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>cmd_type</name></name> <operator>=</operator> <name>PLPGSQL_STMT_EXECSQL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>sqlstmt</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* XXX historically this has not been STRICT */</comment>
        <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>row</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator>
            <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>exec_stmt_execsql</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PLPGSQL_RC_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"open cursor failed during argument processing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments required for cursor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_expr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set up short-lived ParamListInfo
     */</comment>
    <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_unshared_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the cursor (the paramlist will get copied into the portal)
     */</comment>
    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_paramlist</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
                                            <argument><expr><name>paramLI</name></expr></argument>,
                                            <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open cursor: %s"</literal></expr></argument>,
             <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If cursor variable was NULL, store the generated portal name in it
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Clean up before entering exec_for_query
     */</comment>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>stmt_mcontext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Execute the loop.  We can't prefetch because the cursor is accessible
     * to the user, for instance via UPDATE WHERE CURRENT OF within the loop.
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_for_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forq</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ----------
     * Close portal, and restore cursor variable if it was initially NULL.
     * ----------
     */</comment>
    <expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_foreach_a            Loop over elements or slices of an array
 *
 * When looping over elements, the loop variable is the same type that the
 * array stores (eg: integer), when looping through slices, the loop variable
 * is an array of size and dimensions to match the size of the slice.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_foreach_a</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_foreach_a</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>arrtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>arrtypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>loop_var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>loop_var_elem_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayIterator</name></type> <name>array_iterator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>iterator_result_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>iterator_result_typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

    <comment type="block">/* get the value of the array expression */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH expression must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Do as much as possible of the code below in stmt_mcontext, to avoid any
     * leaks from called subroutines.  We need a private stmt_mcontext since
     * we'll be calling arbitrary statement code.
     */</comment>
    <expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>push_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check the type of the expression - must be an array */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>arrtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH expression must yield an array, not type %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>arrtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We must copy the array into stmt_mcontext, else it will disappear in
     * exec_eval_cleanup.  This is annoying, but cleanup will certainly happen
     * while running the loop body, so we have little choice.
     */</comment>
    <expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up any leftover temporary memory */</comment>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Slice dimension must be less than or equal to array dimension */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slice dimension (%d) is out of the valid range 0..%d"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name></expr></argument>, <argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Set up the loop variable and see if it is of an array type */</comment>
    <expr_stmt><expr><name>loop_var</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>loop_var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name> <operator>||</operator>
        <name><name>loop_var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_ROW</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Record/row variable is certainly not of array type, and might not
         * be initialized at all yet, so don't try to get its type
         */</comment>
        <expr_stmt><expr><name>loop_var_elem_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>loop_var_elem_type</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><call><name>plpgsql_exec_get_datum_type</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                                                          <argument><expr><name>loop_var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Sanity-check the loop variable type.  We don't try very hard here, and
     * should not be too picky since it's possible that exec_assign_value can
     * coerce values of different types.  But it seems worthwhile to complain
     * if the array-ness of the loop variable is not right.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>loop_var_elem_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH ... SLICE loop variable must be of an array type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>loop_var_elem_type</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH loop variable must not be of an array type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Create an iterator to step through the array */</comment>
    <expr_stmt><expr><name>array_iterator</name> <operator>=</operator> <call><name>array_create_iterator</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Identify iterator result type */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* When slicing, nominal type of result is same as array type */</comment>
        <expr_stmt><expr><name>iterator_result_type</name> <operator>=</operator> <name>arrtype</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iterator_result_typmod</name> <operator>=</operator> <name>arrtypmod</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Without slicing, results are individual array elements */</comment>
        <expr_stmt><expr><name>iterator_result_type</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iterator_result_typmod</name> <operator>=</operator> <name>arrtypmod</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Iterate over the array elements or slices */</comment>
    <while>while <condition>(<expr><call><name>array_iterate</name><argument_list>(<argument><expr><name>array_iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>            <comment type="block">/* looped at least once */</comment>

        <comment type="block">/* exec_assign_value and exec_stmts must run in the main context */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Assign current element/slice to the loop variable */</comment>
        <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>loop_var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
                          <argument><expr><name>iterator_result_type</name></expr></argument>, <argument><expr><name>iterator_result_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* In slice case, value is temporary; must free it to avoid leakage */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Execute the statements
         */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Handle the return code */</comment>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if>                <comment type="block">/* break out of the loop */</comment>
        <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_EXIT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* unlabelled exit, finish the current loop */</comment>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                     <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* labelled exit, matches the current stmt's label */</comment>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * otherwise, this is a labelled exit that does not match the
             * current statement's label, if any: return RC_EXIT so that the
             * EXIT continues to propagate up the stack.
             */</comment>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_CONTINUE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* unlabelled continue, so re-run the current loop */</comment>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                     <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* label matches named continue, so re-run loop */</comment>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * otherwise, this is a named continue that does not match the
                 * current statement's label, if any: return RC_CONTINUE so
                 * that the CONTINUE will propagate up the stack.
                 */</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Restore memory context state */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pop_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release temporary memory, including the array value */</comment>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the FOUND variable to indicate the result of executing the loop
     * (namely, whether we looped one or more times). This must be set here so
     * that it does not interfere with the value of the FOUND variable inside
     * the loop processing itself.
     */</comment>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_exit            Implements EXIT and CONTINUE
 *
 * This begins the process of exiting / restarting a loop.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_exit</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_exit</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If the exit / continue has a condition, evaluate it
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <name>value</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_exit</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>PLPGSQL_RC_CONTINUE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_return            Evaluate an expression and start
 *                    returning from the function.
 *
 * Note: in the retistuple code paths, the returned tuple is always in the
 * function's main context, whereas for non-tuple data types the result may
 * be in the eval_mcontext.  The former case is not a memory leak since we're
 * about to exit the function anyway.  (If you want to change it, note that
 * exec_stmt_block() knows about this behavior.)  The latter case means that
 * we must not do exec_eval_cleanup while unwinding the control stack.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_return</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_return</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * If processing a set-returning PL/pgSQL function, the final RETURN
     * indicates that the function is finished producing tuples.  The rest of
     * the work will be done at the top level.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* initialize for null result (possibly a tuple) */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Special case path when the RETURN expression is a simple variable
     * reference; in particular, this path is always taken in functions with
     * one or more OUT parameters.
     *
     * This special case is especially efficient for returning variables that
     * have R/W expanded values: we can put the R/W pointer directly into
     * estate-&gt;retval, leading to transferring the value to the caller's
     * context cheaply.  If we went through exec_eval_expr we'd end up with a
     * R/O pointer.  It's okay to skip MakeExpandedObjectReadOnly here since
     * we know we won't need the variable's value within the function anymore.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>retvar</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Cope with retistuple case.  A PLpgSQL_var could not be
                     * of composite type, so we needn't make any effort to
                     * convert.  However, for consistency with the expression
                     * code path, don't throw error if the result is NULL.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot return non-composite value from function returning composite type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>        <name>rettypmod</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                            <argument><expr><name>retvar</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>rettypmod</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>        <name>rettypmod</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row variable has no tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>make_tuple_from_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row not compatible with its own tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                        <argument><expr><name>retvar</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>rettypmod</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>        <name>rettypmod</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name><operator>)</operator></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name><operator>)</operator></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>rettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Convert composite datum to a HeapTuple and TupleDesc */</comment>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>

            <comment type="block">/* Source must be of RECORD or composite type */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot return non-composite value from function returning composite type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>get_tuple_from_datum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>get_tupdesc_from_datum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Special hack for function returning VOID: instead of NULL, return a
     * non-null VOID value.  This is of dubious importance but is kept for
     * backwards compatibility.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>==</operator> <name>VOIDOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_return_next        Evaluate an expression and add it to the
 *                                list of tuples returned by the current
 *                                SRF.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_return_next</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                      <parameter><decl><type><name>PLpgSQL_stmt_return_next</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use RETURN NEXT in a non-SETOF function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exec_init_tuple_store</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* rettupdesc will be filled by exec_init_tuple_store */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Special case path when the RETURN NEXT expression is a simple variable
     * reference; in particular, this path is always taken in functions with
     * one or more OUT parameters.
     *
     * Unlike exec_statement_return, there's no special win here for R/W
     * expanded values, since they'll have to get flattened to go into the
     * tuplestore.  Indeed, we'd better make them R/O to avoid any risk of the
     * casting step changing them in-place.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>retvar</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Datum</name></type>        <name>retval</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>natts</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong result type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* let's be very paranoid about the cast step */</comment>
                    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
                                                        <argument><expr><name>isNull</name></expr></argument>,
                                                        <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* coerce type if needed */</comment>
                    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                             <argument><expr><name>retval</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
                                             <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
                                             <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
                                             <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                             <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>retval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                        <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned"</literal>
                                           <literal type="string">" record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
                    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
                                                        <argument><expr><name>tupdesc</name></expr></argument>,
                                                        <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"wrong record type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
                    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>make_tuple_from_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong record type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>retval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>rettype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>rettypmod</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>rettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Expression should be of RECORD or composite type */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>retvaldesc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot return non-composite value from function returning composite type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
                <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>get_tuple_from_datum</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>retvaldesc</name> <operator>=</operator> <call><name>get_tupdesc_from_datum</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name>retvaldesc</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
                                                    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned record type does not match expected record type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>retvaldesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Composite NULL --- store a row of nulls */</comment>
                <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>nulldatums</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullflags</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>nulldatums</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
                    <call><name>eval_mcontext_alloc0</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nullflags</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
                    <call><name>eval_mcontext_alloc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nullflags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
                                     <argument><expr><name>nulldatums</name></expr></argument>, <argument><expr><name>nullflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Simple scalar result */</comment>
            <if_stmt><if>if <condition>(<expr><name>natts</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong result type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* coerce type if needed */</comment>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                     <argument><expr><name>retval</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
                                     <argument><expr><name>rettype</name></expr></argument>,
                                     <argument><expr><name>rettypmod</name></expr></argument>,
                                     <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                     <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>retval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURN NEXT must have a parameter"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_return_query        Evaluate a query and add it to the
 *                                list of tuples returned by the current
 *                                SRF.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_return_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                       <parameter><decl><type><name>PLpgSQL_stmt_return_query</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use RETURN QUERY in a non-SETOF function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exec_init_tuple_store</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* static query */</comment>
        <expr_stmt><expr><call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* RETURN QUERY EXECUTE */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>exec_dynquery_with_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name></expr></argument>,
                                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
                                        <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name></expr></argument>,
                                        <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"structure of query does not match function result type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64</name></type>        <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* SPI will have changed CurrentMemoryContext */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>processed</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>processed</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_init_tuple_store</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>rsi</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check caller can handle a set result in the way we want
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Switch to the right memory context and resource owner for storing the
     * tuplestore for return set. If we're within a subtransaction opened for
     * an exception-block, for example, we must still create the tuplestore in
     * the resource owner that was active when this function was entered, and
     * not in the subtransaction resource owner.
     */</comment>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>tuple_store_owner</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator>
        <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_RAISE_OPTION_TEXT</name><parameter_list>(<parameter><type><name>opt</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    if (opt) \
        ereport(ERROR, \
                (errcode(ERRCODE_SYNTAX_ERROR), \
                 errmsg("RAISE option already specified: %s", \
                        name))); \
    opt = MemoryContextStrdup(stmt_mcontext, extval); \
} while (0)</cpp:value></cpp:define>

<comment type="block">/* ----------
 * exec_stmt_raise            Build a message and throw it with elog()
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_raise</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_raise</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>err_code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>condname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_detail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_datatype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_schema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* RAISE with no parameters: re-throw current exception */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>message</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* oops, we're not inside a handler */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RAISE without parameters cannot be used outside an exception handler"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We'll need to accumulate the various strings in stmt_mcontext */</comment>
    <expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>err_code</name> <operator>=</operator> <call><name>plpgsql_recognize_err_condition</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>condname</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>ds</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>current_param</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <comment type="block">/* build string in stmt_mcontext */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>current_param</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>message</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/*
             * Occurrences of a single % are replaced by the next parameter's
             * external representation. Double %'s are converted to one %.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>paramtypeid</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>        <name>paramtypmod</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>        <name>paramvalue</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>paramisnull</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* should have been checked at compile time */</comment>
                <if_stmt><if>if <condition>(<expr><name>current_param</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RAISE parameter list length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>paramvalue</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                            <argument><expr><operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>paramisnull</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>paramtypeid</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>paramtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>paramisnull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>extval</name> <operator>=</operator> <literal type="string">"&lt;NULL&gt;"</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                                     <argument><expr><name>paramvalue</name></expr></argument>,
                                                     <argument><expr><name>paramtypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>current_param</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><name><name>cp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* should have been checked at compile time */</comment>
        <if_stmt><if>if <condition>(<expr><name>current_param</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RAISE parameter list length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>err_message</name> <operator>=</operator> <name><name>ds</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_raise_option</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>PLpgSQL_raise_option</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>optionvalue</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>optionisnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>optiontypeid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>optiontypmod</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>optionvalue</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>optionisnull</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>optiontypeid</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>optiontypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>optionisnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RAISE statement option cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>optionvalue</name></expr></argument>, <argument><expr><name>optiontypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>opt_type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_ERRCODE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>err_code</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RAISE option already specified: %s"</literal></expr></argument>,
                                    <argument><expr><literal type="string">"ERRCODE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>err_code</name> <operator>=</operator> <call><name>plpgsql_recognize_err_condition</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>condname</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_MESSAGE</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_message</name></expr></argument>, <argument><expr><literal type="string">"MESSAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_DETAIL</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_detail</name></expr></argument>, <argument><expr><literal type="string">"DETAIL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_HINT</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_hint</name></expr></argument>, <argument><expr><literal type="string">"HINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_COLUMN</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_column</name></expr></argument>, <argument><expr><literal type="string">"COLUMN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_CONSTRAINT</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_constraint</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_DATATYPE</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_datatype</name></expr></argument>, <argument><expr><literal type="string">"DATATYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_TABLE</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_table</name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PLPGSQL_RAISEOPTION_SCHEMA</name></expr>:</case>
                <expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_schema</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized raise option: %d"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>opt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Default code if nothing specified */</comment>
    <if_stmt><if>if <condition>(<expr><name>err_code</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>elog_level</name></name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>err_code</name> <operator>=</operator> <name>ERRCODE_RAISE_EXCEPTION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Default error message if nothing specified */</comment>
    <if_stmt><if>if <condition>(<expr><name>err_message</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>condname</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>err_message</name> <operator>=</operator> <name>condname</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>condname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>err_message</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>,
                                              <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Throw the error (may or may not come back)
     */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>elog_level</name></name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name>err_code</name></expr> ?</condition><then> <expr><call><name>errcode</name><argument_list>(<argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
             <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_message</name></expr></argument>)</argument_list></call><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name>err_detail</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_detail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name>err_hint</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_hint</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name>err_column</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
             <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_COLUMN_NAME</name></expr></argument>, <argument><expr><name>err_column</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name>err_constraint</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
             <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr></argument>, <argument><expr><name>err_constraint</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name>err_datatype</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
             <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_DATATYPE_NAME</name></expr></argument>, <argument><expr><name>err_datatype</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name>err_table</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
             <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_TABLE_NAME</name></expr></argument>, <argument><expr><name>err_table</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name>err_schema</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
             <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_SCHEMA_NAME</name></expr></argument>, <argument><expr><name>err_schema</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up transient strings */</comment>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_assert            Assert statement
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_assert</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_assert</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

    <comment type="block">/* do nothing when asserts are not enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plpgsql_check_asserts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <operator>!</operator><name>value</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>message</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>typeid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>message</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* we mustn't do exec_eval_cleanup here */</comment>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ASSERT_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr> </then><else>:
                 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"assertion failed"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Initialize a mostly empty execution state
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_estate_setup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                     <parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
                     <parameter><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl></parameter>,
                     <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>simple_eval_estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>ctl</name></decl>;</decl_stmt>

    <comment type="block">/* this link will be restored at exit from plpgsql_call_handler */</comment>
    <expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>cur_estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_rettype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_retistuple</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_readonly</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>handle_exceptions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rsi</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_owner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rsi</name></name> <operator>=</operator> <name>rsi</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>found_varno</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>found_varno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* caller is expected to fill the datums array */</comment>

    <comment type="block">/* initialize ParamListInfo with one entry per datum, all invalid */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>=</operator> <operator>(</operator><name>ParamListInfo</name><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
                <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>plpgsql_param_fetch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>plpgsql_parser_setup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled during use */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>paramMask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>params_dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* set up for use of appropriate simple-expression EState and cast hash */</comment>
    <if_stmt><if>if <condition>(<expr><name>simple_eval_estate</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>simple_eval_estate</name></expr>;</expr_stmt>
        <comment type="block">/* Private cast hash just lives in function's main context */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PLpgSQL private cast cache"</literal></expr></argument>,
                                        <argument><expr><literal type="number">16</literal></expr></argument>, <comment type="block">/* start small and extend */</comment>
                                        <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                                        <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash_context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>shared_simple_eval_estate</name></expr>;</expr_stmt>
        <comment type="block">/* Create the session-wide cast-info hash table if we didn't already */</comment>
        <if_stmt><if>if <condition>(<expr><name>shared_cast_hash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>shared_cast_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                        <argument><expr><literal type="string">"PLpgSQL cast info"</literal></expr></argument>,
                                                        <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>shared_cast_context</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>shared_cast_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PLpgSQL cast cache"</literal></expr></argument>,
                                           <argument><expr><literal type="number">16</literal></expr></argument>,    <comment type="block">/* start small and extend */</comment>
                                           <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                                           <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash</name></name> <operator>=</operator> <name>shared_cast_hash</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash_context</name></name> <operator>=</operator> <name>shared_cast_context</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We start with no stmt_mcontext; one will be created only if needed.
     * That context will be a direct child of the function's main execution
     * context.  Additional stmt_mcontexts might be created as children of it.
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_lastoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>plugin_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create an EState and ExprContext for evaluation of simple expressions.
     */</comment>
    <expr_stmt><expr><call><name>plpgsql_create_econtext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the plugin see this function before we initialize any local
     * PL/pgSQL variables - note that we also give the plugin a few function
     * pointers so it can call back into PL/pgSQL for doing things like
     * variable assignments and stack traces
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>error_callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>assign_expr</name></name> <operator>=</operator> <name>exec_assign_expr</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_setup</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_setup</name></name><operator>)</operator> <operator>(</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Release temporary memory used by expression/subselect evaluation
 *
 * NB: the result of the evaluation is no longer valid after this is done,
 * unless it is a pass-by-value datatype.
 *
 * NB: if you change this code, see also the hacks in exec_assign_value's
 * PLPGSQL_DTYPE_ARRAYELEM case for partial cleanup after subscript evals.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_eval_cleanup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Clear result of a full SPI_execute */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Clear result of exec_eval_simple_expr (but keep the econtext).  This
     * also clears any short-lived allocations done via get_eval_mcontext.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * Generate a prepared plan
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_prepare_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SPIPlanPtr</name></type>    <name>plan</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The grammar can't conveniently set expr-&gt;func while building the parse
     * tree, so make sure it's set before parser hooks need it.
     */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate and save the plan
     */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>SPI_prepare_params</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
                              <argument><expr><operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>plpgsql_parser_setup</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
                              <argument><expr><name>cursorOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Some SPI errors deserve specific error messages */</comment>
        <switch>switch <condition>(<expr><name>SPI_result</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>SPI_ERROR_COPY</name></expr>:</case>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot COPY to/from client in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <case>case <expr><name>SPI_ERROR_TRANSACTION</name></expr>:</case>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot begin/end transactions in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use a BEGIN block with an EXCEPTION clause instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare_params failed for \"%s\": %s"</literal></expr></argument>,
                     <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SPI_keepplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>

    <comment type="block">/* Check to see if it's a simple expression */</comment>
    <expr_stmt><expr><call><name>exec_simple_check_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark expression as not using a read-write param.  exec_assign_value has
     * to take steps to override this if appropriate; that seems cleaner than
     * adding parameters to all other callers.
     */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_execsql            Execute an SQL statement (possibly with INTO).
 *
 * Note: some callers rely on this not touching stmt_mcontext.  If it ever
 * needs to use that, fix those callers to push/pop stmt_mcontext.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_execsql</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_stmt_execsql</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>tcount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>sqlstmt</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * On the first call for this statement generate the plan, and detect
     * whether the statement is INSERT/UPDATE/DELETE
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>SPI_plan_get_plan_sources(expr-&gt;plan)</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>plansource-&gt;query_list</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
                        <name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
                        <name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <comment type="block">/* PGXCTODO: Support a better parameter interface for XC with DMLs */</comment>
                    <if_stmt><if>if
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
                       <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>enable_datanode_row_triggers</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
                         <name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
                         <name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name><operator>)</operator></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
                       )</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                         <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Postgres-XL does not support DML queries in PL/pgSQL on Datanodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Set up ParamListInfo to pass to executor
     */</comment>
    <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have INTO, then we only need one row back ... but if we have INTO
     * STRICT, ask for two rows, so that we can verify the statement returns
     * only one.  INSERT/UPDATE/DELETE are always treated strictly. Without
     * INTO, just run the statement to completion (tcount = 0).
     *
     * We could just ask for two rows always when using INTO, but there are
     * some cases where demanding the extra row costs significant time, eg by
     * forcing completion of a sequential scan.  So don't do it unless we need
     * to enforce strictness.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tcount</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>tcount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>tcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Execute the plan
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_execute_plan_with_paramlist</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>,
                                         <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for error, and set FOUND if appropriate (for historical reasons
     * we set FOUND only for certain query types).  Also Assert that we
     * identified the statement type the same as SPI did.
     */</comment>
    <switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>SPI_OK_SELECT</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_processed</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>SPI_OK_INSERT</name></expr>:</case>
        <case>case <expr><name>SPI_OK_UPDATE</name></expr>:</case>
        <case>case <expr><name>SPI_OK_DELETE</name></expr>:</case>
        <case>case <expr><name>SPI_OK_INSERT_RETURNING</name></expr>:</case>
        <case>case <expr><name>SPI_OK_UPDATE_RETURNING</name></expr>:</case>
        <case>case <expr><name>SPI_OK_DELETE_RETURNING</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_processed</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>SPI_OK_SELINTO</name></expr>:</case>
        <case>case <expr><name>SPI_OK_UTILITY</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>SPI_OK_REWRITTEN</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The command was rewritten into another kind of command. It's
             * not clear what FOUND would mean in that case (and SPI doesn't
             * return the row count either), so just set it to false.
             */</comment>
            <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/* Some SPI errors deserve specific error messages */</comment>
        <case>case <expr><name>SPI_ERROR_COPY</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot COPY to/from client in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <case>case <expr><name>SPI_ERROR_TRANSACTION</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot begin/end transactions in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use a BEGIN block with an EXCEPTION clause instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute_plan_with_paramlist failed executing query \"%s\": %s"</literal></expr></argument>,
                 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* All variants should save result info for GET DIAGNOSTICS */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_lastoid</name></name> <operator>=</operator> <name>SPI_lastoid</name></expr>;</expr_stmt>

    <comment type="block">/* Process INTO if present */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64</name></type>        <name>n</name> <init>= <expr><name>SPI_processed</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If the statement did not return a tuple table, complain */</comment>
        <if_stmt><if>if <condition>(<expr><name>tuptab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO used with a command that cannot return data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Determine if we assign to a record or a row */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * If SELECT ... INTO specified STRICT, and the query didn't find
         * exactly one row, throw an error.  If STRICT was not specified, then
         * allow the query to find any number of rows.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_expr_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned no rows"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* set the target to NULL(s) */</comment>
            <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_expr_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ROWS</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned more than one row"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Put the first result row into the target */</comment>
            <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Clean up */</comment>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* If the statement returned a tuple table, complain */</comment>
        <if_stmt><if>if <condition>(<expr><name>SPI_tuptable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query has no destination for result data"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <ternary><condition><expr><operator>(</operator><name>rc</name> <operator>==</operator> <name>SPI_OK_SELECT</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you want to discard the results of a SELECT, use PERFORM instead."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_dynexecute            Execute a dynamic SQL query
 *                    (possibly with INTO).
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_dynexecute</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                     <parameter><decl><type><name>PLpgSQL_stmt_dynexecute</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>restype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>restypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>querystr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>exec_res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * First we evaluate the string expression after the EXECUTE keyword. Its
     * result is the querystring we have to execute.
     */</comment>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query string argument of EXECUTE is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get the C-String representation */</comment>
    <expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy it into the stmt_mcontext before we clean up */</comment>
    <expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>querystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Execute the query without preparing a saved plan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ppd</name> <operator>=</operator> <call><name>exec_eval_using_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>exec_res</name> <operator>=</operator> <call><name>SPI_execute_with_args</name><argument_list>(<argument><expr><name>querystr</name></expr></argument>,
                                         <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,
                                         <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>,
                                         <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>exec_res</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>querystr</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <switch>switch <condition>(<expr><name>exec_res</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>SPI_OK_SELECT</name></expr>:</case>
        <case>case <expr><name>SPI_OK_INSERT</name></expr>:</case>
        <case>case <expr><name>SPI_OK_UPDATE</name></expr>:</case>
        <case>case <expr><name>SPI_OK_DELETE</name></expr>:</case>
        <case>case <expr><name>SPI_OK_INSERT_RETURNING</name></expr>:</case>
        <case>case <expr><name>SPI_OK_UPDATE_RETURNING</name></expr>:</case>
        <case>case <expr><name>SPI_OK_DELETE_RETURNING</name></expr>:</case>
        <case>case <expr><name>SPI_OK_UTILITY</name></expr>:</case>
        <case>case <expr><name>SPI_OK_REWRITTEN</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><literal type="number">0</literal></expr>:</case>

            <comment type="block">/*
             * Also allow a zero return, which implies the querystring
             * contained no commands.
             */</comment>
            <break>break;</break>

        <case>case <expr><name>SPI_OK_SELINTO</name></expr>:</case>

            <comment type="block">/*
             * We want to disallow SELECT INTO for now, because its behavior
             * is not consistent with SELECT INTO in a normal plpgsql context.
             * (We need to reimplement EXECUTE to parse the string as a
             * plpgsql command, not just feed it to SPI_execute.)  This is not
             * a functional limitation because CREATE TABLE AS is allowed.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXECUTE of SELECT ... INTO is not implemented"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might want to use EXECUTE ... INTO or EXECUTE CREATE TABLE ... AS instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/* Some SPI errors deserve specific error messages */</comment>
        <case>case <expr><name>SPI_ERROR_COPY</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot COPY to/from client in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <case>case <expr><name>SPI_ERROR_TRANSACTION</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot begin/end transactions in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use a BEGIN block with an EXCEPTION clause instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute failed executing query \"%s\": %s"</literal></expr></argument>,
                 <argument><expr><name>querystr</name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>exec_res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Save result info for GET DIAGNOSTICS */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_lastoid</name></name> <operator>=</operator> <name>SPI_lastoid</name></expr>;</expr_stmt>

    <comment type="block">/* Process INTO if present */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64</name></type>        <name>n</name> <init>= <expr><name>SPI_processed</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If the statement did not return a tuple table, complain */</comment>
        <if_stmt><if>if <condition>(<expr><name>tuptab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO used with a command that cannot return data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Determine if we assign to a record or a row */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * If SELECT ... INTO specified STRICT, and the query didn't find
         * exactly one row, throw an error.  If STRICT was not specified, then
         * allow the query to find any number of rows.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_preparedparamsdata</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>ppd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned no rows"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* set the target to NULL(s) */</comment>
            <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_preparedparamsdata</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>ppd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ROWS</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned more than one row"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Put the first result row into the target */</comment>
            <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* clean up after exec_move_row() */</comment>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * It might be a good idea to raise an error if the query returned
         * tuples that are being ignored, but historically we have not done
         * that.
         */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Release any result from SPI_execute, as well as transient data */</comment>
    <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_dynfors            Execute a dynamic query, assign each
 *                    tuple to a record or row and
 *                    execute a group of statements
 *                    for it.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_dynfors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_dynfors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>exec_dynquery_with_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Execute the loop
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_for_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forq</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Close the implicit cursor
     */</comment>
    <expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_open            Execute an OPEN cursor statement
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_open</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_open</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

    <comment type="block">/* ----------
     * Get the cursor variable and if it has an assigned name, check
     * that it's not in use currently.
     * ----------
     */</comment>
    <expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <comment type="block">/* We only need stmt_mcontext to hold the cursor name string */</comment>
        <expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" already in use"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ----------
     * Process the OPEN according to it's type.
     * ----------
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* ----------
         * This is an OPEN refcursor FOR SELECT ...
         *
         * We just make sure the query is planned. The real work is
         * done downstairs.
         * ----------
         */</comment>
        <expr_stmt><expr><name>query</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* ----------
         * This is an OPEN refcursor FOR EXECUTE ...
         * ----------
         */</comment>
        <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>exec_dynquery_with_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name></expr></argument>,
                                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
                                           <argument><expr><name>curname</name></expr></argument>,
                                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If cursor variable was NULL, store the generated portal name in it.
         * Note: exec_dynquery_with_params already reset the stmt_mcontext, so
         * curname is a dangling pointer here; but testing it for nullness is
         * OK.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* ----------
         * This is an OPEN cursor
         *
         * Note: parser should already have checked that statement supplies
         * args iff cursor needs them, but we check again to be safe.
         * ----------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* ----------
             * OPEN CURSOR with args.  We fake a SELECT ... INTO ...
             * statement to evaluate the args and put 'em into the
             * internal row.
             * ----------
             */</comment>
            <decl_stmt><decl><type><name>PLpgSQL_stmt_execsql</name></type> <name>set_args</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments given for cursor without arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>set_args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>cmd_type</name></name> <operator>=</operator> <name>PLPGSQL_STMT_EXECSQL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>sqlstmt</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <comment type="block">/* XXX historically this has not been STRICT */</comment>
            <expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>row</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator>
                <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>exec_stmt_execsql</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PLPGSQL_RC_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"open cursor failed during argument processing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments required for cursor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_expr</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Set up short-lived ParamListInfo
     */</comment>
    <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_unshared_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the cursor
     */</comment>
    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_paramlist</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
                                            <argument><expr><name>paramLI</name></expr></argument>,
                                            <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open cursor: %s"</literal></expr></argument>,
             <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If cursor variable was NULL, store the generated portal name in it
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If we had any transient data, clean it up */</comment>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>stmt_mcontext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_fetch            Fetch from a cursor into a target, or just
 *                            move the current position of the cursor
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_fetch</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_fetch</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>how_many</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>how_many</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* ----------
     * Get the portal of the cursor by name
     * ----------
     */</comment>
    <expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor variable \"%s\" is null"</literal></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Use eval_mcontext for short-lived string */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Calculate position for FETCH_RELATIVE or FETCH_ABSOLUTE */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

        <comment type="block">/* XXX should be doing this in LONG not INT width */</comment>
        <expr_stmt><expr><name>how_many</name> <operator>=</operator> <call><name>exec_eval_integer</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relative or absolute cursor position is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_move</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* ----------
         * Determine if we fetch into a record or a row
         * ----------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* ----------
         * Fetch 1 tuple from the cursor
         * ----------
         */</comment>
        <expr_stmt><expr><call><name>SPI_scroll_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>direction</name></name></expr></argument>, <argument><expr><name>how_many</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuptab</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

        <comment type="block">/* ----------
         * Set the target appropriately.
         * ----------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Move the cursor */</comment>
        <expr_stmt><expr><call><name>SPI_scroll_cursor_move</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>direction</name></name></expr></argument>, <argument><expr><name>how_many</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set the ROW_COUNT and the global FOUND variable appropriately. */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_close            Close a cursor
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_close</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_close</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* ----------
     * Get the portal of the cursor by name
     * ----------
     */</comment>
    <expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor variable \"%s\" is null"</literal></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Use eval_mcontext for short-lived string */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>handle_exceptions</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ----------
     * And close it.
     * ----------
     */</comment>
    <expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_assign_expr            Put an expression's result into a variable.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_assign_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                 <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>valtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>valtypmod</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If first time through, create a plan for this expression, and then see
     * if we can pass the target variable as a read-write parameter to the
     * expression.  (This is a bit messy, but it seems cleaner than modifying
     * the API of exec_eval_expr for the purpose.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exec_check_rw_parameter</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>dno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_assign_c_string        Put a C string into a text variable.
 *
 * We take a NULL pointer as signifying empty string, not SQL null.
 *
 * As with the underlying exec_assign_value, caller is expected to do
 * exec_eval_cleanup later.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_assign_c_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Use eval_mcontext for short-lived text value */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                      <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_assign_value            Put a value into a target datum
 *
 * Note: in some code paths, this will leak memory in the eval_mcontext;
 * we assume that will be cleaned up later by exec_eval_cleanup.  We cannot
 * call exec_eval_cleanup here for fear of destroying the input Datum value.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_assign_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
                  <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Target is a variable
                 */</comment>
                <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>        <name>newvalue</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                           <argument><expr><name>value</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
                                           <argument><expr><name>valtype</name></expr></argument>,
                                           <argument><expr><name>valtypmod</name></expr></argument>,
                                           <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
                                           <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null value cannot be assigned to variable \"%s\" declared NOT NULL"</literal></expr></argument>,
                                    <argument><expr><name><name>var</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If type is by-reference, copy the new value (which is
                 * probably in the eval_mcontext) into the procedure's main
                 * memory context.  But if it's a read/write reference to an
                 * expanded object, no physical copy needs to happen; at most
                 * we need to reparent the object's memory context.
                 *
                 * If it's an array, we force the value to be stored in R/W
                 * expanded form.  This wins if the function later does, say,
                 * a lot of array subscripting operations on the variable, and
                 * otherwise might lose.  We might need to use a different
                 * heuristic, but it's too soon to tell.  Also, are there
                 * cases where it'd be useful to force non-array values into
                 * expanded form?
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typisarray</name></name> <operator>&amp;&amp;</operator>
                        <operator>!</operator><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* array and not already R/W, so apply expand_array */</comment>
                        <expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>expand_array</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>,
                                                <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* else transfer value if R/W, else just datumCopy */</comment>
                        <expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>datumTransfer</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>,
                                                 <argument><expr><name>false</name></expr></argument>,
                                                 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Now free the old value, if any, and assign the new one. But
                 * skip the assignment if old and new values are the same.
                 * Note that for expanded objects, this test is necessary and
                 * cannot reliably be made any earlier; we have to be looking
                 * at the object's standard R/W pointer to be sure pointer
                 * equality is meaningful.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>newvalue</name> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>newvalue</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
                                      <argument><expr><operator>(</operator><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Target is a row variable
                 */</comment>
                <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* If source is null, just assign nulls to the row */</comment>
                    <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Source must be of RECORD or composite type */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign non-composite value to a row variable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>exec_move_row_from_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Target is a record variable
                 */</comment>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* If source is null, just assign nulls to the record */</comment>
                    <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Source must be of RECORD or composite type */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign non-composite value to a record variable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>exec_move_row_from_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Target is a field of a record
                 */</comment>
                <decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>fno</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtup</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name><name>colnums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>atttype</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>        <name>atttypmod</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

                <comment type="block">/*
                 * Check that there is already a tuple in the record. We need
                 * that because records don't have any predefined field
                 * structure.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Get the number of the record field to change.  Disallow
                 * system columns because the code below won't cope.
                 */</comment>
                <expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fno</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>colnums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>fno</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Now insert the new value, being careful to cast it to the
                 * right type.
                 */</comment>
                <expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>fno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>atttypmod</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>fno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                            <argument><expr><name>value</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
                                            <argument><expr><name>valtype</name></expr></argument>,
                                            <argument><expr><name>valtypmod</name></expr></argument>,
                                            <argument><expr><name>atttype</name></expr></argument>,
                                            <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple_by_cols</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
                                                   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>colnums</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>freetup</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>freetup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_ARRAYELEM</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Target is an element of an array
                 */</comment>
                <decl_stmt><decl><type><name>PLpgSQL_arrayelem</name> <modifier>*</modifier></type><name>arrayelem</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nsubscripts</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name><name>subscripts</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name><name>subscriptvals</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>        <name>oldarraydatum</name></decl>,
                            <decl><type ref="prev"/><name>newarraydatum</name></decl>,
                            <decl><type ref="prev"/><name>coerced_value</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>oldarrayisnull</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>parenttypoid</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>        <name>parenttypmod</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>save_eval_tuptable</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * We need to do subscript evaluation, which might require
                 * evaluating general expressions; and the caller might have
                 * done that too in order to prepare the input Datum.  We have
                 * to save and restore the caller's SPI_execute result, if
                 * any.
                 */</comment>
                <expr_stmt><expr><name>save_eval_tuptable</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * To handle constructs like x[1][2] := something, we have to
                 * be prepared to deal with a chain of arrayelem datums. Chase
                 * back to find the base array datum, and save the subscript
                 * expressions as we go.  (We are scanning right to left here,
                 * but want to evaluate the subscripts left-to-right to
                 * minimize surprises.)  Note that arrayelem is left pointing
                 * to the leftmost arrayelem datum, where we will cache the
                 * array element type data.
                 */</comment>
                <expr_stmt><expr><name>nsubscripts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <do>do
                <block>{<block_content>
                    <expr_stmt><expr><name>arrayelem</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_arrayelem</name> <operator>*</operator><operator>)</operator> <name>target</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nsubscripts</name> <operator>&gt;=</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
                                        <argument><expr><name>nsubscripts</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>subscripts</name><index>[<expr><name>nsubscripts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>arrayelem</name><operator>-&gt;</operator><name>subscript</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arrayparentno</name></name></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_ARRAYELEM</name></expr>)</condition>;</do>

                <comment type="block">/* Fetch current value of array datum */</comment>
                <expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>parenttypoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parenttypmod</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>oldarraydatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldarrayisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Update cached type data if necessary */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypoid</name></name> <operator>!=</operator> <name>parenttypoid</name> <operator>||</operator>
                    <name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypmod</name></name> <operator>!=</operator> <name>parenttypmod</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>arraytypoid</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>        <name>arraytypmod</name> <init>= <expr><name>parenttypmod</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int16</name></type>        <name>arraytyplen</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>elemtypoid</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int16</name></type>        <name>elemtyplen</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>elemtypbyval</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name></type>        <name>elemtypalign</name></decl>;</decl_stmt>

                    <comment type="block">/* If target is domain over array, reduce to base type */</comment>
                    <expr_stmt><expr><name>arraytypoid</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>parenttypoid</name></expr></argument>,
                                                       <argument><expr><operator>&amp;</operator><name>arraytypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* ... and identify the element type */</comment>
                    <expr_stmt><expr><name>elemtypoid</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>arraytypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elemtypoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscripted object is not an array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* Collect needed data about the types */</comment>
                    <expr_stmt><expr><name>arraytyplen</name> <operator>=</operator> <call><name>get_typlen</name><argument_list>(<argument><expr><name>arraytypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>elemtypoid</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>elemtyplen</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>elemtypbyval</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>elemtypalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Now safe to update the cached data */</comment>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypoid</name></name> <operator>=</operator> <name>parenttypoid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypmod</name></name> <operator>=</operator> <name>parenttypmod</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypoid</name></name> <operator>=</operator> <name>arraytypoid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypmod</name></name> <operator>=</operator> <name>arraytypmod</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytyplen</name></name> <operator>=</operator> <name>arraytyplen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypoid</name></name> <operator>=</operator> <name>elemtypoid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtyplen</name></name> <operator>=</operator> <name>elemtyplen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypbyval</name></name> <operator>=</operator> <name>elemtypbyval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypalign</name></name> <operator>=</operator> <name>elemtypalign</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Evaluate the subscripts, switch into left-to-right order.
                 * Like the expression built by ExecInitArrayRef(), complain
                 * if any subscript is null.
                 */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsubscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>subisnull</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>subscriptvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
                        <call><name>exec_eval_integer</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                          <argument><expr><name><name>subscripts</name><index>[<expr><name>nsubscripts</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>subisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>subisnull</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript in assignment must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/*
                     * Clean up in case the subscript expression wasn't
                     * simple. We can't do exec_eval_cleanup, but we can do
                     * this much (which is safe because the integer subscript
                     * value is surely pass-by-value), and we must do it in
                     * case the next subscript expression isn't simple either.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></for>

                <comment type="block">/* Now we can restore caller's SPI_execute result if any. */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>save_eval_tuptable</name></expr>;</expr_stmt>

                <comment type="block">/* Coerce source value to match array element type. */</comment>
                <expr_stmt><expr><name>coerced_value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                                <argument><expr><name>value</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
                                                <argument><expr><name>valtype</name></expr></argument>,
                                                <argument><expr><name>valtypmod</name></expr></argument>,
                                                <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypoid</name></name></expr></argument>,
                                                <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If the original array is null, cons up an empty array so
                 * that the assignment can proceed; we'll end with a
                 * one-element array containing just the assigned-to
                 * subscript.  This only works for varlena arrays, though; for
                 * fixed-length array types we skip the assignment.  We can't
                 * support assignment of a null entry into a fixed-length
                 * array, either, so that's a no-op too.  This is all ugly but
                 * corresponds to the current behavior of execExpr*.c.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytyplen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>    <comment type="block">/* fixed-length array? */</comment>
                    <operator>(</operator><name>oldarrayisnull</name> <operator>||</operator> <name>isNull</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>

                <comment type="block">/* empty array, if any, and newarraydatum are short-lived */</comment>
                <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>oldarrayisnull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>oldarraydatum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Build the modified array value.
                 */</comment>
                <expr_stmt><expr><name>newarraydatum</name> <operator>=</operator> <call><name>array_set_element</name><argument_list>(<argument><expr><name>oldarraydatum</name></expr></argument>,
                                                  <argument><expr><name>nsubscripts</name></expr></argument>,
                                                  <argument><expr><name>subscriptvals</name></expr></argument>,
                                                  <argument><expr><name>coerced_value</name></expr></argument>,
                                                  <argument><expr><name>isNull</name></expr></argument>,
                                                  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytyplen</name></name></expr></argument>,
                                                  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtyplen</name></name></expr></argument>,
                                                  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypbyval</name></name></expr></argument>,
                                                  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Assign the new array to the base variable.  It's never NULL
                 * at this point.  Note that if the target is a domain,
                 * coercing the base array type back up to the domain will
                 * happen within exec_assign_value.
                 */</comment>
                <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                  <argument><expr><name>newarraydatum</name></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>,
                                  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypoid</name></name></expr></argument>,
                                  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * exec_eval_datum                Get current value of a PLpgSQL_datum
 *
 * The type oid, typmod, value in Datum format, and null flag are returned.
 *
 * At present this doesn't handle PLpgSQL_expr or PLpgSQL_arrayelem datums;
 * that's not needed because we never pass references to such datums to SPI.
 *
 * NOTE: the returned Datum points right at the stored value in the case of
 * pass-by-reference datatypes.  Generally callers should take care not to
 * modify the stored value.  Some callers intentionally manipulate variables
 * referenced by R/W expanded pointers, though; it is those callers'
 * responsibility that the results are semantically OK.
 *
 * In some cases we have to palloc a return value, and in such cases we put
 * it into the estate's eval_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_eval_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeid</name></decl></parameter>,
                <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typetypmod</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row variable has no tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Make sure we have a valid type/typmod setting */</comment>
                <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>make_tuple_from_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row not compatible with its own tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Make sure we have a valid type/typmod setting */</comment>
                <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>heap_copy_tuple_as_datum</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>fno</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fno</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>fno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_exec_get_datum_type                Get datatype of a PLpgSQL_datum
 *
 * This is the same logic as in exec_eval_datum, except that it can handle
 * some cases where exec_eval_datum has to fail; specifically, we may have
 * a tupdesc but no row value for a record variable.  (This currently can
 * happen only for a trigger's NEW/OLD records.)
 */</comment>
<function><type><name>Oid</name></type>
<name>plpgsql_exec_get_datum_type</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                            <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typeid</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row variable has no tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Make sure we have a valid type/typmod setting */</comment>
                <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Make sure we have a valid type/typmod setting */</comment>
                <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>fno</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fno</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>typeid</name> <operator>=</operator> <call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>typeid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_exec_get_datum_type_info            Get datatype etc of a PLpgSQL_datum
 *
 * An extended version of plpgsql_exec_get_datum_type, which also retrieves the
 * typmod and collation of the datum.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_exec_get_datum_type_info</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                                 <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>,
                                 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeid</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>collation</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row variable has no tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Make sure we have a valid type/typmod setting */</comment>
                <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
                <comment type="block">/* do NOT return the mutable typmod of a RECORD variable */</comment>
                <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <comment type="block">/* composite types are never collatable */</comment>
                <expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Make sure we have a valid type/typmod setting */</comment>
                <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
                <comment type="block">/* do NOT return the mutable typmod of a RECORD variable */</comment>
                <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <comment type="block">/* composite types are never collatable */</comment>
                <expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>fno</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fno</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
                                    <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>fno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>fno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>fno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attcollation</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>            <comment type="block">/* no system column types have collation */</comment>
                    <expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
            <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_eval_integer        Evaluate an expression, coerce result to int4
 *
 * Note we do not do exec_eval_cleanup here; the caller must do it at
 * some later point.  (We do this because the caller may be holding the
 * results of other, pass-by-reference, expression evaluations, such as
 * an array value to be subscripted.)
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_eval_integer</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>exprdatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>exprtypeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>exprtypmod</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>exprdatum</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
                                <argument><expr><name>exprtypeid</name></expr></argument>, <argument><expr><name>exprtypmod</name></expr></argument>,
                                <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>exprdatum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_eval_boolean        Evaluate an expression, coerce result to bool
 *
 * Note we do not do exec_eval_cleanup here; the caller must do it at
 * some later point.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exec_eval_boolean</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>exprdatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>exprtypeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>exprtypmod</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>exprdatum</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
                                <argument><expr><name>exprtypeid</name></expr></argument>, <argument><expr><name>exprtypmod</name></expr></argument>,
                                <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>exprdatum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_eval_expr            Evaluate an expression and return
 *                    the result Datum, along with data type/typmod.
 *
 * NOTE: caller must do exec_eval_cleanup when done with the Datum.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>exec_eval_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
               <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
               <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
               <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If first time through, create a plan for this expression.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If this is a simple expression, bypass SPI and use the executor
     * directly
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>exec_eval_simple_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>rettypmod</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Else do it the hard way via exec_run_select
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" did not return data"</literal></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the expression returns exactly one column...
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" returned %d column"</literal></expr></argument>,
                               <argument><expr><literal type="string">"query \"%s\" returned %d columns"</literal></expr></argument>,
                               <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
                               <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
                               <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * ... and get the column's datatype.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>rettypmod</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If there are no rows selected, the result is a NULL of that type.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check that the expression returned no more than one row.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" returned more than one row"</literal></expr></argument>,
                        <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Return the single result Datum.
     */</comment>
    <return>return <expr><call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                         <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_run_select            Execute a select query
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_run_select</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>maxtuples</name></decl></parameter>, <parameter><decl><type><name>Portal</name> <modifier>*</modifier></type><name>portalP</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * On the first call for this expression generate the plan.
     *
     * If we don't need to return a portal, then we're just going to execute
     * the query once, which means it's OK to use a parallel plan, even if the
     * number of rows being fetched is limited.  If we do need to return a
     * portal, the caller might do cursor operations, which parallel query
     * can't support.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
                          <argument><expr><ternary><condition><expr><name>portalP</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>CURSOR_OPT_PARALLEL_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If a portal was requested, put the query into the portal
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>portalP</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Set up short-lived ParamListInfo
         */</comment>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_unshared_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>portalP</name> <operator>=</operator> <call><name>SPI_cursor_open_with_paramlist</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
                                                  <argument><expr><name>paramLI</name></expr></argument>,
                                                  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>portalP</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open implicit cursor for query \"%s\": %s"</literal></expr></argument>,
                 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SPI_OK_CURSOR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Set up ParamListInfo to pass to executor
     */</comment>
    <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Execute the query
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_execute_plan_with_paramlist</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>,
                                         <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><name>maxtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" is not a SELECT"</literal></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Save query results for eventual cleanup */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_lastoid</name></name> <operator>=</operator> <name>SPI_lastoid</name></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * exec_for_query --- execute body of FOR loop for each row from a portal
 *
 * Used by exec_stmt_fors, exec_stmt_forc and exec_stmt_dynfors
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_for_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_forq</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
               <parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefetch_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>count</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Determine if we assign to a record or a row
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Make sure the portal doesn't get closed by the user statements we
     * execute.
     */</comment>
    <expr_stmt><expr><call><name>PinPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Fetch the initial tuple(s).  If prefetching is allowed then we grab a
     * few more rows to avoid multiple trips through executor startup
     * overhead.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REMOTE_QUERY_FETCH</name></cpp:macro>    <cpp:value>200000</cpp:value></cpp:define>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>(</operator><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>commandType</name> <operator>!=</operator> <name>CMD_UTILITY</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>planTree</name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <name>MAX_REMOTE_QUERY_FETCH</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <ternary><condition><expr><name>prefetch_ok</name></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuptab</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>MAX_REMOTE_QUERY_FETCH</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Can fetch only %d tuples via RemoteQuery execution"</literal></expr></argument>,
                <argument><expr><name>MAX_REMOTE_QUERY_FETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the query didn't return any rows, set the target to NULL and fall
     * through with found = false.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>            <comment type="block">/* processed at least one tuple */</comment>

    <comment type="block">/*
     * Now do the loop
     */</comment>
    <while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64</name></type>        <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/*
             * Assign the tuple to the target
             */</comment>
            <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Execute the statements
             */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_OK</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_EXIT</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* unlabelled exit, so exit the current loop */</comment>
                        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                             <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* label matches this loop, so exit loop */</comment>
                        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * otherwise, we processed a labelled exit that does not
                     * match the current statement's label, if any; return
                     * RC_EXIT so that the EXIT continues to recurse upward.
                     */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_CONTINUE</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* unlabelled continue, so re-run the current loop */</comment>
                        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                             <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* label matches this loop, so re-run loop */</comment>
                        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PLPGSQL_RC_OK</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * otherwise, we process a labelled continue that does not
                     * match the current statement's label, if any; return
                     * RC_CONTINUE so that the CONTINUE will propagate up the
                     * stack.
                     */</comment>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * We're aborting the loop.  Need a goto to get out of two
                 * levels of loop...
                 */</comment>
                <goto>goto <name>loop_exit</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Fetch more tuples.  If prefetching is allowed, grab 50 at a time.
         */</comment>
        <expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><ternary><condition><expr><name>prefetch_ok</name></expr> ?</condition><then> <expr><literal type="number">50</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuptab</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
    </block_content>}</block></while>

<label><name>loop_exit</name>:</label>

    <comment type="block">/*
     * Release last group of tuples (if any)
     */</comment>
    <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnpinPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the FOUND variable to indicate the result of executing the loop
     * (namely, whether we looped one or more times). This must be set last so
     * that it does not interfere with the value of the FOUND variable inside
     * the loop processing itself.
     */</comment>
    <expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_eval_simple_expr -        Evaluate a simple expression returning
 *                                a Datum by directly calling ExecEvalExpr().
 *
 * If successful, store results into *result, *isNull, *rettype, *rettypmod
 * and return TRUE.  If the expression cannot be handled by simple evaluation,
 * return FALSE.
 *
 * Because we only store one execution tree for a simple expression, we
 * can't handle recursion cases.  So, if we see the tree is already busy
 * with an evaluation in the current xact, we just return FALSE and let the
 * caller run the expression the hard way.  (Other alternatives such as
 * creating a new tree for a recursive call either introduce memory leaks,
 * or add enough bookkeeping to be doubtful wins anyway.)  Another case that
 * is covered by the expr_simple_in_use test is where a previous execution
 * of the tree was aborted by an error: the tree may contain bogus state
 * so we dare not re-use it.
 *
 * It is possible though unlikely for a simple expression to become non-simple
 * (consider for example redefining a trivial view).  We must handle that for
 * correctness; fortunately it's normally inexpensive to call
 * SPI_plan_get_cached_plan for a simple expression.  We do not consider the
 * other direction (non-simple expression becoming simple) because we'll still
 * give correct results if that happens, and it's unlikely to be worth the
 * cycles to check.
 *
 * Note: if pass-by-reference, the result is in the eval_mcontext.
 * It will be freed when exec_eval_cleanup is done.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exec_eval_simple_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                      <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
                      <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
                      <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>curlxid</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>save_setup_arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Forget it if expression wasn't simple before.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If expression is in use in current xact, don't touch it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>==</operator> <name>curlxid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Revalidate cached plan, so that we will notice if it became stale. (We
     * need to hold a refcount while using the plan, anyway.)  If replanning
     * is needed, do that work in the eval_mcontext.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>SPI_plan_get_cached_plan</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We can't get a failure here, because the number of CachedPlanSources in
     * the SPI plan can't change from what exec_simple_check_plan saw; it's a
     * property of the raw parsetree generated from the query text.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cplan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cplan</name><operator>-&gt;</operator><name>generation</name></name> <operator>!=</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_generation</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* It got replanned ... is it still simple? */</comment>
        <expr_stmt><expr><call><name>exec_simple_recheck_plan</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* better recheck r/w safety, as well */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exec_check_rw_parameter</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Oops, release refcount and fail */</comment>
            <expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Pass back previously-determined result type.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_type</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>rettypmod</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_typmod</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Prepare the expression for execution, if it's not been done already in
     * the current transaction.  (This will be forced to happen if we called
     * exec_simple_recheck_plan above.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>!=</operator> <name>curlxid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_state</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>=</operator> <name>curlxid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We have to do some of the things SPI_execute_plan would do, in
     * particular advance the snapshot if we are in a non-read-only function.
     * Without this, stable functions within the expression would fail to see
     * updates made so far by our own function.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Set up ParamListInfo to pass to executor.  We need an unshared list if
     * it's going to include any R/W expanded-object pointer.  For safety,
     * save and restore estate-&gt;paramLI-&gt;parserSetupArg around our use of the
     * param list.
     */</comment>
    <expr_stmt><expr><name>save_setup_arg</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_unshared_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name>paramLI</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark expression as busy for the duration of the ExecEvalExpr call.
     */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Finally we can call the executor to evaluate the expression
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_state</name></name></expr></argument>,
                           <argument><expr><name>econtext</name></expr></argument>,
                           <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Assorted cleanup */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>save_setup_arg</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now we can release our refcount on the cached plan.
     */</comment>
    <expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * That's it.
     */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create a ParamListInfo to pass to SPI
 *
 * We share a single ParamListInfo array across all SPI calls made from this
 * estate, except calls creating cursors, which use setup_unshared_param_list
 * (see its comments for reasons why), and calls that pass a R/W expanded
 * object pointer.  A shared array is generally OK since any given slot in
 * the array would need to contain the same current datum value no matter
 * which query or expression we're evaluating; but of course that doesn't
 * hold when a specific variable is being passed as a R/W pointer, because
 * other expressions in the same function probably don't want to do that.
 *
 * Note that paramLI-&gt;parserSetupArg points to the specific PLpgSQL_expr
 * being evaluated.  This is not an issue for statement-level callers, but
 * lower-level callers must save and restore estate-&gt;paramLI-&gt;parserSetupArg
 * just in case there's an active evaluation at an outer call level.
 *
 * The general plan for passing parameters to SPI is that plain VAR datums
 * always have valid images in the shared param list.  This is ensured by
 * assign_simple_var(), which also marks those params as PARAM_FLAG_CONST,
 * allowing the planner to use those values in custom plans.  However, non-VAR
 * datums cannot conveniently be managed that way.  For one thing, they could
 * throw errors (for example "no such record field") and we do not want that
 * to happen in a part of the expression that might never be evaluated at
 * runtime.  For another thing, exec_eval_datum() may return short-lived
 * values stored in the estate's eval_mcontext, which will not necessarily
 * survive to the next SPI operation.  And for a third thing, ROW
 * and RECFIELD datums' values depend on other datums, and we don't have a
 * cheap way to track that.  Therefore, param slots for non-VAR datum types
 * are always reset here and then filled on-demand by plpgsql_param_fetch().
 * We can save a few cycles by not bothering with the reset loop unless at
 * least one such param has actually been filled by plpgsql_param_fetch().
 */</comment>
<function><type><specifier>static</specifier> <name>ParamListInfo</name></type>
<name>setup_param_list</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We must have created the SPIPlan already (hence, query text has been
     * parsed/analyzed at least once); else we cannot rely on expr-&gt;paramnos.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Expressions with R/W parameters can't use the shared param list.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We only need a ParamListInfo if the expression has parameters.  In
     * principle we should test with bms_is_empty(), but we use a not-null
     * test because it's faster.  In current usage bits are never removed from
     * expr-&gt;paramnos, only added, so this test is correct anyway.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Use the common ParamListInfo */</comment>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>paramLI</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * If any resettable parameters have been passed to the executor since
         * last time, we need to reset those param slots to "invalid", for the
         * reasons mentioned in the comment above.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>params_dirty</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>resettable_datums</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>resettable_datums</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>dno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>(</operator><name>dno</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>resettable_datums</name></expr></argument>, <argument><expr><name>dno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>dno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>params_dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Set up link to active expr where the hook functions can find it.
         * Callers must save and restore parserSetupArg if there is any chance
         * that they are interrupting an active use of parameters.
         */</comment>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Allow parameters that aren't needed by this expression to be
         * ignored.
         */</comment>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramMask</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Also make sure this is set before parser hooks need it.  There is
         * no need to save and restore, since the value is always correct once
         * set.  (Should be set already, but let's be sure.)
         */</comment>
        <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Expression requires no parameters.  Be sure we represent this case
         * as a NULL ParamListInfo, so that plancache.c knows there is no
         * point in a custom plan.
         */</comment>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create an unshared, short-lived ParamListInfo to pass to SPI
 *
 * When creating a cursor, we do not use the shared ParamListInfo array
 * but create a short-lived one that will contain only params actually
 * referenced by the query.  The reason for this is that copyParamList() will
 * be used to copy the parameters into cursor-lifespan storage, and we don't
 * want it to copy anything that's not used by the specific cursor; that
 * could result in uselessly copying some large values.
 *
 * We also use this for expressions that are passing a R/W object pointer
 * to some trusted function.  We don't want the R/W pointer to get into the
 * shared param list, where it could get passed to some less-trusted function.
 *
 * The result, if not NULL, is in the estate's eval_mcontext.
 *
 * XXX. Could we use ParamListInfo's new paramMask to avoid creating unshared
 * parameter lists?
 */</comment>
<function><type><specifier>static</specifier> <name>ParamListInfo</name></type>
<name>setup_unshared_param_list</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We must have created the SPIPlan already (hence, query text has been
     * parsed/analyzed at least once); else we cannot rely on expr-&gt;paramnos.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We only need a ParamListInfo if the expression has parameters.  In
     * principle we should test with bms_is_empty(), but we use a not-null
     * test because it's faster.  In current usage bits are never removed from
     * expr-&gt;paramnos, only added, so this test is correct anyway.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>dno</name></decl>;</decl_stmt>

        <comment type="block">/* initialize ParamListInfo with one entry per datum, all invalid */</comment>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <operator>(</operator><name>ParamListInfo</name><operator>)</operator>
            <call><name>eval_mcontext_alloc0</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
                                 <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>plpgsql_param_fetch</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>estate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>plpgsql_parser_setup</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramMask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Instantiate values for "safe" parameters of the expression.  We
         * could skip this and leave them to be filled by plpgsql_param_fetch;
         * but then the values would not be available for query planning,
         * since the planner doesn't call the paramFetch hook.
         */</comment>
        <expr_stmt><expr><name>dno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>dno</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>, <argument><expr><name>dno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>dno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>dno</name> <operator>==</operator> <name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
                                                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
                                                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/*
         * Also make sure this is set before parser hooks need it.  There is
         * no need to save and restore, since the value is always correct once
         * set.  (Should be set already, but let's be sure.)
         */</comment>
        <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Expression requires no parameters.  Be sure we represent this case
         * as a NULL ParamListInfo, so that plancache.c knows there is no
         * point in a custom plan.
         */</comment>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_fetch        paramFetch callback for dynamic parameter fetch
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_param_fetch</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paramid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>dno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>prmtypmod</name></decl>;</decl_stmt>

    <comment type="block">/* paramid's are 1-based, but dnos are 0-based */</comment>
    <expr_stmt><expr><name>dno</name> <operator>=</operator> <name>paramid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* fetch back the hook data */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* now we can access the target datum */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Since copyParamList() or SerializeParamList() will try to materialize
     * every single parameter slot, it's important to do nothing when asked
     * for a datum that's not supposed to be used by this SQL expression.
     * Otherwise we risk failures in exec_eval_datum(), or copying a lot more
     * data than necessary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>dno</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>params</name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>paramLI</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We need to mark the shared params array dirty if we're about to
         * evaluate a resettable datum.
         */</comment>
        <switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
            <case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
            <case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>params_dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* OK, evaluate the value and store into the appropriate paramlist slot */</comment>
    <expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmtypmod</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We can always mark params as "const" for executor's purposes */</comment>
    <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If it's a read/write expanded datum, convert reference to read-only,
     * unless it's safe to pass as read-write.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name> <operator>&amp;&amp;</operator> <name>dno</name> <operator>!=</operator> <name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
                                                <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
                                                <argument><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name><operator>)</operator><operator>-&gt;</operator><name><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_move_row            Move one tuple's values into a record or row
 *
 * Since this uses exec_assign_value, caller should eventually call
 * exec_eval_cleanup to prevent long-term memory leaks.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_move_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
              <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
              <parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
              <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * Record is simple - just copy the tuple and its descriptor into the
     * record variable
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>rec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Copy input first, just in case it is pointing at variable's value
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>tupdesc</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If we have a tupdesc but no data, form an all-nulls tuple */</comment>
            <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
                <call><name>eval_mcontext_alloc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>tupdesc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Free the old value ... */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>freetup</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>freetup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>freetupdesc</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>freetupdesc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* ... and install the new */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>freetup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>tupdesc</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>freetupdesc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Row is a bit more complicated in that we assign the individual
     * attributes of the tuple to the variables the row points to.
     *
     * NOTE: this code used to demand row-&gt;nfields ==
     * HeapTupleHeaderGetNatts(tup-&gt;t_data), but that's wrong.  The tuple
     * might have more fields than we expected if it's from an
     * inheritance-child table of the current table, or it might have fewer if
     * the table has had columns added by ALTER TABLE. Ignore extra columns
     * and assume NULL for missing columns, the same as heap_getattr would do.
     * We also have to skip over dropped columns in either the source or
     * destination.
     *
     * If we have no tuple data at all, we'll assign NULL to all columns of
     * the row variable.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>row</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>td_natts</name> <init>= <expr><ternary><condition><expr><name>tupdesc</name></expr> ?</condition><then> <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>t_natts</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>fnum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>anum</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>t_natts</name> <operator>=</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>t_natts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>anum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>fnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fnum</name> <operator>&lt;</operator> <name><name>row</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>fnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>valtype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>valtypmod</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>fnum</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* skip dropped column in row struct */</comment>

            <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>fnum</name></expr>]</index></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

            <while>while <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name> <operator>&amp;&amp;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>anum</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>            <comment type="block">/* skip dropped column in tuple */</comment>

            <if_stmt><if>if <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>t_natts</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>valtype</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>anum</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>valtypmod</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>anum</name></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>valtype</name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>valtypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                              <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * make_tuple_from_row        Make a tuple from the values of a row object
 *
 * A NULL return indicates rowtype mismatch; caller must raise suitable error
 *
 * The result tuple is freshly palloc'd in caller's context.  Some junk
 * may be left behind in eval_mcontext, too.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>make_tuple_from_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                    <parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
                    <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>natts</name> <operator>!=</operator> <name><name>row</name><operator>-&gt;</operator><name>nfields</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>dvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>eval_mcontext_alloc0</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>eval_mcontext_alloc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>fieldtypeid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>fieldtypmod</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>    <comment type="block">/* leave the column as null */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"dropped rowtype entry for non-dropped column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>fieldtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fieldtypmod</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldtypeid</name> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* XXX should we insist on typmod match, too? */</comment>
    </block_content>}</block></for>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_tuple_from_datum        extract a tuple from a composite Datum
 *
 * Returns a HeapTuple, freshly palloc'd in caller's context.
 *
 * Note: it's caller's responsibility to be sure value is of composite type.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>get_tuple_from_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name> <init>= <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

    <comment type="block">/* Build a temporary HeapTuple control structure */</comment>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <comment type="block">/* Build a copy and return it */</comment>
    <return>return <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_tupdesc_from_datum    get a tuple descriptor for a composite Datum
 *
 * Returns a pointer to the TupleDesc of the tuple's rowtype.
 * Caller is responsible for calling ReleaseTupleDesc when done with it.
 *
 * Note: it's caller's responsibility to be sure value is of composite type.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>get_tupdesc_from_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name> <init>= <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tupType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>tupTypmod</name></decl>;</decl_stmt>

    <comment type="block">/* Extract rowtype info and find a tupdesc */</comment>
    <expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_move_row_from_datum        Move a composite Datum into a record or row
 *
 * This is equivalent to get_tuple_from_datum() followed by exec_move_row(),
 * but we avoid constructing an intermediate physical copy of the tuple.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_move_row_from_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                         <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
                         <parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name> <init>= <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tupType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>tupTypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

    <comment type="block">/* Extract rowtype info and find a tupdesc */</comment>
    <expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build a temporary HeapTuple control structure */</comment>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_xc_node_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Do the move */</comment>
    <expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release tupdesc usage count */</comment>
    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * convert_value_to_string            Convert a non-null Datum to C string
 *
 * Note: the result is in the estate's eval_mcontext, and will be cleared
 * by the next exec_eval_cleanup() call.  The invoked output function might
 * leave additional cruft there as well, so just pfree'ing the result string
 * would not be enough to avoid memory leaks if we did not do it like this.
 * In most usages the Datum being passed in is also in that context (if
 * pass-by-reference) and so an exec_eval_cleanup() call is needed anyway.
 *
 * Note: not caching the conversion function lookup is bad for performance.
 * However, this function isn't currently used in any places where an extra
 * catalog lookup or two seems like a big deal.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convert_value_to_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typoutput</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typIsVarlena</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_cast_value            Cast a value if required
 *
 * Note that *isnull is an input and also an output parameter.  While it's
 * unlikely that a cast operation would produce null from non-null or vice
 * versa, that could happen in principle.
 *
 * Note: the estate's eval_mcontext is used for temporary storage, and may
 * also contain the result Datum if we have to do a conversion to a pass-
 * by-reference data type.  Be sure to do an exec_eval_cleanup() call when
 * done with the result.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>exec_cast_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name></type> <name>reqtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>reqtypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If the type of the given value isn't what's requested, convert it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>valtype</name> <operator>!=</operator> <name>reqtype</name> <operator>||</operator>
        <operator>(</operator><name>valtypmod</name> <operator>!=</operator> <name>reqtypmod</name> <operator>&amp;&amp;</operator> <name>reqtypmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type><name>cast_entry</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cast_entry</name> <operator>=</operator> <call><name>get_cast_hashentry</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                        <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
                                        <argument><expr><name>reqtype</name></expr></argument>, <argument><expr><name>reqtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cast_entry</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_datum</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_isNull</name></name> <operator>=</operator> <operator>*</operator><name>isnull</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_exprstate</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
                                 <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_cast_hashentry            Look up how to perform a type cast
 *
 * Returns a plpgsql_CastHashEntry if an expression has to be evaluated,
 * or NULL if the cast is a mere no-op relabeling.  If there's work to be
 * done, the cast_exprstate field contains an expression evaluation tree
 * based on a CaseTestExpr input, and the cast_in_use field should be set
 * TRUE while executing it.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type>
<name>get_cast_hashentry</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>srctype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>srctypmod</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>dsttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dsttypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>plpgsql_CastHashKey</name></type> <name>cast_key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type><name>cast_entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>curlxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Look for existing entry */</comment>
    <expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>srctype</name></name> <operator>=</operator> <name>srctype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>dsttype</name></name> <operator>=</operator> <name>dsttype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>srctypmod</name></name> <operator>=</operator> <name>srctypmod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>dsttypmod</name></name> <operator>=</operator> <name>dsttypmod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cast_entry</name> <operator>=</operator> <operator>(</operator><name>plpgsql_CastHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash</name></name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cast_key</name></expr></argument>,
                                                       <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>cast_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We've not looked up this coercion before */</comment>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>cast_expr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>placeholder</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Since we could easily fail (no such coercion), construct a
         * temporary coercion expression tree in the short-lived
         * eval_mcontext, then if successful copy it to cast_hash_context.
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We use a CaseTestExpr as the base of the coercion tree, since it's
         * very cheap to insert the source value for that.
         */</comment>
        <expr_stmt><expr><name>placeholder</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>srctype</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>srctypmod</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Apply coercion.  We use ASSIGNMENT coercion because that's the
         * closest match to plpgsql's historical behavior; in particular,
         * EXPLICIT coercion would allow silent truncation to a destination
         * varchar/bpchar's length, which we do not want.
         *
         * If source type is UNKNOWN, coerce_to_target_type will fail (it only
         * expects to see that for Const input nodes), so don't call it; we'll
         * apply CoerceViaIO instead.  Likewise, it doesn't currently work for
         * coercing RECORD to some other type, so skip for that too.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>||</operator> <name>srctype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr></argument>, <argument><expr><name>srctype</name></expr></argument>,
                                              <argument><expr><name>dsttype</name></expr></argument>, <argument><expr><name>dsttypmod</name></expr></argument>,
                                              <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                              <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * If there's no cast path according to the parser, fall back to using
         * an I/O coercion; this is semantically dubious but matches plpgsql's
         * historical behavior.  We would need something of the sort for
         * UNKNOWN literals in any case.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>cast_expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>dsttype</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>iocoerce</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>dsttypmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                                  <argument><expr><name>cast_expr</name></expr></argument>, <argument><expr><name>dsttype</name></expr></argument>,
                                                  <argument><expr><name>dsttype</name></expr></argument>, <argument><expr><name>dsttypmod</name></expr></argument>,
                                                  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                                  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                                  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Note: we don't bother labeling the expression tree with collation */</comment>

        <comment type="block">/* Detect whether we have a no-op (RelabelType) coercion */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cast_expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>cast_expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name> <operator>==</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cast_expr</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* ExecInitExpr assumes we've planned the expression */</comment>
            <expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cast_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Now copy the tree into cast_hash_context */</comment>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cast_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now we can fill in a hashtable entry. */</comment>
        <expr_stmt><expr><name>cast_entry</name> <operator>=</operator> <operator>(</operator><name>plpgsql_CastHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash</name></name></expr></argument>,
                                                           <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cast_key</name></expr></argument>,
                                                           <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* wasn't there a moment ago */</comment>
        <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cast_expr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_exprstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Done if we have determined that this is a no-op cast. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Prepare the expression for execution, if it's not been done already in
     * the current transaction; also, if it's marked busy in the current
     * transaction, abandon that expression tree and build a new one, so as to
     * avoid potential problems with recursive cast expressions and failed
     * executions.  (We will leak some memory intra-transaction if that
     * happens a lot, but we don't expect it to.)  It's okay to update the
     * hash table with the new tree because all plpgsql functions within a
     * given transaction share the same simple_eval_estate.  (Well, regular
     * functions do; DO blocks have private simple_eval_estates, and private
     * cast hash tables to go with them.)
     */</comment>
    <expr_stmt><expr><name>curlxid</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_lxid</name></name> <operator>!=</operator> <name>curlxid</name> <operator>||</operator> <name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_lxid</name></name> <operator>=</operator> <name>curlxid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>cast_entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_simple_check_node -        Recursively check if an expression
 *                                is made only of simple things we can
 *                                hand out directly to ExecEvalExpr()
 *                                instead of calling SPI.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exec_simple_check_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Const</name></expr>:</case>
            <return>return <expr><name>TRUE</name></expr>;</return>

        <case>case <expr><name>T_Param</name></expr>:</case>
            <return>return <expr><name>TRUE</name></expr>;</return>

        <case>case <expr><name>T_ArrayRef</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_FuncExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_OpExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_DistinctExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_NullIfExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_BoolExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_FieldSelect</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_FieldStore</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_RelabelType</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_CaseExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_CaseWhen</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
            <return>return <expr><name>TRUE</name></expr>;</return>

        <case>case <expr><name>T_ArrayExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_RowExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
            <return>return <expr><name>TRUE</name></expr>;</return>

        <case>case <expr><name>T_XmlExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_NullTest</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_BooleanTest</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
            <return>return <expr><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
            <return>return <expr><name>TRUE</name></expr>;</return>

        <case>case <expr><name>T_List</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>expr</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>

                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block>

        <default>default:</default>
            <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_simple_check_plan -        Check if a plan is simple enough to
 *                                be evaluated by ExecEvalExpr() instead
 *                                of SPI.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_simple_check_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>plansources</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Initialize to "not simple", and remember the plan generation number we
     * last checked.  (If we don't get as far as obtaining a plan to check, we
     * just leave expr_simple_generation set to 0.)
     */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_generation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * We can only test queries that resulted in exactly one CachedPlanSource
     */</comment>
    <expr_stmt><expr><name>plansources</name> <operator>=</operator> <call><name>SPI_plan_get_plan_sources</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>plansources</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>plansources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do some checking on the analyzed-and-rewritten form of the query. These
     * checks are basically redundant with the tests in
     * exec_simple_recheck_plan, but the point is to avoid building a plan if
     * possible.  Since this function is only called immediately after
     * creating the CachedPlanSource, we need not worry about the query being
     * stale.
     */</comment>

    <comment type="block">/*
     * 1. There must be one single querytree.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * 2. It must be a plain SELECT query without any input tables
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * 3. Can't have any subplans, aggregates, qual clauses either
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * 4. The query must have a single attribute as result
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * OK, it seems worth constructing a plan for more careful checking.
     *
     * Get the generic plan for the query.  If replanning is needed, do that
     * work in the eval_mcontext.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>SPI_plan_get_cached_plan</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Can't fail, because we checked for a single CachedPlanSource above */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cplan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Share the remaining work with recheck code path */</comment>
    <expr_stmt><expr><call><name>exec_simple_recheck_plan</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release our plan refcount */</comment>
    <expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_simple_recheck_plan --- check for simple plan once we have CachedPlan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_simple_recheck_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Initialize to "not simple", and remember the plan generation number we
     * last checked.
     */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_generation</name></name> <operator>=</operator> <name><name>cplan</name><operator>-&gt;</operator><name>generation</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * 1. There must be one single plantree
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * 2. It must be a RESULT plan --&gt; no scan's required
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * 3. Can't have any subplan or qual clause, either
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * 4. The plan must have a single attribute as result
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * 5. Check that all the nodes in the expression are non-scary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_simple_check_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Yes - this is a simple expression.  Mark it as such, and initialize
     * state to "not valid in current transaction".
     */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
    <comment type="block">/* Also stash away the expression result type */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_type</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_typmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_check_rw_parameter --- can we pass expanded object as read/write param?
 *
 * If we have an assignment like "x := array_append(x, foo)" in which the
 * top-level function is trusted not to corrupt its argument in case of an
 * error, then when x has an expanded object as value, it is safe to pass the
 * value as a read/write pointer and let the function modify the value
 * in-place.
 *
 * This function checks for a safe expression, and sets expr-&gt;rwparam to the
 * dno of the target variable (x) if safe, or -1 if not safe.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_check_rw_parameter</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target_dno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>funcid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Assume unsafe */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * If the expression isn't simple, there's no point in trying to optimize
     * (because the exec_run_select code path will flatten any expanded result
     * anyway).  Even without that, this seems like a good safety restriction.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If target variable isn't referenced by expression, no need to look
     * further.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>target_dno</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Top level of expression must be a simple FuncExpr or OpExpr.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcid</name> <operator>=</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fargs</name> <operator>=</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcid</name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fargs</name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return;</return></block_content></block></else></if_stmt>

    <comment type="block">/*
     * The top-level function must be one that we trust to be "safe".
     * Currently we hard-wire the list, but it would be very desirable to
     * allow extensions to mark their functions as safe ...
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>funcid</name> <operator>==</operator> <name>F_ARRAY_APPEND</name> <operator>||</operator>
          <name>funcid</name> <operator>==</operator> <name>F_ARRAY_PREPEND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The target variable (in the form of a Param) must only appear as a
     * direct argument of the top-level function.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fargs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* A Param is OK, whether it's the target variable or not */</comment>
        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* Otherwise, argument expression must not reference target */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>contains_target_param</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_dno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* OK, we can pass target as a read-write parameter */</comment>
    <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>=</operator> <name>target_dno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively check for a Param referencing the target variable
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_target_param</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>target_dno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name> <operator>&amp;&amp;</operator>
            <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>==</operator> <operator>*</operator><name>target_dno</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contains_target_param</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>target_dno</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_set_found            Set the global found variable to true/false
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_set_found</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>estate</name><operator>-&gt;</operator><name>found_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_create_econtext --- create an eval_econtext for the current function
 *
 * We may need to create a new shared_simple_eval_estate too, if there's not
 * one already for the current transaction.  The EState will be cleaned up at
 * transaction end.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_create_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Create an EState for evaluation of simple expressions, if there's not
     * one already in the current transaction.  The EState is made a child of
     * TopTransactionContext so it will have the right lifespan.
     *
     * Note that this path is never taken when executing a DO block; the
     * required EState was already made by plpgsql_inline_handler.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shared_simple_eval_estate</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>shared_simple_eval_estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>shared_simple_eval_estate</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Create a child econtext for the current function.
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make a stack entry so we can clean up the econtext at subxact end.
     * Stack entries are kept in TopTransactionContext for simplicity.
     */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>SimpleEcontextStackEntry</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SimpleEcontextStackEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stack_econtext</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_subxid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>simple_econtext_stack</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_destroy_econtext --- destroy function's econtext
 *
 * We check that it matches the top stack entry, and destroy the stack
 * entry along with the context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_destroy_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>simple_econtext_stack</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>stack_econtext</name></name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>simple_econtext_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_xact_cb --- post-transaction-commit-or-abort cleanup
 *
 * If a simple-expression EState was created in the current transaction,
 * it has to be cleaned up.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_xact_cb</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If we are doing a clean transaction shutdown, free the EState (so that
     * any remaining resources will be released correctly). In an abort, we
     * expect the regular abort recovery procedures to release everything of
     * interest.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>XACT_EVENT_COMMIT</name> <operator>||</operator> <name>event</name> <operator>==</operator> <name>XACT_EVENT_PREPARE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Shouldn't be any econtext stack entries left at commit */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>simple_econtext_stack</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>shared_simple_eval_estate</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>shared_simple_eval_estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>shared_simple_eval_estate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>event</name> <operator>==</operator> <name>XACT_EVENT_ABORT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>shared_simple_eval_estate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_subxact_cb --- post-subtransaction-commit-or-abort cleanup
 *
 * Make sure any simple-expression econtexts created in the current
 * subtransaction get cleaned up.  We have to do this explicitly because
 * no other code knows which econtexts belong to which level of subxact.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_subxact_cb</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
                   <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_COMMIT_SUB</name> <operator>||</operator> <name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_ABORT_SUB</name></expr>)</condition>
    <block>{<block_content>
        <while>while <condition>(<expr><name>simple_econtext_stack</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
               <name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>xact_subxid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>stack_econtext</name></name></expr></argument>,
                            <argument><expr><operator>(</operator><name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_COMMIT_SUB</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>simple_econtext_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * assign_simple_var --- assign a new value to any VAR datum.
 *
 * This should be the only mechanism for assignment to simple variables,
 * lest we forget to update the paramLI image.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_simple_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name></type> <name>newvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>freeable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Free the old value if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>freeval</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
                                           <argument><expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
                                           <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Assign new value to datum */</comment>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>newvalue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>freeval</name></name> <operator>=</operator> <name>freeable</name></expr>;</expr_stmt>
    <comment type="block">/* And update the image in the common parameter list */</comment>
    <expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>,
                                            <argument><expr><name>isnull</name></expr></argument>,
                                            <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
    <comment type="block">/* these might be set already, but let's be sure */</comment>
    <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * free old value of a text variable and assign new value from C string
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_text_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_eval_using_params --- evaluate params of USING clause
 *
 * The result data structure is created in the stmt_mcontext, and should
 * be freed by resetting that context.
 */</comment>
<function><type><specifier>static</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type>
<name>exec_eval_using_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ppd</name> <operator>=</operator> <operator>(</operator><name>PreparedParamsData</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PreparedParamsData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>params</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>ppdtypmod</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>param</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>ppdtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><literal type="char">'n'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Treat 'unknown' parameters as text, since that's what most
             * people would expect. SPI_execute_with_args can coerce unknown
             * constants in a more intelligent way, but not unknown Params.
             * This code also takes care of copying into the right context.
             * Note we assume 'unknown' has the representation of C-string.
             */</comment>
            <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* pass-by-ref non null values must be copied into stmt_mcontext */</comment>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int16</name></type>        <name>typLen</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>typByVal</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>typByVal</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>ppd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open portal for dynamic query
 *
 * Caution: this resets the stmt_mcontext at exit.  We might eventually need
 * to move that responsibility to the callers, but currently no caller needs
 * to have statement-lifetime temp data that survives past this, so it's
 * simpler to do it here.
 */</comment>
<function><type><specifier>static</specifier> <name>Portal</name></type>
<name>exec_dynquery_with_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                          <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>dynquery</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portalname</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>restype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>restypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>querystr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Evaluate the string expression after the EXECUTE keyword. Its result is
     * the querystring we have to execute.
     */</comment>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>dynquery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query string argument of EXECUTE is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get the C-String representation */</comment>
    <expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy it into the stmt_mcontext before we clean up */</comment>
    <expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>querystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open an implicit cursor for the query.  We use
     * SPI_cursor_open_with_args even when there are no params, because this
     * avoids making and freeing one copy of the plan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>params</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>ppd</name> <operator>=</operator> <call><name>exec_eval_using_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_args</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>,
                                           <argument><expr><name>querystr</name></expr></argument>,
                                           <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,
                                           <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>,
                                           <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>,
                                           <argument><expr><name>cursorOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_args</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>,
                                           <argument><expr><name>querystr</name></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>,
                                           <argument><expr><name>cursorOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open implicit cursor for query \"%s\": %s"</literal></expr></argument>,
             <argument><expr><name>querystr</name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Release transient data */</comment>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>portal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a formatted string with information about an expression's parameters,
 * or NULL if the expression does not take any parameters.
 * The result is in the eval_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_expr_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>paramno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>paramstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>dno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>dno</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>, <argument><expr><name>dno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>paramdatum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>paramtypeid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>paramisnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>paramtypmod</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>curvar</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>paramtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramtypmod</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>paramdatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"%s%s = "</literal></expr></argument>,
                         <argument><expr><ternary><condition><expr><name>paramno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                         <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>paramisnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>paramdatum</name></expr></argument>, <argument><expr><name>paramtypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* double single quotes */</comment>
                    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>paramno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>paramstr</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a formatted string with information about PreparedParamsData, or NULL
 * if there are no parameters.
 * The result is in the eval_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_preparedparamsdata</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>paramno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>paramstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ppd</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"%s$%d = "</literal></expr></argument>,
                         <argument><expr><ternary><condition><expr><name>paramno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                         <argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>paramno</name></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* double single quotes */</comment>
                    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>paramstr</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
