<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/pgbench/pgbench.c"><comment type="block">/*
 * pgbench.c
 *
 * A simple benchmark program for PostgreSQL
 * Originally written by Tatsuo Ishii and enhanced by many contributors.
 *
 * src/bin/pgbench/pgbench.c
 * Copyright (c) 2000-2017, PostgreSQL Global Development Group
 * ALL RIGHTS RESERVED;
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE AUTHOR OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE AUTHOR OR DISTRIBUTORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHOR AND DISTRIBUTORS SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE AUTHOR AND DISTRIBUTORS HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_SETSIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>            <comment type="block">/* set before winsock2.h is included */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* ! WIN32 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>        <comment type="block">/* for getrlimit */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_PI</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI</name></cpp:macro> <cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgbench.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_UNDEFINED_TABLE</name></cpp:macro>  <cpp:value>"42P01"</cpp:value></cpp:define>

<comment type="block">/*
 * Multi-platform pthread implementations
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/* Use native win32 threads on Windows */</comment>
<typedef>typedef <type><name><name>struct</name> <name>win32_pthread</name></name> <modifier>*</modifier></type><name>pthread_t</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>pthread_attr_t</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>pthread_create</name><parameter_list>(<parameter><decl><type><name>pthread_t</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>pthread_attr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>start_routine</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>pthread_join</name><parameter_list>(<parameter><decl><type><name>pthread_t</name></type> <name>th</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>thread_return</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* Use platform-dependent pthread capability */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* No threads implementation, use none (-j 1) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_t</name></cpp:macro> <cpp:value>void *</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block" format="doxygen">/********************************************************************
 * some configurable parameters */</comment>

<comment type="block">/* max number of clients allowed */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FD_SETSIZE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCLIENTS</name></cpp:macro>    <cpp:value>(FD_SETSIZE - 10)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCLIENTS</name></cpp:macro>    <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_STEP_SECONDS</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>    <comment type="block">/* seconds between log messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_NXACTS</name></cpp:macro>    <cpp:value>10</cpp:value></cpp:define>        <comment type="block">/* default nxacts */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_GAUSSIAN_PARAM</name></cpp:macro>        <cpp:value>2.0</cpp:value></cpp:define> <comment type="block">/* minimum parameter for gauss */</comment>

<decl_stmt><decl><type><name>int</name></type>            <name>nxacts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* number of transactions per client */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>duration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* duration in seconds */</comment>
<decl_stmt><decl><type><name>int64</name></type>        <name>end_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* when to stop in micro seconds, under -T */</comment>

<comment type="block">/*
 * scaling factor. for example, scale = 10 will make 1000000 tuples in
 * pgbench_accounts table.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>scale</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * fillfactor. for example, fillfactor = 90 will use only 90 percent
 * space during inserts and leave 10 percent free.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>fillfactor</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * create foreign key constraints on the tables?
 */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>foreign_keys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * use unlogged tables?
 */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>unlogged_tables</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * log sampling rate (1.0 = log everything, 0.0 = option not given)
 */</comment>
<decl_stmt><decl><type><name>double</name></type>        <name>sample_rate</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * When threads are throttled to a given rate limit, this is the target delay
 * to reach that rate in usec.  0 is the default and means no throttling.
 */</comment>
<decl_stmt><decl><type><name>int64</name></type>        <name>throttle_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Transactions which take longer than this limit (in usec) are counted as
 * late, and reported as such, although they are completed anyway. When
 * throttling is enabled, execution time slots that are more than this late
 * are skipped altogether, and counted separately.
 */</comment>
<decl_stmt><decl><type><name>int64</name></type>        <name>latency_limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * tablespace selection
 */</comment>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>index_tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * end of configurable parameters
 *********************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nbranches</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>            <comment type="block">/* Makes little sense to change this.  Change
                                 * -s instead */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ntellers</name></cpp:macro>    <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>naccounts</name></cpp:macro>    <cpp:value>100000</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>        <name>use_branch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* use branch id in DDL and DML */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * The scale factor at/beyond which 32bit integers are incapable of storing
 * 64bit values.
 *
 * Although the actual threshold is 21474, we use 20000 because it is easier to
 * document and remember, and isn't that far away from the real threshold.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCALE_32BIT_THRESHOLD</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>

<decl_stmt><decl><type><name>bool</name></type>        <name>use_log</name></decl>;</decl_stmt>            <comment type="block">/* log transaction latencies to a file */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>use_quiet</name></decl>;</decl_stmt>            <comment type="block">/* quiet logging onto stderr */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>agg_interval</name></decl>;</decl_stmt>        <comment type="block">/* log aggregates instead of individual
                                 * transactions */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>per_script_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* whether to collect stats per script */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>progress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* thread progress report every this seconds */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>progress_timestamp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* progress report with Unix time */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>nclients</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* number of clients */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>nthreads</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* number of threads */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>is_connect</name></decl>;</decl_stmt>            <comment type="block">/* establish connection for each transaction */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>is_latencies</name></decl>;</decl_stmt>        <comment type="block">/* report per-command latencies */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>main_pid</name></decl>;</decl_stmt>            <comment type="block">/* main process id used in log filename */</comment>

<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pghost</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pgport</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>login</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dbName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>logfile_prefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WSEP</name></cpp:macro> <cpp:value>'@'</cpp:value></cpp:define>                <comment type="block">/* weight separator */</comment>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>timer_exceeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* flag from signal handler */</comment>

<comment type="block">/*
 * Variable definitions.  If a variable has a string value, "value" is that
 * value, is_numeric is false, and num_value is undefined.  If the value is
 * known to be numeric, is_numeric is true and num_value contains the value
 * (in any permitted numeric variant).  In this case "value" contains the
 * string equivalent of the number, if we've had occasion to compute that,
 * or NULL if we haven't.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>            <comment type="block">/* variable's name */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>            <comment type="block">/* its value in string form, if known */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_numeric</name></decl>;</decl_stmt>        <comment type="block">/* is numeric value known? */</comment>
    <decl_stmt><decl><type><name>PgBenchValue</name></type> <name>num_value</name></decl>;</decl_stmt>        <comment type="block">/* variable's value in numeric form */</comment>
}</block></struct></type> <name>Variable</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SCRIPTS</name></cpp:macro>        <cpp:value>128</cpp:value></cpp:define>        <comment type="block">/* max number of SQL scripts allowed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_COMMAND_SIZE</name></cpp:macro>    <cpp:value>256</cpp:value></cpp:define> <comment type="block">/* maximum size allowed for shell command */</comment>

<comment type="block">/*
 * Simple data structure to keep stats about something.
 *
 * XXX probably the first value should be kept and used as an offset for
 * better numerical stability...
 */</comment>
<typedef>typedef <type><struct>struct <name>SimpleStats</name>
<block>{
    <decl_stmt><decl><type><name>int64</name></type>        <name>count</name></decl>;</decl_stmt>            <comment type="block">/* how many values were encountered */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>min</name></decl>;</decl_stmt>            <comment type="block">/* the minimum seen */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>max</name></decl>;</decl_stmt>            <comment type="block">/* the maximum seen */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>sum</name></decl>;</decl_stmt>            <comment type="block">/* sum of values */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>sum2</name></decl>;</decl_stmt>            <comment type="block">/* sum of squared values */</comment>
}</block></struct></type> <name>SimpleStats</name>;</typedef>

<comment type="block">/*
 * Data structure to hold various statistics: per-thread and per-script stats
 * are maintained and merged together.
 */</comment>
<typedef>typedef <type><struct>struct <name>StatsData</name>
<block>{
    <decl_stmt><decl><type><name>time_t</name></type>        <name>start_time</name></decl>;</decl_stmt>        <comment type="block">/* interval start time, for aggregates */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>cnt</name></decl>;</decl_stmt>            <comment type="block">/* number of transactions */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>skipped</name></decl>;</decl_stmt>        <comment type="block">/* number of transactions skipped under --rate
                                 * and --latency-limit */</comment>
    <decl_stmt><decl><type><name>SimpleStats</name></type> <name>latency</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SimpleStats</name></type> <name>lag</name></decl>;</decl_stmt>
}</block></struct></type> <name>StatsData</name>;</typedef>

<comment type="block">/*
 * Connection state machine states.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <comment type="block">/*
     * The client must first choose a script to execute.  Once chosen, it can
     * either be throttled (state CSTATE_START_THROTTLE under --rate) or start
     * right away (state CSTATE_START_TX).
     */</comment>
    <decl><name>CSTATE_CHOOSE_SCRIPT</name></decl>,

    <comment type="block">/*
     * In CSTATE_START_THROTTLE state, we calculate when to begin the next
     * transaction, and advance to CSTATE_THROTTLE.  CSTATE_THROTTLE state
     * sleeps until that moment.  (If throttling is not enabled, doCustom()
     * falls directly through from CSTATE_START_THROTTLE to CSTATE_START_TX.)
     */</comment>
    <decl><name>CSTATE_START_THROTTLE</name></decl>,
    <decl><name>CSTATE_THROTTLE</name></decl>,

    <comment type="block">/*
     * CSTATE_START_TX performs start-of-transaction processing.  Establishes
     * a new connection for the transaction, in --connect mode, and records
     * the transaction start time.
     */</comment>
    <decl><name>CSTATE_START_TX</name></decl>,

    <comment type="block">/*
     * We loop through these states, to process each command in the script:
     *
     * CSTATE_START_COMMAND starts the execution of a command.  On a SQL
     * command, the command is sent to the server, and we move to
     * CSTATE_WAIT_RESULT state.  On a \sleep meta-command, the timer is set,
     * and we enter the CSTATE_SLEEP state to wait for it to expire. Other
     * meta-commands are executed immediately.
     *
     * CSTATE_WAIT_RESULT waits until we get a result set back from the server
     * for the current command.
     *
     * CSTATE_SLEEP waits until the end of \sleep.
     *
     * CSTATE_END_COMMAND records the end-of-command timestamp, increments the
     * command counter, and loops back to CSTATE_START_COMMAND state.
     */</comment>
    <decl><name>CSTATE_START_COMMAND</name></decl>,
    <decl><name>CSTATE_WAIT_RESULT</name></decl>,
    <decl><name>CSTATE_SLEEP</name></decl>,
    <decl><name>CSTATE_END_COMMAND</name></decl>,

    <comment type="block">/*
     * CSTATE_END_TX performs end-of-transaction processing.  Calculates
     * latency, and logs the transaction.  In --connect mode, closes the
     * current connection.  Chooses the next script to execute and starts over
     * in CSTATE_START_THROTTLE state, or enters CSTATE_FINISHED if we have no
     * more work to do.
     */</comment>
    <decl><name>CSTATE_END_TX</name></decl>,

    <comment type="block">/*
     * Final states.  CSTATE_ABORTED means that the script execution was
     * aborted because a command failed, CSTATE_FINISHED means success.
     */</comment>
    <decl><name>CSTATE_ABORTED</name></decl>,
    <decl><name>CSTATE_FINISHED</name></decl>
}</block></enum></type> <name>ConnectionStateEnum</name>;</typedef>

<comment type="block">/*
 * Connection state.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>            <comment type="block">/* connection handle to DB */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>id</name></decl>;</decl_stmt>                <comment type="block">/* client No. */</comment>
    <decl_stmt><decl><type><name>ConnectionStateEnum</name></type> <name>state</name></decl>;</decl_stmt>    <comment type="block">/* state machine's current state. */</comment>

    <decl_stmt><decl><type><name>int</name></type>            <name>use_file</name></decl>;</decl_stmt>        <comment type="block">/* index in sql_script for this client */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>command</name></decl>;</decl_stmt>        <comment type="block">/* command number in script */</comment>

    <comment type="block">/* client variables */</comment>
    <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>variables</name></decl>;</decl_stmt>        <comment type="block">/* array of variable definitions */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nvariables</name></decl>;</decl_stmt>        <comment type="block">/* number of variables */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>vars_sorted</name></decl>;</decl_stmt>    <comment type="block">/* are variables sorted by name? */</comment>

    <comment type="block">/* various times about current transaction */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>txn_scheduled</name></decl>;</decl_stmt>    <comment type="block">/* scheduled start time of transaction (usec) */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>sleep_until</name></decl>;</decl_stmt>    <comment type="block">/* scheduled start time of next cmd (usec) */</comment>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>txn_begin</name></decl>;</decl_stmt>        <comment type="block">/* used for measuring schedule lag times */</comment>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>stmt_begin</name></decl>;</decl_stmt>        <comment type="block">/* used for measuring statement latencies */</comment>

    <decl_stmt><decl><type><name>bool</name></type>        <name><name>prepared</name><index>[<expr><name>MAX_SCRIPTS</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* whether client prepared the script */</comment>

    <comment type="block">/* per client collected stats */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>cnt</name></decl>;</decl_stmt>            <comment type="block">/* transaction count */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>ecnt</name></decl>;</decl_stmt>            <comment type="block">/* error count */</comment>
}</block></struct></type> <name>CState</name>;</typedef>

<comment type="block">/*
 * Thread state
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>tid</name></decl>;</decl_stmt>            <comment type="block">/* thread id */</comment>
    <decl_stmt><decl><type><name>pthread_t</name></type>    <name>thread</name></decl>;</decl_stmt>            <comment type="block">/* thread handle */</comment>
    <decl_stmt><decl><type><name>CState</name>       <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>            <comment type="block">/* array of CState */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nstate</name></decl>;</decl_stmt>            <comment type="block">/* length of state[] */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name><name>random_state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* separate randomness for each thread */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>throttle_trigger</name></decl>;</decl_stmt>    <comment type="block">/* previous/next throttling (us) */</comment>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>logfile</name></decl>;</decl_stmt>        <comment type="block">/* where to log, or NULL */</comment>

    <comment type="block">/* per thread collected stats */</comment>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>start_time</name></decl>;</decl_stmt>        <comment type="block">/* thread start time */</comment>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>conn_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StatsData</name></type>    <name>stats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>latency_late</name></decl>;</decl_stmt>    <comment type="block">/* executed but late transactions */</comment>
}</block></struct></type> <name>TState</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_THREAD</name></cpp:macro>        <cpp:value>((pthread_t) 0)</cpp:value></cpp:define>

<comment type="block">/*
 * queries read from files
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_COMMAND</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COMMAND</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ARGS</name></cpp:macro>        <cpp:value>10</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <name>QueryMode</name>
<block>{
    <decl><name>QUERY_SIMPLE</name></decl>,                <comment type="block">/* simple query */</comment>
    <decl><name>QUERY_EXTENDED</name></decl>,                <comment type="block">/* extended query */</comment>
    <decl><name>QUERY_PREPARED</name></decl>,                <comment type="block">/* extended query with prepared statements */</comment>
    <decl><name>NUM_QUERYMODE</name></decl>
}</block></enum></type> <name>QueryMode</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>QueryMode</name></type> <name>querymode</name> <init>= <expr><name>QUERY_SIMPLE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>QUERYMODE</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"simple"</literal></expr>, <expr><literal type="string">"extended"</literal></expr>, <expr><literal type="string">"prepared"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>            <comment type="block">/* text of command line */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>command_num</name></decl>;</decl_stmt>    <comment type="block">/* unique index of this Command struct */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>type</name></decl>;</decl_stmt>            <comment type="block">/* command type (SQL_COMMAND or META_COMMAND) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>argc</name></decl>;</decl_stmt>            <comment type="block">/* number of command words */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name><name>argv</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* command word list */</comment>
    <decl_stmt><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>            <comment type="block">/* parsed expression, if needed */</comment>
    <decl_stmt><decl><type><name>SimpleStats</name></type> <name>stats</name></decl>;</decl_stmt>            <comment type="block">/* time spent in this command */</comment>
}</block></struct></type> <name>Command</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParsedScript</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>            <comment type="block">/* script descriptor (eg, file name) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>weight</name></decl>;</decl_stmt>            <comment type="block">/* selection weight */</comment>
    <decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name></decl>;</decl_stmt>        <comment type="block">/* NULL-terminated array of Commands */</comment>
    <decl_stmt><decl><type><name>StatsData</name></type>    <name>stats</name></decl>;</decl_stmt>            <comment type="block">/* total time spent in script */</comment>
}</block></struct></type> <name>ParsedScript</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ParsedScript</name></type> <name><name>sql_script</name><index>[<expr><name>MAX_SCRIPTS</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* SQL script files */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>num_scripts</name></decl>;</decl_stmt>        <comment type="block">/* number of scripts in sql_script[] */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>num_commands</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* total number of Command structs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>total_weight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>debug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* debug flag */</comment>

<comment type="block">/* Builtin test scripts */</comment>
<typedef>typedef <type><struct>struct <name>BuiltinScript</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>            <comment type="block">/* very short name for -b ... */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>            <comment type="block">/* short description */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>script</name></decl>;</decl_stmt>            <comment type="block">/* actual pgbench script */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type>    <name>branch</name></decl>;</decl_stmt>            <comment type="block">/* additional branch conditions */</comment>
}</block></struct></type> <name>BuiltinScript</name>;</typedef>



<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>BuiltinScript</name></type> <name><name>builtin_script</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><block>{
        <expr><literal type="string">"tpcb-like"</literal></expr>,
        <expr><literal type="string">"&lt;builtin: TPC-B (sort of)&gt;"</literal></expr>,
        <expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set bid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>nbranches</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set tid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>ntellers</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set delta random(-5000, 5000)\n"</literal>
        <literal type="string">"BEGIN;\n"</literal>
        <literal type="string">"UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;\n"</literal>
        <literal type="string">"SELECT abalance FROM pgbench_accounts WHERE aid = :aid;\n"</literal>
        <literal type="string">"UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;\n"</literal>
        <literal type="string">"UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;\n"</literal>
        <literal type="string">"INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\n"</literal>
        <literal type="string">"END;\n"</literal></expr>,
        <expr><name>false</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><literal type="string">"simple-update"</literal></expr>,
        <expr><literal type="string">"&lt;builtin: simple update&gt;"</literal></expr>,
        <expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set bid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>nbranches</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set tid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>ntellers</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set delta random(-5000, 5000)\n"</literal>
        <literal type="string">"BEGIN;\n"</literal>
        <literal type="string">"UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;\n"</literal>
        <literal type="string">"SELECT abalance FROM pgbench_accounts WHERE aid = :aid;\n"</literal>
        <literal type="string">"INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\n"</literal>
        <literal type="string">"END;\n"</literal></expr>,
        <expr><name>false</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><literal type="string">"select-only"</literal></expr>,
        <expr><literal type="string">"&lt;builtin: select only&gt;"</literal></expr>,
        <expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"SELECT abalance FROM pgbench_accounts WHERE aid = :aid;\n"</literal></expr>,
        <expr><name>false</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><literal type="string">"tpcb-like"</literal></expr>,
        <expr><literal type="string">"&lt;builtin: TPC-B (sort of)&gt;"</literal></expr>,
        <expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set bid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>nbranches</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set tid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>ntellers</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set delta random(-5000, 5000)\n"</literal>
        <literal type="string">"BEGIN;\n"</literal>
        <literal type="string">"UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid AND bid = :bid;\n"</literal>
        <literal type="string">"SELECT abalance FROM pgbench_accounts WHERE aid = :aid AND bid = :bid;\n"</literal>
        <literal type="string">"UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid AND bid = :bid;\n"</literal>
        <literal type="string">"UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;\n"</literal>
        <literal type="string">"INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\n"</literal>
        <literal type="string">"END;\n"</literal></expr>,
        <expr><name>true</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><literal type="string">"simple-update"</literal></expr>,
        <expr><literal type="string">"&lt;builtin: simple update bid&gt;"</literal></expr>,
        <expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set bid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>nbranches</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set tid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>ntellers</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set delta random(-5000, 5000)\n"</literal>
        <literal type="string">"BEGIN;\n"</literal>
        <literal type="string">"UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid AND bid = :bid;\n"</literal>
        <literal type="string">"SELECT abalance FROM pgbench_accounts WHERE aid = :aid AND bid = :bid;\n"</literal>
        <literal type="string">"INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\n"</literal>
        <literal type="string">"END;\n"</literal></expr>,
        <expr><name>true</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><literal type="string">"select-only"</literal></expr>,
        <expr><literal type="string">"&lt;builtin: select only&gt;"</literal></expr>,
        <expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"\\set bid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>nbranches</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
        <literal type="string">"SELECT abalance FROM pgbench_accounts WHERE aid = :aid AND bid = :bid;\n"</literal></expr>,
        <expr><name>true</name></expr>
    }</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setIntValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>ival</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setDoubleValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>evaluateExpr</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doLog</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
      <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>latency</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processXactStats</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>now</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgbench_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addScript</name><parameter_list>(<parameter><decl><type><name>ParsedScript</name></type> <name>script</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>threadRun</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setalarm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* callback functions for our flex lexer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PsqlScanCallbacks</name></type> <name>pgbench_callbacks</name> <init>= <expr><block>{
    <expr><name>NULL</name></expr>,                        <comment type="block">/* don't need get_variable functionality */</comment>
    <expr><name>pgbench_error</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s is a benchmarking tool for PostgreSQL.\n\n"</literal>
           <literal type="string">"Usage:\n"</literal>
           <literal type="string">"  %s [OPTION]... [DBNAME]\n"</literal>
           <literal type="string">"\nInitialization options:\n"</literal>
           <literal type="string">"  -i, --initialize         invokes initialization mode\n"</literal>
           <literal type="string">"  -F, --fillfactor=NUM     set fill factor\n"</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
           <literal type="string">"  -k                       distribute tables by branch id (bid)\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
           <literal type="string">"  -n, --no-vacuum          do not run VACUUM after initialization\n"</literal>
           <literal type="string">"  -q, --quiet              quiet logging (one message each 5 seconds)\n"</literal>
           <literal type="string">"  -s, --scale=NUM          scaling factor\n"</literal>
           <literal type="string">"  --foreign-keys           create foreign key constraints between tables\n"</literal>
           <literal type="string">"  --index-tablespace=TABLESPACE\n"</literal>
           <literal type="string">"                           create indexes in the specified tablespace\n"</literal>
           <literal type="string">"  --tablespace=TABLESPACE  create tables in the specified tablespace\n"</literal>
           <literal type="string">"  --unlogged-tables        create tables as unlogged tables\n"</literal>
           <literal type="string">"\nOptions to select what to run:\n"</literal>
           <literal type="string">"  -b, --builtin=NAME[@W]   add builtin script NAME weighted at W (default: 1)\n"</literal>
           <literal type="string">"                           (use \"-b list\" to list available scripts)\n"</literal>
           <literal type="string">"  -f, --file=FILENAME[@W]  add script FILENAME weighted at W (default: 1)\n"</literal>
           <literal type="string">"  -N, --skip-some-updates  skip updates of pgbench_tellers and pgbench_branches\n"</literal>
           <literal type="string">"                           (same as \"-b simple-update\")\n"</literal>
           <literal type="string">"  -S, --select-only        perform SELECT-only transactions\n"</literal>
           <literal type="string">"                           (same as \"-b select-only\")\n"</literal>
           <literal type="string">"\nBenchmarking options:\n"</literal>
           <literal type="string">"  -c, --client=NUM         number of concurrent database clients (default: 1)\n"</literal>
           <literal type="string">"  -C, --connect            establish new connection for each transaction\n"</literal>
           <literal type="string">"  -D, --define=VARNAME=VALUE\n"</literal>
           <literal type="string">"                           define variable for use by custom script\n"</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
           <literal type="string">"  -k                       query with additional branch id (bid) key\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
           <literal type="string">"  -j, --jobs=NUM           number of threads (default: 1)\n"</literal>
           <literal type="string">"  -l, --log                write transaction times to log file\n"</literal>
           <literal type="string">"  -L, --latency-limit=NUM  count transactions lasting more than NUM ms as late\n"</literal>
           <literal type="string">"  -M, --protocol=simple|extended|prepared\n"</literal>
           <literal type="string">"                           protocol for submitting queries (default: simple)\n"</literal>
           <literal type="string">"  -n, --no-vacuum          do not run VACUUM before tests\n"</literal>
           <literal type="string">"  -P, --progress=NUM       show thread progress report every NUM seconds\n"</literal>
           <literal type="string">"  -r, --report-latencies   report average latency per command\n"</literal>
           <literal type="string">"  -R, --rate=NUM           target rate in transactions per second\n"</literal>
           <literal type="string">"  -s, --scale=NUM          report this scale factor in output\n"</literal>
           <literal type="string">"  -t, --transactions=NUM   number of transactions each client runs (default: 10)\n"</literal>
           <literal type="string">"  -T, --time=NUM           duration of benchmark test in seconds\n"</literal>
           <literal type="string">"  -v, --vacuum-all         vacuum all four standard tables before tests\n"</literal>
           <literal type="string">"  --aggregate-interval=NUM aggregate data over NUM seconds\n"</literal>
           <literal type="string">"  --log-prefix=PREFIX      prefix for transaction time log file\n"</literal>
           <literal type="string">"                           (default: \"pgbench_log\")\n"</literal>
           <literal type="string">"  --progress-timestamp     use Unix epoch timestamps for progress\n"</literal>
           <literal type="string">"  --sampling-rate=NUM      fraction of transactions to log (e.g., 0.01 for 1%%)\n"</literal>
           <literal type="string">"\nCommon options:\n"</literal>
           <literal type="string">"  -d, --debug              print debugging output\n"</literal>
           <literal type="string">"  -h, --host=HOSTNAME      database server host or socket directory\n"</literal>
           <literal type="string">"  -p, --port=PORT          database server port number\n"</literal>
           <literal type="string">"  -U, --username=USERNAME  connect as specified database user\n"</literal>
           <literal type="string">"  -V, --version            output version information, then exit\n"</literal>
           <literal type="string">"  -?, --help               show this help, then exit\n"</literal>
           <literal type="string">"\n"</literal>
           <literal type="string">"Report bugs to &lt;pgsql-bugs@postgresql.org&gt;.\n"</literal></expr></argument>,
           <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return whether str matches "^\s*[-+]?[0-9]+$" */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_an_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* skip leading spaces; cast is consistent with strtoint64 */</comment>
    <while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* skip sign */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* at least one digit */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* eat all digits */</comment>
    <while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* must have reached end of string */</comment>
    <return>return <expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * strtoint64 -- convert a string to 64-bit integer
 *
 * This function is a modified version of scanint8() from
 * src/backend/utils/adt/int8.c.
 */</comment>
<function><type><name>int64</name></type>
<name>strtoint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Do our own scan, rather than relying on sscanf which might be broken
     * for long long.
     */</comment>

    <comment type="block">/* skip leading spaces */</comment>
    <while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* handle sign */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Do an explicit check for INT64_MIN.  Ugly though this is, it's
         * cleaner than trying to get the loop below to handle it portably.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"9223372036854775808"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>PG_INT64_MIN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">19</literal></expr>;</expr_stmt>
            <goto>goto <name>gotdigits</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* require at least one digit */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid input syntax for integer: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* process digits */</comment>
    <while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64</name></type>        <name>tmp</name> <init>= <expr><name>result</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>ptr</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator> <operator>!=</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* overflow? */</comment>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"value \"%s\" is out of range for type bigint\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></while>

<label><name>gotdigits</name>:</label>

    <comment type="block">/* allow trailing whitespace, but not other trailing chars */</comment>
    <while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid input syntax for integer: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>result</name></expr> </then><else>: <expr><name>result</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* random number generator: uniform distribution from min to max inclusive */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getrand</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Odd coding is so that min and max have approximately the same chance of
     * being selected as do numbers between them.
     *
     * pg_erand48() is thread-safe and concurrent, which is why we use it
     * rather than random(), which in glibc is non-reentrant, and therefore
     * protected by a mutex, and therefore a bottleneck on machines with many
     * CPUs.
     */</comment>
    <return>return <expr><name>min</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * random number generator: exponential distribution from min to max inclusive.
 * the parameter is so that the density of probability for the last cut-off max
 * value is exp(-parameter).
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getExponentialRand</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>parameter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>cut</name></decl>,
                <decl><type ref="prev"/><name>uniform</name></decl>,
                <decl><type ref="prev"/><name>rand</name></decl>;</decl_stmt>

    <comment type="block">/* abort if wrong parameter, but must really be checked beforehand */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parameter</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cut</name> <operator>=</operator> <call><name>exp</name><argument_list>(<argument><expr><operator>-</operator><name>parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* erand in [0, 1), uniform in (0, 1] */</comment>
    <expr_stmt><expr><name>uniform</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * inner expression in (cut, 1] (if parameter &gt; 0), rand in [0, 1)
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>cut</name><operator>)</operator> <operator>!=</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rand</name> <operator>=</operator> <operator>-</operator><call><name>log</name><argument_list>(<argument><expr><name>cut</name> <operator>+</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>cut</name><operator>)</operator> <operator>*</operator> <name>uniform</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>parameter</name></expr>;</expr_stmt>
    <comment type="block">/* return int64 random number within between min and max */</comment>
    <return>return <expr><name>min</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>rand</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* random number generator: gaussian distribution from min to max inclusive */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getGaussianRand</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>parameter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>stdev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>rand</name></decl>;</decl_stmt>

    <comment type="block">/* abort if parameter is too low, but must really be checked beforehand */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parameter</name> <operator>&gt;=</operator> <name>MIN_GAUSSIAN_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get user specified random number from this loop, with -parameter &lt;
     * stdev &lt;= parameter
     *
     * This loop is executed until the number is in the expected range.
     *
     * As the minimum parameter is 2.0, the probability of looping is low:
     * sqrt(-2 ln(r)) &lt;= 2 =&gt; r &gt;= e^{-2} ~ 0.135, then when taking the
     * average sinus multiplier as 2/pi, we have a 8.6% looping probability in
     * the worst case. For a parameter value of 5.0, the looping probability
     * is about e^{-5} * 2 / pi ~ 0.43%.
     */</comment>
    <do>do
    <block>{<block_content>
        <comment type="block">/*
         * pg_erand48 generates [0,1), but for the basic version of the
         * Box-Muller transform the two uniformly distributed random numbers
         * are expected in (0, 1] (see
         * http://en.wikipedia.org/wiki/Box_muller)
         */</comment>
        <decl_stmt><decl><type><name>double</name></type>        <name>rand1</name> <init>= <expr><literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>rand2</name> <init>= <expr><literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Box-Muller basic form transform */</comment>
        <decl_stmt><decl><type><name>double</name></type>        <name>var_sqrt</name> <init>= <expr><call><name>sqrt</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2.0</literal> <operator>*</operator> <call><name>log</name><argument_list>(<argument><expr><name>rand1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>stdev</name> <operator>=</operator> <name>var_sqrt</name> <operator>*</operator> <call><name>sin</name><argument_list>(<argument><expr><literal type="number">2.0</literal> <operator>*</operator> <name>M_PI</name> <operator>*</operator> <name>rand2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * we may try with cos, but there may be a bias induced if the
         * previous value fails the test. To be on the safe side, let us try
         * over.
         */</comment>
    </block_content>}</block>
    while <condition>(<expr><name>stdev</name> <operator>&lt;</operator> <operator>-</operator><name>parameter</name> <operator>||</operator> <name>stdev</name> <operator>&gt;=</operator> <name>parameter</name></expr>)</condition>;</do>

    <comment type="block">/* stdev is in [-parameter, parameter), normalization to [0,1) */</comment>
    <expr_stmt><expr><name>rand</name> <operator>=</operator> <operator>(</operator><name>stdev</name> <operator>+</operator> <name>parameter</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>parameter</name> <operator>*</operator> <literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* return int64 random number within between min and max */</comment>
    <return>return <expr><name>min</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>rand</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * random number generator: generate a value, such that the series of values
 * will approximate a Poisson distribution centered on the given value.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getPoissonRand</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>center</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Use inverse transform sampling to generate a value &gt; 0, such that the
     * expected (i.e. average) value is the given argument.
     */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>uniform</name></decl>;</decl_stmt>

    <comment type="block">/* erand in [0, 1), uniform in (0, 1] */</comment>
    <expr_stmt><expr><name>uniform</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>-</operator><call><name>log</name><argument_list>(<argument><expr><name>uniform</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>center</name><operator>)</operator> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the given SimpleStats struct to all zeroes
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initSimpleStats</name><parameter_list>(<parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SimpleStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate one value into a SimpleStats struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addToSimpleStats</name><parameter_list>(<parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>val</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>min</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>val</name> <operator>&gt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>sum</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>sum2</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Merge two SimpleStats objects
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mergeSimpleStats</name><parameter_list>(<parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>, <parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ss</name><operator>-&gt;</operator><name>min</name></name> <operator>&lt;</operator> <name><name>acc</name><operator>-&gt;</operator><name>min</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>min</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ss</name><operator>-&gt;</operator><name>max</name></name> <operator>&gt;</operator> <name><name>acc</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>max</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>ss</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>sum</name></name> <operator>+=</operator> <name><name>ss</name><operator>-&gt;</operator><name>sum</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>sum2</name></name> <operator>+=</operator> <name><name>ss</name><operator>-&gt;</operator><name>sum2</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a StatsData struct to mostly zeroes, with its start time set to
 * the given value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initStats</name><parameter_list>(<parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>start_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>start_time</name></name> <operator>=</operator> <name>start_time</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>skipped</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sd</name><operator>-&gt;</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sd</name><operator>-&gt;</operator><name>lag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate one additional item into the given stats object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accumStats</name><parameter_list>(<parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lat</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>skipped</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* no latency to record on skipped transactions */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>skipped</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>addToSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>latency</name></name></expr></argument>, <argument><expr><name>lat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* and possibly the same for schedule lag */</comment>
        <if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addToSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>lag</name></name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* call PQexec() and exit() on failure */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>executeStatement</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* call PQexec() and complain, but without exiting, on failure */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tryExecuteStatement</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"(ignoring this error and continuing anyway)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* set up a connection to the backend */</comment>
<function><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type>
<name>doConnect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>new_pass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>have_password</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>password</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Start the connection.  Loop until we have a password if requested by
     * backend.
     */</comment>
    <do>do
    <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAMS_ARRAY_SIZE</name></cpp:macro>    <cpp:value>7</cpp:value></cpp:define>

        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>keywords</name><index>[<expr><name>PARAMS_ARRAY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>values</name><index>[<expr><name>PARAMS_ARRAY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pghost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pgport</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>login</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"password"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>have_password</name></expr> ?</condition><then> <expr><name>password</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>dbName</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>progname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"connection to database \"%s\" failed\n"</literal></expr></argument>,
                    <argument><expr><name>dbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name> <operator>&amp;&amp;</operator>
            <call><name>PQconnectionNeedsPassword</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><name>have_password</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>have_password</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>new_pass</name></expr>)</condition>;</do>

    <comment type="block">/* check to see that the backend connection was successfully made */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"connection to database \"%s\" failed:\n%s"</literal></expr></argument>,
                <argument><expr><name>dbName</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* throw away response from backend */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>discard_response</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>res</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* qsort comparator for Variable array */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compareVariableNames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Variable</name> <operator>*</operator><operator>)</operator> <name>v1</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>,
                  <argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Variable</name> <operator>*</operator><operator>)</operator> <name>v2</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Locate a variable by name; returns NULL if unknown */</comment>
<function><type><specifier>static</specifier> <name>Variable</name> <modifier>*</modifier></type>
<name>lookupVariable</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Variable</name></type>    <name>key</name></decl>;</decl_stmt>

    <comment type="block">/* On some versions of Solaris, bsearch of zero items dumps core */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>nvariables</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Sort if we have to */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>vars_sorted</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>nvariables</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>compareVariableNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>vars_sorted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now we can search */</comment>
    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>Variable</name> <operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>,
                                <argument><expr><name><name>st</name><operator>-&gt;</operator><name>nvariables</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                <argument><expr><name>compareVariableNames</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the value of a variable, in string form; returns NULL if unknown */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getVariable</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>stringform</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* not found */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* we have it in string form */</comment>

    <comment type="block">/* We need to produce a string equivalent of the numeric value */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>is_numeric</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>num_value</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>num_value</name><operator>.</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>num_value</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><literal type="string">"%.*g"</literal></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>num_value</name><operator>.</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Try to convert variable to numeric form; return false on failure */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>makeVariableNumeric</name><parameter_list>(<parameter><decl><type><name>Variable</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>is_numeric</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* no work */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>is_an_int</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>num_value</name></name></expr></argument>, <argument><expr><call><name>strtoint64</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>is_numeric</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else                        <comment type="block">/* type should be double */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>dv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>xs</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"%lf%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"malformed variable \"%s\" value: \"%s\"\n"</literal></expr></argument>,
                    <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>num_value</name></name></expr></argument>, <argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>is_numeric</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* check whether the name consists of alphabets, numerals and underscores. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isLegalVariableName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>(</operator><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>                <comment type="block">/* must be non-empty */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup a variable by name, creating it if need be.
 * Caller is expected to assign a value to the variable.
 * Returns NULL on failure (bad name).
 */</comment>
<function><type><specifier>static</specifier> <name>Variable</name> <modifier>*</modifier></type>
<name>lookupCreateVariable</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>newvars</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Check for the name only when declaring a new variable to avoid
         * overhead.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isLegalVariableName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: invalid variable name: \"%s\"\n"</literal></expr></argument>,
                    <argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Create variable at the end of the array */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newvars</name> <operator>=</operator> <operator>(</operator><name>Variable</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>,
                                              <argument><expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>nvariables</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>newvars</name> <operator>=</operator> <operator>(</operator><name>Variable</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>variables</name></name> <operator>=</operator> <name>newvars</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>&amp;</operator><name><name>newvars</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>nvariables</name></name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <comment type="block">/* caller is expected to initialize remaining fields */</comment>

        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>nvariables</name></name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* we don't re-sort the array till we have to */</comment>
        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>vars_sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assign a string value to a variable, creating it if need be */</comment>
<comment type="block">/* Returns false on failure (bad name) */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>putVariable</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupCreateVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* dup then free, in case value is pointing at this variable */</comment>
    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>is_numeric</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assign a numeric value to a variable, creating it if need be */</comment>
<comment type="block">/* Returns false on failure (bad name) */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>putVariableNumber</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>PgBenchValue</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupCreateVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>is_numeric</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>num_value</name></name> <operator>=</operator> <operator>*</operator><name>value</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assign an integer value to a variable, creating it if need be */</comment>
<comment type="block">/* Returns false on failure (bad name) */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>putVariableInt</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgBenchValue</name></type> <name>val</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>putVariableNumber</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parseVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>eaten</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>sql</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>sql</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sql</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>name</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>eaten</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>replaceVariable</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>valueln</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>valueln</name> <operator>&gt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>offset</name> <init>= <expr><name>param</name> <operator>-</operator> <operator>*</operator><name>sql</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>sql</name> <operator>=</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>sql</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>sql</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>len</name> <operator>+</operator> <name>valueln</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>*</operator><name>sql</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>valueln</name> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>param</name> <operator>+</operator> <name>valueln</name></expr></argument>, <argument><expr><name>param</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>param</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>valueln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>param</name> <operator>+</operator> <name>valueln</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>assignVariables</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>name</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>eaten</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>parseVariable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eaten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>replaceVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>eaten</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>sql</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>getQueryParams</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Command</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>command</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* get a value as an int, tell if there is a problem */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>coerceToInt</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>ival</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ival</name> <operator>=</operator> <name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>dval</name> <init>= <expr><name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dval</name> <operator>&lt;</operator> <name>PG_INT64_MIN</name> <operator>||</operator> <name>PG_INT64_MAX</name> <operator>&lt;</operator> <name>dval</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"double to int overflow for %f\n"</literal></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>ival</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>dval</name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* get a value as a double, or tell if there is a problem */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>coerceToDouble</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>dval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>dval</name> <operator>=</operator> <name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dval</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* assign an integer value */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setIntValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>ival</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>PGBT_INT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <name>ival</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* assign a double value */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setDoubleValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>PGBT_DOUBLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name> <operator>=</operator> <name>dval</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* maximum number of function arguments */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FARGS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
 * Recursive evaluation of functions
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evalFunc</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
         <parameter><decl><type><name>PgBenchFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>PgBenchExprLink</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* evaluate all function arguments */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgBenchValue</name></type> <name><name>vargs</name><index>[<expr><name>MAX_FARGS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgBenchExprLink</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name>args</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nargs</name> <operator>&lt;</operator> <name>MAX_FARGS</name> <operator>&amp;&amp;</operator> <name>l</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>nargs</name><operator>++</operator></expr><operator>,</operator> <expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><name>nargs</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><literal type="string">"too many function arguments, maximum is %d\n"</literal></expr></argument>, <argument><expr><name>MAX_FARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* then evaluate function */</comment>
    <switch>switch <condition>(<expr><name>func</name></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* overloaded operators */</comment>
        <case>case <expr><name>PGBENCH_ADD</name></expr>:</case>
        <case>case <expr><name>PGBENCH_SUB</name></expr>:</case>
        <case>case <expr><name>PGBENCH_MUL</name></expr>:</case>
        <case>case <expr><name>PGBENCH_DIV</name></expr>:</case>
        <case>case <expr><name>PGBENCH_MOD</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>lval</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>rval</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* overloaded type management, double if some double */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name> <operator>||</operator>
                     <name><name>rval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>func</name> <operator>!=</operator> <name>PGBENCH_MOD</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>double</name></type>        <name>ld</name></decl>,
                                <decl><type ref="prev"/><name>rd</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ld</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                    <switch>switch <condition>(<expr><name>func</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>PGBENCH_ADD</name></expr>:</case>
                            <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>+</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>

                        <case>case <expr><name>PGBENCH_SUB</name></expr>:</case>
                            <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>-</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>

                        <case>case <expr><name>PGBENCH_MUL</name></expr>:</case>
                            <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>*</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>

                        <case>case <expr><name>PGBENCH_DIV</name></expr>:</case>
                            <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>/</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>

                        <default>default:</default>
                            <comment type="block">/* cannot get here */</comment>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></switch>
                </block_content>}</block></if>
                <else>else            <comment type="block">/* we have integer operands, or % */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name></type>        <name>li</name></decl>,
                                <decl><type ref="prev"/><name>ri</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                    <switch>switch <condition>(<expr><name>func</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>PGBENCH_ADD</name></expr>:</case>
                            <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>+</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>

                        <case>case <expr><name>PGBENCH_SUB</name></expr>:</case>
                            <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>-</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>

                        <case>case <expr><name>PGBENCH_MUL</name></expr>:</case>
                            <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>*</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>

                        <case>case <expr><name>PGBENCH_DIV</name></expr>:</case>
                        <case>case <expr><name>PGBENCH_MOD</name></expr>:</case>
                            <if_stmt><if>if <condition>(<expr><name>ri</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"division by zero\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><name>false</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                            <comment type="block">/* special handling of -1 divisor */</comment>
                            <if_stmt><if>if <condition>(<expr><name>ri</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_DIV</name></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="block">/* overflow check (needed for INT64_MIN) */</comment>
                                    <if_stmt><if>if <condition>(<expr><name>li</name> <operator>==</operator> <name>PG_INT64_MIN</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"bigint out of range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <return>return <expr><name>false</name></expr>;</return>
                                    </block_content>}</block></if>
                                    <else>else<block type="pseudo"><block_content>
                                        <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><operator>-</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                                </block_content>}</block></if>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                                <return>return <expr><name>true</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                            <comment type="block">/* else divisor is not -1 */</comment>
                            <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_DIV</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>/</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                            <else>else<block type="pseudo"><block_content>    <comment type="block">/* func == PGBENCH_MOD */</comment>
                                <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>%</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                            <return>return <expr><name>true</name></expr>;</return>

                        <default>default:</default>
                            <comment type="block">/* cannot get here */</comment>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></switch>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block>

            <comment type="block">/* no arguments */</comment>
        <case>case <expr><name>PGBENCH_PI</name></expr>:</case>
            <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>M_PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>

            <comment type="block">/* 1 overloaded argument */</comment>
        <case>case <expr><name>PGBENCH_ABS</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>varg</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name></type>        <name>i</name> <init>= <expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>i</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>double</name></type>        <name>d</name> <init>= <expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><ternary><condition><expr><name>d</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>d</name></expr> </then><else>: <expr><name>d</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>PGBENCH_DEBUG</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>varg</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"debug(script=%d,command=%d): "</literal></expr></argument>,
                        <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"int "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"double %.*g\n"</literal></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <operator>*</operator><name>varg</name></expr>;</expr_stmt>

                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

            <comment type="block">/* 1 double argument */</comment>
        <case>case <expr><name>PGBENCH_DOUBLE</name></expr>:</case>
        <case>case <expr><name>PGBENCH_SQRT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>double</name></type>        <name>dval</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_SQRT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>dval</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

            <comment type="block">/* 1 int argument */</comment>
        <case>case <expr><name>PGBENCH_INT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type>        <name>ival</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

            <comment type="block">/* variable number of arguments */</comment>
        <case>case <expr><name>PGBENCH_LEAST</name></expr>:</case>
        <case>case <expr><name>PGBENCH_GREATEST</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>havedouble</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* need double result if any input is double */</comment>
                <expr_stmt><expr><name>havedouble</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>vargs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>havedouble</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>havedouble</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>double</name></type>        <name>extremum</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extremum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>double</name></type>        <name>dval</name></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_LEAST</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>extremum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name></type>        <name>extremum</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extremum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64</name></type>        <name>ival</name></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_LEAST</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>extremum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

            <comment type="block">/* random functions */</comment>
        <case>case <expr><name>PGBENCH_RANDOM</name></expr>:</case>
        <case>case <expr><name>PGBENCH_RANDOM_EXPONENTIAL</name></expr>:</case>
        <case>case <expr><name>PGBENCH_RANDOM_GAUSSIAN</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type>        <name>imin</name></decl>,
                            <decl><type ref="prev"/><name>imax</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imin</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                <comment type="block">/* check random range */</comment>
                <if_stmt><if>if <condition>(<expr><name>imin</name> <operator>&gt;</operator> <name>imax</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"empty range given to random\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>imax</name> <operator>-</operator> <name>imin</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>imax</name> <operator>-</operator> <name>imin</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* prevent int overflows in random functions */</comment>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"random range is too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_RANDOM</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><call><name>getrand</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>imin</name></expr></argument>, <argument><expr><name>imax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else            <comment type="block">/* gaussian &amp; exponential */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>double</name></type>        <name>param</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_RANDOM_GAUSSIAN</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>param</name> <operator>&lt;</operator> <name>MIN_GAUSSIAN_PARAM</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                                    <argument><expr><literal type="string">"gaussian parameter must be at least %f "</literal>
                                    <literal type="string">"(not %f)\n"</literal></expr></argument>, <argument><expr><name>MIN_GAUSSIAN_PARAM</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>false</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
                                    <argument><expr><call><name>getGaussianRand</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>imin</name></expr></argument>, <argument><expr><name>imax</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else        <comment type="block">/* exponential */</comment>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>param</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                                    <argument><expr><literal type="string">"exponential parameter must be greater than zero"</literal>
                                    <literal type="string">" (got %f)\n"</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>false</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
                                    <argument><expr><call><name>getExponentialRand</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>imin</name></expr></argument>, <argument><expr><name>imax</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>

                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

        <default>default:</default>
            <comment type="block">/* cannot get here */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* dead code to avoid a compiler warning */</comment>
            <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive evaluation of an expression in a pgbench script
 * using the current state of variables.
 * Returns whether the evaluation was ok,
 * the value itself is returned through the retval pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evaluateExpr</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>etype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>ENODE_CONSTANT</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>constant</name></name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>ENODE_VARIABLE</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>var</name> <operator>=</operator> <call><name>lookupVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>variable</name><operator>.</operator><name>varname</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"undefined variable \"%s\"\n"</literal></expr></argument>,
                            <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>variable</name><operator>.</operator><name>varname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>makeVariableNumeric</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>num_value</name></name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>ENODE_FUNCTION</name></expr>:</case>
            <return>return <expr><call><name>evalFunc</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>,
                            <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>function</name></name></expr></argument>,
                            <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>args</name></name></expr></argument>,
                            <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>

        <default>default:</default>
            <comment type="block">/* internal error which should never occur */</comment>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unexpected enode type in evaluation: %d\n"</literal></expr></argument>,
                    <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>etype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Run a shell command. The result is assigned to the variable if not NULL.
 * Return true if succeeded, or false on error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>runShellCommand</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>command</name><index>[<expr><name>SHELL_COMMAND_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>res</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>retval</name></decl>;</decl_stmt>

    <comment type="block">/*----------
     * Join arguments with whitespace separators. Arguments starting with
     * exactly one colon are treated as variables:
     *    name - append a string "name"
     *    :var - append a variable named 'var'
     *    ::name - append a string ":name"
     *----------
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>arglen</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>        <comment type="block">/* a string literal */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* a string literal starting with colons */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>arg</name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: undefined variable \"%s\"\n"</literal></expr></argument>,
                    <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>arglen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>arglen</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>&gt;=</operator> <name>SHELL_COMMAND_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: shell command is too long\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>command</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>command</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>arglen</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>command</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/* Fast path for non-assignment case */</comment>
    <if_stmt><if>if <condition>(<expr><name>variable</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>timer_exceeded</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not launch shell command\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Execute the command with pipe and read the standard output. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not launch shell command\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>timer_exceeded</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not read result of shell command\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not close shell command\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check whether the result is an integer and assign it to the variable */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>res</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: shell command must return an integer (not \"%s\")\n"</literal></expr></argument>,
                <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariableInt</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"setshell"</literal></expr></argument>, <argument><expr><name>variable</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"shell parameter name: \"%s\", value: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PREPARE_NAME</name></cpp:macro>        <cpp:value>32</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>preparedStatementName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"P%d_%d"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>commandFailed</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <argument><expr><literal type="string">"client %d aborted in command %d of script %d; %s\n"</literal></expr></argument>,
            <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return a script number with a weighted choice. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>chooseScript</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>w</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>getrand</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>total_weight</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>-=</operator> <name><name>sql_script</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>w</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <return>return <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Send a SQL command, using the chosen querymode */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sendCommand</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>Command</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>r</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>querymode</name> <operator>==</operator> <name>QUERY_SIMPLE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>assignVariables</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d sending %s\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>querymode</name> <operator>==</operator> <name>QUERY_EXTENDED</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>getQueryParams</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d sending %s\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQsendQueryParams</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>querymode</name> <operator>==</operator> <name>QUERY_PREPARED</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>name</name><index>[<expr><name>MAX_PREPARE_NAME</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>prepared</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name> <init>= <expr><name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name>commands</name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type>        <name><name>name</name><index>[<expr><name>MAX_PREPARE_NAME</name></expr>]</index></name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>SQL_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>preparedStatementName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQprepare</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                                <argument><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>prepared</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>getQueryParams</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>preparedStatementName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d sending %s\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQsendQueryPrepared</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                                <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>                        <comment type="block">/* unknown sql mode */</comment>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d could not send %s\n"</literal></expr></argument>,
                    <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>ecnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the argument to a \sleep command, and return the requested amount
 * of delay, in microseconds.  Returns true on success, false on error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evaluateSleep</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>usecs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>usec</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>var</name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: undefined variable \"%s\"\n"</literal></expr></argument>,
                    <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>usec</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>usec</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>usec</name> <operator>*=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>usec</name> <operator>*=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>usec</name> <operator>*=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>usecs</name> <operator>=</operator> <name>usec</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the state machine of a connection, if possible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doCustom</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>now</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>end_tx_processed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>wait</name></decl>;</decl_stmt>

    <comment type="block">/*
     * gettimeofday() isn't free, so we get the current timestamp lazily the
     * first time it's needed, and reuse the same value throughout this
     * function after that.  This also ensures that e.g. the calculated
     * latency reported in the log file and in the totals are the same. Zero
     * means "not set yet".  Reset "now" when we execute shell commands or
     * expressions, which might take a non-negligible amount of time, though.
     */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop in the state machine, until we have to wait for a result from the
     * server (or have to sleep, for throttling or for \sleep).
     *
     * Note: In the switch-statement below, 'break' will loop back here,
     * meaning "continue in the state machine".  Return is used to return to
     * the caller.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/*
                 * Select transaction to run.
                 */</comment>
            <case>case <expr><name>CSTATE_CHOOSE_SCRIPT</name></expr>:</case>

                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name> <operator>=</operator> <call><name>chooseScript</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d executing script \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
                            <argument><expr><name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>throttle_delay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_THROTTLE</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_TX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Handle throttling once per transaction by sleeping.
                 */</comment>
            <case>case <expr><name>CSTATE_START_THROTTLE</name></expr>:</case>

                <comment type="block">/*
                 * Generate a delay such that the series of delays will
                 * approximate a Poisson distribution centered on the
                 * throttle_delay time.
                 *
                 * If transactions are too slow or a given wait is shorter
                 * than a transaction, the next transaction will start right
                 * away.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>throttle_delay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>wait</name> <operator>=</operator> <call><name>getPoissonRand</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>throttle_delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>+=</operator> <name>wait</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>=</operator> <name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * stop client if next transaction is beyond pgbench end of
                 * execution
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>&gt;</operator> <name>end_time</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * If this --latency-limit is used, and this slot is already
                 * late so that the transaction will miss the latency limit
                 * even if it completed immediately, we skip this time slot
                 * and iterate till the next slot that isn't late yet.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name></type>        <name>now_us</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>now_us</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <while>while <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>&lt;</operator> <name>now_us</name> <operator>-</operator> <name>latency_limit</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>processXactStats</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* next rendez-vous */</comment>
                        <expr_stmt><expr><name>wait</name> <operator>=</operator> <call><name>getPoissonRand</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>throttle_delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>+=</operator> <name>wait</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>=</operator> <name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name></expr>;</expr_stmt>
                    </block_content>}</block></while>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_THROTTLE</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d throttling "</literal> <name>INT64_FORMAT</name> <literal type="string">" us\n"</literal></expr></argument>,
                            <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Wait until it's time to start next transaction.
                 */</comment>
            <case>case <expr><name>CSTATE_THROTTLE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>        <comment type="block">/* Still sleeping, nothing to do here */</comment>

                <comment type="block">/* Else done sleeping, start the transaction */</comment>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_TX</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/* Start new transaction */</comment>
            <case>case <expr><name>CSTATE_START_TX</name></expr>:</case>

                <comment type="block">/*
                 * Establish connection on first call, or if is_connect is
                 * true.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>instr_time</name></type>    <name>start</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>start</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d aborted while establishing connection\n"</literal></expr></argument>,
                                <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Reset session-local state */</comment>
                    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>prepared</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>prepared</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Record transaction start time under logging, progress or
                 * throttling.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>use_log</name> <operator>||</operator> <name>progress</name> <operator>||</operator> <name>throttle_delay</name> <operator>||</operator> <name>latency_limit</name> <operator>||</operator>
                    <name>per_script_stats</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_begin</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * When not throttling, this is also the transaction's
                     * scheduled start time.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>throttle_delay</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Begin with the first command */</comment>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Send a command to server (or execute a meta-command)
                 */</comment>
            <case>case <expr><name>CSTATE_START_COMMAND</name></expr>:</case>
                <expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * If we reached the end of the script, move to end-of-xact
                 * processing.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>command</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_TX</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Record statement start time if per-command latencies are
                 * requested
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>is_latencies</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>stmt_begin</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SQL_COMMAND</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sendCommand</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Failed. Stay in CSTATE_START_COMMAND state, to
                         * retry. ??? What the point or retrying? Should
                         * rather abort?
                         */</comment>
                        <return>return;</return>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_WAIT_RESULT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>META_COMMAND</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>argc</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>,
                                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>argv</name></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d executing \\%s"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"sleep"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * A \sleep doesn't execute anything, we just get the
                         * delay from the argument, and enter the CSTATE_SLEEP
                         * state.  (The per-command latency will be recorded
                         * in CSTATE_SLEEP state, not here, after the delay
                         * has elapsed.)
                         */</comment>
                        <decl_stmt><decl><type><name>int</name></type>            <name>usec</name></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateSleep</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usec</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"execution of meta-command 'sleep' failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>sleep_until</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>usec</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_SLEEP</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"set"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>PgBenchValue</name></type> <name>result</name></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"evaluation of meta-command 'set' failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariableNumber</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"assignment of meta-command 'set' failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"setshell"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>bool</name></type>        <name>ret</name> <init>= <expr><call><name>runShellCommand</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>timer_exceeded</name></expr>)</condition> <comment type="block">/* timeout */</comment>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>    <comment type="block">/* on error */</comment>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"execution of meta-command 'setshell' failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <comment type="block">/* succeeded */</comment>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"shell"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>bool</name></type>        <name>ret</name> <init>= <expr><call><name>runShellCommand</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>timer_exceeded</name></expr>)</condition> <comment type="block">/* timeout */</comment>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>    <comment type="block">/* on error */</comment>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"execution of meta-command 'shell' failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <comment type="block">/* succeeded */</comment>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="block">/*
                         * executing the expression or shell command might
                         * take a non-negligible amount of time, so reset
                         * 'now'
                         */</comment>
                        <expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_COMMAND</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Wait for the current SQL command to complete
                 */</comment>
            <case>case <expr><name>CSTATE_WAIT_RESULT</name></expr>:</case>
                <expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"client %d receiving\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>                <comment type="block">/* there's something wrong */</comment>
                    <expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"perhaps the backend died while processing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>        <comment type="block">/* don't have the whole result yet */</comment>

                <comment type="block">/*
                 * Read and discard the query result;
                 */</comment>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
                    <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
                    <case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
                        <comment type="block">/* OK */</comment>
                        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>discard_response</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_COMMAND</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <break>break;</break>

                <comment type="block">/*
                 * Wait until sleep is done. This state is entered after a
                 * \sleep metacommand. The behavior is similar to
                 * CSTATE_THROTTLE, but proceeds to CSTATE_START_COMMAND
                 * instead of CSTATE_START_TX.
                 */</comment>
            <case>case <expr><name>CSTATE_SLEEP</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>sleep_until</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>        <comment type="block">/* Still sleeping, nothing to do here */</comment>
                <comment type="block">/* Else done sleeping. */</comment>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_COMMAND</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * End of command: record stats and proceed to next command.
                 */</comment>
            <case>case <expr><name>CSTATE_END_COMMAND</name></expr>:</case>

                <comment type="block">/*
                 * command completed: accumulate per-command execution times
                 * in thread-local data structure, if per-command latencies
                 * are requested.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>is_latencies</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* XXX could use a mutex here, but we choose not to */</comment>
                    <expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>addToSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>command</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
                                     <argument><expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator>
                                     <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>stmt_begin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Go ahead with next command */</comment>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * End of transaction.
                 */</comment>
            <case>case <expr><name>CSTATE_END_TX</name></expr>:</case>

                <comment type="block">/*
                 * transaction finished: calculate latency and log the
                 * transaction
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>progress</name> <operator>||</operator> <name>throttle_delay</name> <operator>||</operator> <name>latency_limit</name> <operator>||</operator>
                    <name>per_script_stats</name> <operator>||</operator> <name>use_log</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>processXactStats</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>is_connect</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><operator>++</operator><name><name>st</name><operator>-&gt;</operator><name>cnt</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>cnt</name></name> <operator>&gt;=</operator> <name>nxacts</name> <operator>&amp;&amp;</operator> <name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>timer_exceeded</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* exit success */</comment>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * No transaction is underway anymore.
                 */</comment>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_CHOOSE_SCRIPT</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * If we paced through all commands in the script in this
                 * loop, without returning to the caller even once, do it now.
                 * This gives the thread a chance to process other
                 * connections, and to do progress reporting.  This can
                 * currently only happen if the script consists entirely of
                 * meta-commands.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>end_tx_processed</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>end_tx_processed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/*
                 * Final states.  Close the connection if it's still open.
                 */</comment>
            <case>case <expr><name>CSTATE_ABORTED</name></expr>:</case>
            <case>case <expr><name>CSTATE_FINISHED</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <return>return;</return>
        </block_content>}</block></switch>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Print log entry after completing one transaction.
 *
 * We print Unix-epoch timestamps in the log, so that entries can be
 * correlated against other logs.  On some platforms this could be obtained
 * from the instr_time reading the caller has, but rather than get entangled
 * with that, we just eat the cost of an extra syscall in all cases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doLog</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
      <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>latency</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>logfile</name> <init>= <expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>use_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Skip the log entry if sampling is enabled and this row doesn't belong
     * to the random sample.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>!=</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator>
        <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>sample_rate</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* should we aggregate the results or not? */</comment>
    <if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Loop until we reach the interval of the current moment, and print
         * any empty intervals in between (this may happen with very low tps,
         * e.g. --rate=0.1).
         */</comment>
        <decl_stmt><decl><type><name>time_t</name></type>        <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>start_time</name></name> <operator>+</operator> <name>agg_interval</name> <operator>&lt;=</operator> <name>now</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* print aggregated report to logfile */</comment>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%ld "</literal> <name>INT64_FORMAT</name> <literal type="string">" %.0f %.0f %.0f %.0f"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>,
                    <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>,
                    <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>sum</name></name></expr></argument>,
                    <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>sum2</name></name></expr></argument>,
                    <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>min</name></name></expr></argument>,
                    <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" %.0f %.0f %.0f %.0f"</literal></expr></argument>,
                        <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>sum</name></name></expr></argument>,
                        <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>sum2</name></name></expr></argument>,
                        <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>min</name></name></expr></argument>,
                        <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>skipped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* reset data and move to next interval */</comment>
            <expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><name>agg</name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>start_time</name></name> <operator>+</operator> <name>agg_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* accumulate the current transaction */</comment>
        <expr_stmt><expr><call><name>accumStats</name><argument_list>(<argument><expr><name>agg</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* no, print raw transactions */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>skipped</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal> <name>INT64_FORMAT</name> <literal type="string">" skipped %d %ld %ld"</literal></expr></argument>,
                    <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal> <name>INT64_FORMAT</name> <literal type="string">" %.0f %d %ld %ld"</literal></expr></argument>,
                    <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" %.0f"</literal></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate and report statistics at end of a transaction.
 *
 * (This is also called when a transaction is late and thus skipped.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processXactStats</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>now</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>latency</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>lag</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>skipped</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipped</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* compute latency &amp; lag */</comment>
        <expr_stmt><expr><name>latency</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lag</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>txn_begin</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>progress</name> <operator>||</operator> <name>throttle_delay</name> <operator>||</operator> <name>latency_limit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>accumStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* count transactions over the latency limit, if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name>latency_limit</name> <operator>&amp;&amp;</operator> <name>latency</name> <operator>&gt;</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>latency_late</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>use_log</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>doLog</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* XXX could use a mutex here, but we choose not to */</comment>
    <if_stmt><if>if <condition>(<expr><name>per_script_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>accumStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name>stats</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* discard connections */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>disconnect_all</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>con</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>con</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* create tables and setup data */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_no_vacuum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<comment type="block">/*
 * The scale factor at/beyond which 32-bit integers are insufficient for
 * storing TPC-B account IDs.
 *
 * Although the actual threshold is 21474, we use 20000 because it is easier to
 * document and remember, and isn't that far away from the real threshold.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCALE_32BIT_THRESHOLD</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>

    <comment type="block">/*
     * Note: TPC-B requires at least 100 bytes per row, and the "filler"
     * fields in these table declarations were intended to comply with that.
     * The pgbench_accounts table complies with that because the "filler"
     * column is set to blank-padded empty string. But for all other tables
     * the columns default to NULL and so don't actually take any space.  We
     * could fix that by giving them non-null default values.  However, that
     * would completely break comparability of pgbench results with prior
     * versions. Since pgbench has never pretended to be fully TPC-B compliant
     * anyway, we stick with the historical behavior.
     */</comment>
    <struct>struct <name>ddlinfo</name>
    <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>        <comment type="block">/* table name */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>smcols</name></decl>;</decl_stmt>        <comment type="block">/* column decls if accountIDs are 32 bits */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bigcols</name></decl>;</decl_stmt>    <comment type="block">/* column decls if accountIDs are 64 bits */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>declare_fillfactor</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>distribute_by</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>;</struct>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ddlinfo</name></name></type> <name><name>DDLs</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{
            <expr><literal type="string">"pgbench_history"</literal></expr>,
            <expr><literal type="string">"tid int,bid int,aid    int,delta int,mtime timestamp,filler char(22)"</literal></expr>,
            <expr><literal type="string">"tid int,bid int,aid bigint,delta int,mtime timestamp,filler char(22)"</literal></expr>,
            <expr><literal type="number">0</literal></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            , <expr><literal type="string">"distribute by hash (bid)"</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></expr>,
        <expr><block>{
            <expr><literal type="string">"pgbench_tellers"</literal></expr>,
            <expr><literal type="string">"tid int not null,bid int,tbalance int,filler char(84)"</literal></expr>,
            <expr><literal type="string">"tid int not null,bid int,tbalance int,filler char(84)"</literal></expr>,
            <expr><literal type="number">1</literal></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            , <expr><literal type="string">"distribute by hash (bid)"</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></expr>,
        <expr><block>{
            <expr><literal type="string">"pgbench_accounts"</literal></expr>,
            <expr><literal type="string">"aid    int not null,bid int,abalance int,filler char(84)"</literal></expr>,
            <expr><literal type="string">"aid bigint not null,bid int,abalance int,filler char(84)"</literal></expr>,
            <expr><literal type="number">1</literal></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            , <expr><literal type="string">"distribute by hash (bid)"</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></expr>,
        <expr><block>{
            <expr><literal type="string">"pgbench_branches"</literal></expr>,
            <expr><literal type="string">"bid int not null,bbalance int,filler char(88)"</literal></expr>,
            <expr><literal type="string">"bid int not null,bbalance int,filler char(88)"</literal></expr>,
            <expr><literal type="number">1</literal></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            , <expr><literal type="string">"distribute by hash (bid)"</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>DDLINDEXes</name><index>[]</index></name> <init>= <expr><block>{
        <expr><literal type="string">"alter table pgbench_branches add primary key (bid)"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_tellers add primary key (tid)"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_accounts add primary key (aid)"</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>DDLKEYs</name><index>[]</index></name> <init>= <expr><block>{
        <expr><literal type="string">"alter table pgbench_tellers add foreign key (bid) references pgbench_branches"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_accounts add foreign key (bid) references pgbench_branches"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_history add foreign key (bid) references pgbench_branches"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_history add foreign key (tid) references pgbench_tellers"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_history add foreign key (aid) references pgbench_accounts"</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>DDLAFTERs_bid</name><index>[]</index></name> <init>= <expr><block>{
        <expr><literal type="string">"alter table pgbench_branches add primary key (bid)"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_tellers add primary key (tid,bid)"</literal></expr>,
        <expr><literal type="string">"alter table pgbench_accounts add primary key (aid,bid)"</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sql</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>k</name></decl>;</decl_stmt>

    <comment type="block">/* used to track elapsed time and estimate of the remaining time */</comment>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>start</name></decl>,
                <decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>elapsed_sec</name></decl>,
                <decl><type ref="prev"/><name>remaining_sec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>log_interval</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>con</name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>DDLs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>opts</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ddlinfo</name></name> <modifier>*</modifier></type><name>ddl</name> <init>= <expr><operator>&amp;</operator><name><name>DDLs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cols</name></decl>;</decl_stmt>

        <comment type="block">/* Remove old table, if it exists. */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"drop table if exists %s"</literal></expr></argument>, <argument><expr><name><name>ddl</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Construct new create table statement. */</comment>
        <expr_stmt><expr><name><name>opts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ddl</name><operator>-&gt;</operator><name>declare_fillfactor</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>opts</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><literal type="string">" with (fillfactor=%d)"</literal></expr></argument>, <argument><expr><name>fillfactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>escape_tablespace</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>escape_tablespace</name> <operator>=</operator> <call><name>PQescapeIdentifier</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>,
                                                   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>opts</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><literal type="string">" tablespace %s"</literal></expr></argument>, <argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>cols</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>scale</name> <operator>&gt;=</operator> <name>SCALE_32BIT_THRESHOLD</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>ddl</name><operator>-&gt;</operator><name>bigcols</name></name></expr> </then><else>: <expr><name><name>ddl</name><operator>-&gt;</operator><name>smcols</name></name></expr></else></ternary></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Add distribution columns if necessary */</comment>
        <if_stmt><if>if <condition>(<expr><name>use_branch</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"create%s table %s(%s)%s %s"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>unlogged_tables</name></expr> ?</condition><then> <expr><literal type="string">" unlogged"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                     <argument><expr><name><name>ddl</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>cols</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name><name>ddl</name><operator>-&gt;</operator><name>distribute_by</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"create%s table %s(%s)%s"</literal></expr></argument>,
                 <argument><expr><ternary><condition><expr><name>unlogged_tables</name></expr> ?</condition><then> <expr><literal type="string">" unlogged"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                 <argument><expr><name><name>ddl</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>cols</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"begin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbranches</name> <operator>*</operator> <name>scale</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* "filler" column defaults to NULL */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><literal type="string">"insert into pgbench_branches(bid,bbalance) values(%d,0)"</literal></expr></argument>,
                 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntellers</name> <operator>*</operator> <name>scale</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* "filler" column defaults to NULL */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><literal type="string">"insert into pgbench_tellers(tid,bid,tbalance) values (%d,%d,0)"</literal></expr></argument>,
                 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name> <operator>/</operator> <name>ntellers</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"commit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * fill the pgbench_accounts table with some data
     */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"creating tables...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"begin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"truncate pgbench_accounts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"copy pgbench_accounts from stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64</name></type>        <name>j</name> <init>= <expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* "filler" column defaults to blank padded empty string */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><name>INT64_FORMAT</name> <literal type="string">"\t"</literal> <name>INT64_FORMAT</name> <literal type="string">"\t%d\t\n"</literal></expr></argument>,
                 <argument><expr><name>j</name></expr></argument>, <argument><expr><name>k</name> <operator>/</operator> <name>naccounts</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQputline</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQputline failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we want to stick with the original logging, print a message each
         * 100k inserted rows.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>use_quiet</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>%</operator> <literal type="number">100000</literal> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>elapsed_sec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining_sec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>scale</name> <operator>*</operator> <name>naccounts</name> <operator>-</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>elapsed_sec</name> <operator>/</operator> <name>j</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">" of "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples (%d%%) done (elapsed %.2f s, remaining %.2f s)\n"</literal></expr></argument>,
                    <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name>j</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>naccounts</name> <operator>*</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>scale</name><operator>)</operator><operator>)</operator></expr></argument>,
                    <argument><expr><name>elapsed_sec</name></expr></argument>, <argument><expr><name>remaining_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* let's not call the timing for each row, but only each 100 rows */</comment>
        <if type="elseif">else if <condition>(<expr><name>use_quiet</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>%</operator> <literal type="number">100</literal> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>elapsed_sec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining_sec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>scale</name> <operator>*</operator> <name>naccounts</name> <operator>-</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>elapsed_sec</name> <operator>/</operator> <name>j</name></expr>;</expr_stmt>

            <comment type="block">/* have we reached the next interval (or end)? */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>==</operator> <name>scale</name> <operator>*</operator> <name>naccounts</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>elapsed_sec</name> <operator>&gt;=</operator> <name>log_interval</name> <operator>*</operator> <name>LOG_STEP_SECONDS</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">" of "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples (%d%%) done (elapsed %.2f s, remaining %.2f s)\n"</literal></expr></argument>,
                        <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name>j</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>naccounts</name> <operator>*</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>scale</name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name>elapsed_sec</name></expr></argument>, <argument><expr><name>remaining_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* skip to the next interval */</comment>
                <expr_stmt><expr><name>log_interval</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>elapsed_sec</name> <operator>/</operator> <name>LOG_STEP_SECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><call><name>PQputline</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"\\.\n"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"very last PQputline failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQendcopy</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQendcopy failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"commit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* vacuum */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_no_vacuum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"vacuum...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze pgbench_branches"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze pgbench_tellers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze pgbench_accounts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze pgbench_history"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * create indexes
     */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"set primary key...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * If all the tables are distributed according to bid, create an index on it
     * instead.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_branch</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>DDLAFTERs_bid</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>DDLAFTERs_bid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>index_tablespace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>escape_tablespace</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>escape_tablespace</name> <operator>=</operator> <call><name>PQescapeIdentifier</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>index_tablespace</name></expr></argument>,
                                                   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">256</literal> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">" using index tablespace %s"</literal></expr></argument>, <argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>DDLINDEXes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>DDLINDEXes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>index_tablespace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>escape_tablespace</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>escape_tablespace</name> <operator>=</operator> <call><name>PQescapeIdentifier</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>index_tablespace</name></expr></argument>,
                                                   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><literal type="string">" using index tablespace %s"</literal></expr></argument>, <argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for></block_content></block></else></if_stmt>

    <comment type="block">/*
     * create foreign keys
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>foreign_keys</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"set foreign keys...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>DDLKEYs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name><name>DDLKEYs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"done.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Replace :param with $n throughout the command's SQL text, which
 * is a modifiable string in cmd-&gt;argv[0].
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parseQuery</name><parameter_list>(<parameter><decl><type><name>Command</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sql</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* We don't want to scribble on cmd-&gt;argv[0] until done */</comment>
    <expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>var</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>eaten</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>parseVariable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eaten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <name>MAX_ARGS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"statement has too many arguments (maximum is %d): %s\n"</literal></expr></argument>,
                    <argument><expr><name>MAX_ARGS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>replaceVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>eaten</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name></expr>]</index></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Simple error-printing function, might be needed by lexer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgbench_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type>        <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * syntax error while parsing a script (in practice, while parsing a
 * backslash command, because we don't detect syntax errors in SQL)
 *
 * source: source of script (filename or builtin-script ID)
 * lineno: line number within script (count from 1)
 * line: whole line of backslash command, if available
 * command: backslash command name, if available
 * msg: the actual error message
 * more: optional extra message
 * column: zero-based column number, or -1 if unknown
 */</comment>
<function><type><name>void</name></type>
<name>syntax_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>more</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: %s"</literal></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>more</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" (%s)"</literal></expr></argument>, <argument><expr><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>column</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" at column %d"</literal></expr></argument>, <argument><expr><name>column</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>command</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" in command \"%s\""</literal></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>column</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>column</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"^ error found here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a SQL command; return a Command struct, or NULL if it's a comment
 *
 * On entry, psqlscan.l has collected the command into "buf", so we don't
 * really need to do much here except check for comment and set up a
 * Command struct.
 */</comment>
<function><type><specifier>static</specifier> <name>Command</name> <modifier>*</modifier></type>
<name>process_sql_command</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>my_command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nlpos</name></decl>;</decl_stmt>

    <comment type="block">/* Skip any leading whitespace, as well as "--" style comments */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If there's nothing but whitespace and comments, we're done */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Allocate and initialize Command structure */</comment>
    <expr_stmt><expr><name>my_command</name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>command_num</name></name> <operator>=</operator> <name>num_commands</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SQL_COMMAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_command</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Install query text as the sole argv string.  If we are using a
     * non-simple query mode, we'll extract parameters from it later.
     */</comment>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * If SQL command is multi-line, we only want to save the first line as
     * the "line" label.
     */</comment>
    <expr_stmt><expr><name>nlpos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nlpos</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>nlpos</name> <operator>-</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nlpos</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name><index>[<expr><name>nlpos</name> <operator>-</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>my_command</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a backslash command; return a Command struct, or NULL if comment
 *
 * At call, we have scanned only the initial backslash.
 */</comment>
<function><type><specifier>static</specifier> <name>Command</name> <modifier>*</modifier></type>
<name>process_backslash_command</name><parameter_list>(<parameter><decl><type><name>PsqlScanState</name></type> <name>sstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>my_command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>word_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>word_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>offsets</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* offsets of argument words */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>start_offset</name></decl>,
                <decl><type ref="prev"/><name>end_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>lineno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remember location of the backslash */</comment>
    <expr_stmt><expr><name>start_offset</name> <operator>=</operator> <call><name>expr_scanner_offset</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>expr_scanner_get_lineno</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Collect first word of command */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_lex_one_word</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_offset</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Allocate and initialize Command structure */</comment>
    <expr_stmt><expr><name>my_command</name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>command_num</name></name> <operator>=</operator> <name>num_commands</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>META_COMMAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_command</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Save first word (command name) */</comment>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>word_offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>word_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"set"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* For \set, collect var name, then lex the expression. */</comment>
        <decl_stmt><decl><type><name>yyscan_t</name></type>    <name>yyscanner</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_lex_one_word</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                         <argument><expr><literal type="string">"missing argument"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>word_offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>word_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>yyscanner</name> <operator>=</operator> <call><name>expr_scanner_init</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>,
                                      <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expr_yyparse</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* dead code: exit done from syntax_error called by yyerror */</comment>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr_parse_result</name></expr>;</expr_stmt>

        <comment type="block">/* Get location of the ending newline */</comment>
        <expr_stmt><expr><name>end_offset</name> <operator>=</operator> <call><name>expr_scanner_offset</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* Save line */</comment>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>expr_scanner_get_substring</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>,
                                                      <argument><expr><name>start_offset</name></expr></argument>,
                                                      <argument><expr><name>end_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>expr_scanner_finish</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>my_command</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* For all other commands, collect remaining words. */</comment>
    <while>while <condition>(<expr><call><name>expr_lex_one_word</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_offset</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                         <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>word_offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>word_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Get location of the ending newline */</comment>
    <expr_stmt><expr><name>end_offset</name> <operator>=</operator> <call><name>expr_scanner_offset</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Save line */</comment>
    <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>expr_scanner_get_substring</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>,
                                                  <argument><expr><name>start_offset</name></expr></argument>,
                                                  <argument><expr><name>end_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"sleep"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                         <argument><expr><literal type="string">"missing argument"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                         <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Split argument into number and unit to allow "sleep 1ms" etc. We
         * don't have to terminate the number argument with null because it
         * will be parsed with atoi, which ignores trailing non-digit
         * characters.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>c</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"us"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                             <argument><expr><literal type="string">"unrecognized time unit, must be us, ms or s"</literal></expr></argument>,
                             <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"setshell"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                         <argument><expr><literal type="string">"missing argument"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"shell"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                         <argument><expr><literal type="string">"missing command"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                     <argument><expr><literal type="string">"invalid command"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>my_command</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a script (either the contents of a file, or a built-in script)
 * and add it to the list of scripts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseScript</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>script</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ParsedScript</name></type> <name>ps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PsqlScanState</name></type> <name>sstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>line_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>alloc_num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMANDS_ALLOC_NUM</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
    <expr_stmt><expr><name>alloc_num</name> <operator>=</operator> <name>COMMANDS_ALLOC_NUM</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize all fields of ps */</comment>
    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><operator>.</operator><name>stats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Prepare to parse script */</comment>
    <expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>psql_scan_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pgbench_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Ideally, we'd scan scripts using the encoding and stdstrings settings
     * we get from a DB connection.  However, without major rearrangement of
     * pgbench's argument parsing, we can't have a DB connection at the time
     * we parse scripts.  Using SQL_ASCII (encoding 0) should work well enough
     * with any backend-safe encoding, though conceivably we could be fooled
     * if a script file uses a client-only encoding.  We also assume that
     * stdstrings should be true, which is a bit riskier.
     */</comment>
    <expr_stmt><expr><call><name>psql_scan_setup</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PsqlScanResult</name></type> <name>sr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>promptStatus_t</name></type> <name>prompt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>sr</name> <operator>=</operator> <call><name>psql_scan</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we collected a SQL command, process that */</comment>
        <expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>process_sql_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>command</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>alloc_num</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>alloc_num</name> <operator>+=</operator> <name>COMMANDS_ALLOC_NUM</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                    <call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>commands</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we reached a backslash, process that */</comment>
        <if_stmt><if>if <condition>(<expr><name>sr</name> <operator>==</operator> <name>PSCAN_BACKSLASH</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>process_backslash_command</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>command</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>alloc_num</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>alloc_num</name> <operator>+=</operator> <name>COMMANDS_ALLOC_NUM</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                        <call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>commands</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Done if we reached EOF */</comment>
        <if_stmt><if>if <condition>(<expr><name>sr</name> <operator>==</operator> <name>PSCAN_INCOMPLETE</name> <operator>||</operator> <name>sr</name> <operator>==</operator> <name>PSCAN_EOL</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>addScript</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>psql_scan_finish</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>psql_scan_destroy</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the entire contents of file fd, and return it in a malloc'd buffer.
 *
 * The buffer will typically be larger than necessary, but we don't care
 * in this program, because we'll free it as soon as we've parsed the script.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_file_contents</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>buflen</name> <init>= <expr><name>BUFSIZ</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>nread</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>used</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>used</name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>
        <comment type="block">/* If fread() read less than requested, must be EOF or error */</comment>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <name>BUFSIZ</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* Enlarge buf so we can read some more */</comment>
        <expr_stmt><expr><name>buflen</name> <operator>+=</operator> <name>BUFSIZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* There is surely room for a terminator */</comment>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>used</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a file name, read it and add its script to the list.
 * "-" means to read stdin.
 * NB: filename must be storage that won't disappear.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

    <comment type="block">/* Slurp the file contents into "buf" */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\": %s\n"</literal></expr></argument>,
                <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_file_contents</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not read file \"%s\": %s\n"</literal></expr></argument>,
                <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ParseScript</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse the given builtin script and add it to the list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_builtin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BuiltinScript</name> <modifier>*</modifier></type><name>bi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ParseScript</name><argument_list>(<argument><expr><name><name>bi</name><operator>-&gt;</operator><name>script</name></name></expr></argument>, <argument><expr><name><name>bi</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* show available builtin scripts */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>listAvailableScripts</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>branch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Available builtin scripts:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>builtin_script</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>branch</name> <operator>==</operator> <name>branch</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\t%s\n"</literal></expr></argument>, <argument><expr><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return builtin script "name" if unambiguous, fails if not found */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>BuiltinScript</name> <modifier>*</modifier></type>
<name>findBuiltin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>branch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BuiltinScript</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>builtin_script</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>branch</name> <operator>!=</operator> <name>branch</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* ok, unambiguous result */</comment>
    <if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* error cases */</comment>
    <if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"no builtin script found for name \"%s\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>                        <comment type="block">/* found &gt; 1 */</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><literal type="string">"ambiguous builtin name: %d builtin scripts found for prefix \"%s\"\n"</literal></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>listAvailableScripts</name><argument_list>(<argument><expr><name>branch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the weight specification from a script option (-b, -f), if any,
 * and return it as an integer (1 is returned if there's no weight).  The
 * script name is returned in *script as a malloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parseScriptWeight</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>script</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>weight</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sep</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>WSEP</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>namelen</name> <init>= <expr><name>sep</name> <operator>-</operator> <name>option</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type>        <name>wtmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>badp</name></decl>;</decl_stmt>

        <comment type="block">/* generate the script name */</comment>
        <expr_stmt><expr><operator>*</operator><name>script</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>namelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>*</operator><name>script</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>script</name><operator>)</operator><index>[<expr><name>namelen</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <comment type="block">/* process digits of the weight spec */</comment>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>wtmp</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>badp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>badp</name> <operator>==</operator> <name>sep</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>badp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid weight specification: %s\n"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>wtmp</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>wtmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"weight specification out of range (0 .. %u): "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
                    <argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>wtmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>weight</name> <operator>=</operator> <name>wtmp</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>script</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>weight</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* append a script to the list of scripts to process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addScript</name><parameter_list>(<parameter><decl><type><name>ParsedScript</name></type> <name>script</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>script</name><operator>.</operator><name>commands</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>script</name><operator>.</operator><name>commands</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"empty command list for script \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>script</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>&gt;=</operator> <name>MAX_SCRIPTS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"at most %d SQL scripts are allowed\n"</literal></expr></argument>, <argument><expr><name>MAX_SCRIPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>sql_script</name><index>[<expr><name>num_scripts</name></expr>]</index></name> <operator>=</operator> <name>script</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_scripts</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printSimpleStats</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* print NaN if no transactions where executed */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>latency</name> <init>= <expr><name><name>ss</name><operator>-&gt;</operator><name>sum</name></name> <operator>/</operator> <name><name>ss</name><operator>-&gt;</operator><name>count</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>stddev</name> <init>= <expr><call><name>sqrt</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>sum2</name></name> <operator>/</operator> <name><name>ss</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>latency</name> <operator>*</operator> <name>latency</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s average = %.3f ms\n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s stddev = %.3f ms\n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name>stddev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* print out results */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printResults</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>threads</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>total</name></decl></parameter>, <parameter><decl><type><name>instr_time</name></type> <name>total_time</name></decl></parameter>,
             <parameter><decl><type><name>instr_time</name></type> <name>conn_total_time</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>latency_late</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>time_include</name></decl>,
                <decl><type ref="prev"/><name>tps_include</name></decl>,
                <decl><type ref="prev"/><name>tps_exclude</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>time_include</name> <operator>=</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tps_include</name> <operator>=</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name> <operator>/</operator> <name>time_include</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tps_exclude</name> <operator>=</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name> <operator>/</operator> <operator>(</operator><name>time_include</name> <operator>-</operator>
                                <operator>(</operator><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>conn_total_time</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>nclients</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Report test parameters. */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"transaction type: %s\n"</literal></expr></argument>,
           <argument><expr><ternary><condition><expr><name>num_scripts</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>sql_script</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name></expr> </then><else>: <expr><literal type="string">"multiple scripts"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"scaling factor: %d\n"</literal></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"query mode: %s\n"</literal></expr></argument>, <argument><expr><name><name>QUERYMODE</name><index>[<expr><name>querymode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of clients: %d\n"</literal></expr></argument>, <argument><expr><name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of threads: %d\n"</literal></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions per client: %d\n"</literal></expr></argument>, <argument><expr><name>nxacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions actually processed: "</literal> <name>INT64_FORMAT</name> <literal type="string">"/%d\n"</literal></expr></argument>,
               <argument><expr><name><name>total</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>, <argument><expr><name>nxacts</name> <operator>*</operator> <name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"duration: %d s\n"</literal></expr></argument>, <argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions actually processed: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
               <argument><expr><name><name>total</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Remaining stats are nonsensical if we failed to execute any xacts */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>cnt</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>throttle_delay</name> <operator>&amp;&amp;</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions skipped: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f %%)\n"</literal></expr></argument>,
               <argument><expr><name><name>total</name><operator>-&gt;</operator><name>skipped</name></name></expr></argument>,
               <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>skipped</name></name> <operator>/</operator> <operator>(</operator><name><name>total</name><operator>-&gt;</operator><name>skipped</name></name> <operator>+</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions above the %.1f ms latency limit: %d (%.3f %%)\n"</literal></expr></argument>,
               <argument><expr><name>latency_limit</name> <operator>/</operator> <literal type="number">1000.0</literal></expr></argument>, <argument><expr><name>latency_late</name></expr></argument>,
               <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name>latency_late</name> <operator>/</operator> <operator>(</operator><name><name>total</name><operator>-&gt;</operator><name>skipped</name></name> <operator>+</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>throttle_delay</name> <operator>||</operator> <name>progress</name> <operator>||</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printSimpleStats</name><argument_list>(<argument><expr><literal type="string">"latency"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>total</name><operator>-&gt;</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* no measurement, show average latency computed from run time */</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"latency average = %.3f ms\n"</literal></expr></argument>,
               <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name>time_include</name> <operator>*</operator> <name>nclients</name> <operator>/</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Report average transaction lag under rate limit throttling.  This
         * is the delay between scheduled and actual start times for the
         * transaction.  The measured lag may be caused by thread/client load,
         * the database load, or the Poisson throttling process.
         */</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"rate limit schedule lag: avg %.3f (max %.3f) ms\n"</literal></expr></argument>,
               <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>sum</name></name> <operator>/</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>, <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"tps = %f (including connections establishing)\n"</literal></expr></argument>, <argument><expr><name>tps_include</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"tps = %f (excluding connections establishing)\n"</literal></expr></argument>, <argument><expr><name>tps_exclude</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Report per-script/command statistics */</comment>
    <if_stmt><if>if <condition>(<expr><name>per_script_stats</name> <operator>||</operator> <name>latency_limit</name> <operator>||</operator> <name>is_latencies</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_scripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SQL script %d: %s\n"</literal>
                       <literal type="string">" - weight: %d (targets %.1f%% of total)\n"</literal>
                       <literal type="string">" - "</literal> <name>INT64_FORMAT</name> <literal type="string">" transactions (%.1f%% of total, tps = %f)\n"</literal></expr></argument>,
                       <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr></argument>,
                       <argument><expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name></expr></argument>,
                       <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name> <operator>/</operator> <name>total_weight</name></expr></argument>,
                       <argument><expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>cnt</name></name></expr></argument>,
                       <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>cnt</name></name> <operator>/</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>,
                       <argument><expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>cnt</name></name> <operator>/</operator> <name>time_include</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"script statistics:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - number of transactions skipped: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
                       <argument><expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>skipped</name></name></expr></argument>,
                       <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>skipped</name></name> <operator>/</operator>
                       <operator>(</operator><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>skipped</name></name> <operator>+</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>cnt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printSimpleStats</name><argument_list>(<argument><expr><literal type="string">" - latency"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Report per-command latencies */</comment>
            <if_stmt><if>if <condition>(<expr><name>is_latencies</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - statement latencies in milliseconds:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>(<init><expr><name>commands</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commands</name></expr>;</init>
                     <condition><expr><operator>*</operator><name>commands</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
                     <incr><expr><name>commands</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"   %11.3f  %s\n"</literal></expr></argument>,
                           <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name><name>stats</name><operator>.</operator><name>sum</name></name></name> <operator>/</operator>
                           <name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name><name>stats</name><operator>.</operator><name>count</name></name></name></expr></argument>,
                           <argument><expr><name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
        <comment type="block">/* systematic long/short named options */</comment>
        <expr><block>{<expr><literal type="string">"builtin"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'b'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"client"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"connect"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'C'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"define"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"fillfactor"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"initialize"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'i'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"jobs"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'j'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"latency-limit"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'L'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"no-vacuum"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"progress"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'P'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"protocol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'M'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"quiet"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'q'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"report-latencies"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"rate"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"scale"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"select-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"skip-some-updates"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"time"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"transactions"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"vacuum-all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
        <comment type="block">/* long-named only options */</comment>
        <expr><block>{<expr><literal type="string">"foreign-keys"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name>foreign_keys</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"index-tablespace"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"tablespace"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"unlogged-tables"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name>unlogged_tables</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"sampling-rate"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"aggregate-interval"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"progress-timestamp"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"log-prefix"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
        <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>is_init_mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* initialize mode? */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>is_no_vacuum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* no vacuum at all before testing? */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>do_vacuum_accounts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* do vacuum accounts before testing? */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>optindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>scale_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type>        <name>benchmarking_option_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>initialization_option_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>internal_script_used</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>list_scripts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CState</name>       <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>            <comment type="block">/* status of clients */</comment>
    <decl_stmt><decl><type><name>TState</name>       <modifier>*</modifier></type><name>threads</name></decl>;</decl_stmt>        <comment type="block">/* array of thread */</comment>

    <decl_stmt><decl><type><name>instr_time</name></type>    <name>start_time</name></decl>;</decl_stmt>        <comment type="block">/* start up time */</comment>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>total_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>conn_total_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>latency_late</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StatsData</name></type>    <name>stats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>weight</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>            <name>nscripts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>weights</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name><name>scripts</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nclients_dealt</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETRLIMIT</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pgbench (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="block">/* stderr is buffered on Win32. */</comment>
    <expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGHOST"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pghost</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgport</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGUSER"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>login</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>CState</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"ih:knvp:dqb:SNc:j:Crs:t:T:U:lf:D:F:M:P:R:L:"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"ih:nvp:dqb:SNc:j:Crs:t:T:U:lf:D:F:M:P:R:L:"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>script</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'i'</literal></expr>:</case>
                <expr_stmt><expr><name>is_init_mode</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <case>case <expr><literal type="char">'k'</literal></expr>:</case>
                <expr_stmt><expr><name>use_branch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><literal type="char">'h'</literal></expr>:</case>
                <expr_stmt><expr><name>pghost</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                <expr_stmt><expr><name>is_no_vacuum</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'v'</literal></expr>:</case>
                <expr_stmt><expr><name>do_vacuum_accounts</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>
                <expr_stmt><expr><name>pgport</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'d'</literal></expr>:</case>
                <expr_stmt><expr><name>debug</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'c'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nclients</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nclients</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nclients</name> <operator>&gt;</operator> <name>MAXCLIENTS</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid number of clients: \"%s\"\n"</literal></expr></argument>,
                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETRLIMIT</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RLIMIT_NOFILE</name></cpp:ifdef>            <comment type="block">/* most platforms use RLIMIT_NOFILE */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* but BSD doesn't ... */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_OFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* RLIMIT_NOFILE */</comment>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"getrlimit failed: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&lt;</operator> <name>nclients</name> <operator>+</operator> <literal type="number">3</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"need at least %d open files, but system limit is %ld\n"</literal></expr></argument>,
                            <argument><expr><name>nclients</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Reduce number of clients, or use limit/ulimit to increase the system limit.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* HAVE_GETRLIMIT */</comment>
                <break>break;</break>
            <case>case <expr><literal type="char">'j'</literal></expr>:</case>            <comment type="block">/* jobs */</comment>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nthreads</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid number of threads: \"%s\"\n"</literal></expr></argument>,
                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifndef>
                <if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"threads are not supported on this platform; use -j1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* !ENABLE_THREAD_SAFETY */</comment>
                <break>break;</break>
            <case>case <expr><literal type="char">'C'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_connect</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>per_script_stats</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_latencies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'s'</literal></expr>:</case>
                <expr_stmt><expr><name>scale_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid scaling factor: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"specify either a number of transactions (-t) or a duration (-T), not both\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>nxacts</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nxacts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid number of transactions: \"%s\"\n"</literal></expr></argument>,
                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'T'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nxacts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"specify either a number of transactions (-t) or a duration (-T), not both\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>duration</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid duration: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'U'</literal></expr>:</case>
                <expr_stmt><expr><name>login</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'l'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>use_log</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'q'</literal></expr>:</case>
                <expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>use_quiet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>list_scripts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>weights</name><index>[<expr><name>nscripts</name></expr>]</index></name> <operator>=</operator> <call><name>parseScriptWeight</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scripts</name><index>[<expr><name>nscripts</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nscripts</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'S'</literal></expr>:</case>
                <expr_stmt><expr><name><name>weights</name><index>[<expr><name>nscripts</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scripts</name><index>[<expr><name>nscripts</name></expr>]</index></name> <operator>=</operator> <literal type="string">"select-only"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>nscripts</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'N'</literal></expr>:</case>
                <expr_stmt><expr><name><name>weights</name><index>[<expr><name>nscripts</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scripts</name><index>[<expr><name>nscripts</name></expr>]</index></name> <operator>=</operator> <literal type="string">"simple-update"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>nscripts</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                <expr_stmt><expr><name>weight</name> <operator>=</operator> <call><name>parseScriptWeight</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>process_file</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>p</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid variable definition: \"%s\"\n"</literal></expr></argument>,
                                <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"option"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="char">'F'</literal></expr>:</case>
                <expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>fillfactor</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>fillfactor</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">10</literal> <operator>||</operator> <name>fillfactor</name></expr></argument> &gt;</argument_list></name> <literal type="number">100</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid fillfactor: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'M'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>querymode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>querymode</name> <operator>&lt;</operator> <name>NUM_QUERYMODE</name></expr>;</condition> <incr><expr><name>querymode</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>QUERYMODE</name><index>[<expr><name>querymode</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
                <if_stmt><if>if <condition>(<expr><name>querymode</name> <operator>&gt;=</operator> <name>NUM_QUERYMODE</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid query mode (-M): \"%s\"\n"</literal></expr></argument>,
                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'P'</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid thread progress delay: \"%s\"\n"</literal></expr></argument>,
                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'R'</literal></expr>:</case>
                <block>{<block_content>
                    <comment type="block">/* get a double from the beginning of option value */</comment>
                    <decl_stmt><decl><type><name>double</name></type>        <name>throttle_value</name> <init>= <expr><call><name>atof</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>throttle_value</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid rate limit: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* Invert rate limit into a time offset */</comment>
                    <expr_stmt><expr><name>throttle_delay</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><literal type="number">1000000.0</literal> <operator>/</operator> <name>throttle_value</name><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="char">'L'</literal></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>double</name></type>        <name>limit_ms</name> <init>= <expr><call><name>atof</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>limit_ms</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid latency limit: \"%s\"\n"</literal></expr></argument>,
                                <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>latency_limit</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><name>limit_ms</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="number">0</literal></expr>:</case>
                <comment type="block">/* This covers long options which take no argument. */</comment>
                <if_stmt><if>if <condition>(<expr><name>foreign_keys</name> <operator>||</operator> <name>unlogged_tables</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>                <comment type="block">/* tablespace */</comment>
                <expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr>:</case>                <comment type="block">/* index-tablespace */</comment>
                <expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>index_tablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">4</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sample_rate</name> <operator>=</operator> <call><name>atof</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>&lt;=</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>sample_rate</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid sampling rate: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">5</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>agg_interval</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid number of seconds for aggregation: \"%s\"\n"</literal></expr></argument>,
                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">6</literal></expr>:</case>
                <expr_stmt><expr><name>progress_timestamp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">7</literal></expr>:</case>
                <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>logfile_prefix</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></while></block_content></block></while>

    <comment type="block">/* requested to list available scripts */</comment>
    <if_stmt><if>if <condition>(<expr><name>list_scripts</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>listAvailableScripts</name><argument_list>(<argument><expr><name>use_branch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* process the collected scripts */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>process_builtin</name><argument_list>(<argument><expr><call><name>findBuiltin</name><argument_list>(<argument><expr><name><name>scripts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>use_branch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>weights</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* set default script if none */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_init_mode</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>process_builtin</name><argument_list>(<argument><expr><call><name>findBuiltin</name><argument_list>(<argument><expr><literal type="string">"tpcb-like"</literal></expr></argument>, <argument><expr><name>use_branch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if not simple query mode, parse the script(s) to find parameters */</comment>
    <if_stmt><if>if <condition>(<expr><name>querymode</name> <operator>!=</operator> <name>QUERY_SIMPLE</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_scripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name> <init>= <expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commands</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>SQL_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parseQuery</name><argument_list>(<argument><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* compute total_weight */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_scripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <comment type="block">/* cannot overflow: weight is 32b, total_weight 64b */</comment>
        <expr_stmt><expr><name>total_weight</name> <operator>+=</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>total_weight</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_init_mode</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"total script weight must not be zero\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* show per script stats if several scripts are used */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>per_script_stats</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Don't need more threads than there are clients.  (This is not merely an
     * optimization; throttle_delay is calculated incorrectly below if some
     * threads have no clients assigned to them.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>&gt;</operator> <name>nclients</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nthreads</name> <operator>=</operator> <name>nclients</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* compute a per thread delay */</comment>
    <expr_stmt><expr><name>throttle_delay</name> <operator>*=</operator> <name>nthreads</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <name>optind</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dbName</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATABASE"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>dbName</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>login</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>login</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>dbName</name> <operator>=</operator> <name>login</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>dbName</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_init_mode</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>benchmarking_option_set</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"some of the specified options cannot be used in initialization (-i) mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><name>is_no_vacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>initialization_option_set</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"some of the specified options cannot be used in benchmarking mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Use DEFAULT_NXACTS if neither nxacts nor duration is specified. */</comment>
    <if_stmt><if>if <condition>(<expr><name>nxacts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nxacts</name> <operator>=</operator> <name>DEFAULT_NXACTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* --sampling-rate may be used only with -l */</comment>
    <if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>&gt;</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_log</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"log sampling (--sampling-rate) is allowed only when logging transactions (-l)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* --sampling-rate may not be used with --aggregate-interval */</comment>
    <if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>&gt;</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"log sampling (--sampling-rate) and aggregation (--aggregate-interval) cannot be used at the same time\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_log</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"log aggregation is allowed only when actually logging transactions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_log</name> <operator>&amp;&amp;</operator> <name>logfile_prefix</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"log file prefix (--log-prefix) is allowed only when logging transactions (-l)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>agg_interval</name> <operator>&gt;</operator> <name>duration</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"number of seconds for aggregation (%d) must not be higher than test duration (%d)\n"</literal></expr></argument>, <argument><expr><name>agg_interval</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>duration</name> <operator>%</operator> <name>agg_interval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"duration (%d) must be a multiple of aggregation interval (%d)\n"</literal></expr></argument>, <argument><expr><name>duration</name></expr></argument>, <argument><expr><name>agg_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * save main process id in the global variable because process id will be
     * changed after fork.
     */</comment>
    <expr_stmt><expr><name>main_pid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nclients</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>CState</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>state</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nclients</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* copy any -D switch values to all clients */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nvariables</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>variables</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>is_numeric</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariableNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>,
                                           <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>num_value</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>,
                                     <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"pghost: %s pgport: %s nclients: %d nxacts: %d dbName: %s\n"</literal></expr></argument>,
                   <argument><expr><name>pghost</name></expr></argument>, <argument><expr><name>pgport</name></expr></argument>, <argument><expr><name>nclients</name></expr></argument>, <argument><expr><name>nxacts</name></expr></argument>, <argument><expr><name>dbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"pghost: %s pgport: %s nclients: %d duration: %d dbName: %s\n"</literal></expr></argument>,
                   <argument><expr><name>pghost</name></expr></argument>, <argument><expr><name>pgport</name></expr></argument>, <argument><expr><name>nclients</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>, <argument><expr><name>dbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* opening connection... */</comment>
    <expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>con</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"connection to database \"%s\" failed\n"</literal></expr></argument>, <argument><expr><name>dbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>internal_script_used</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * get the scaling factor that should be same as count(*) from
         * pgbench_branches if this is not a custom query
         */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"select count(*) from pgbench_branches"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sqlState</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>sqlState</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>, <argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Perhaps you need to do initialization (\"pgbench -i\") in database \"%s\"\n"</literal></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid count(*) from pgbench_branches: \"%s\"\n"</literal></expr></argument>,
                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* warn if we override user-given -s switch */</comment>
        <if_stmt><if>if <condition>(<expr><name>scale_given</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"scale option ignored, using count from pgbench_branches table (%d)\n"</literal></expr></argument>,
                    <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * :scale variables normally get -s or database scale, but don't override
     * an explicit -D switch
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lookupVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"scale"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariableInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><literal type="string">"scale"</literal></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Define a :client_id variable that is unique per connection. But don't
     * override an explicit -D switch.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lookupVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"client_id"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariableInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><literal type="string">"client_id"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_no_vacuum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"starting vacuum..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum pgbench_branches"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum pgbench_tellers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"truncate pgbench_history"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"end.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>do_vacuum_accounts</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"starting vacuum pgbench_accounts..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze pgbench_accounts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"end.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set random seed */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set up thread data structures */</comment>
    <expr_stmt><expr><name>threads</name> <operator>=</operator> <operator>(</operator><name>TState</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nclients_dealt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TState</name>       <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><index>[<expr><name>nclients_dealt</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>nstate</name></name> <operator>=</operator>
            <operator>(</operator><name>nclients</name> <operator>-</operator> <name>nclients_dealt</name> <operator>+</operator> <name>nthreads</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>nthreads</name> <operator>-</operator> <name>i</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled in later */</comment>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>latency_late</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>nclients_dealt</name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* all clients must be assigned to a thread */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nclients_dealt</name> <operator>==</operator> <name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get start up time */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set alarm if duration is specified. */</comment>
    <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>setalarm</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* start threads */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TState</name>       <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* compute when to stop */</comment>
        <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
                <operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1000000</literal> <operator>*</operator> <name>duration</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* the first thread (i = 0) is executed by main thread */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>err</name> <init>= <expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>threadRun</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>thread</name><operator>-&gt;</operator><name>thread</name></name> <operator>==</operator> <name>INVALID_THREAD</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not create thread: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>thread</name></name> <operator>=</operator> <name>INVALID_THREAD</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>threads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* compute when to stop */</comment>
    <if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>threads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>start_time</name></expr></argument>)</argument_list></call> <operator>+</operator>
            <operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1000000</literal> <operator>*</operator> <name>duration</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>threads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>thread</name> <operator>=</operator> <name>INVALID_THREAD</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* ENABLE_THREAD_SAFETY */</comment>

    <comment type="block">/* wait for threads and accumulate results */</comment>
    <expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>conn_total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TState</name>       <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>thread</name> <operator>==</operator> <name>INVALID_THREAD</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* actually run this thread directly in the main thread */</comment>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>threadRun</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <comment type="block">/* wait of other threads. should check that 0 is returned? */</comment>
            <expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>threadRun</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* ENABLE_THREAD_SAFETY */</comment>

        <comment type="block">/* aggregate thread level stats */</comment>
        <expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>.</operator><name>latency</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>.</operator><name>lag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>cnt</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>cnt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>skipped</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>skipped</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>latency_late</name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>latency_late</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>conn_total_time</name></expr></argument>, <argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>disconnect_all</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * XXX We compute results as though every client of every thread started
     * and finished at the same time.  That model can diverge noticeably from
     * reality for a short benchmark run involving relatively many threads.
     * The first thread may process notably many transactions before the last
     * thread begins.  Improving the model alone would bring limited benefit,
     * because performance during those periods of partial thread count can
     * easily exceed steady state performance.  This is one of the many ways
     * short runs convey deceptive performance figures.
     */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>, <argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printResults</name><argument_list>(<argument><expr><name>threads</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><name>total_time</name></expr></argument>, <argument><expr><name>conn_total_time</name></expr></argument>, <argument><expr><name>latency_late</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>threadRun</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TState</name>       <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>(</operator><name>TState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CState</name>       <modifier>*</modifier></type><name>state</name> <init>= <expr><name><name>thread</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>start</name></decl>,
                <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nstate</name> <init>= <expr><name><name>thread</name><operator>-&gt;</operator><name>nstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>remains</name> <init>= <expr><name>nstate</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* number of remaining clients */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* for reporting progress: */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>thread_start</name> <init>= <expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>last_report</name> <init>= <expr><name>thread_start</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>next_report</name> <init>= <expr><name>last_report</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>progress</name> <operator>*</operator> <literal type="number">1000000</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StatsData</name></type>    <name>last</name></decl>,
                <decl><type ref="prev"/><name>aggs</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Initialize throttling rate target for all of the thread's clients.  It
     * might be a little more accurate to reset thread-&gt;start_time here too.
     * The possible drift seems too small relative to typical throttle delay
     * times to worry about it.
     */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aggs</name></expr></argument>, <argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>last</name> <operator>=</operator> <name>aggs</name></expr>;</expr_stmt>

    <comment type="block">/* open log file if requested */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_log</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>logpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>prefix</name> <init>= <expr><ternary><condition><expr><name>logfile_prefix</name></expr> ?</condition><then> <expr><name>logfile_prefix</name></expr> </then><else>: <expr><literal type="string">"pgbench_log"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>main_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%d.%d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>main_pid</name></expr></argument>, <argument><expr><name><name>thread</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>logpath</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not open logfile \"%s\": %s\n"</literal></expr></argument>,
                    <argument><expr><name>logpath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>done</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_connect</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* make connections to the database */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>con</name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* time after thread and connections set up */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>, <argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* explicitly initialize the state machines */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>CSTATE_CHOOSE_SCRIPT</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* loop till all clients have terminated */</comment>
    <while>while <condition>(<expr><name>remains</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>fd_set</name></type>        <name>input_mask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>maxsock</name></decl>;</decl_stmt>    <comment type="block">/* max socket number to be waited for */</comment>
        <decl_stmt><decl><type><name>int64</name></type>        <name>min_usec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64</name></type>        <name>now_usec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* set this only if needed */</comment>

        <comment type="block">/* identify which client sockets should be checked for input */</comment>
        <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>maxsock</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>min_usec</name> <operator>=</operator> <name>PG_INT64_MAX</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CState</name>       <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_THROTTLE</name> <operator>&amp;&amp;</operator> <name>timer_exceeded</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* interrupt client that has not started a transaction */</comment>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>remains</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_SLEEP</name> <operator>||</operator> <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_THROTTLE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* a nap from the script, or under throttling */</comment>
                <decl_stmt><decl><type><name>int64</name></type>        <name>this_usec</name></decl>;</decl_stmt>

                <comment type="block">/* get current time if needed */</comment>
                <if_stmt><if>if <condition>(<expr><name>now_usec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>instr_time</name></type>    <name>now</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>now_usec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* min_usec should be the minimum delay across all clients */</comment>
                <expr_stmt><expr><name>this_usec</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_SLEEP</name></expr> ?</condition><then>
                             <expr><name><name>st</name><operator>-&gt;</operator><name>sleep_until</name></name></expr> </then><else>: <expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>now_usec</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>min_usec</name> <operator>&gt;</operator> <name>this_usec</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>min_usec</name> <operator>=</operator> <name>this_usec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_WAIT_RESULT</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * waiting for result from server - nothing to do unless the
                 * socket is readable
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type>            <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid socket: %s"</literal></expr></argument>,
                            <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>maxsock</name> <operator>&lt;</operator> <name>sock</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>maxsock</name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>CSTATE_ABORTED</name> <operator>&amp;&amp;</operator>
                     <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>CSTATE_FINISHED</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * This client thread is ready to do something, so we don't
                 * want to wait.  No need to examine additional clients.
                 */</comment>
                <expr_stmt><expr><name>min_usec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* also wake up to print the next progress report on time */</comment>
        <if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name>min_usec</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* get current time if needed */</comment>
            <if_stmt><if>if <condition>(<expr><name>now_usec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>instr_time</name></type>    <name>now</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>now_usec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>now_usec</name> <operator>&gt;=</operator> <name>next_report</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>min_usec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>(</operator><name>next_report</name> <operator>-</operator> <name>now_usec</name><operator>)</operator> <operator>&lt;</operator> <name>min_usec</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>min_usec</name> <operator>=</operator> <name>next_report</name> <operator>-</operator> <name>now_usec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If no clients are ready to execute actions, sleep until we receive
         * data from the server, or a nap-time specified in the script ends,
         * or it's time to print a progress report.  Update input_mask to show
         * which client(s) received data.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>min_usec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>			<name>nsocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* return from select(2) if called */</comment>

            <if_stmt><if>if <condition>(<expr><name>min_usec</name> <operator>!=</operator> <name>PG_INT64_MAX</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>maxsock</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>min_usec</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name>min_usec</name> <operator>%</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nsocks</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else <comment type="block">/* nothing active, simple sleep */</comment>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>min_usec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else <comment type="block">/* no explicit delay, select without timeout */</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>nsocks</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>nsocks</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* On EINTR, go back to top of loop */</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* must be something wrong */</comment>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"select() failed: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>done</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else <comment type="block">/* min_usec == 0, i.e. something needs to be executed */</comment>
        <block>{<block_content>
            <comment type="block">/* If we didn't call select(), don't try to read any data */</comment>
            <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* ok, advance the state machine of each connection */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CState</name>       <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_WAIT_RESULT</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* don't call doCustom unless data is available */</comment>
                <decl_stmt><decl><type><name>int</name></type>            <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid socket: %s"</literal></expr></argument>,
                            <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_FINISHED</name> <operator>||</operator>
                     <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_ABORTED</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* this client is done, no need to consider it anymore */</comment>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>doCustom</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If doCustom changed client to finished state, reduce remains */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_FINISHED</name> <operator>||</operator> <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_ABORTED</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>remains</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* progress report is made by thread 0 for all threads */</comment>
        <if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>instr_time</name></type>    <name>now_time</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64</name></type>        <name>now</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>next_report</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* generate and show report */</comment>
                <decl_stmt><decl><type><name>StatsData</name></type>    <name>cur</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int64</name></type>        <name>run</name> <init>= <expr><name>now</name> <operator>-</operator> <name>last_report</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name></type>        <name>tps</name></decl>,
                            <decl><type ref="prev"/><name>total_run</name></decl>,
                            <decl><type ref="prev"/><name>latency</name></decl>,
                            <decl><type ref="prev"/><name>sqlat</name></decl>,
                            <decl><type ref="prev"/><name>lag</name></decl>,
                            <decl><type ref="prev"/><name>stdev</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type>        <name><name>tbuf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Add up the statistics of all threads.
                 *
                 * XXX: No locking. There is no guarantee that we get an
                 * atomic snapshot of the transaction count and latencies, so
                 * these figures can well be off by a small amount. The
                 * progress is report's purpose is to give a quick overview of
                 * how the test is going, so that shouldn't matter too much.
                 * (If a read from a 64-bit integer is not atomic, you might
                 * get a "torn" read and completely bogus latencies though!)
                 */</comment>
                <expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>.</operator><name>latency</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>.</operator><name>lag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>lag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cur</name><operator>.</operator><name>cnt</name></name> <operator>+=</operator> <name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>cnt</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cur</name><operator>.</operator><name>skipped</name></name> <operator>+=</operator> <name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>skipped</name></name></expr>;</expr_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><name>total_run</name> <operator>=</operator> <operator>(</operator><name>now</name> <operator>-</operator> <name>thread_start</name><operator>)</operator> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>tps</name> <operator>=</operator> <literal type="number">1000000.0</literal> <operator>*</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>cnt</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>cnt</name></name><operator>)</operator> <operator>/</operator> <name>run</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>latency</name> <operator>=</operator> <literal type="number">0.001</literal> <operator>*</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum</name></name><operator>)</operator> <operator>/</operator>
                    <operator>(</operator><name><name>cur</name><operator>.</operator><name>cnt</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>cnt</name></name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>sqlat</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum2</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum2</name></name><operator>)</operator>
                    <operator>/</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>cnt</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>cnt</name></name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>stdev</name> <operator>=</operator> <literal type="number">0.001</literal> <operator>*</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>sqlat</name> <operator>-</operator> <literal type="number">1000000.0</literal> <operator>*</operator> <name>latency</name> <operator>*</operator> <name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lag</name> <operator>=</operator> <literal type="number">0.001</literal> <operator>*</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>lag</name><operator>.</operator><name>sum</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>lag</name><operator>.</operator><name>sum</name></name><operator>)</operator> <operator>/</operator>
                    <operator>(</operator><name><name>cur</name><operator>.</operator><name>cnt</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>cnt</name></name><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>progress_timestamp</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * On some platforms the current system timestamp is
                     * available in now_time, but rather than get entangled
                     * with that, we just eat the cost of an extra syscall in
                     * all cases.
                     */</comment>
                    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%ld.%03ld s"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.1f s"</literal></expr></argument>, <argument><expr><name>total_run</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><literal type="string">"progress: %s, %.1f tps, lat %.3f ms stddev %.3f"</literal></expr></argument>,
                        <argument><expr><name>tbuf</name></expr></argument>, <argument><expr><name>tps</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>stdev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">", lag %.3f ms"</literal></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">" skipped"</literal></expr></argument>,
                                <argument><expr><name><name>cur</name><operator>.</operator><name>skipped</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>skipped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>last</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>last_report</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Ensure that the next report is in the future, in case
                 * pgbench/postgres got stuck somewhere.
                 */</comment>
                <do>do
                <block>{<block_content>
                    <expr_stmt><expr><name>next_report</name> <operator>+=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>progress</name> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>next_report</name></expr>)</condition>;</do>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>disconnect_all</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* log aggregated but not yet reported transactions */</comment>
            <expr_stmt><expr><call><name>doLog</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Support for duration option: set timer_exceeded after so many seconds.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_sig_alarm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>timer_exceeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setalarm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>handle_sig_alarm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>alarm</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* WIN32 */</comment>

<function><type><specifier>static</specifier> <name>VOID</name> <name>CALLBACK</name></type>
<name>win32_timer_callback</name><parameter_list>(<parameter><decl><type><name>PVOID</name></type> <name>lpParameter</name></decl></parameter>, <parameter><decl><type><name>BOOLEAN</name></type> <name>TimerOrWaitFired</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>timer_exceeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setalarm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HANDLE</name></type>        <name>queue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type>        <name>timer</name></decl>;</decl_stmt>

    <comment type="block">/* This function will be called at most once, so we can cheat a bit. */</comment>
    <expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>CreateTimerQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>seconds</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>DWORD</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal> <operator>||</operator>
        <operator>!</operator><call><name>CreateTimerQueueTimer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timer</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>,
                               <argument><expr><name>win32_timer_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>seconds</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>WT_EXECUTEINTIMERTHREAD</name> <operator>|</operator> <name>WT_EXECUTEONLYONCE</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to set timer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* partial pthread implementation for Windows */</comment>

<typedef>typedef <type><struct>struct <name>win32_pthread</name>
<block>{
    <decl_stmt><decl><type><name>HANDLE</name></type>        <name>handle</name></decl>;</decl_stmt>
    <function_decl><type><name>void</name>       <modifier>*</modifier></type>(<modifier>*</modifier><name>routine</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
}</block></struct></type> <name>win32_pthread</name>;</typedef>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>__stdcall</name></type>
<name>win32_pthread_run</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>win32_pthread</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><operator>(</operator><name>win32_pthread</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name><name>th</name><operator>-&gt;</operator><name>routine</name></name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pthread_create</name><parameter_list>(<parameter><decl><type><name>pthread_t</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>,
               <parameter><decl><type><name>pthread_attr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>,
               <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>start_routine</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
               <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>win32_pthread</name> <modifier>*</modifier></type><name>th</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>th</name> <operator>=</operator> <operator>(</operator><name>win32_pthread</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>win32_pthread</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>routine</name></name> <operator>=</operator> <name>start_routine</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>win32_pthread_run</name></expr></argument>, <argument><expr><name>th</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>save_errno</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>thread</name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pthread_join</name><parameter_list>(<parameter><decl><type><name>pthread_t</name></type> <name>th</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>thread_return</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>th</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>th</name><operator>-&gt;</operator><name>handle</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>WAIT_OBJECT_0</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>errno</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>thread_return</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>thread_return</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>
</unit>
