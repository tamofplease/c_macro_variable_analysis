<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/initdb/initdb.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * initdb --- initialize a PostgreSQL installation
 *
 * initdb creates (initializes) a PostgreSQL database cluster (site,
 * instance, installation, whatever).  A database cluster is a
 * collection of PostgreSQL databases all managed by the same server.
 *
 * To create the database cluster, we create the directory that contains
 * all its data, create the files that hold the global tables, create
 * a few other control files for it, and create three databases: the
 * template databases "template0" and "template1", and a default user
 * database "postgres".
 *
 * The template databases are ordinary PostgreSQL databases.  template0
 * is never supposed to change after initdb, whereas template1 can be
 * changed to add site-local standard data.  Either one can be copied
 * to produce a new database.
 *
 * For largely-historical reasons, the template1 database is the one built
 * by the basic bootstrap process.  After it is complete, template0 and
 * the default database, postgres, are made just by copying template1.
 *
 * To create template1, we run the postgres (backend) program in bootstrap
 * mode and feed it data from the postgres.bki library file.  After this
 * initial bootstrap phase, some additional stuff is created by normal
 * SQL commands fed to a standalone backend.  Some of those commands are
 * just embedded into this program (yeah, it's ugly), but larger chunks
 * are taken from script files.
 *
 *
 * Note:
 *     The program has some memory leakage - it isn't worth cleaning it up.
 *
 * This is a C implementation of the previous shell script for setting up a
 * PostgreSQL cluster location, and should be highly compatible with it.
 * author of C translation: Andrew Dunstan       mailto:andrew@dunslane.net
 *
 * This code is released under the terms of the PostgreSQL License.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/initdb/initdb.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SHM_OPEN</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sys/mman.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/restricted_token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/username.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getaddrinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>


<comment type="block">/* Ideally this would be in a .h file, but it hardly seems worth the trouble */</comment>
<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>select_default_timezone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>share_path</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>auth_methods_host</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"trust"</literal></expr>, <expr><literal type="string">"reject"</literal></expr>, <expr><literal type="string">"scram-sha-256"</literal></expr>, <expr><literal type="string">"md5"</literal></expr>, <expr><literal type="string">"password"</literal></expr>, <expr><literal type="string">"ident"</literal></expr>, <expr><literal type="string">"radius"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
    <expr><literal type="string">"gss"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
    <expr><literal type="string">"sspi"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>
    <expr><literal type="string">"pam"</literal></expr>, <expr><literal type="string">"pam "</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
    <expr><literal type="string">"bsd"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
    <expr><literal type="string">"ldap"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
    <expr><literal type="string">"cert"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>auth_methods_local</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"trust"</literal></expr>, <expr><literal type="string">"reject"</literal></expr>, <expr><literal type="string">"scram-sha-256"</literal></expr>, <expr><literal type="string">"md5"</literal></expr>, <expr><literal type="string">"password"</literal></expr>, <expr><literal type="string">"peer"</literal></expr>, <expr><literal type="string">"radius"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>
    <expr><literal type="string">"pam"</literal></expr>, <expr><literal type="string">"pam "</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
    <expr><literal type="string">"bsd"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
    <expr><literal type="string">"ldap"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * these values are passed in by makefile defines
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>share_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* values to be obtained from arguments */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_data</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_collate</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_ctype</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_monetary</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_numeric</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_time</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_messages</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>default_text_search_config</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pwprompt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pwfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>superuser_password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>authmethodhost</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>authmethodlocal</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>noclean</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_sync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>sync_only</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>show_setting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>data_checksums</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog_dir</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mls_admin</name>     <init>= <expr><literal type="string">"mls_admin"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>audit_admin</name>   <init>= <expr><literal type="string">"audit_admin"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/* Name of the PGXC node initialized */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>nodename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Type of the PGXC node initialized */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>nodetype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>master_gtm_ip</name>           <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>master_gtm_port</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>master_gtm_nodename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* internal vars */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>encodingid</name> <init>= <expr><literal type="string">"0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>bki_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>desc_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>shdesc_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>hba_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ident_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>conf_file</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>bouncer_conf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>bouncer_auth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>gtm_proxy</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>conversion_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>dictionary_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>info_schema_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>features_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>system_views_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>infoversion</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>caught_signal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>output_failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>output_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pgdata_native</name></decl>;</decl_stmt>

<comment type="block">/* defaults */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>n_connections</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>n_buffers</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>dynamic_shared_memory_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Warning messages for authentication methods
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTHTRUST_WARNING</name></cpp:macro> \
<cpp:value>"# CAUTION: Configuring the system for local \"trust\" authentication\n" \
"# allows any local user to connect as any PostgreSQL user, including\n" \
"# the database superuser.  If you do not trust all your local users,\n" \
"# use another authentication method.\n"</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>authwarning</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Centralized knowledge of switches to pass to backend
 *
 * Note: we run the backend with -F (fsync disabled) and then do a single
 * pass of fsync'ing at the end.  This is faster than fsync'ing each step.
 *
 * Note: in the shell-script version, we also passed PGDATA as a -D switch,
 * but here it is more convenient to pass it as an environment variable
 * (no quoting to worry about).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>boot_options</name> <init>= <expr><literal type="string">"-F"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backend_options</name> <init>= <expr><literal type="string">"--single "</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                                     <literal type="string">"--localxid "</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                     <literal type="string">"-F -O -j -c search_path=pg_catalog -c exit_on_error=true"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>subdirs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"global"</literal></expr>,
    <expr><literal type="string">"pg_wal/archive_status"</literal></expr>,
    <expr><literal type="string">"pg_commit_ts"</literal></expr>,
    <expr><literal type="string">"pg_dynshmem"</literal></expr>,
    <expr><literal type="string">"pg_notify"</literal></expr>,
    <expr><literal type="string">"pg_serial"</literal></expr>,
    <expr><literal type="string">"pg_snapshots"</literal></expr>,
    <expr><literal type="string">"pg_subtrans"</literal></expr>,
    <expr><literal type="string">"pg_twophase"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <expr><literal type="string">"pg_2pc"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><literal type="string">"pg_multixact"</literal></expr>,
    <expr><literal type="string">"pg_multixact/members"</literal></expr>,
    <expr><literal type="string">"pg_multixact/offsets"</literal></expr>,
    <expr><literal type="string">"base"</literal></expr>,
    <expr><literal type="string">"base/1"</literal></expr>,
    <expr><literal type="string">"pg_replslot"</literal></expr>,
    <expr><literal type="string">"pg_tblspc"</literal></expr>,
    <expr><literal type="string">"pg_stat"</literal></expr>,
    <expr><literal type="string">"pg_stat_tmp"</literal></expr>,
    <expr><literal type="string">"pg_xact"</literal></expr>,
    <expr><literal type="string">"pg_logical"</literal></expr>,
    <expr><literal type="string">"pg_logical/snapshots"</literal></expr>,
    <expr><literal type="string">"pg_logical/mappings"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* path to 'initdb' binary directory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>bin_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>backend_exec</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>replace_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filter_lines_with_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writefile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>popen_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exit_nicely</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_encoding_id</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>encoding_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_version_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extrapath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_null_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>test_config_settings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bootstrap_template1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_auth</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_pgxc_node</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_su_pwd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_depend</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_sysviews</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_nodeself</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_description</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_collation</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_conversion</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_dictionary</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_privileges</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_info_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_schema</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_plpgsql</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_gtm_info</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_db</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_template0</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_postgres</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>trapsig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_ok</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>escape_quotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>locale_date_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_locale_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>,
                  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>canonname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_locale_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setlocales</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>setup_pgdata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>setup_bin_paths</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>setup_data_file_paths</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>setup_locale_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>setup_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>setup_text_search</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>create_data_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>create_xlog_or_symlink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>warn_on_mount_point</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>initialize_data_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * macros for running pipes to postgres
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_DECL</name></cpp:macro>        <cpp:value>char cmd[MAXPGPATH]; FILE *cmdfd</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_OPEN</name></cpp:macro> \
<cpp:value>do { \
    cmdfd = popen_check(cmd, "w"); \
    if (cmdfd == NULL) \
        exit_nicely(); <comment type="block">/* message already printed by popen_check */</comment> \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_CLOSE</name></cpp:macro> \
<cpp:value>do { \
    if (pclose_check(cmdfd)) \
        exit_nicely(); <comment type="block">/* message already printed by pclose_check */</comment> \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PUTS</name><parameter_list>(<parameter><type><name>line</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    if (fputs(line, cmdfd) &lt; 0 || fflush(cmdfd) &lt; 0) \
        output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PRINTF1</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    if (fprintf(cmdfd, fmt, arg1) &lt; 0 || fflush(cmdfd) &lt; 0) \
        output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PRINTF2</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>, <parameter><type><name>arg2</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    if (fprintf(cmdfd, fmt, arg1, arg2) &lt; 0 || fflush(cmdfd) &lt; 0) \
        output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PRINTF3</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>, <parameter><type><name>arg2</name></type></parameter>, <parameter><type><name>arg3</name></type></parameter>)</parameter_list></cpp:macro>        \
<cpp:value>do { \
    if (fprintf(cmdfd, fmt, arg1, arg2, arg3) &lt; 0 || fflush(cmdfd) &lt; 0) \
        output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>escape_quotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>escape_single_quotes_ascii</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make a copy of the array of lines, with token replaced by replacement
 * the first time it occurs on each line.
 *
 * This does most of what sed was used for in the shell script, but
 * doesn't need any regexp stuff.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>replace_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numlines</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>toklen</name></decl>,
                <decl><type ref="prev"/><name>replen</name></decl>,
                <decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>numlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numlines</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>toklen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>replen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>diff</name> <operator>=</operator> <name>replen</name> <operator>-</operator> <name>toklen</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numlines</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>where</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newline</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>pre</name></decl>;</decl_stmt>

        <comment type="block">/* just copy pointer if NULL or no change needed */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>where</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* if we get here a change is needed - set up new line */</comment>

        <expr_stmt><expr><name>newline</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>diff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pre</name> <operator>=</operator> <name>where</name> <operator>-</operator> <name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newline</name></expr></argument>, <argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newline</name> <operator>+</operator> <name>pre</name></expr></argument>, <argument><expr><name>replacement</name></expr></argument>, <argument><expr><name>replen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newline</name> <operator>+</operator> <name>pre</name> <operator>+</operator> <name>replen</name></expr></argument>, <argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>pre</name> <operator>+</operator> <name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newline</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make a copy of lines without any that contain the token
 *
 * a sort of poor man's grep -v
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>filter_lines_with_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numlines</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>src</name></decl>,
                <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>numlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numlines</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>src</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>dst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>src</name> <operator>&lt;</operator> <name>numlines</name></expr>;</condition> <incr><expr><name>src</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>dst</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get the lines from a text file
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>infile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxlength</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>linelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nlines</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>infile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pass over the file twice - the first time to size the result */</comment>

    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>linelen</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nlines</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;</operator> <name>maxlength</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>maxlength</name> <operator>=</operator> <name>linelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>linelen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* handle last line without a terminating newline (yuck) */</comment>
    <if_stmt><if>if <condition>(<expr><name>linelen</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;</operator> <name>maxlength</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>maxlength</name> <operator>=</operator> <name>linelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* set up the result and the line buffer */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>nlines</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>maxlength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* now reprocess the file and store the lines */</comment>
    <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>infile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name>nlines</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write an array of lines to a file
 *
 * This is only used to write text files.  Use fopen "w" not PG_BINARY_W
 * so that the resulting configuration files are nicely editable on Windows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>writefile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>out_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>out_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>fputs</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>, <argument><expr><name>out_file</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>out_file</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open a subcommand with suitable error messaging
 */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>popen_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>cmdfd</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cmdfd</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmdfd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not execute command \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>cmdfd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clean up any files we created on failure
 * if we created the data directory remove it too
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exit_nicely</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noclean</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>found_existing_pgdata</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing contents of data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove contents of data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing WAL directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove WAL directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>found_existing_xlogdir</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing contents of WAL directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove contents of WAL directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* otherwise died during startup, do nothing! */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name> <operator>||</operator> <name>found_existing_pgdata</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: data directory \"%s\" not removed at user's request\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name> <operator>||</operator> <name>found_existing_xlogdir</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WAL directory \"%s\" not removed at user's request\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find the current user
 *
 * on unix make sure it isn't root
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>            <comment type="block">/* 0 is root's uid */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot be run as root\n"</literal>
                  <literal type="string">"Please log in (using, e.g., \"su\") as the "</literal>
                  <literal type="string">"(unprivileged) user that will\n"</literal>
                  <literal type="string">"own the server process.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>get_user_name_or_exit</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>encodingid_to_string</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>result</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get the encoding id for a given encoding name
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_encoding_id</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>encoding_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>enc</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>encoding_name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>encoding_name</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>enc</name> <operator>=</operator> <call><name>pg_valid_server_encoding</name><argument_list>(<argument><expr><name>encoding_name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>encodingid_to_string</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: \"%s\" is not a valid server encoding name\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>progname</name></expr></argument>, <argument><expr><ternary><condition><expr><name>encoding_name</name></expr> ?</condition><then> <expr><name>encoding_name</name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for determining the best default text search configuration.
 * We key this off the first part of LC_CTYPE (ie, the language name).
 */</comment>
<struct>struct <name>tsearch_config_match</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tsconfname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>langname</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>tsearch_config_match</name></name></type> <name><name>tsearch_config_languages</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><block>{<expr><literal type="string">"danish"</literal></expr>, <expr><literal type="string">"da"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"danish"</literal></expr>, <expr><literal type="string">"Danish"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"dutch"</literal></expr>, <expr><literal type="string">"nl"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"dutch"</literal></expr>, <expr><literal type="string">"Dutch"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"C"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"POSIX"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"en"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"English"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"finnish"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"finnish"</literal></expr>, <expr><literal type="string">"Finnish"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"french"</literal></expr>, <expr><literal type="string">"fr"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"french"</literal></expr>, <expr><literal type="string">"French"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"german"</literal></expr>, <expr><literal type="string">"de"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"german"</literal></expr>, <expr><literal type="string">"German"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"hungarian"</literal></expr>, <expr><literal type="string">"hu"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"hungarian"</literal></expr>, <expr><literal type="string">"Hungarian"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"italian"</literal></expr>, <expr><literal type="string">"it"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"italian"</literal></expr>, <expr><literal type="string">"Italian"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"norwegian"</literal></expr>, <expr><literal type="string">"no"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"norwegian"</literal></expr>, <expr><literal type="string">"Norwegian"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"portuguese"</literal></expr>, <expr><literal type="string">"pt"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"portuguese"</literal></expr>, <expr><literal type="string">"Portuguese"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"romanian"</literal></expr>, <expr><literal type="string">"ro"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"russian"</literal></expr>, <expr><literal type="string">"ru"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"russian"</literal></expr>, <expr><literal type="string">"Russian"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"spanish"</literal></expr>, <expr><literal type="string">"es"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"spanish"</literal></expr>, <expr><literal type="string">"Spanish"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"swedish"</literal></expr>, <expr><literal type="string">"sv"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"swedish"</literal></expr>, <expr><literal type="string">"Swedish"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"turkish"</literal></expr>, <expr><literal type="string">"tr"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"turkish"</literal></expr>, <expr><literal type="string">"Turkish"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>                <comment type="block">/* end marker */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Look for a text search configuration matching lc_ctype, and return its
 * name; return NULL if no match.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>find_matching_ts_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>langname</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Convert lc_ctype to a language name by stripping everything after an
     * underscore (usual case) or a hyphen (Windows "locale name"; see
     * comments at IsoLocaleName()).
     *
     * XXX Should ' ' be a stop character?    This would select "norwegian" for
     * the Windows locale "Norwegian (Nynorsk)_Norway.1252".  If we do so, we
     * should also accept the "nn" and "nb" Unix locales.
     *
     * Just for paranoia, we also stop at '.' or '@'.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>lc_type</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>langname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>langname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>lc_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator>
               <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tsearch_config_languages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tsconfname</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>tsearch_config_languages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>langname</name></expr></argument>, <argument><expr><name>langname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>langname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>tsearch_config_languages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tsconfname</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>langname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * set name of given input file variable under data directory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>share_path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check that given input file exists
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: file \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
                      <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not access file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                    <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
                      <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: file \"%s\" is not a regular file\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
                  <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * write out the PG_VERSION file in the data dir, or its subdirectory
 * if extrapath is not NULL
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_version_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extrapath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>version_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>extrapath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>extrapath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>version_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>version_file</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>PG_MAJORVERSION</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>fclose</name><argument_list>(<argument><expr><name>version_file</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up an empty config file so we can check config settings by launching
 * a test backend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_null_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>conf_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/postgresql.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conf_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>conf_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine which dynamic shared memory implementation should be used on
 * this platform.  POSIX shared memory is preferable because the default
 * allocation limits are much higher than the limits for System V on most
 * systems that support both, but the fact that a platform has shm_open
 * doesn't guarantee that that call will succeed when attempted.  So, we
 * attempt to reproduce what the postmaster will do when allocating a POSIX
 * segment in dsm_impl.c; if it doesn't work, we assume it won't work for
 * the postmaster either, and configure the cluster for System V shared
 * memory instead.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>choose_dsm_implementation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SHM_OPEN</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>            <name>ntries</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>ntries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>handle</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"/PostgreSQL.%u"</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>shm_open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>shm_unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="string">"posix"</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>--</operator><name>ntries</name></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <return>return <expr><literal type="string">"windows"</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><literal type="string">"sysv"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Determine platform-specific config settings
 *
 * Use reasonable values if kernel will let us, else scale back.  Probe
 * for max_connections first since it is subject to more constraints than
 * shared_buffers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_config_settings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * This macro defines the minimum shared_buffers we want for a given
     * max_connections value. The arrays show the settings to try.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_BUFS_FOR_CONNS</name><parameter_list>(<parameter><type><name>nconns</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((nconns) * 10)</cpp:value></cpp:define>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>trial_conns</name><index>[]</index></name> <init>= <expr><block>{
        <expr><literal type="number">100</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">10</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>trial_bufs</name><index>[]</index></name> <init>= <expr><block>{
        <expr><literal type="number">16384</literal></expr>, <expr><literal type="number">8192</literal></expr>, <expr><literal type="number">4096</literal></expr>, <expr><literal type="number">3584</literal></expr>, <expr><literal type="number">3072</literal></expr>, <expr><literal type="number">2560</literal></expr>, <expr><literal type="number">2048</literal></expr>, <expr><literal type="number">1536</literal></expr>,
        <expr><literal type="number">1000</literal></expr>, <expr><literal type="number">900</literal></expr>, <expr><literal type="number">800</literal></expr>, <expr><literal type="number">700</literal></expr>, <expr><literal type="number">600</literal></expr>, <expr><literal type="number">500</literal></expr>,
        <expr><literal type="number">400</literal></expr>, <expr><literal type="number">300</literal></expr>, <expr><literal type="number">200</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">50</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name></type>        <name><name>cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>    <name>connslen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>trial_conns</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>    <name>bufslen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>trial_bufs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>status</name></decl>,
                <decl><type ref="prev"/><name>test_conns</name></decl>,
                <decl><type ref="prev"/><name>test_buffs</name></decl>,
                <decl><type ref="prev"/><name>ok_buffers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"selecting default max_connections ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>connslen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>test_conns</name> <operator>=</operator> <name><name>trial_conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>test_buffs</name> <operator>=</operator> <call><name>MIN_BUFS_FOR_CONNS</name><argument_list>(<argument><expr><name>test_conns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><literal type="string">"\"%s\" --boot -x0 %s "</literal>
                 <literal type="string">"-c max_connections=%d "</literal>
                 <literal type="string">"-c shared_buffers=%d "</literal>
                 <literal type="string">"-c dynamic_shared_memory_type=none "</literal>
                 <literal type="string">"&lt; \"%s\" &gt; \"%s\" 2&gt;&amp;1"</literal></expr></argument>,
                 <argument><expr><name>backend_exec</name></expr></argument>, <argument><expr><name>boot_options</name></expr></argument>,
                 <argument><expr><name>test_conns</name></expr></argument>, <argument><expr><name>test_buffs</name></expr></argument>,
                 <argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ok_buffers</name> <operator>=</operator> <name>test_buffs</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>connslen</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>connslen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>n_connections</name> <operator>=</operator> <name><name>trial_conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>n_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"selecting default shared_buffers ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bufslen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Use same amount of memory, independent of BLCKSZ */</comment>
        <expr_stmt><expr><name>test_buffs</name> <operator>=</operator> <operator>(</operator><name><name>trial_bufs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">8192</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>test_buffs</name> <operator>&lt;=</operator> <name>ok_buffers</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>test_buffs</name> <operator>=</operator> <name>ok_buffers</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><literal type="string">"\"%s\" --boot -x0 %s "</literal>
                 <literal type="string">"-c max_connections=%d "</literal>
                 <literal type="string">"-c shared_buffers=%d "</literal>
                 <literal type="string">"-c dynamic_shared_memory_type=none "</literal>
                 <literal type="string">"&lt; \"%s\" &gt; \"%s\" 2&gt;&amp;1"</literal></expr></argument>,
                 <argument><expr><name>backend_exec</name></expr></argument>, <argument><expr><name>boot_options</name></expr></argument>,
                 <argument><expr><name>n_connections</name></expr></argument>, <argument><expr><name>test_buffs</name></expr></argument>,
                 <argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>n_buffers</name> <operator>=</operator> <name>test_buffs</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>%</operator> <literal type="number">1024</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%dMB\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%dkB\n"</literal></expr></argument>, <argument><expr><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"selecting dynamic shared memory implementation ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dynamic_shared_memory_type</name> <operator>=</operator> <call><name>choose_dsm_implementation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>dynamic_shared_memory_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up all the config files
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>conflines</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>repltok</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>default_timezone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name><name>autoconflines</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating configuration files ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* postgresql.conf */</comment>

    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"max_connections = %d"</literal></expr></argument>, <argument><expr><name>n_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#max_connections = 100"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>%</operator> <literal type="number">1024</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"shared_buffers = %dMB"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"shared_buffers = %dkB"</literal></expr></argument>,
                 <argument><expr><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#shared_buffers = 32MB"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#unix_socket_directories = '%s'"</literal></expr></argument>,
             <argument><expr><name>DEFAULT_PGSOCKET_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#unix_socket_directories = ''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#unix_socket_directories = '/tmp'"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEF_PGPORT</name> <operator>!=</operator> <literal type="number">5432</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#port = %d"</literal></expr></argument>, <argument><expr><name>DEF_PGPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#port = 5432"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_messages = '%s'"</literal></expr></argument>,
             <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_messages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_messages = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_monetary = '%s'"</literal></expr></argument>,
             <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_monetary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_monetary = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_numeric = '%s'"</literal></expr></argument>,
             <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_numeric</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_numeric = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_time = '%s'"</literal></expr></argument>,
             <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_time = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>locale_date_order</name><argument_list>(<argument><expr><name>lc_time</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>DATEORDER_YMD</name></expr>:</case>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><literal type="string">"datestyle = 'iso, ymd'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>DATEORDER_DMY</name></expr>:</case>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><literal type="string">"datestyle = 'iso, dmy'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>DATEORDER_MDY</name></expr>:</case>
        <default>default:</default>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><literal type="string">"datestyle = 'iso, mdy'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#datestyle = 'iso, mdy'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>,
             <argument><expr><literal type="string">"default_text_search_config = 'pg_catalog.%s'"</literal></expr></argument>,
             <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>default_text_search_config</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"#default_text_search_config = 'pg_catalog.simple'"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Add Postgres-XC node name to configuration file */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>,
             <argument><expr><literal type="string">"pgxc_node_name = '%s'"</literal></expr></argument>,
             <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#pgxc_node_name = ''"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>default_timezone</name> <operator>=</operator> <call><name>select_default_timezone</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>default_timezone</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"timezone = '%s'"</literal></expr></argument>,
                 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>default_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#timezone = 'GMT'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"log_timezone = '%s'"</literal></expr></argument>,
                 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>default_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#log_timezone = 'GMT'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"dynamic_shared_memory_type = %s"</literal></expr></argument>,
             <argument><expr><name>dynamic_shared_memory_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#dynamic_shared_memory_type = posix"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_BACKEND_FLUSH_AFTER</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#backend_flush_after = %dkB"</literal></expr></argument>,
             <argument><expr><name>DEFAULT_BACKEND_FLUSH_AFTER</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#backend_flush_after = 0"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_BGWRITER_FLUSH_AFTER</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#bgwriter_flush_after = %dkB"</literal></expr></argument>,
             <argument><expr><name>DEFAULT_BGWRITER_FLUSH_AFTER</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#bgwriter_flush_after = 0"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_CHECKPOINT_FLUSH_AFTER</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#checkpoint_flush_after = %dkB"</literal></expr></argument>,
             <argument><expr><name>DEFAULT_CHECKPOINT_FLUSH_AFTER</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#checkpoint_flush_after = 0"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifndef>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"#effective_io_concurrency = 1"</literal></expr></argument>,
                              <argument><expr><literal type="string">"#effective_io_concurrency = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"#update_process_title = on"</literal></expr></argument>,
                              <argument><expr><literal type="string">"#update_process_title = off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                                  <argument><expr><literal type="string">"#password_encryption = md5"</literal></expr></argument>,
                                  <argument><expr><literal type="string">"password_encryption = scram-sha-256"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/postgresql.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * create the automatic configuration file to store the configuration
     * parameters set by ALTER SYSTEM command. The parameters present in this
     * file will override the value of parameters that exists before parse of
     * this file.
     */</comment>
    <expr_stmt><expr><name><name>autoconflines</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"# Do not edit this file manually!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>autoconflines</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"# It will be overwritten by the ALTER SYSTEM command.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>autoconflines</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s/postgresql.auto.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>autoconflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* pg_hba.conf */</comment>

    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>hba_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>filter_lines_with_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"@remove-line-for-nolocal@"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"@remove-line-for-nolocal@"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>

    <comment type="block">/*
     * Probe to see if there is really any platform support for IPv6, and
     * comment out the relevant pg_hba line if not.  This avoids runtime
     * warnings if getaddrinfo doesn't actually cope with IPv6.  Particularly
     * useful on Windows, where executables built on a machine with IPv6 may
     * have to run on a machine without.
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>gai_result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <comment type="block">/* need to call WSAStartup before calling getaddrinfo */</comment>
        <decl_stmt><decl><type><name>WSADATA</name></type>        <name>wsaData</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsaData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* for best results, this code should match parse_hba() */</comment>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addrlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_canonname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>getaddrinfo</name><argument_list>(<argument><expr><literal type="string">"::1"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                                      <argument><expr><literal type="string">"host    all             all             ::1"</literal></expr></argument>,
                                      <argument><expr><literal type="string">"#host    all             all             ::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                                      <argument><expr><literal type="string">"host    replication     all             ::1"</literal></expr></argument>,
                                      <argument><expr><literal type="string">"#host    replication     all             ::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* !HAVE_IPV6 */</comment>
    <comment type="block">/* If we didn't compile IPV6 support at all, always comment it out */</comment>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"host    all             all             ::1"</literal></expr></argument>,
                              <argument><expr><literal type="string">"#host    all             all             ::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"host    replication     all             ::1"</literal></expr></argument>,
                              <argument><expr><literal type="string">"#host    replication     all             ::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* HAVE_IPV6 */</comment>

    <comment type="block">/* Replace default authentication methods */</comment>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"@authmethodhost@"</literal></expr></argument>,
                              <argument><expr><name>authmethodhost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"@authmethodlocal@"</literal></expr></argument>,
                              <argument><expr><name>authmethodlocal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"@authcomment@"</literal></expr></argument>,
                              <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"trust"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"trust"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>AUTHTRUST_WARNING</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/pg_hba.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pg_ident.conf */</comment>

    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>ident_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/pg_ident.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* pgbouncer.ini */</comment>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>bouncer_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/pgbouncer.ini"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pgbouncer log file path */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"logfile = %s/pgbouncer.log"</literal></expr></argument>,
             <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"logfile = /var/log/pgbouncer/pgbouncer.log"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pgbouncer pid file path*/</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pidfile = %s/pgbouncer.pid"</literal></expr></argument>,
             <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"pidfile = /var/run/pgbouncer/pgbouncer.pid"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pgbouncer auth file path*/</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"auth_file = %s/userlist.txt"</literal></expr></argument>,
             <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                              <argument><expr><literal type="string">"auth_file = /etc/pgbouncer/userlist.txt"</literal></expr></argument>,
                              <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pgbouncer auth file */</comment>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>bouncer_auth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/userlist.txt"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pgbouncer auth file */</comment>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>gtm_proxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/gtm_proxy.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * run the BKI script in bootstrap mode to create template1
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bootstrap_template1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><name>PG_CMD_DECL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>talkargs</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>bki_lines</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>headerline</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"running bootstrap script ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>talkargs</name> <operator>=</operator> <literal type="string">"-d 5"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>bki_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check that bki file appears to be of the right version */</comment>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>headerline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>headerline</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"# PostgreSQL %s\n"</literal></expr></argument>,
             <argument><expr><name>PG_MAJORVERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>headerline</name></expr></argument>, <argument><expr><operator>*</operator><name>bki_lines</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: input file \"%s\" does not belong to PostgreSQL %s\n"</literal>
                  <literal type="string">"Check your installation or specify the correct path "</literal>
                  <literal type="string">"using the option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>bki_file</name></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Substitute for various symbols used in the BKI file */</comment>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"NAMEDATALEN"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"SIZEOF_POINTER"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"ALIGNOF_POINTER"</literal></expr></argument>,
                              <argument><expr><ternary><condition><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"i"</literal></expr> </then><else>: <expr><literal type="string">"d"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"FLOAT4PASSBYVAL"</literal></expr></argument>,
                              <argument><expr><ternary><condition><expr><name>FLOAT4PASSBYVAL</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"FLOAT8PASSBYVAL"</literal></expr></argument>,
                              <argument><expr><ternary><condition><expr><name>FLOAT8PASSBYVAL</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"POSTGRES"</literal></expr></argument>, <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"ENCODING"</literal></expr></argument>, <argument><expr><name>encodingid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"LC_COLLATE"</literal></expr></argument>, <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_collate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"LC_CTYPE"</literal></expr></argument>, <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"mls_admin"</literal></expr></argument>, <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>mls_admin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"audit_admin"</literal></expr></argument>, <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>audit_admin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/*
     * Pass correct LC_xxx environment to bootstrap.
     *
     * The shell script arranged to restore the LC settings afterwards, but
     * there doesn't seem to be any compelling reason to do that.
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LC_COLLATE=%s"</literal></expr></argument>, <argument><expr><name>lc_collate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LC_CTYPE=%s"</literal></expr></argument>, <argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Also ensure backend isn't confused by this environment var: */</comment>
    <expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
             <argument><expr><literal type="string">"\"%s\" --boot -x1 %s %s %s"</literal></expr></argument>,
             <argument><expr><name>backend_exec</name></expr></argument>,
             <argument><expr><ternary><condition><expr><name>data_checksums</name></expr> ?</condition><then> <expr><literal type="string">"-k"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
             <argument><expr><name>boot_options</name></expr></argument>, <argument><expr><name>talkargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>PG_CMD_OPEN</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>bki_lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>PG_CMD_CLOSE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up the shadow password table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_auth</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>pg_authid_setup</name><index>[]</index></name> <init>= <expr><block>{
        <comment type="block">/*
         * The authid table shouldn't be readable except through views, to
         * ensure passwords are not publicly visible.
         */</comment>
        <expr><literal type="string">"REVOKE ALL on pg_authid FROM public;\n\n"</literal></expr>,
        <expr><name>NULL</name></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>pg_authid_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>superuser_password</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_CMD_PRINTF2</name><argument_list>(<argument><expr><literal type="string">"ALTER USER \"%s\" WITH PASSWORD E'%s';\n\n"</literal></expr></argument>,
                       <argument><expr><name>username</name></expr></argument>, <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>superuser_password</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up the pgxc_node table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_pgxc_node</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>pgxc_node_setup</name><index>[]</index></name> <init>= <expr><block>{
			<comment type="block">/*
			 * Grant all priviledge except node_host and node_port
			 */</comment>
			<expr><literal type="string">"REVOKE ALL on pgxc_node FROM public;\n\n"</literal></expr>,

			<expr><literal type="string">"GRANT ALL (xmin_gts, xmax_gts, shardid, xc_node_id ,    "</literal>
			<literal type="string">" tableoid, cmax, xmax, cmin, xmin, oid, ctid, node_name,"</literal>
			<literal type="string">" node_type, nodeis_primary, nodeis_preferred, node_id,  "</literal>
			<literal type="string">" node_cluster_name) ON pgxc_node TO public;\n\n"</literal></expr>,
			<expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>pgxc_node_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * get the superuser password if required
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_su_pwd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pwd1</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pwd2</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pwprompt</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Read password from terminal
         */</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Enter new superuser password: "</literal></expr></argument>, <argument><expr><name>pwd1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Enter it again: "</literal></expr></argument>, <argument><expr><name>pwd2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwd2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>, <argument><expr><name>pwd2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Passwords didn't match.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Read password from file
         *
         * Ideally this should insist that the file not be world-readable.
         * However, this option is mainly intended for use on Windows where
         * file permissions may not exist at all, so we'll skip the paranoia
         * for now.
         */</comment>
        <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>pwf</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>pwfilename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pwf</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pwfilename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fgets</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pwf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>pwf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read password from file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pwfilename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: password file \"%s\" is empty\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pwfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pwf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pwd1</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name><name>pwd1</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pwd1</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>superuser_password</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up pg_depend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_depend</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>pg_depend_setup</name><index>[]</index></name> <init>= <expr><block>{
        <comment type="block">/*
         * Make PIN entries in pg_depend for all objects made so far in the
         * tables that the dependency code handles.  This is overkill (the
         * system doesn't really depend on having every last weird datatype,
         * for instance) but generating only the minimum required set of
         * dependencies seems hard.
         *
         * Catalogs that are intentionally not scanned here are:
         *
         * pg_database: it's a feature, not a bug, that template1 is not
         * pinned.
         *
         * pg_extension: a pinned extension isn't really an extension, hmm?
         *
         * pg_tablespace: tablespaces don't participate in the dependency
         * code, and DropTableSpace() explicitly protects the built-in
         * tablespaces.
         *
         * First delete any already-made entries; PINs override all else, and
         * must be the only entries for their objects.
         */</comment>
        <expr><literal type="string">"DELETE FROM pg_depend;\n\n"</literal></expr>,
        <expr><literal type="string">"VACUUM pg_depend;\n\n"</literal></expr>,
        <expr><literal type="string">"DELETE FROM pg_shdepend;\n\n"</literal></expr>,
        <expr><literal type="string">"VACUUM pg_shdepend;\n\n"</literal></expr>,

        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_class;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_proc;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_type;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_cast;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_constraint;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_conversion;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_attrdef;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_language;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_operator;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_opclass;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_opfamily;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_am;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_amop;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_amproc;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_rewrite;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_trigger;\n\n"</literal></expr>,

        <comment type="block">/*
         * restriction here to avoid pinning the public namespace
         */</comment>
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_namespace "</literal>
        <literal type="string">"    WHERE nspname LIKE 'pg%';\n\n"</literal></expr>,

        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_ts_parser;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_ts_dict;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_ts_template;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_ts_config;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
        <literal type="string">" FROM pg_collation;\n\n"</literal></expr>,
        <expr><literal type="string">"INSERT INTO pg_shdepend SELECT 0,0,0,0, tableoid,oid, 'p' "</literal>
        <literal type="string">" FROM pg_authid;\n\n"</literal></expr>,
        <expr><name>NULL</name></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>pg_depend_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * set up system views
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_sysviews</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>sysviews_setup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sysviews_setup</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>system_views_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>sysviews_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sysviews_setup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * set up Postgres-XC cluster node catalog data with node self
 * which is the node currently initialized.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_nodeself</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating cluster information ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_CMD_PRINTF2</name><argument_list>(<argument><expr><literal type="string">"CREATE NODE %s WITH (type = '%s');\n"</literal></expr></argument>,
                   <argument><expr><name>nodename</name></expr></argument>, <argument><expr><name>nodetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * load description data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_description</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"CREATE TEMP TABLE tmp_pg_description ( "</literal>
                <literal type="string">"    objoid oid, "</literal>
                <literal type="string">"    classname name, "</literal>
                <literal type="string">"    objsubid int4, "</literal>
                <literal type="string">"    description text) WITHOUT OIDS;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_CMD_PRINTF1</name><argument_list>(<argument><expr><literal type="string">"COPY tmp_pg_description FROM E'%s';\n\n"</literal></expr></argument>,
                   <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>desc_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"INSERT INTO pg_description "</literal>
                <literal type="string">" SELECT t.objoid, c.oid, t.objsubid, t.description "</literal>
                <literal type="string">"  FROM tmp_pg_description t, pg_class c "</literal>
                <literal type="string">"    WHERE c.relname = t.classname;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"CREATE TEMP TABLE tmp_pg_shdescription ( "</literal>
                <literal type="string">" objoid oid, "</literal>
                <literal type="string">" classname name, "</literal>
                <literal type="string">" description text) WITHOUT OIDS;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_CMD_PRINTF1</name><argument_list>(<argument><expr><literal type="string">"COPY tmp_pg_shdescription FROM E'%s';\n\n"</literal></expr></argument>,
                   <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>shdesc_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <macro><name>PG_CMD_PUTS</name><argument_list>(<argument><literal type="string">"INSERT INTO pg_catalog.pg_shdescription "</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    PG_CMD_PUTS(<literal type="string">"INSERT INTO pg_shdescription "</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <literal type="string">" SELECT t.objoid, c.oid, t.description "</literal>
                <literal type="string">"  FROM tmp_pg_shdescription t, pg_class c "</literal>
                <literal type="string">"   WHERE c.relname = t.classname;\n\n"</literal>);

    <comment type="block">/* Create default descriptions for operator implementation functions */</comment>
    PG_CMD_PUTS(<literal type="string">"WITH funcdescs AS ( "</literal>
                <literal type="string">"SELECT p.oid as p_oid, oprname, "</literal>
                <literal type="string">"coalesce(obj_description(o.oid, 'pg_operator'),'') as opdesc "</literal>
                <literal type="string">"FROM pg_proc p JOIN pg_operator o ON oprcode = p.oid ) "</literal>
                <literal type="string">"INSERT INTO pg_description "</literal>
                <literal type="string">"  SELECT p_oid, 'pg_proc'::regclass, 0, "</literal>
                <literal type="string">"    'implementation of ' || oprname || ' operator' "</literal>
                <literal type="string">"  FROM funcdescs "</literal>
                <literal type="string">"  WHERE opdesc NOT LIKE 'deprecated%' AND "</literal>
                <literal type="string">"  NOT EXISTS (SELECT 1 FROM pg_description "</literal>
                <literal type="string">"    WHERE objoid = p_oid AND classoid = 'pg_proc'::regclass);\n\n"</literal>);

    <comment type="block">/*
     * Even though the tables are temp, drop them explicitly so they don't get
     * copied into template0/postgres databases.
     */</comment>
    PG_CMD_PUTS(<literal type="string">"DROP TABLE tmp_pg_description;\n\n"</literal>);
    PG_CMD_PUTS(<literal type="string">"DROP TABLE tmp_pg_shdescription;\n\n"</literal>);
}

<comment type="block">/*
 * populate pg_collation
 */</comment>
static void
setup_collation(FILE *cmdfd)
{
    <comment type="block">/*
     * Add an SQL-standard name.  We don't want to pin this, so it doesn't go
     * in pg_collation.h.  But add it before reading system collations, so
     * that it wins if libc defines a locale named ucs_basic.
     */</comment>
    PG_CMD_PRINTF3(<literal type="string">"INSERT INTO pg_collation (collname, collnamespace, collowner, collprovider, collencoding, collcollate, collctype) VALUES ('ucs_basic', 'pg_catalog'::regnamespace, %u, '%c', %d, 'C', 'C');\n\n"</literal>,
                   BOOTSTRAP_SUPERUSERID, COLLPROVIDER_LIBC, PG_UTF8);

    <comment type="block">/* Now import all collations we can find in the operating system */</comment>
    PG_CMD_PUTS(<literal type="string">"SELECT pg_import_system_collations('pg_catalog');\n\n"</literal>);
}

<comment type="block">/*
 * load conversion functions
 */</comment>
static void
setup_conversion(FILE *cmdfd)
{
    char      **line;
    char      **conv_lines;

    conv_lines = readfile(conversion_file);
    for (line = conv_lines; *line != NULL; line++)
    {
        if (strstr(*line, <literal type="string">"DROP CONVERSION"</literal>) != *line)
            PG_CMD_PUTS(*line);
        free(*line);
    }

    free(conv_lines);
}

<comment type="block">/*
 * load extra dictionaries (Snowball stemmers)
 */</comment>
static void
setup_dictionary(FILE *cmdfd)
{
    char      **line;
    char      **conv_lines;

    conv_lines = readfile(dictionary_file);
    for (line = conv_lines; *line != NULL; line++)
    {
        PG_CMD_PUTS(*line);
        free(*line);
    }

    free(conv_lines);
}

<comment type="block">/*
 * Set up privileges
 *
 * We mark most system catalogs as world-readable.  We don't currently have
 * to touch functions, languages, or databases, because their default
 * permissions are OK.
 *
 * Some objects may require different permissions by default, so we
 * make sure we don't overwrite privilege sets that have already been
 * set (NOT NULL).
 *
 * Also populate pg_init_privs to save what the privileges are at init
 * time.  This is used by pg_dump to allow users to change privileges
 * on catalog objects and to have those privilege changes preserved
 * across dump/reload and pg_upgrade.
 *
 * Note that pg_init_privs is only for per-database objects and therefore
 * we don't include databases or tablespaces.
 */</comment>
static void
setup_privileges(FILE *cmdfd)
{
    char      **line;
    char      **priv_lines;
    static char *privileges_setup[] = {
        <literal type="string">"UPDATE pg_class "</literal>
        <literal type="string">"  SET relacl = (SELECT array_agg(a.acl) FROM "</literal>
        <literal type="string">" (SELECT E'=r/\"$POSTGRES_SUPERUSERNAME\"' as acl "</literal>
        <literal type="string">"  UNION SELECT unnest(pg_catalog.acldefault("</literal>
        <literal type="string">"    CASE WHEN relkind = "</literal> CppAsString2(RELKIND_SEQUENCE) <literal type="string">" THEN 's' "</literal>
        <literal type="string">"         ELSE 'r' END::\"char\","</literal> CppAsString2(BOOTSTRAP_SUPERUSERID) <literal type="string">"::oid))"</literal>
        <literal type="string">" ) as a) "</literal>
        <literal type="string">"  WHERE relkind IN ("</literal> CppAsString2(RELKIND_RELATION) <literal type="string">", "</literal>
        CppAsString2(RELKIND_VIEW) <literal type="string">", "</literal> CppAsString2(RELKIND_MATVIEW) <literal type="string">", "</literal>
        CppAsString2(RELKIND_SEQUENCE) <literal type="string">")"</literal>
        <literal type="string">"  AND relacl IS NULL;\n\n"</literal></argument>,
        <argument><literal type="string">"GRANT USAGE ON SCHEMA pg_catalog TO PUBLIC;\n\n"</literal></argument>,
        <argument><literal type="string">"GRANT CREATE, USAGE ON SCHEMA public TO PUBLIC;\n\n"</literal></argument>,
        <argument><literal type="string">"REVOKE ALL ON pg_largeobject FROM PUBLIC;\n\n"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_class'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        relacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_class"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        relacl IS NOT NULL"</literal>
        <literal type="string">"        AND relkind IN ("</literal> CppAsString2(RELKIND_RELATION) <literal type="string">", "</literal>
        CppAsString2(RELKIND_VIEW) <literal type="string">", "</literal> CppAsString2(RELKIND_MATVIEW) <literal type="string">", "</literal>
        CppAsString2(RELKIND_SEQUENCE) <literal type="string">");"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        pg_class.oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_class'),"</literal>
        <literal type="string">"        pg_attribute.attnum,"</literal>
        <literal type="string">"        pg_attribute.attacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_class"</literal>
        <literal type="string">"        JOIN pg_attribute ON (pg_class.oid = pg_attribute.attrelid)"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        pg_attribute.attacl IS NOT NULL"</literal>
        <literal type="string">"        AND pg_class.relkind IN ("</literal> CppAsString2(RELKIND_RELATION) <literal type="string">", "</literal>
        CppAsString2(RELKIND_VIEW) <literal type="string">", "</literal> CppAsString2(RELKIND_MATVIEW) <literal type="string">", "</literal>
        CppAsString2(RELKIND_SEQUENCE) <literal type="string">");"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_proc'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        proacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_proc"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        proacl IS NOT NULL;"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_type'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        typacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_type"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        typacl IS NOT NULL;"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_language'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        lanacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_language"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        lanacl IS NOT NULL;"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE "</literal>
        <literal type="string">"          relname = 'pg_largeobject_metadata'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        lomacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_largeobject_metadata"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        lomacl IS NOT NULL;"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_namespace'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        nspacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_namespace"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        nspacl IS NOT NULL;"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class WHERE "</literal>
        <literal type="string">"          relname = 'pg_foreign_data_wrapper'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        fdwacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_foreign_data_wrapper"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        fdwacl IS NOT NULL;"</literal></argument>,
        <argument><literal type="string">"INSERT INTO pg_init_privs "</literal>
        <literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
        <literal type="string">"    SELECT"</literal>
        <literal type="string">"        oid,"</literal>
        <literal type="string">"        (SELECT oid FROM pg_class "</literal>
        <literal type="string">"          WHERE relname = 'pg_foreign_server'),"</literal>
        <literal type="string">"        0,"</literal>
        <literal type="string">"        srvacl,"</literal>
        <literal type="string">"        'i'"</literal>
        <literal type="string">"    FROM"</literal>
        <literal type="string">"        pg_foreign_server"</literal>
        <literal type="string">"    WHERE"</literal>
        <literal type="string">"        srvacl IS NOT NULL;"</literal></argument>,
        <argument>NULL
    };

    priv_lines = replace_token(privileges_setup, <literal type="string">"$POSTGRES_SUPERUSERNAME"</literal>,
                               escape_quotes(username));
    for (line = priv_lines; *line != NULL; line++)
        PG_CMD_PUTS(*line);
}

<comment type="block">/*
 * extract the strange version of version required for information schema
 * (09.08.0007abc)
 */</comment>
static void
set_info_version(void)
{
    char       *letterversion;
    long        major = <literal type="number">0</literal></argument>,
                <argument>minor = <literal type="number">0</literal></argument>,
                <argument>micro = <literal type="number">0</literal>;
    char       *endptr;
    char       *vstr = pg_strdup(PG_VERSION);
    char       *ptr;

    ptr = vstr + (strlen(vstr) - <literal type="number">1</literal>);
    while (ptr != vstr &amp;&amp; (*ptr &lt; <literal type="char">'0'</literal> || *ptr &gt; <literal type="char">'9'</literal>))
        ptr--;
    letterversion = ptr + <literal type="number">1</literal>;
    major = strtol(vstr, &amp;endptr, <literal type="number">10</literal>);
    if (*endptr)
        minor = strtol(endptr + <literal type="number">1</literal>, &amp;endptr, <literal type="number">10</literal>);
    if (*endptr)
        micro = strtol(endptr + <literal type="number">1</literal>, &amp;endptr, <literal type="number">10</literal>);
    snprintf(infoversion, sizeof(infoversion), <literal type="string">"%02ld.%02ld.%04ld%s"</literal>,
             major, minor, micro, letterversion);
}

<comment type="block">/*
 * load info schema and populate from features file
 */</comment>
static void
setup_schema(FILE *cmdfd)
{
    char      **line;
    char      **lines;

    lines = readfile(info_schema_file);

    for (line = lines; *line != NULL; line++)
    {
        PG_CMD_PUTS(*line);
        free(*line);
    }

    free(lines);

    PG_CMD_PRINTF1(<literal type="string">"UPDATE information_schema.sql_implementation_info "</literal>
                   <literal type="string">"  SET character_value = '%s' "</literal>
                   <literal type="string">"  WHERE implementation_info_name = 'DBMS VERSION';\n\n"</literal>,
                   infoversion);

    PG_CMD_PRINTF1(<literal type="string">"COPY information_schema.sql_features "</literal>
                   <literal type="string">"  (feature_id, feature_name, sub_feature_id, "</literal>
                   <literal type="string">"  sub_feature_name, is_supported, comments) "</literal>
                   <literal type="string">" FROM E'%s';\n\n"</literal>,
                   escape_quotes(features_file));
}

<comment type="block">/*
 * load PL/pgSQL server-side language
 */</comment>
static void
load_plpgsql(FILE *cmdfd)
{
    PG_CMD_PUTS(<literal type="string">"CREATE EXTENSION plpgsql;\n\n"</literal>);
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
static void
load_gtm_info(FILE *cmdfd)
{
    PG_CMD_PRINTF3(<literal type="string">"create gtm node %s with (type='gtm', host='%s',port=%s, primary=1);\n\n"</literal>, 
                master_gtm_nodename, master_gtm_ip, master_gtm_port);
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * Vacuum Freeze given database. This is required to prevent xid wraparound
 * issues when a node is brought up with xids out-of-sync w.r.t. gtm xids.
 */</comment>
static void
vacuumfreeze(char *dbname)
{
    PG_CMD_DECL;
    char msg[MAXPGPATH];
    snprintf(msg, sizeof(msg), <literal type="string">"freezing database %s ... "</literal>, dbname);

    fputs(_(msg), stdout);
    fflush(stdout);

    snprintf(cmd, sizeof(cmd),
             <literal type="string">"\"%s\" %s %s &gt;%s"</literal>,
             backend_exec, backend_options, dbname,
             DEVNULL);

    PG_CMD_OPEN;

    PG_CMD_PUTS(<literal type="string">"VACUUM FREEZE;\n"</literal>);

    PG_CMD_CLOSE;

    check_ok();
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

<comment type="block">/*
 * clean everything up in template1
 */</comment>
static void
vacuum_db(FILE *cmdfd)
{
    <comment type="block">/* Run analyze before VACUUM so the statistics are frozen. */</comment>
    PG_CMD_PUTS(<literal type="string">"ANALYZE;\n\nVACUUM FREEZE;\n\n"</literal>);
}

<comment type="block">/*
 * copy template1 to template0
 */</comment>
static void
make_template0(FILE *cmdfd)
{
    const char *const *line;
    static const char *const template0_setup[] = {
        <literal type="string">"CREATE DATABASE template0 IS_TEMPLATE = true ALLOW_CONNECTIONS = false;\n\n"</literal></argument>,

        <comment type="block">/*
         * We use the OID of template0 to determine lastsysoid
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <argument><literal type="string">"UPDATE pg_catalog.pg_database SET datlastsysoid = "</literal>
        <literal type="string">"    (SELECT oid FROM pg_catalog.pg_database "</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <literal type="string">"UPDATE pg_database SET datlastsysoid = "</literal>
        <literal type="string">"    (SELECT oid FROM pg_database "</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <literal type="string">"    WHERE datname = 'template0');\n\n"</literal></argument>,

        <comment type="block">/*
         * Explicitly revoke public create-schema and create-temp-table
         * privileges in template1 and template0; else the latter would be on
         * by default
         */</comment>
        <argument><literal type="string">"REVOKE CREATE,TEMPORARY ON DATABASE template1 FROM public;\n\n"</literal></argument>,
        <argument><literal type="string">"REVOKE CREATE,TEMPORARY ON DATABASE template0 FROM public;\n\n"</literal></argument>,

        <argument><literal type="string">"COMMENT ON DATABASE template0 IS 'unmodifiable empty database';\n\n"</literal></argument>,

        <comment type="block">/*
         * Finally vacuum to clean up dead rows in pg_database
         */</comment>
        <argument><literal type="string">"VACUUM pg_catalog.pg_database;\n\n"</literal></argument>,

        <argument>NULL
    };

    for (line = template0_setup; *line; line++)
        PG_CMD_PUTS(*line);
}

<comment type="block">/*
 * copy template1 to postgres
 */</comment>
static void
make_postgres(FILE *cmdfd)
{
    const char *const *line;
    static const char *const postgres_setup[] = {
        <literal type="string">"CREATE DATABASE postgres;\n\n"</literal></argument>,
        <argument><literal type="string">"COMMENT ON DATABASE postgres IS 'default administrative connection database';\n\n"</literal></argument>,
        <argument>NULL
    };

    for (line = postgres_setup; *line; line++)
        PG_CMD_PUTS(*line);
}

<comment type="block">/*
 * signal handler in case we are interrupted.
 *
 * The Windows runtime docs at
 * http://msdn.microsoft.com/library/en-us/vclib/html/_crt_signal.asp
 * specifically forbid a number of things being done from a signal handler,
 * including IO, memory allocation and system calls, and only allow jmpbuf
 * if you are handling SIGFPE.
 *
 * I avoided doing the forbidden things by setting a flag instead of calling
 * exit_nicely() directly.
 *
 * Also note the behaviour of Windows with SIGINT, which says this:
 *     Note    SIGINT is not supported for any Win32 application, including
 *     Windows 98/Me and Windows NT/2000/XP. When a CTRL+C interrupt occurs,
 *     Win32 operating systems generate a new thread to specifically handle
 *     that interrupt. This can cause a single-thread application such as UNIX,
 *     to become multithreaded, resulting in unexpected behavior.
 *
 * I have no idea how to handle this. (Strange they call UNIX an application!)
 * So this will need some testing on Windows.
 */</comment>
static void
trapsig(int signum)
{
    <comment type="block">/* handle systems that reset the handler, like Windows (grr) */</comment>
    pqsignal(signum, trapsig);
    caught_signal = true;
}

<comment type="block">/*
 * call exit_nicely() if we got a signal, or else output "ok".
 */</comment>
static void
check_ok(void)
{
    if (caught_signal)
    {
        printf(_(<literal type="string">"caught signal\n"</literal>));
        fflush(stdout);
        exit_nicely();
    }
    else if (output_failed)
    {
        printf(_(<literal type="string">"could not write to child process: %s\n"</literal>),
               strerror(output_errno));
        fflush(stdout);
        exit_nicely();
    }
    else
    {
        <comment type="block">/* all seems well */</comment>
        printf(_(<literal type="string">"ok\n"</literal>));
        fflush(stdout);
    }
}

<comment type="block">/* Hack to suppress a warning about %x from some versions of gcc */</comment>
static inline size_t
my_strftime(char *s, size_t max, const char *fmt, const struct tm *tm)
{
    return strftime(s, max, fmt, tm);
}

<comment type="block">/*
 * Determine likely date order from locale
 */</comment>
static int
locale_date_order(const char *locale)
{<comment type="line">// #lizard forgives</comment>
    struct tm    testtime;
    char        buf[<literal type="number">128</literal>];
    char       *posD;
    char       *posM;
    char       *posY;
    char       *save;
    size_t        res;
    int            result;

    result = DATEORDER_MDY;        <comment type="block">/* default */</comment>

    save = setlocale(LC_TIME, NULL);
    if (!save)
        return result;
    save = pg_strdup(save);

    setlocale(LC_TIME, locale);

    memset(&amp;testtime, <literal type="number">0</literal>, sizeof(testtime));
    testtime.tm_mday = <literal type="number">22</literal>;
    testtime.tm_mon = <literal type="number">10</literal>;        <comment type="block">/* November, should come out as "11" */</comment>
    testtime.tm_year = <literal type="number">133</literal>;        <comment type="block">/* 2033 */</comment>

    res = my_strftime(buf, sizeof(buf), <literal type="string">"%x"</literal>, &amp;testtime);

    setlocale(LC_TIME, save);
    free(save);

    if (res == <literal type="number">0</literal>)
        return result;

    posM = strstr(buf, <literal type="string">"11"</literal>);
    posD = strstr(buf, <literal type="string">"22"</literal>);
    posY = strstr(buf, <literal type="string">"33"</literal>);

    if (!posM || !posD || !posY)
        return result;

    if (posY &lt; posM &amp;&amp; posM &lt; posD)
        result = DATEORDER_YMD;
    else if (posD &lt; posM)
        result = DATEORDER_DMY;
    else
        result = DATEORDER_MDY;

    return result;
}

<comment type="block">/*
 * Verify that locale name is valid for the locale category.
 *
 * If successful, and canonname isn't NULL, a malloc'd copy of the locale's
 * canonical name is stored there.  This is especially useful for figuring out
 * what locale name "" means (ie, the environment value).  (Actually,
 * it seems that on most implementations that's the only thing it's good for;
 * we could wish that setlocale gave back a canonically spelled version of
 * the locale name, but typically it doesn't.)
 *
 * this should match the backend's check_locale() function
 */</comment>
static void
check_locale_name(int category, const char *locale, char **canonname)
{<comment type="line">// #lizard forgives</comment>
    char       *save;
    char       *res;

    if (canonname)
        *canonname = NULL;        <comment type="block">/* in case of failure */</comment>

    save = setlocale(category, NULL);
    if (!save)
    {
        fprintf(stderr, _(<literal type="string">"%s: setlocale() failed\n"</literal>),
                progname);
        exit(<literal type="number">1</literal>);
    }

    <comment type="block">/* save may be pointing at a modifiable scratch variable, so copy it. */</comment>
    save = pg_strdup(save);

    <comment type="block">/* set the locale with setlocale, to see if it accepts it. */</comment>
    res = setlocale(category, locale);

    <comment type="block">/* save canonical name if requested. */</comment>
    if (res &amp;&amp; canonname)
        *canonname = pg_strdup(res);

    <comment type="block">/* restore old value. */</comment>
    if (!setlocale(category, save))
    {
        fprintf(stderr, _(<literal type="string">"%s: failed to restore old locale \"%s\"\n"</literal>),
                progname, save);
        exit(<literal type="number">1</literal>);
    }
    free(save);

    <comment type="block">/* complain if locale wasn't valid */</comment>
    if (res == NULL)
    {
        if (*locale)
            fprintf(stderr, _(<literal type="string">"%s: invalid locale name \"%s\"\n"</literal>),
                    progname, locale);
        else
        {
            <comment type="block">/*
             * If no relevant switch was given on command line, locale is an
             * empty string, which is not too helpful to report.  Presumably
             * setlocale() found something it did not like in the environment.
             * Ideally we'd report the bad environment variable, but since
             * setlocale's behavior is implementation-specific, it's hard to
             * be sure what it didn't like.  Print a safe generic message.
             */</comment>
            fprintf(stderr, _(<literal type="string">"%s: invalid locale settings; check LANG and LC_* environment variables\n"</literal>),
                    progname);
        }
        exit(<literal type="number">1</literal>);
    }
}

<comment type="block">/*
 * check if the chosen encoding matches the encoding required by the locale
 *
 * this should match the similar check in the backend createdb() function
 */</comment>
static bool
check_locale_encoding(const char *locale, int user_enc)
{
    int            locale_enc;

    locale_enc = pg_get_encoding_from_locale(locale, true);

    <comment type="block">/* See notes in createdb() to understand these tests */</comment>
    if (!(locale_enc == user_enc ||
          locale_enc == PG_SQL_ASCII ||
          locale_enc == -<literal type="number">1</literal> ||
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
          user_enc == PG_UTF8 ||
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          user_enc == PG_SQL_ASCII))
    {
        fprintf(stderr, _(<literal type="string">"%s: encoding mismatch\n"</literal>), progname);
        fprintf(stderr,
                _(<literal type="string">"The encoding you selected (%s) and the encoding that the\n"</literal>
                  <literal type="string">"selected locale uses (%s) do not match.  This would lead to\n"</literal>
                  <literal type="string">"misbehavior in various character string processing functions.\n"</literal>
                  <literal type="string">"Rerun %s and either do not specify an encoding explicitly,\n"</literal>
                  <literal type="string">"or choose a matching combination.\n"</literal>),
                pg_encoding_to_char(user_enc),
                pg_encoding_to_char(locale_enc),
                progname);
        return false;
    }
    return true;
}

<comment type="block">/*
 * set up the locale variables
 *
 * assumes we have called setlocale(LC_ALL, "") -- see set_pglocale_pgservice
 */</comment>
static void
setlocales(void)
{<comment type="line">// #lizard forgives</comment>
    char       *canonname;

    <comment type="block">/* set empty lc_* values to locale config if set */</comment>

    if (strlen(locale) &gt; <literal type="number">0</literal>)
    {
        if (strlen(lc_ctype) == <literal type="number">0</literal>)
            lc_ctype = locale;
        if (strlen(lc_collate) == <literal type="number">0</literal>)
            lc_collate = locale;
        if (strlen(lc_numeric) == <literal type="number">0</literal>)
            lc_numeric = locale;
        if (strlen(lc_time) == <literal type="number">0</literal>)
            lc_time = locale;
        if (strlen(lc_monetary) == <literal type="number">0</literal>)
            lc_monetary = locale;
        if (strlen(lc_messages) == <literal type="number">0</literal>)
            lc_messages = locale;
    }

    <comment type="block">/*
     * canonicalize locale names, and obtain any missing values from our
     * current environment
     */</comment>

    check_locale_name(LC_CTYPE, lc_ctype, &amp;canonname);
    lc_ctype = canonname;
    check_locale_name(LC_COLLATE, lc_collate, &amp;canonname);
    lc_collate = canonname;
    check_locale_name(LC_NUMERIC, lc_numeric, &amp;canonname);
    lc_numeric = canonname;
    check_locale_name(LC_TIME, lc_time, &amp;canonname);
    lc_time = canonname;
    check_locale_name(LC_MONETARY, lc_monetary, &amp;canonname);
    lc_monetary = canonname;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    check_locale_name(LC_MESSAGES, lc_messages, &amp;canonname);
    lc_messages = canonname;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* when LC_MESSAGES is not available, use the LC_CTYPE setting */</comment>
    check_locale_name(LC_CTYPE, lc_messages, &amp;canonname);
    lc_messages = canonname;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

<comment type="block">/*
 * print help text
 */</comment>
static void
usage(const char *progname)
{
    printf(_(<literal type="string">"%s initializes a PostgreSQL database cluster.\n\n"</literal>), progname);
    printf(_(<literal type="string">"Usage:\n"</literal>));
    printf(_(<literal type="string">"  %s [OPTION]... [DATADIR] [NODENAME]\n"</literal>), progname);
    printf(_(<literal type="string">"\nOptions:\n"</literal>));
    printf(_(<literal type="string">"  -A, --auth=METHOD         default authentication method for local connections\n"</literal>));
    printf(_(<literal type="string">"      --auth-host=METHOD    default authentication method for local TCP/IP connections\n"</literal>));
    printf(_(<literal type="string">"      --auth-local=METHOD   default authentication method for local-socket connections\n"</literal>));
    printf(_(<literal type="string">" [-D, --pgdata=]DATADIR     location for this database cluster\n"</literal>));
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    printf(_(<literal type="string">"      --nodename=NODENAME   name of Postgres-XL node initialized\n"</literal>));
    printf(_(<literal type="string">"      --nodetype=NODETYPE   type(datanode or coordinator) of Postgres-XL node initialized\n"</literal>));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    printf(_(<literal type="string">"  -E, --encoding=ENCODING   set default encoding for new databases\n"</literal>));
    printf(_(<literal type="string">"      --locale=LOCALE       set default locale for new databases\n"</literal>));
    printf(_(<literal type="string">"      --lc-collate=, --lc-ctype=, --lc-messages=LOCALE\n"</literal>
             <literal type="string">"      --lc-monetary=, --lc-numeric=, --lc-time=LOCALE\n"</literal>
             <literal type="string">"                            set default locale in the respective category for\n"</literal>
             <literal type="string">"                            new databases (default taken from environment)\n"</literal>));
    printf(_(<literal type="string">"      --no-locale           equivalent to --locale=C\n"</literal>));
    printf(_(<literal type="string">"      --pwfile=FILE         read password for the new superuser from file\n"</literal>));
    printf(_(<literal type="string">"  -T, --text-search-config=CFG\n"</literal>
             <literal type="string">"                            default text search configuration\n"</literal>));
    printf(_(<literal type="string">"  -U, --username=NAME       database superuser name\n"</literal>));
    printf(_(<literal type="string">"  -W, --pwprompt            prompt for a password for the new superuser\n"</literal>));
    printf(_(<literal type="string">"  -X, --waldir=WALDIR       location for the write-ahead log directory\n"</literal>));
    printf(_(<literal type="string">"\nLess commonly used options:\n"</literal>));
    printf(_(<literal type="string">"  -d, --debug               generate lots of debugging output\n"</literal>));
    printf(_(<literal type="string">"  -k, --data-checksums      use data page checksums\n"</literal>));
    printf(_(<literal type="string">"  -L DIRECTORY              where to find the input files\n"</literal>));
    printf(_(<literal type="string">"  -n, --no-clean            do not clean up after errors\n"</literal>));
    printf(_(<literal type="string">"  -N, --no-sync             do not wait for changes to be written safely to disk\n"</literal>));
    printf(_(<literal type="string">"  -s, --show                show internal settings\n"</literal>));
    printf(_(<literal type="string">"  -S, --sync-only           only sync data directory\n"</literal>));
    printf(_(<literal type="string">"\nOther options:\n"</literal>));
    printf(_(<literal type="string">"  -V, --version             output version information, then exit\n"</literal>));
    printf(_(<literal type="string">"  -?, --help                show this help, then exit\n"</literal>));
    printf(_(<literal type="string">"\nIf the data directory is not specified, the environment variable PGDATA\n"</literal>
             <literal type="string">"is used.\n"</literal>));
    printf(_(<literal type="string">"\nReport bugs to &lt;pgsql-bugs@postgresql.org&gt;.\n"</literal>));
}

static void
check_authmethod_unspecified(const char **authmethod)
{
    if (*authmethod == NULL || strlen(*authmethod) == <literal type="number">0</literal>)
    {
        authwarning = _(<literal type="string">"\nWARNING: enabling \"trust\" authentication for local connections\n"</literal>
                        <literal type="string">"You can change this by editing pg_hba.conf or using the option -A, or\n"</literal>
                        <literal type="string">"--auth-local and --auth-host, the next time you run initdb.\n"</literal>);
        *authmethod = <literal type="string">"trust"</literal>;
    }
}

static void
check_authmethod_valid(const char *authmethod, const char *const *valid_methods, const char *conntype)
{
    const char *const *p;

    for (p = valid_methods; *p; p++)
    {
        if (strcmp(authmethod, *p) == <literal type="number">0</literal>)
            return;
        <comment type="block">/* with space = param */</comment>
        if (strchr(authmethod, <literal type="char">' '</literal>))
            if (strncmp(authmethod, *p, (authmethod - strchr(authmethod, <literal type="char">' '</literal>))) == <literal type="number">0</literal>)
                return;
    }

    fprintf(stderr, _(<literal type="string">"%s: invalid authentication method \"%s\" for \"%s\" connections\n"</literal>),
            progname, authmethod, conntype);
    exit(<literal type="number">1</literal>);
}

static void
check_need_password(const char *authmethodlocal, const char *authmethodhost)
{<comment type="line">// #lizard forgives</comment>
    if ((strcmp(authmethodlocal, <literal type="string">"md5"</literal>) == <literal type="number">0</literal> ||
         strcmp(authmethodlocal, <literal type="string">"password"</literal>) == <literal type="number">0</literal> ||
         strcmp(authmethodlocal, <literal type="string">"scram-sha-256"</literal>) == <literal type="number">0</literal>) &amp;&amp;
        (strcmp(authmethodhost, <literal type="string">"md5"</literal>) == <literal type="number">0</literal> ||
         strcmp(authmethodhost, <literal type="string">"password"</literal>) == <literal type="number">0</literal> ||
         strcmp(authmethodhost, <literal type="string">"scram-sha-256"</literal>) == <literal type="number">0</literal>) &amp;&amp;
        !(pwprompt || pwfilename))
    {
        fprintf(stderr, _(<literal type="string">"%s: must specify a password for the superuser to enable %s authentication\n"</literal>), progname,
                (strcmp(authmethodlocal, <literal type="string">"md5"</literal>) == <literal type="number">0</literal> ||
                 strcmp(authmethodlocal, <literal type="string">"password"</literal>) == <literal type="number">0</literal> ||
                 strcmp(authmethodlocal, <literal type="string">"scram-sha-256"</literal>) == <literal type="number">0</literal>)
                ? authmethodlocal
                : authmethodhost);
        exit(<literal type="number">1</literal>);
    }
}


void
setup_pgdata(void)
{
    char       *pgdata_get_env</argument>,
               <argument>*pgdata_set_env;

    if (strlen(pg_data) == <literal type="number">0</literal>)
    {
        pgdata_get_env = getenv(<literal type="string">"PGDATA"</literal>);
        if (pgdata_get_env &amp;&amp; strlen(pgdata_get_env))
        {
            <comment type="block">/* PGDATA found */</comment>
            pg_data = pg_strdup(pgdata_get_env);
        }
        else
        {
            fprintf(stderr,
                    _(<literal type="string">"%s: no data directory specified\n"</literal>
                      <literal type="string">"You must identify the directory where the data for this database system\n"</literal>
                      <literal type="string">"will reside.  Do this with either the invocation option -D or the\n"</literal>
                      <literal type="string">"environment variable PGDATA.\n"</literal>),
                    progname);
            exit(<literal type="number">1</literal>);
        }
    }

    pgdata_native = pg_strdup(pg_data);
    canonicalize_path(pg_data);

    <comment type="block">/*
     * we have to set PGDATA for postgres rather than pass it on the command
     * line to avoid dumb quoting problems on Windows, and we would especially
     * need quotes otherwise on Windows because paths there are most likely to
     * have embedded spaces.
     */</comment>
    pgdata_set_env = psprintf(<literal type="string">"PGDATA=%s"</literal>, pg_data);
    putenv(pgdata_set_env);
}


void
setup_bin_paths(const char *argv0)
{
    int            ret;

    if ((ret = find_other_exec(argv0, <literal type="string">"postgres"</literal>, PG_BACKEND_VERSIONSTR,
                               backend_exec)) &lt; <literal type="number">0</literal>)
    {
        char        full_path[MAXPGPATH];

        if (find_my_exec(argv0, full_path) &lt; <literal type="number">0</literal>)
            strlcpy(full_path, progname, sizeof(full_path));

        if (ret == -<literal type="number">1</literal>)
            fprintf(stderr,
                    _(<literal type="string">"The program \"postgres\" is needed by %s "</literal>
                      <literal type="string">"but was not found in the\n"</literal>
                      <literal type="string">"same directory as \"%s\".\n"</literal>
                      <literal type="string">"Check your installation.\n"</literal>),
                    progname, full_path);
        else
            fprintf(stderr,
                    _(<literal type="string">"The program \"postgres\" was found by \"%s\"\n"</literal>
                      <literal type="string">"but was not the same version as %s.\n"</literal>
                      <literal type="string">"Check your installation.\n"</literal>),
                    full_path, progname);
        exit(<literal type="number">1</literal>);
    }

    <comment type="block">/* store binary directory */</comment>
    strcpy(bin_path, backend_exec);
    *last_dir_separator(bin_path) = <literal type="char">'\0'</literal>;
    canonicalize_path(bin_path);

    if (!share_path)
    {
        share_path = pg_malloc(MAXPGPATH);
        get_share_path(backend_exec, share_path);
    }
    else if (!is_absolute_path(share_path))
    {
        fprintf(stderr, _(<literal type="string">"%s: input file location must be an absolute path\n"</literal>), progname);
        exit(<literal type="number">1</literal>);
    }

    canonicalize_path(share_path);
}

void
setup_locale_encoding(void)
{<comment type="line">// #lizard forgives</comment>
    int            user_enc;

    setlocales();

    if (strcmp(lc_ctype, lc_collate) == <literal type="number">0</literal> &amp;&amp;
        strcmp(lc_ctype, lc_time) == <literal type="number">0</literal> &amp;&amp;
        strcmp(lc_ctype, lc_numeric) == <literal type="number">0</literal> &amp;&amp;
        strcmp(lc_ctype, lc_monetary) == <literal type="number">0</literal> &amp;&amp;
        strcmp(lc_ctype, lc_messages) == <literal type="number">0</literal>)
        printf(_(<literal type="string">"The database cluster will be initialized with locale \"%s\".\n"</literal>), lc_ctype);
    else
    {
        printf(_(<literal type="string">"The database cluster will be initialized with locales\n"</literal>
                 <literal type="string">"  COLLATE:  %s\n"</literal>
                 <literal type="string">"  CTYPE:    %s\n"</literal>
                 <literal type="string">"  MESSAGES: %s\n"</literal>
                 <literal type="string">"  MONETARY: %s\n"</literal>
                 <literal type="string">"  NUMERIC:  %s\n"</literal>
                 <literal type="string">"  TIME:     %s\n"</literal>),
               lc_collate,
               lc_ctype,
               lc_messages,
               lc_monetary,
               lc_numeric,
               lc_time);
    }

    if (strlen(encoding) == <literal type="number">0</literal>)
    {
        int            ctype_enc;

        ctype_enc = pg_get_encoding_from_locale(lc_ctype, true);

        if (ctype_enc == -<literal type="number">1</literal>)
        {
            <comment type="block">/* Couldn't recognize the locale's codeset */</comment>
            fprintf(stderr, _(<literal type="string">"%s: could not find suitable encoding for locale \"%s\"\n"</literal>),
                    progname, lc_ctype);
            fprintf(stderr, _(<literal type="string">"Rerun %s with the -E option.\n"</literal>), progname);
            fprintf(stderr, _(<literal type="string">"Try \"%s --help\" for more information.\n"</literal>),
                    progname);
            exit(<literal type="number">1</literal>);
        }
        else if (!pg_valid_server_encoding_id(ctype_enc))
        {
            <comment type="block">/*
             * We recognized it, but it's not a legal server encoding. On
             * Windows, UTF-8 works with any locale, so we can fall back to
             * UTF-8.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
            printf(_(<literal type="string">"Encoding \"%s\" implied by locale is not allowed as a server-side encoding.\n"</literal>
                     <literal type="string">"The default database encoding will be set to \"%s\" instead.\n"</literal>),
                   pg_encoding_to_char(ctype_enc),
                   pg_encoding_to_char(PG_UTF8));
            ctype_enc = PG_UTF8;
            encodingid = encodingid_to_string(ctype_enc);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            fprintf(stderr,
                    _(<literal type="string">"%s: locale \"%s\" requires unsupported encoding \"%s\"\n"</literal>),
                    progname, lc_ctype, pg_encoding_to_char(ctype_enc));
            fprintf(stderr,
                    _(<literal type="string">"Encoding \"%s\" is not allowed as a server-side encoding.\n"</literal>
                      <literal type="string">"Rerun %s with a different locale selection.\n"</literal>),
                    pg_encoding_to_char(ctype_enc), progname);
            exit(<literal type="number">1</literal>);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }
        else
        {
            encodingid = encodingid_to_string(ctype_enc);
            printf(_(<literal type="string">"The default database encoding has accordingly been set to \"%s\".\n"</literal>),
                   pg_encoding_to_char(ctype_enc));
        }
    }
    else
        encodingid = get_encoding_id(encoding);

    user_enc = atoi(encodingid);
    if (!check_locale_encoding(lc_ctype, user_enc) ||
        !check_locale_encoding(lc_collate, user_enc))
        exit(<literal type="number">1</literal>);                <comment type="block">/* check_locale_encoding printed the error */</comment>

}


void
setup_data_file_paths(void)
{
    set_input(&amp;bki_file, <literal type="string">"postgres.bki"</literal>);
    set_input(&amp;desc_file, <literal type="string">"postgres.description"</literal>);
    set_input(&amp;shdesc_file, <literal type="string">"postgres.shdescription"</literal>);
    set_input(&amp;hba_file, <literal type="string">"pg_hba.conf.sample"</literal>);
    set_input(&amp;ident_file, <literal type="string">"pg_ident.conf.sample"</literal>);
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    set_input(&amp;bouncer_conf, <literal type="string">"pgbouncer.ini"</literal>);    
    set_input(&amp;bouncer_auth, <literal type="string">"userlist.txt"</literal>);
    set_input(&amp;gtm_proxy, <literal type="string">"gtm_proxy.conf.sample"</literal>);    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    set_input(&amp;conf_file, <literal type="string">"postgresql.conf.sample"</literal>);
    set_input(&amp;conversion_file, <literal type="string">"conversion_create.sql"</literal>);
    set_input(&amp;dictionary_file, <literal type="string">"snowball_create.sql"</literal>);
    set_input(&amp;info_schema_file, <literal type="string">"information_schema.sql"</literal>);
    set_input(&amp;features_file, <literal type="string">"sql_features.txt"</literal>);
    set_input(&amp;system_views_file, <literal type="string">"system_views.sql"</literal>);

    if (show_setting || debug)
    {
        fprintf(stderr,
                <literal type="string">"VERSION=%s\n"</literal>
                <literal type="string">"PGDATA=%s\nshare_path=%s\nPGPATH=%s\n"</literal>
                <literal type="string">"POSTGRES_SUPERUSERNAME=%s\nPOSTGRES_BKI=%s\n"</literal>
                <literal type="string">"POSTGRES_DESCR=%s\nPOSTGRES_SHDESCR=%s\n"</literal>
                <literal type="string">"POSTGRESQL_CONF_SAMPLE=%s\n"</literal>
                <literal type="string">"PG_HBA_SAMPLE=%s\nPG_IDENT_SAMPLE=%s\n"</literal>
                <literal type="string">"PG_BOUNCER_SAMPLE=%s\nPG_BOUNCER_AUTH=%s\n"</literal>
                <literal type="string">"GTM_PROXY_SAMPLE=%s\n"</literal>,
                PG_VERSION,
                pg_data, share_path, bin_path,
                username, bki_file,
                desc_file, shdesc_file,
                conf_file,
                hba_file, ident_file, bouncer_conf, bouncer_auth, gtm_proxy);
        if (show_setting)
            exit(<literal type="number">0</literal>);
    }

    check_input(bki_file);
    check_input(desc_file);
    check_input(shdesc_file);
    check_input(hba_file);
    check_input(ident_file);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    check_input(bouncer_conf);
    check_input(bouncer_auth);
    check_input(gtm_proxy);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    check_input(conf_file);
    check_input(conversion_file);
    check_input(dictionary_file);
    check_input(info_schema_file);
    check_input(features_file);
    check_input(system_views_file);
}


void
setup_text_search(void)
{
    if (strlen(default_text_search_config) == <literal type="number">0</literal>)
    {
        default_text_search_config = find_matching_ts_config(lc_ctype);
        if (default_text_search_config == NULL)
        {
            printf(_(<literal type="string">"%s: could not find suitable text search configuration for locale \"%s\"\n"</literal>),
                   progname, lc_ctype);
            default_text_search_config = <literal type="string">"simple"</literal>;
        }
    }
    else
    {
        const char *checkmatch = find_matching_ts_config(lc_ctype);

        if (checkmatch == NULL)
        {
            printf(_(<literal type="string">"%s: warning: suitable text search configuration for locale \"%s\" is unknown\n"</literal>),
                   progname, lc_ctype);
        }
        else if (strcmp(checkmatch, default_text_search_config) != <literal type="number">0</literal>)
        {
            printf(_(<literal type="string">"%s: warning: specified text search configuration \"%s\" might not match locale \"%s\"\n"</literal>),
                   progname, default_text_search_config, lc_ctype);
        }
    }

    printf(_(<literal type="string">"The default text search configuration will be set to \"%s\".\n"</literal>),
           default_text_search_config);

}


void
setup_signals(void)
{
    <comment type="block">/* some of these are not valid on Windows */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
    pqsignal(SIGHUP, trapsig);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
    pqsignal(SIGINT, trapsig);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGQUIT</name></cpp:ifdef>
    pqsignal(SIGQUIT, trapsig);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTERM</name></cpp:ifdef>
    pqsignal(SIGTERM, trapsig);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Ignore SIGPIPE when writing to backend, so we can clean up */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
    pqsignal(SIGPIPE, SIG_IGN);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Prevent SIGSYS so we can probe for kernel calls that might not work */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSYS</name></cpp:ifdef>
    pqsignal(SIGSYS, SIG_IGN);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}


void
create_data_directory(void)
{<comment type="line">// #lizard forgives</comment>
    int            ret;

    switch ((ret = pg_check_dir(pg_data)))
    {
        case <literal type="number">0</literal>:
            <comment type="block">/* PGDATA not there, must create it */</comment>
            printf(_(<literal type="string">"creating directory %s ... "</literal>),
                   pg_data);
            fflush(stdout);

            if (pg_mkdir_p(pg_data, S_IRWXU) != <literal type="number">0</literal>)
            {
                fprintf(stderr, _(<literal type="string">"%s: could not create directory \"%s\": %s\n"</literal>),
                        progname, pg_data, strerror(errno));
                exit_nicely();
            }
            else
                check_ok();

            made_new_pgdata = true;
            break;

        case <literal type="number">1</literal>:
            <comment type="block">/* Present but empty, fix permissions and use it */</comment>
            printf(_(<literal type="string">"fixing permissions on existing directory %s ... "</literal>),
                   pg_data);
            fflush(stdout);

            if (chmod(pg_data, S_IRWXU) != <literal type="number">0</literal>)
            {
                fprintf(stderr, _(<literal type="string">"%s: could not change permissions of directory \"%s\": %s\n"</literal>),
                        progname, pg_data, strerror(errno));
                exit_nicely();
            }
            else
                check_ok();

            found_existing_pgdata = true;
            break;

        case <literal type="number">2</literal>:
        case <literal type="number">3</literal>:
        case <literal type="number">4</literal>:
            <comment type="block">/* Present and not empty */</comment>
            fprintf(stderr,
                    _(<literal type="string">"%s: directory \"%s\" exists but is not empty\n"</literal>),
                    progname, pg_data);
            if (ret != <literal type="number">4</literal>)
                warn_on_mount_point(ret);
            else
                fprintf(stderr,
                        _(<literal type="string">"If you want to create a new database system, either remove or empty\n"</literal>
                          <literal type="string">"the directory \"%s\" or run %s\n"</literal>
                          <literal type="string">"with an argument other than \"%s\".\n"</literal>),
                        pg_data, progname, pg_data);
            exit(<literal type="number">1</literal>);            <comment type="block">/* no further message needed */</comment>

        default:
            <comment type="block">/* Trouble accessing directory */</comment>
            fprintf(stderr, _(<literal type="string">"%s: could not access directory \"%s\": %s\n"</literal>),
                    progname, pg_data, strerror(errno));
            exit_nicely();
    }
}


<comment type="block">/* Create WAL directory, and symlink if required */</comment>
void
create_xlog_or_symlink(void)
{<comment type="line">// #lizard forgives</comment>
    char       *subdirloc;

    <comment type="block">/* form name of the place for the subdirectory or symlink */</comment>
    subdirloc = psprintf(<literal type="string">"%s/pg_wal"</literal>, pg_data);

    if (strcmp(xlog_dir, <literal type="string">""</literal>) != <literal type="number">0</literal>)
    {
        int            ret;

        <comment type="block">/* clean up xlog directory name, check it's absolute */</comment>
        canonicalize_path(xlog_dir);
        if (!is_absolute_path(xlog_dir))
        {
            fprintf(stderr, _(<literal type="string">"%s: WAL directory location must be an absolute path\n"</literal>), progname);
            exit_nicely();
        }

        <comment type="block">/* check if the specified xlog directory exists/is empty */</comment>
        switch ((ret = pg_check_dir(xlog_dir)))
        {
            case <literal type="number">0</literal>:
                <comment type="block">/* xlog directory not there, must create it */</comment>
                printf(_(<literal type="string">"creating directory %s ... "</literal>),
                       xlog_dir);
                fflush(stdout);

                if (pg_mkdir_p(xlog_dir, S_IRWXU) != <literal type="number">0</literal>)
                {
                    fprintf(stderr, _(<literal type="string">"%s: could not create directory \"%s\": %s\n"</literal>),
                            progname, xlog_dir, strerror(errno));
                    exit_nicely();
                }
                else
                    check_ok();

                made_new_xlogdir = true;
                break;

            case <literal type="number">1</literal>:
                <comment type="block">/* Present but empty, fix permissions and use it */</comment>
                printf(_(<literal type="string">"fixing permissions on existing directory %s ... "</literal>),
                       xlog_dir);
                fflush(stdout);

                if (chmod(xlog_dir, S_IRWXU) != <literal type="number">0</literal>)
                {
                    fprintf(stderr, _(<literal type="string">"%s: could not change permissions of directory \"%s\": %s\n"</literal>),
                            progname, xlog_dir, strerror(errno));
                    exit_nicely();
                }
                else
                    check_ok();

                found_existing_xlogdir = true;
                break;

            case <literal type="number">2</literal>:
            case <literal type="number">3</literal>:
            case <literal type="number">4</literal>:
                <comment type="block">/* Present and not empty */</comment>
                fprintf(stderr,
                        _(<literal type="string">"%s: directory \"%s\" exists but is not empty\n"</literal>),
                        progname, xlog_dir);
                if (ret != <literal type="number">4</literal>)
                    warn_on_mount_point(ret);
                else
                    fprintf(stderr,
                            _(<literal type="string">"If you want to store the WAL there, either remove or empty the directory\n"</literal>
                              <literal type="string">"\"%s\".\n"</literal>),
                            xlog_dir);
                exit_nicely();

            default:
                <comment type="block">/* Trouble accessing directory */</comment>
                fprintf(stderr, _(<literal type="string">"%s: could not access directory \"%s\": %s\n"</literal>),
                        progname, xlog_dir, strerror(errno));
                exit_nicely();
        }

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
        if (symlink(xlog_dir, subdirloc) != <literal type="number">0</literal>)
        {
            fprintf(stderr, _(<literal type="string">"%s: could not create symbolic link \"%s\": %s\n"</literal>),
                    progname, subdirloc, strerror(errno));
            exit_nicely();
        }
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        fprintf(stderr, _(<literal type="string">"%s: symlinks are not supported on this platform"</literal>));
        exit_nicely();
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }
    else
    {
        <comment type="block">/* Without -X option, just make the subdirectory normally */</comment>
        if (mkdir(subdirloc, S_IRWXU) &lt; <literal type="number">0</literal>)
        {
            fprintf(stderr, _(<literal type="string">"%s: could not create directory \"%s\": %s\n"</literal>),
                    progname, subdirloc, strerror(errno));
            exit_nicely();
        }
    }

    free(subdirloc);
}


void
warn_on_mount_point(int error)
{
    if (error == <literal type="number">2</literal>)
        fprintf(stderr,
                _(<literal type="string">"It contains a dot-prefixed/invisible file, perhaps due to it being a mount point.\n"</literal>));
    else if (error == <literal type="number">3</literal>)
        fprintf(stderr,
                _(<literal type="string">"It contains a lost+found directory, perhaps due to it being a mount point.\n"</literal>));

    fprintf(stderr,
            _(<literal type="string">"Using a mount point directly as the data directory is not recommended.\n"</literal>
              <literal type="string">"Create a subdirectory under the mount point.\n"</literal>));
}


void
initialize_data_directory(void)
{
    PG_CMD_DECL;
    int            i;

    setup_signals();

    umask(S_IRWXG | S_IRWXO);

    create_data_directory();

    create_xlog_or_symlink();

    <comment type="block">/* Create required subdirectories (other than pg_wal) */</comment>
    printf(_(<literal type="string">"creating subdirectories ... "</literal>));
    fflush(stdout);

    for (i = <literal type="number">0</literal>; i &lt; lengthof(subdirs); i++)
    {
        char       *path;

        path = psprintf(<literal type="string">"%s/%s"</literal>, pg_data, subdirs[i]);

        <comment type="block">/*
         * The parent directory already exists, so we only need mkdir() not
         * pg_mkdir_p() here, which avoids some failure modes; cf bug #13853.
         */</comment>
        if (mkdir(path, S_IRWXU) &lt; <literal type="number">0</literal>)
        {
            fprintf(stderr, _(<literal type="string">"%s: could not create directory \"%s\": %s\n"</literal>),
                    progname, path, strerror(errno));
            exit_nicely();
        }

        free(path);
    }

    check_ok();

    <comment type="block">/* Top level PG_VERSION is checked by bootstrapper, so make it first */</comment>
    write_version_file(NULL);

    <comment type="block">/* Select suitable configuration settings */</comment>
    set_null_conf();
    test_config_settings();

    <comment type="block">/* Now create all the text config files */</comment>
    setup_config();

    <comment type="block">/* Bootstrap template1 */</comment>
    bootstrap_template1();

    <comment type="block">/*
     * Make the per-database PG_VERSION for template1 only after init'ing it
     */</comment>
    write_version_file(<literal type="string">"base/1"</literal>);

    <comment type="block">/*
     * Create the stuff we don't need to use bootstrap mode for, using a
     * backend running in simple standalone mode.
     */</comment>
    fputs(_(<literal type="string">"performing post-bootstrap initialization ... "</literal>), stdout);
    fflush(stdout);

    snprintf(cmd, sizeof(cmd),
             <literal type="string">"\"%s\" %s template1 &gt;%s"</literal>,
             backend_exec, backend_options,
             DEVNULL);

    PG_CMD_OPEN;

    setup_auth(cmdfd);

	setup_pgxc_node(cmdfd);

    setup_depend(cmdfd);

    <comment type="block">/*
     * Note that no objects created after setup_depend() will be "pinned".
     * They are all droppable at the whim of the DBA.
     */</comment>

    setup_sysviews(cmdfd);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Initialize catalog information about the node self */</comment>
    setup_nodeself(cmdfd);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    setup_description(cmdfd);

    setup_collation(cmdfd);

    setup_conversion(cmdfd);

    setup_dictionary(cmdfd);

    setup_privileges(cmdfd);

    setup_schema(cmdfd);

    load_plpgsql(cmdfd);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    load_gtm_info(cmdfd);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    vacuum_db(cmdfd);

    make_template0(cmdfd);

    make_postgres(cmdfd);

    PG_CMD_CLOSE;

    check_ok();
}


int
main(int argc, char *argv[])
{<comment type="line">// #lizard forgives</comment>
    static struct option long_options[] = {
        {<literal type="string">"pgdata"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'D'</literal>}</argument>,
        <argument>{<literal type="string">"encoding"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'E'</literal>}</argument>,
        <argument>{<literal type="string">"locale"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">1</literal>}</argument>,
        <argument>{<literal type="string">"lc-collate"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">2</literal>}</argument>,
        <argument>{<literal type="string">"lc-ctype"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">3</literal>}</argument>,
        <argument>{<literal type="string">"lc-monetary"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">4</literal>}</argument>,
        <argument>{<literal type="string">"lc-numeric"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">5</literal>}</argument>,
        <argument>{<literal type="string">"lc-time"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">6</literal>}</argument>,
        <argument>{<literal type="string">"lc-messages"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">7</literal>}</argument>,
        <argument>{<literal type="string">"no-locale"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">8</literal>}</argument>,
        <argument>{<literal type="string">"text-search-config"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'T'</literal>}</argument>,
        <argument>{<literal type="string">"auth"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'A'</literal>}</argument>,
        <argument>{<literal type="string">"auth-local"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">10</literal>}</argument>,
        <argument>{<literal type="string">"auth-host"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">11</literal>}</argument>,
        <argument>{<literal type="string">"pwprompt"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'W'</literal>}</argument>,
        <argument>{<literal type="string">"pwfile"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">9</literal>}</argument>,
        <argument>{<literal type="string">"username"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'U'</literal>}</argument>,
        <argument>{<literal type="string">"help"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'?'</literal>}</argument>,
        <argument>{<literal type="string">"version"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'V'</literal>}</argument>,
        <argument>{<literal type="string">"debug"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'d'</literal>}</argument>,
        <argument>{<literal type="string">"show"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'s'</literal>}</argument>,
        <argument>{<literal type="string">"noclean"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'n'</literal>}</argument>,    <comment type="block">/* for backwards compatibility */</comment>
        <argument>{<literal type="string">"no-clean"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'n'</literal>}</argument>,
        <argument>{<literal type="string">"nosync"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'N'</literal>}</argument>, <comment type="block">/* for backwards compatibility */</comment>
        <argument>{<literal type="string">"no-sync"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'N'</literal>}</argument>,
        <argument>{<literal type="string">"sync-only"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'S'</literal>}</argument>,
        <argument>{<literal type="string">"waldir"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'X'</literal>}</argument>,
        <argument>{<literal type="string">"data-checksums"</literal></argument>, <argument>no_argument</argument>, <argument>NULL</argument>, <argument><literal type="char">'k'</literal>}</argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <argument>{<literal type="string">"nodename"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">12</literal>}</argument>,
        <argument>{<literal type="string">"nodetype"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">13</literal>}</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <argument>{<literal type="string">"mls_user"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">14</literal>}</argument>,
        <argument>{<literal type="string">"audit_user"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">15</literal>}</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <argument>{<literal type="string">"master_gtm_ip"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">16</literal>}</argument>,
        <argument>{<literal type="string">"master_gtm_port"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">17</literal>}</argument>,
        <argument>{<literal type="string">"master_gtm_nodename"</literal></argument>, <argument>required_argument</argument>, <argument>NULL</argument>, <argument><literal type="number">18</literal>}</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <argument>{NULL</argument>, <argument><literal type="number">0</literal></argument>, <argument>NULL</argument>, <argument><literal type="number">0</literal>}
    };

    <comment type="block">/*
     * options with no short version return a low integer, the rest return
     * their short version value
     */</comment>
    int            c;
    int            option_index;
    char       *effective_user;
    PQExpBuffer start_db_cmd;
    char        pg_ctl_path[MAXPGPATH];

    <comment type="block">/*
     * Ensure that buffering behavior of stdout and stderr matches what it is
     * in interactive usage (at least on most platforms).  This prevents
     * unexpected output ordering when, eg, output is redirected to a file.
     * POSIX says we must do this before any other usage of these files.
     */</comment>
    setvbuf(stdout, NULL, PG_IOLBF, <literal type="number">0</literal>);
    setvbuf(stderr, NULL, _IONBF, <literal type="number">0</literal>);

    progname = get_progname(argv[<literal type="number">0</literal>]);
    set_pglocale_pgservice(argv[<literal type="number">0</literal>], PG_TEXTDOMAIN(<literal type="string">"initdb"</literal>));

    if (argc &gt; <literal type="number">1</literal>)
    {
        if (strcmp(argv[<literal type="number">1</literal>], <literal type="string">"--help"</literal>) == <literal type="number">0</literal> || strcmp(argv[<literal type="number">1</literal>], <literal type="string">"-?"</literal>) == <literal type="number">0</literal>)
        {
            usage(progname);
            exit(<literal type="number">0</literal>);
        }
        if (strcmp(argv[<literal type="number">1</literal>], <literal type="string">"--version"</literal>) == <literal type="number">0</literal> || strcmp(argv[<literal type="number">1</literal>], <literal type="string">"-V"</literal>) == <literal type="number">0</literal>)
        {
            puts(<literal type="string">"initdb (PostgreSQL) "</literal> PG_VERSION);
            exit(<literal type="number">0</literal>);
        }
    }

    <comment type="block">/* process command-line options */</comment>

    while ((c = getopt_long(argc, argv, <literal type="string">"dD:E:kL:nNU:WA:sST:X:"</literal>, long_options, &amp;option_index)) != -<literal type="number">1</literal>)
    {
        switch (c)
        {
            case <literal type="char">'A'</literal>:
                authmethodlocal = authmethodhost = pg_strdup(optarg);

                <comment type="block">/*
                 * When ident is specified, use peer for local connections.
                 * Mirrored, when peer is specified, use ident for TCP/IP
                 * connections.
                 */</comment>
                if (strcmp(authmethodhost, <literal type="string">"ident"</literal>) == <literal type="number">0</literal>)
                    authmethodlocal = <literal type="string">"peer"</literal>;
                else if (strcmp(authmethodlocal, <literal type="string">"peer"</literal>) == <literal type="number">0</literal>)
                    authmethodhost = <literal type="string">"ident"</literal>;
                break;
            case <literal type="number">10</literal>:
                authmethodlocal = pg_strdup(optarg);
                break;
            case <literal type="number">11</literal>:
                authmethodhost = pg_strdup(optarg);
                break;
            case <literal type="char">'D'</literal>:
                pg_data = pg_strdup(optarg);
                break;
            case <literal type="char">'E'</literal>:
                encoding = pg_strdup(optarg);
                break;
            case <literal type="char">'W'</literal>:
                pwprompt = true;
                break;
            case <literal type="char">'U'</literal>:
                username = pg_strdup(optarg);
                break;
            case <literal type="char">'d'</literal>:
                debug = true;
                printf(_(<literal type="string">"Running in debug mode.\n"</literal>));
                break;
            case <literal type="char">'n'</literal>:
                noclean = true;
                printf(_(<literal type="string">"Running in no-clean mode.  Mistakes will not be cleaned up.\n"</literal>));
                break;
            case <literal type="char">'N'</literal>:
                do_sync = false;
                break;
            case <literal type="char">'S'</literal>:
                sync_only = true;
                break;
            case <literal type="char">'k'</literal>:
                data_checksums = true;
                break;
            case <literal type="char">'L'</literal>:
                share_path = pg_strdup(optarg);
                break;
            case <literal type="number">1</literal>:
                locale = pg_strdup(optarg);
                break;
            case <literal type="number">2</literal>:
                lc_collate = pg_strdup(optarg);
                break;
            case <literal type="number">3</literal>:
                lc_ctype = pg_strdup(optarg);
                break;
            case <literal type="number">4</literal>:
                lc_monetary = pg_strdup(optarg);
                break;
            case <literal type="number">5</literal>:
                lc_numeric = pg_strdup(optarg);
                break;
            case <literal type="number">6</literal>:
                lc_time = pg_strdup(optarg);
                break;
            case <literal type="number">7</literal>:
                lc_messages = pg_strdup(optarg);
                break;
            case <literal type="number">8</literal>:
                locale = <literal type="string">"C"</literal>;
                break;
            case <literal type="number">9</literal>:
                pwfilename = pg_strdup(optarg);
                break;
            case <literal type="char">'s'</literal>:
                show_setting = true;
                break;
            case <literal type="char">'T'</literal>:
                default_text_search_config = pg_strdup(optarg);
                break;
            case <literal type="char">'X'</literal>:
                xlog_dir = pg_strdup(optarg);
                break;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            case <literal type="number">12</literal>:
                nodename = pg_strdup(optarg);
                break;
            case <literal type="number">13</literal>:
                {
                    nodetype = pg_strdup(optarg);
                    break;
                }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            case <literal type="number">14</literal>: <comment type="block">/*pg_mls_user*/</comment>
                {
                    mls_admin = pg_strdup(optarg);
                    printf(_(<literal type="string">"get new mls admin:%s.\n"</literal>), mls_admin);
                    break;
                }
            case <literal type="number">15</literal>: <comment type="block">/*pg_audit_user*/</comment>
                {
                    audit_admin = pg_strdup(optarg);
                    printf(_(<literal type="string">"get new audit admin:%s.\n"</literal>), audit_admin);
                    break;
                }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            case <literal type="number">16</literal>: <comment type="block">/*master gtm ip*/</comment>
                {
                    master_gtm_ip = pg_strdup(optarg);
                    printf(_(<literal type="string">"get master gtm ip:%s.\n"</literal>), master_gtm_ip);
                    break;
                }
            case <literal type="number">17</literal>: <comment type="block">/*master gtm port*/</comment>
                {
                    master_gtm_port = pg_strdup(optarg);
                    printf(_(<literal type="string">"get master gtm port:%s.\n"</literal>), master_gtm_port);
                    break;
                }    
            case <literal type="number">18</literal>: <comment type="block">/*master gtm nodename*/</comment>
                {
                    master_gtm_nodename = pg_strdup(optarg);
                    printf(_(<literal type="string">"get master gtm nodename:%s.\n"</literal>), master_gtm_nodename);
                    break;
                }    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            default:
                <comment type="block">/* getopt_long already emitted a complaint */</comment>
                fprintf(stderr, _(<literal type="string">"Try \"%s --help\" for more information.\n"</literal>),
                        progname);
                exit(<literal type="number">1</literal>);
        }
    }


    <comment type="block">/*
     * Non-option argument specifies data directory as long as it wasn't
     * already specified with -D / --pgdata
     */</comment>
    if (optind &lt; argc &amp;&amp; strlen(pg_data) == <literal type="number">0</literal>)
    {
        pg_data = pg_strdup(argv[optind]);
        optind++;
    }

    if (optind &lt; argc)
    {
        fprintf(stderr, _(<literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal>),
                progname, argv[optind]);
        fprintf(stderr, _(<literal type="string">"Try \"%s --help\" for more information.\n"</literal>),
                progname);
        exit(<literal type="number">1</literal>);
    }

    <comment type="block">/* If we only need to fsync, just do it and exit */</comment>
    if (sync_only)
    {
        setup_pgdata();

        <comment type="block">/* must check that directory is readable */</comment>
        if (pg_check_dir(pg_data) &lt;= <literal type="number">0</literal>)
        {
            fprintf(stderr, _(<literal type="string">"%s: could not access directory \"%s\": %s\n"</literal>),
                    progname, pg_data, strerror(errno));
            exit_nicely();
        }

        fputs(_(<literal type="string">"syncing data to disk ... "</literal>), stdout);
        fflush(stdout);
        fsync_pgdata(pg_data, progname, PG_VERSION_NUM);
        check_ok();
        return <literal type="number">0</literal>;
    }

    if (pwprompt &amp;&amp; pwfilename)
    {
        fprintf(stderr, _(<literal type="string">"%s: password prompt and password file cannot be specified together\n"</literal>), progname);
        exit(<literal type="number">1</literal>);
    }

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    if (!nodename || !nodetype)
    {
        fprintf(stderr, _(<literal type="string">"%s: Postgres-XL node name  and node type is mandatory\n"</literal>), progname);
        fprintf(stderr, _(<literal type="string">"Try \"%s --help\" for more information.\n"</literal>),
                progname);
        exit(<literal type="number">1</literal>);
    }
    
    if (strcasecmp(nodetype, <literal type="string">"datanode"</literal>) != <literal type="number">0</literal> &amp;&amp; strcasecmp(nodetype, <literal type="string">"coordinator"</literal>) != <literal type="number">0</literal>)
    {
        fprintf(stderr, _(<literal type="string">"%s: Postgres-XL node type is supposed to be 'datanode' or 'coordinator'\n"</literal>), progname);
        fprintf(stderr, _(<literal type="string">"Try \"%s --help\" for more information.\n"</literal>),
                progname);
        exit(<literal type="number">1</literal>);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    check_authmethod_unspecified(&amp;authmethodlocal);
    check_authmethod_unspecified(&amp;authmethodhost);

    check_authmethod_valid(authmethodlocal, auth_methods_local, <literal type="string">"local"</literal>);
    check_authmethod_valid(authmethodhost, auth_methods_host, <literal type="string">"host"</literal>);

    check_need_password(authmethodlocal, authmethodhost);

    get_restricted_token(progname);

    setup_pgdata();

    setup_bin_paths(argv[<literal type="number">0</literal>]);

    effective_user = get_id();
    if (strlen(username) == <literal type="number">0</literal>)
        username = effective_user;

    if (strncmp(username, <literal type="string">"pg_"</literal>, <literal type="number">3</literal>) == <literal type="number">0</literal>)
    {
        fprintf(stderr, _(<literal type="string">"%s: superuser name \"%s\" is disallowed; role names cannot begin with \"pg_\"\n"</literal>), progname, username);
        exit(<literal type="number">1</literal>);
    }

    printf(_(<literal type="string">"The files belonging to this database system will be owned "</literal>
             <literal type="string">"by user \"%s\".\n"</literal>
             <literal type="string">"This user must also own the server process.\n\n"</literal>),
           effective_user);

    set_info_version();

    setup_data_file_paths();

    setup_locale_encoding();

    setup_text_search();

    printf(<literal type="string">"\n"</literal>);

    if (data_checksums)
        printf(_(<literal type="string">"Data page checksums are enabled.\n"</literal>));
    else
        printf(_(<literal type="string">"Data page checksums are disabled.\n"</literal>));

    if (pwprompt || pwfilename)
        get_su_pwd();

    printf(<literal type="string">"\n"</literal>);

    initialize_data_directory();

    if (do_sync)
    {
        fputs(_(<literal type="string">"syncing data to disk ... "</literal>), stdout);
        fflush(stdout);
        fsync_pgdata(pg_data, progname, PG_VERSION_NUM);
        check_ok();
    }
    else
        printf(_(<literal type="string">"\nSync to disk skipped.\nThe data directory might become corrupt if the operating system crashes.\n"</literal>));

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    vacuumfreeze(<literal type="string">"template0"</literal>);
    vacuumfreeze(<literal type="string">"template1"</literal>);
    vacuumfreeze(<literal type="string">"postgres"</literal>);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    if (authwarning != NULL)
        fprintf(stderr, <literal type="string">"%s"</literal>, authwarning);

    <comment type="block">/*
     * Build up a shell command to tell the user how to start the server
     */</comment>
    start_db_cmd = createPQExpBuffer();

    <comment type="block">/* Get directory specification used to start initdb ... */</comment>
    strlcpy(pg_ctl_path, argv[<literal type="number">0</literal>], sizeof(pg_ctl_path));
    canonicalize_path(pg_ctl_path);
    get_parent_directory(pg_ctl_path);
    <comment type="block">/* ... and tag on pg_ctl instead */</comment>
    join_path_components(pg_ctl_path, pg_ctl_path, <literal type="string">"pg_ctl"</literal>);

    <comment type="block">/* path to pg_ctl, properly quoted */</comment>
    appendShellString(start_db_cmd, pg_ctl_path);

    <comment type="block">/* add -D switch, with properly quoted data directory */</comment>
    appendPQExpBufferStr(start_db_cmd, <literal type="string">" -D "</literal>);
    appendShellString(start_db_cmd, pgdata_native);

    <comment type="block">/* add suggested -l switch and "start" command */</comment>
    <comment type="block">/* translator: This is a placeholder in a shell command. */</comment>
    appendPQExpBuffer(start_db_cmd, <literal type="string">" -l %s start"</literal>, _(<literal type="string">"logfile"</literal>));


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    printf(_(<literal type="string">"\nSuccess.\n"</literal>));
    {
        char *pgxc_ctl_silent = getenv(<literal type="string">"PGXC_CTL_SILENT"</literal>);
        if (!pgxc_ctl_silent || !strlen(pgxc_ctl_silent))
        {
            printf(_(<literal type="string">"\nSuccess. You can now start the database server of the Postgres-XL coordinator using:\n\n"</literal>
                        <literal type="string">"    %s -Z coordinator\n\n"</literal>
                        <literal type="string">"or\n"</literal>
                        <literal type="string">" You can now start the database server of the Postgres-XL datanode using:\n\n"</literal>
                        <literal type="string">"    %s -Z datanode\n\n"</literal>),
                    start_db_cmd-&gt;data,
                    start_db_cmd-&gt;data);
        }
    }
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    printf(_(<literal type="string">"\nSuccess. You can now start the database server using:\n\n"</literal>
             <literal type="string">"    %s\n\n"</literal>),
           start_db_cmd-&gt;data);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    destroyPQExpBuffer(start_db_cmd);

    return <literal type="number">0</literal>;
}</argument></argument_list></macro></block_content></block></function>

</unit>
