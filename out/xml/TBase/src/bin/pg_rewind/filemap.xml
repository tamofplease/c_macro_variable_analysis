<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/pg_rewind/filemap.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * filemap.c
 *      A data structure for keeping track of files that have changed.
 *
 * Copyright (c) 2013-2017, PostgreSQL Global Development Group
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datapagemap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filemap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_rewind.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>filemap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isRelDataFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>datasegpath</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
            <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>path_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>final_filemap_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>filemap_list_to_array</name><parameter_list>(<parameter><decl><type><name>filemap_t</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create a new file map (stored in the global pointer "filemap").
 */</comment>
<function><type><name>void</name></type>
<name>filemap_create</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filemap_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>narray</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>filemap</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>filemap</name> <operator>=</operator> <name>map</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback for processing source file list.
 *
 * This is called once for every file in the source server. We decide what
 * action needs to be taken for the file, depending on whether the file
 * exists in the target and whether the size matches.
 */</comment>
<function><type><name>void</name></type>
<name>process_source_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>file_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newsize</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>link_target</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>exists</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>localpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>map</name> <init>= <expr><name>filemap</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_action_t</name></type> <name>action</name> <init>= <expr><name>FILE_ACTION_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>oldsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Completely ignore some special files in source and destination.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"postmaster.pid"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"postmaster.opts"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Pretend that pg_wal is a directory, even if it's really a symlink. We
     * don't want to mess with the symlink itself, nor complain if it's a
     * symlink in source but not in target or vice versa.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>FILE_TYPE_SYMLINK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name>FILE_TYPE_DIRECTORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Skip temporary files, .../pgsql_tmp/... and .../pgsql_tmp.* in source.
     * This has the effect that all temporary files in the destination will be
     * removed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"/"</literal> <name>PG_TEMP_FILE_PREFIX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"/"</literal> <name>PG_TEMP_FILES_DIR</name> <literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * sanity check: a filename that looks like a data file better be a
     * regular file
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>FILE_TYPE_REGULAR</name> <operator>&amp;&amp;</operator> <call><name>isRelDataFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"data file \"%s\" in source is not a regular file\n"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>localpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>datadir_target</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Does the corresponding file exist in the target data dir? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>localpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %s\n"</literal></expr></argument>,
                     <argument><expr><name>localpath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>FILE_TYPE_DIRECTORY</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>exists</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* it's a directory in source, but not in target. Strange.. */</comment>
                <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a directory\n"</literal></expr></argument>, <argument><expr><name>localpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_CREATE</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>FILE_TYPE_SYMLINK</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>exists</name> <operator>&amp;&amp;</operator>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
                <operator>!</operator><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <operator>!</operator><call><name>pgwin32_is_junction</name><argument_list>(<argument><expr><name>localpath</name></expr></argument>)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                )</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * It's a symbolic link in source, but not in target.
                 * Strange..
                 */</comment>
                <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a symbolic link\n"</literal></expr></argument>, <argument><expr><name>localpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_CREATE</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>FILE_TYPE_REGULAR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>exists</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a regular file\n"</literal></expr></argument>, <argument><expr><name>localpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name> <operator>||</operator> <operator>!</operator><call><name>isRelDataFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * File exists in source, but not in target. Or it's a
                 * non-data file that we have no special processing for. Copy
                 * it in toto.
                 *
                 * An exception: PG_VERSIONs should be identical, but avoid
                 * overwriting it for paranoia.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"PG_VERSION"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_NONE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_COPY</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * It's a data file that exists in both.
                 *
                 * If it's larger in target, we can truncate it. There will
                 * also be a WAL record of the truncation in the source
                 * system, so WAL replay would eventually truncate the target
                 * too, but we might as well do it now.
                 *
                 * If it's smaller in the target, it means that it has been
                 * truncated in the target, or enlarged in the source, or
                 * both. If it was truncated in the target, we need to copy
                 * the missing tail from the source system. If it was enlarged
                 * in the source system, there will be WAL records in the
                 * source system for the new blocks, so we wouldn't need to
                 * copy them here. But we don't know which scenario we're
                 * dealing with, and there's no harm in copying the missing
                 * blocks now, so do it now.
                 *
                 * If it's the same size, do nothing here. Any blocks modified
                 * in the target will be copied based on parsing the target
                 * system's WAL, and any blocks modified in the source will be
                 * updated after rewinding, when the source system's WAL is
                 * replayed.
                 */</comment>
                <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_COPY_TAIL</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>oldsize</name> <operator>&gt;</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_TRUNCATE</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>action</name> <operator>=</operator> <name>FILE_ACTION_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Create a new entry for this file */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_entry_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>oldsize</name></name> <operator>=</operator> <name>oldsize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>newsize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>link_target</name></name> <operator>=</operator> <ternary><condition><expr><name>link_target</name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>link_target</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name><operator>.</operator><name>bitmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name><operator>.</operator><name>bitmapsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isrelfile</name></name> <operator>=</operator> <call><name>isRelDataFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nlist</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback for processing target file list.
 *
 * All source files must be already processed before calling this. This only
 * marks target data directory's files that didn't exist in the source for
 * deletion.
 */</comment>
<function><type><name>void</name></type>
<name>process_target_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>file_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>oldsize</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>link_target</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>exists</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>localpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>key_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>map</name> <init>= <expr><name>filemap</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>localpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>datadir_target</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>localpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %s\n"</literal></expr></argument>,
                     <argument><expr><name>localpath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* on first call, initialize lookup array */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>nlist</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* should not happen */</comment>
            <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"source file list is empty\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>filemap_list_to_array</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_entry_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>path_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Completely ignore some special files
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"postmaster.pid"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"postmaster.opts"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Like in process_source_file, pretend that xlog is always a  directory.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>FILE_TYPE_SYMLINK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name>FILE_TYPE_DIRECTORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>path</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>key_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>exists</name> <operator>=</operator> <operator>(</operator><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_ptr</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_entry_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                      <argument><expr><name>path_cmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Remove any file or folder that doesn't exist in the source system. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_entry_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>FILE_ACTION_REMOVE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>oldsize</name></name> <operator>=</operator> <name>oldsize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>newsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>link_target</name></name> <operator>=</operator> <ternary><condition><expr><name>link_target</name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>link_target</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name><operator>.</operator><name>bitmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name><operator>.</operator><name>bitmapsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isrelfile</name></name> <operator>=</operator> <call><name>isRelDataFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>last</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nlist</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * We already handled all files that exist in the source system in
         * process_source_file().
         */</comment>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This callback gets called while we read the WAL in the target, for every
 * block that have changed in the target system. It makes note of all the
 * changed blocks in the pagemap of the file.
 */</comment>
<function><type><name>void</name></type>
<name>process_block_change</name><parameter_list>(<parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>key_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno_inseg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>segno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>map</name> <init>= <expr><name>filemap</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>segno</name> <operator>=</operator> <name>blkno</name> <operator>/</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>blkno_inseg</name> <operator>=</operator> <name>blkno</name> <operator>%</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>datasegpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>path</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>key_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>key</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_ptr</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_entry_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>path_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>*</operator><name>e</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>isrelfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>FILE_ACTION_NONE</name></expr>:</case>
            <case>case <expr><name>FILE_ACTION_TRUNCATE</name></expr>:</case>
                <comment type="block">/* skip if we're truncating away the modified block anyway */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>blkno_inseg</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>BLCKSZ</name> <operator>&lt;=</operator> <name><name>entry</name><operator>-&gt;</operator><name>newsize</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>datapagemap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name></name></expr></argument>, <argument><expr><name>blkno_inseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><name>FILE_ACTION_COPY_TAIL</name></expr>:</case>

                <comment type="block">/*
                 * skip the modified block if it is part of the "tail" that
                 * we're copying anyway.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>blkno_inseg</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>BLCKSZ</name> <operator>&lt;=</operator> <name><name>entry</name><operator>-&gt;</operator><name>oldsize</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>datapagemap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name></name></expr></argument>, <argument><expr><name>blkno_inseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><name>FILE_ACTION_COPY</name></expr>:</case>
            <case>case <expr><name>FILE_ACTION_REMOVE</name></expr>:</case>
                <break>break;</break>

            <case>case <expr><name>FILE_ACTION_CREATE</name></expr>:</case>
                <expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"unexpected page modification for directory or symbolic link \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If we don't have any record of this file in the file map, it means
         * that it's a relation that doesn't exist in the source system, and
         * it was subsequently removed in the target system, too. We can
         * safely ignore it.
         */</comment>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert the linked list of entries in map-&gt;first/last to the array,
 * map-&gt;array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>filemap_list_to_array</name><parameter_list>(<parameter><decl><type><name>filemap_t</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>narray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <operator>(</operator><name>file_entry_t</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,
                   <argument><expr><operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>nlist</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>narray</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>file_entry_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>narray</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>entry</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>narray</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>narray</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>nlist</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>narray</name></name> <operator>=</operator> <name>narray</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>filemap_finalize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>map</name> <init>= <expr><name>filemap</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>filemap_list_to_array</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_entry_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
          <argument><expr><name>final_filemap_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>action_to_str</name><parameter_list>(<parameter><decl><type><name>file_action_t</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>action</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>FILE_ACTION_NONE</name></expr>:</case>
            <return>return <expr><literal type="string">"NONE"</literal></expr>;</return>
        <case>case <expr><name>FILE_ACTION_COPY</name></expr>:</case>
            <return>return <expr><literal type="string">"COPY"</literal></expr>;</return>
        <case>case <expr><name>FILE_ACTION_TRUNCATE</name></expr>:</case>
            <return>return <expr><literal type="string">"TRUNCATE"</literal></expr>;</return>
        <case>case <expr><name>FILE_ACTION_COPY_TAIL</name></expr>:</case>
            <return>return <expr><literal type="string">"COPY_TAIL"</literal></expr>;</return>
        <case>case <expr><name>FILE_ACTION_CREATE</name></expr>:</case>
            <return>return <expr><literal type="string">"CREATE"</literal></expr>;</return>
        <case>case <expr><name>FILE_ACTION_REMOVE</name></expr>:</case>
            <return>return <expr><literal type="string">"REMOVE"</literal></expr>;</return>

        <default>default:</default>
            <return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the totals needed for progress reports.
 */</comment>
<function><type><name>void</name></type>
<name>calculate_totals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>map</name> <init>= <expr><name>filemap</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>total_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>FILE_TYPE_REGULAR</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>total_size</name></name> <operator>+=</operator> <name><name>entry</name><operator>-&gt;</operator><name>newsize</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>FILE_ACTION_COPY</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>+=</operator> <name><name>entry</name><operator>-&gt;</operator><name>newsize</name></name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>FILE_ACTION_COPY_TAIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>+=</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>newsize</name></name> <operator>-</operator> <name><name>entry</name><operator>-&gt;</operator><name>oldsize</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name><operator>.</operator><name>bitmapsize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>datapagemap_iterator_t</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>datapagemap_iterate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>datapagemap_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>+=</operator> <name>BLCKSZ</name></expr>;</expr_stmt></block_content></block></while>

            <expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>print_filemap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>filemap_t</name>  <modifier>*</modifier></type><name>map</name> <init>= <expr><name>filemap</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>narray</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>FILE_ACTION_NONE</name> <operator>||</operator>
            <name><name>entry</name><operator>-&gt;</operator><name>pagemap</name><operator>.</operator><name>bitmapsize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_DEBUG</name></expr></argument>,
            <comment type="block">/*------
               translator: first %s is a file path, second is a keyword such as COPY */</comment>
                   <argument><expr><literal type="string">"%s (%s)\n"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
                   <argument><expr><call><name>action_to_str</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name><operator>.</operator><name>bitmapsize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>datapagemap_print</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>pagemap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Does it look like a relation data file?
 *
 * For our purposes, only files belonging to the main fork are considered
 * relation files. Other forks are always copied in toto, because we cannot
 * reliably track changes to them, because WAL only contains block references
 * for the main fork.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isRelDataFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">20</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>segNo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nmatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>matched</name></decl>;</decl_stmt>

    <comment type="block">/*----
     * Relation data files can be in one of the following directories:
     *
     * global/
     *        shared relations
     *
     * base/&lt;db oid&gt;/
     *        regular relations, default tablespace
     *
     * pg_tblspc/&lt;tblspc oid&gt;/PG_9.4_201403261/
     *        within a non-default tablespace (the name of the directory
     *        depends on version)
     *
     * And the relation data files themselves have a filename like:
     *
     * &lt;oid&gt;.&lt;segment number&gt;
     *
     *----
     */</comment>
    <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>segNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>matched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nmatch</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"global/%u.%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nmatch</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>nmatch</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>GLOBALTABLESPACE_OID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>nmatch</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"base/%u/%u.%u"</literal></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nmatch</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name>nmatch</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>DEFAULTTABLESPACE_OID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>nmatch</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%u/PG_%20s/%u/%u.%u"</literal></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>segNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nmatch</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>nmatch</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * The sscanf tests above can match files that have extra characters at
     * the end, and the last check can also match a path belonging to a
     * different version (different TABLESPACE_VERSION_DIRECTORY). To make
     * eliminate such cases, cross-check that GetRelationPath creates the
     * exact same filename, when passed the RelFileNode information we
     * extracted from the filename.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>matched</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>check_path</name> <init>= <expr><call><name>datasegpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>segNo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>check_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>matched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>check_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>matched</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A helper function to create the path of a relation file and segment.
 *
 * The returned path is palloc'd
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>datasegpath</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>segpath</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * TODO!! Pass correct node name
     */</comment>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathperm_client</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathperm</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>segpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>segpath</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>path</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>path_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>fa</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>file_entry_t</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>fb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>file_entry_t</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * In the final stage, the filemap is sorted so that removals come last.
 * From disk space usage point of view, it would be better to do removals
 * first, but for now, safety first. If a whole directory is deleted, all
 * files and subdirectories inside it need to removed first. On creation,
 * parent directory needs to be created before files and directories inside
 * it. To achieve that, the file_action_t enum is ordered so that we can
 * just sort on that first. Furthermore, sort REMOVE entries in reverse
 * path order, so that "foo/bar" subdirectory is removed before "foo".
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>final_filemap_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>fa</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>file_entry_t</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>file_entry_t</name> <modifier>*</modifier></type><name>fb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>file_entry_t</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fa</name><operator>-&gt;</operator><name>action</name></name> <operator>&gt;</operator> <name><name>fb</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fa</name><operator>-&gt;</operator><name>action</name></name> <operator>&lt;</operator> <name><name>fb</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fa</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>FILE_ACTION_REMOVE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
