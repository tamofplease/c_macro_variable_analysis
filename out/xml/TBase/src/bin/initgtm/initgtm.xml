<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/initgtm/initgtm.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * initgtm --- initialize a GTM (Global transaction manager) installation
 *
 * initgtm creates (initializes) a GTM/GTM-Proxy for Postgres-XC database
 * cluster (site, instance, installation, whatever).
 *
 * Note:
 *     The program has some memory leakage - it isn't worth cleaning it up.
 *
 * This code is released under the terms of the PostgreSQL License.
 *
 * Portions Copyright (c) 1996-2011, PostgreSQL Global Development Group
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/initgtm/initgtm.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getaddrinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm.h"</cpp:file></cpp:include>

<comment type="block">/*
 * these values are passed in by makefile defines
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>share_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* values to be obtained from arguments */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_data</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>noclean</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>show_setting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* internal vars */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>conf_file</name></decl>;</decl_stmt> <comment type="block">/* Used by GTM */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>caught_signal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>output_failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>output_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* about instance initialized */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_gtm</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt> <comment type="block">/* GTM or proxy */</comment>

<comment type="block">/* defaults for all nodes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>n_port</name> <init>= <expr><literal type="number">6666</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>    <modifier>*</modifier></type><name>n_name</name> <init>= <expr><literal type="string">"a_one"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* defaults for proxies - connection parameters to GTM */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>gtm_port</name> <init>= <expr><literal type="number">6668</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>gtm_host</name> <init>= <expr><literal type="string">"localhost"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* path to 'initgtm' binary directory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>bin_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>backend_exec</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>xstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>replace_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filter_lines_with_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writefile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exit_nicely</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mkdatadir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_null_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__XLOG__</name></cpp:ifndef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_control</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>trapsig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_ok</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>CreateRestrictedProcess</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>PROCESS_INFORMATION</name> <modifier>*</modifier></type><name>processInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUOTE_PATH</name></cpp:macro>    <cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIR_SEP</name></cpp:macro> <cpp:value>"/"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUOTE_PATH</name></cpp:macro>    <cpp:value>"\""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIR_SEP</name></cpp:macro> <cpp:value>"\\"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>xstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make a copy of the array of lines, with token replaced by replacement
 * the first time it occurs on each line.
 *
 * This does most of what sed was used for in the shell script, but
 * doesn't need any regexp stuff.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>replace_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numlines</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>toklen</name></decl>,
                <decl><type ref="prev"/><name>replen</name></decl>,
                <decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>numlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numlines</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>toklen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>replen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>diff</name> <operator>=</operator> <name>replen</name> <operator>-</operator> <name>toklen</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numlines</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>where</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newline</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>pre</name></decl>;</decl_stmt>

        <comment type="block">/* just copy pointer if NULL or no change needed */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>where</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* if we get here a change is needed - set up new line */</comment>

        <expr_stmt><expr><name>newline</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>diff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pre</name> <operator>=</operator> <name>where</name> <operator>-</operator> <name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>newline</name></expr></argument>, <argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newline</name> <operator>+</operator> <name>pre</name></expr></argument>, <argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newline</name> <operator>+</operator> <name>pre</name> <operator>+</operator> <name>replen</name></expr></argument>, <argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>pre</name> <operator>+</operator> <name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newline</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make a copy of lines without any that contain the token
 *
 * a sort of poor man's grep -v
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>filter_lines_with_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numlines</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>src</name></decl>,
                <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>numlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numlines</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>src</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>dst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>src</name> <operator>&lt;</operator> <name>numlines</name></expr>;</condition> <incr><expr><name>src</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>dst</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get the lines from a text file
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>infile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxlength</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>linelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nlines</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>infile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pass over the file twice - the first time to size the result */</comment>

    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>linelen</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nlines</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;</operator> <name>maxlength</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>maxlength</name> <operator>=</operator> <name>linelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>linelen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* handle last line without a terminating newline (yuck) */</comment>
    <if_stmt><if>if <condition>(<expr><name>linelen</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;</operator> <name>maxlength</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>maxlength</name> <operator>=</operator> <name>linelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* set up the result and the line buffer */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>nlines</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>maxlength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* now reprocess the file and store the lines */</comment>
    <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nlines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>infile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><name>nlines</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>nlines</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write an array of lines to a file
 *
 * This is only used to write text files.  Use fopen "w" not PG_BINARY_W
 * so that the resulting configuration files are nicely editable on Windows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>writefile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>out_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>out_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>fputs</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>, <argument><expr><name>out_file</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>out_file</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * clean up any files we created on failure
 * if we created the data directory remove it too
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exit_nicely</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noclean</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>found_existing_pgdata</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing contents of data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove contents of data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* otherwise died during startup, do nothing! */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name> <operator>||</operator> <name>found_existing_pgdata</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
              <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: data directory \"%s\" not removed at user's request\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find the current user
 *
 * on unix make sure it isn't really root
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

    <decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pw</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>            <comment type="block">/* 0 is root's uid */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot be run as root\n"</literal>
                  <literal type="string">"Please log in (using, e.g., \"su\") as the "</literal>
                  <literal type="string">"(unprivileged) user that will\n"</literal>
                  <literal type="string">"own the server process.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pw</name> <operator>=</operator> <call><name>getpwuid</name><argument_list>(<argument><expr><call><name>geteuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pw</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
              <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not obtain information about current user: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* the windows code */</comment>

    <struct>struct <name>passwd_win32</name>
    <block>{
        <decl_stmt><decl><type><name>int</name></type>            <name>pw_uid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>pw_name</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    }</block>            <decl><name>pass_win32</name></decl>;</struct>
    <decl_stmt><decl><type><name><name>struct</name> <name>passwd_win32</name></name> <modifier>*</modifier></type><name>pw</name> <init>= <expr><operator>&amp;</operator><name>pass_win32</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type>        <name>pwname_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pass_win32</name><operator>.</operator><name>pw_name</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pw</name><operator>-&gt;</operator><name>pw_uid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetUserName</name><argument_list>(<argument><expr><name><name>pw</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwname_size</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get current user name: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name><name>pw</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * make the data directory (or one of its subdirectories if subdir is not NULL)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>mkdatadir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator>
                     <operator>(</operator><ternary><condition><expr><name>subdir</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>subdir</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>subdir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_mkdir_p</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * set name of given input file variable under data directory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>dest</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>share_path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check that given input file exists
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: file \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
                    <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not access file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                    <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
                    <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: file \"%s\" is not a regular file\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
          <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * set up an empty config file so we can check config settings by launching
 * a test backend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_null_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>conf_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_gtm</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s/gtm.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s/gtm_proxy.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>conf_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>conf_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * set up all the config files
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>conflines</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>repltok</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating configuration files ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* gtm.conf/gtm_proxy.conf */</comment>

    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set options dedicated to both nodes */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"nodename = '%s'"</literal></expr></argument>, <argument><expr><name>n_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#nodename = ''"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"port = %d"</literal></expr></argument>, <argument><expr><name>n_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#port = 6666"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_gtm</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/gtm.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Set options dedicated to Proxy */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"gtm_host = '%s'"</literal></expr></argument>, <argument><expr><name>gtm_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#gtm_host = ''"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"gtm_port = %d"</literal></expr></argument>, <argument><expr><name>gtm_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#gtm_port ="</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/gtm_proxy.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__XLOG__</name></cpp:ifndef>
<comment type="block">/*
 * set up all the control file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_control</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>controlline</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_gtm</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating control file ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/gtm.control"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>controlline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_xlog</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_gtm</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating xlog dir ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>mkdatadir</name><argument_list>(<argument><expr><literal type="string">"gtm_xlog"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * signal handler in case we are interrupted.
 *
 * The Windows runtime docs at
 * http://msdn.microsoft.com/library/en-us/vclib/html/_crt_signal.asp
 * specifically forbid a number of things being done from a signal handler,
 * including IO, memory allocation and system calls, and only allow jmpbuf
 * if you are handling SIGFPE.
 *
 * I avoided doing the forbidden things by setting a flag instead of calling
 * exit_nicely() directly.
 *
 * Also note the behaviour of Windows with SIGINT, which says this:
 *     Note    SIGINT is not supported for any Win32 application, including
 *     Windows 98/Me and Windows NT/2000/XP. When a CTRL+C interrupt occurs,
 *     Win32 operating systems generate a new thread to specifically handle
 *     that interrupt. This can cause a single-thread application such as UNIX,
 *     to become multithreaded, resulting in unexpected behavior.
 *
 * I have no idea how to handle this. (Strange they call UNIX an application!)
 * So this will need some testing on Windows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>trapsig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* handle systems that reset the handler, like Windows (grr) */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>caught_signal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * call exit_nicely() if we got a signal, or else output "ok".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_ok</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>caught_signal</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"caught signal\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>output_failed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not write to child process: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>output_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* all seems well */</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ok\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<comment type="block">/*
 * Replace 'needle' with 'replacement' in 'str' . Note that the replacement
 * is done in-place, so 'replacement' must be shorter than 'needle'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>strreplace</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>needle</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>replacementlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rest</name> <init>= <expr><name>s</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>replacement</name></expr></argument>, <argument><expr><name>replacementlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <name>replacementlen</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* WIN32 */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>__CreateRestrictedToken</name>) <parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PSID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PLUID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PSID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>PHANDLE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Windows API define missing from some versions of MingW headers */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>DISABLE_MAX_PRIVILEGE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_MAX_PRIVILEGE</name></cpp:macro>    <cpp:value>0x1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Create a restricted token and execute the specified process with it.
 *
 * Returns 0 on failure, non-zero on success, same as CreateProcess().
 *
 * On NT4, or any other system not containing the required functions, will
 * NOT execute anything.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CreateRestrictedProcess</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>PROCESS_INFORMATION</name> <modifier>*</modifier></type><name>processInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BOOL</name></type>        <name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type>        <name>origToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type>        <name>restrictedToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SID_IDENTIFIER_AUTHORITY</name></type> <name>NtAuthority</name> <init>= <expr><block>{<expr><name>SECURITY_NT_AUTHORITY</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SID_AND_ATTRIBUTES</name></type> <name><name>dropSids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>__CreateRestrictedToken</name></type> <name>_CreateRestrictedToken</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type>        <name>Advapi32Handle</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><name>Advapi32Handle</name> <operator>=</operator> <call><name>LoadLibrary</name><argument_list>(<argument><expr><literal type="string">"ADVAPI32.DLL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>Advapi32Handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>_CreateRestrictedToken</name> <operator>=</operator> <operator>(</operator><name>__CreateRestrictedToken</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>, <argument><expr><literal type="string">"CreateRestrictedToken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>_CreateRestrictedToken</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WARNING: cannot create restricted tokens on this platform\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>Advapi32Handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Open the current token to use as a base for the restricted one */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OpenProcessToken</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TOKEN_ALL_ACCESS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>origToken</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to open process token: %lu\n"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Allocate list of SIDs to remove */</comment>
    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dropSids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dropSids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocateAndInitializeSid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NtAuthority</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
         <argument><expr><name>SECURITY_BUILTIN_DOMAIN_RID</name></expr></argument>, <argument><expr><name>DOMAIN_ALIAS_RID_ADMINS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>AllocateAndInitializeSid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NtAuthority</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
    <argument><expr><name>SECURITY_BUILTIN_DOMAIN_RID</name></expr></argument>, <argument><expr><name>DOMAIN_ALIAS_RID_POWER_USERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dropSids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate SIDs: %lu\n"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>_CreateRestrictedToken</name><argument_list>(<argument><expr><name>origToken</name></expr></argument>,
                               <argument><expr><name>DISABLE_MAX_PRIVILEGE</name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dropSids</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                               <argument><expr><name>dropSids</name></expr></argument>,
                               <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>restrictedToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FreeSid</name><argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeSid</name><argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>origToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to create restricted token: %lu\n"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__CYGWIN__</name></cpp:ifndef>
    <expr_stmt><expr><call><name>AddUserToTokenDacl</name><argument_list>(<argument><expr><name>restrictedToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateProcessAsUser</name><argument_list>(<argument><expr><name>restrictedToken</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>cmd</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>TRUE</name></expr></argument>,
                             <argument><expr><name>CREATE_SUSPENDED</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,
                             <argument><expr><name>processInfo</name></expr></argument>)</argument_list></call></expr>)</condition>

    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"CreateProcessAsUser failed: %lu\n"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>ResumeThread</name><argument_list>(<argument><expr><name><name>processInfo</name><operator>-&gt;</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * print help text
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s initializes GTM for a Postgres-XL database cluster.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [NODE-TYPE] [OPTION]... [DATADIR]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" [-D, --pgdata=]DATADIR     location for this GTM node\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" [-Z]NODE-TYPE              can be \"gtm\" or \"gtm_proxy\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nLess commonly used options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --debug               generate lots of debugging output\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --noclean             do not clean up after errors\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --show                show internal settings\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOther options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help                show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version             output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * options with no short version return a low integer, the rest return
     * their short version value
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{<expr><literal type="string">"pgdata"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"show"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"noclean"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
        <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>option_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>effective_user</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>bin_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pg_data_native</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>node_type_specified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"initgtm"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"initgtm (Postgres-XL) "</literal> <name>PGXC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* process command-line options */</comment>

    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"dD:nsZ:"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>
                <expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'d'</literal></expr>:</case>
                <expr_stmt><expr><name>debug</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Running in debug mode.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                <expr_stmt><expr><name>noclean</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Running in noclean mode.  Mistakes will not be cleaned up.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'s'</literal></expr>:</case>
                <expr_stmt><expr><name>show_setting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'Z'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"gtm"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>is_gtm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"gtm_proxy"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>is_gtm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>node_type_specified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <comment type="block">/* getopt_long already emitted a complaint */</comment>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <comment type="block">/* Non-option argument specifies data directory */</comment>
    <if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check on definition of GTM data folder */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no data directory specified\n"</literal>
                  <literal type="string">"You must identify the directory where the data for this GTM system\n"</literal>
                  <literal type="string">"will reside.  Do this with either the invocation option -D or the\n"</literal>
                  <literal type="string">"environment variable PGDATA.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node_type_specified</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no node type specified\n"</literal>
                  <literal type="string">"You must identify the node type chosen for initialization.\n"</literal>
                  <literal type="string">"Do this with the invocation option -Z by choosing \"gtm\" or"</literal>
                  <literal type="string">"\"gtm_proxy\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pg_data_native</name> <operator>=</operator> <name>pg_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

    <comment type="block">/*
     * Before we execute another program, make sure that we are running with a
     * restricted token. If not, re-execute ourselves with one.
     */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>restrict_env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PG_RESTRICT_EXEC"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
        <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>restrict_env</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cmdline</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>cmdline</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>GetCommandLine</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><literal type="string">"PG_RESTRICT_EXEC=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateRestrictedProcess</name><argument_list>(<argument><expr><name>cmdline</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to re-exec with restricted token: %lu.\n"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Successfully re-execed. Now wait for child process to capture
             * exitcode.
             */</comment>
            <decl_stmt><decl><type><name>DWORD</name></type>        <name>x</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetExitCodeProcess</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to get exit code from subprocess: %lu\n"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Like for initdb, check if a valid version of Postgres is running */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>find_other_exec</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>PG_BACKEND_VERSIONSTR</name></expr></argument>,
                               <argument><expr><name>backend_exec</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The program \"postgres\" is needed by %s "</literal>
                      <literal type="string">"but was not found in the\n"</literal>
                      <literal type="string">"same directory as \"%s\".\n"</literal>
                      <literal type="string">"Check your installation.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The program \"postgres\" was found by \"%s\"\n"</literal>
                      <literal type="string">"but was not the same version as %s.\n"</literal>
                      <literal type="string">"Check your installation.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* store binary directory */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>bin_path</name></expr></argument>, <argument><expr><name>backend_exec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><call><name>last_dir_separator</name><argument_list>(<argument><expr><name>bin_path</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>bin_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>share_path</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>share_path</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>get_share_path</name><argument_list>(<argument><expr><name>backend_exec</name></expr></argument>, <argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: input file location must be an absolute path\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>effective_user</name> <operator>=</operator> <call><name>get_id</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Take into account GTM and GTM-proxy cases */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_gtm</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conf_file</name></expr></argument>, <argument><expr><literal type="string">"gtm.conf.sample"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conf_file</name></expr></argument>, <argument><expr><literal type="string">"gtm_proxy.conf.sample"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>show_setting</name> <operator>||</operator> <name>debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><literal type="string">"VERSION=%s\n"</literal>
                <literal type="string">"GTMDATA=%s\nshare_path=%s\nGTMPATH=%s\n"</literal>
                <literal type="string">"GTM_CONF_SAMPLE=%s\n"</literal></expr></argument>,
                <argument><expr><name>PGXC_VERSION</name></expr></argument>,
                <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>share_path</name></expr></argument>, <argument><expr><name>bin_path</name></expr></argument>,
                <argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>show_setting</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The files belonging to this GTM system will be owned "</literal>
             <literal type="string">"by user \"%s\".\n"</literal>
             <literal type="string">"This user must also own the server process.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>effective_user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * now we are starting to do real work, trap signals so we can clean up
     */</comment>

    <comment type="block">/* some of these are not valid on Windows */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGQUIT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTERM</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Ignore SIGPIPE when writing to backend, so we can clean up */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><call><name>pg_check_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case>
            <comment type="block">/* PGDATA not there, must create it */</comment>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating directory %s ... "</literal></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mkdatadir</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>made_new_pgdata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <comment type="block">/* Present but empty, fix permissions and use it */</comment>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fixing permissions on existing directory %s ... "</literal></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>found_existing_pgdata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <comment type="block">/* Present and not empty */</comment>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: directory \"%s\" exists but is not empty\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"If you want to create a new GTM system, either remove or empty\n"</literal>
                      <literal type="string">"the directory \"%s\" or run %s\n"</literal>
                      <literal type="string">"with an argument other than \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* no further message needed */</comment>

        <default>default:</default>
            <comment type="block">/* Trouble accessing directory */</comment>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not access directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* Select suitable configuration settings */</comment>
    <expr_stmt><expr><call><name>set_null_conf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now create all the text config files */</comment>
    <expr_stmt><expr><call><name>setup_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__XLOG__</name></cpp:ifndef>
    <comment type="block">/* Now create the control file */</comment>
    <expr_stmt><expr><call><name>setup_control</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>setup_xlog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Get directory specification used to start this executable */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>bin_dir</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_parent_directory</name><argument_list>(<argument><expr><name>bin_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nSuccess.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pgxc_ctl_silent</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGXC_CTL_SILENT"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgxc_ctl_silent</name> <operator>||</operator> <operator>!</operator><call><name>strlen</name><argument_list>(<argument><expr><name>pgxc_ctl_silent</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>is_gtm</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"You can now start the GTM server using:\n\n"</literal>
                            <literal type="string">"    %s%s%sgtm%s -D %s%s%s\n"</literal>
                            <literal type="string">"or\n"</literal>
                            <literal type="string">"    %s%s%sgtm_ctl%s -Z gtm -D %s%s%s -l logfile start\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>bin_dir</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>bin_dir</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>DIR_SEP</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>pg_data_native</name></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>bin_dir</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>bin_dir</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>DIR_SEP</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>pg_data_native</name></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"You can now start the GTM proxy server using:\n\n"</literal>
                            <literal type="string">"    %s%s%sgtm_proxy%s -D %s%s%s\n"</literal>
                            <literal type="string">"or\n"</literal>
                            <literal type="string">"    %s%s%sgtm_ctl%s -Z gtm_proxy -D %s%s%s -l logfile start\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>bin_dir</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>bin_dir</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>DIR_SEP</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>pg_data_native</name></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>bin_dir</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>bin_dir</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>DIR_SEP</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>,
                        <argument><expr><name>QUOTE_PATH</name></expr></argument>, <argument><expr><name>pg_data_native</name></expr></argument>, <argument><expr><name>QUOTE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
