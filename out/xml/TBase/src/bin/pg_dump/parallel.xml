<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/pg_dump/parallel.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parallel.c
 *
 *    Parallel support for pg_dump and pg_restore
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *        src/bin/pg_dump/parallel.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Parallel operation works like this:
 *
 * The original, master process calls ParallelBackupStart(), which forks off
 * the desired number of worker processes, which each enter WaitForCommands().
 *
 * The master process dispatches an individual work item to one of the worker
 * processes in DispatchJobForTocEntry().  We send a command string such as
 * "DUMP 1234" or "RESTORE 1234", where 1234 is the TocEntry ID.
 * The worker process receives and decodes the command and passes it to the
 * routine pointed to by AH-&gt;WorkerJobDumpPtr or AH-&gt;WorkerJobRestorePtr,
 * which are routines of the current archive format.  That routine performs
 * the required action (dump or restore) and returns an integer status code.
 * This is passed back to the master where we pass it to the
 * ParallelCompletionPtr callback function that was passed to
 * DispatchJobForTocEntry().  The callback function does state updating
 * for the master control logic in pg_backup_archiver.c.
 *
 * In principle additional archive-format-specific information might be needed
 * in commands or worker status responses, but so far that hasn't proved
 * necessary, since workers have full copies of the ArchiveHandle/TocEntry
 * data structures.  Remember that we have forked off the workers only after
 * we have read in the catalog.  That's why our worker processes can also
 * access the catalog information.  (In the Windows case, the workers are
 * threads in the same process.  To avoid problems, they work with cloned
 * copies of the Archive data structure; see RunWorker().)
 *
 * In the master process, the workerStatus field for each worker has one of
 * the following values:
 *        WRKR_IDLE: it's waiting for a command
 *        WRKR_WORKING: it's working on a command
 *        WRKR_TERMINATED: process ended
 * The pstate-&gt;te[] entry for each worker is valid when it's in WRKR_WORKING
 * state, and must be NULL in other states.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>

<comment type="block">/* Mnemonic macros for indexing the fd array returned by pipe(2) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIPE_READ</name></cpp:macro>                            <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIPE_WRITE</name></cpp:macro>                            <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SLOT</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>            <comment type="block">/* Failure result for GetIdleWorker() */</comment>

<comment type="block">/* Worker process statuses */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>WRKR_IDLE</name></decl>,
    <decl><name>WRKR_WORKING</name></decl>,
    <decl><name>WRKR_TERMINATED</name></decl>
}</block></enum></type> <name>T_WorkerStatus</name>;</typedef>

<comment type="block">/*
 * Private per-parallel-worker state (typedef for this is in parallel.h).
 *
 * Much of this is valid only in the master process (or, on Windows, should
 * be touched only by the master thread).  But the AH field should be touched
 * only by workers.  The pipe descriptors are valid everywhere.
 */</comment>
<struct>struct <name>ParallelSlot</name>
<block>{
    <decl_stmt><decl><type><name>T_WorkerStatus</name></type> <name>workerStatus</name></decl>;</decl_stmt>    <comment type="block">/* see enum above */</comment>

    <comment type="block">/* These fields are valid if workerStatus == WRKR_WORKING: */</comment>
    <decl_stmt><decl><type><name>ParallelCompletionPtr</name></type> <name>callback</name></decl>;</decl_stmt> <comment type="block">/* function to call on completion */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>callback_data</name></decl>;</decl_stmt>    <comment type="block">/* passthrough data for it */</comment>

    <decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl>;</decl_stmt>            <comment type="block">/* Archive data worker is using */</comment>

    <decl_stmt><decl><type><name>int</name></type>            <name>pipeRead</name></decl>;</decl_stmt>        <comment type="block">/* master's end of the pipes */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>pipeWrite</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pipeRevRead</name></decl>;</decl_stmt>    <comment type="block">/* child's end of the pipes */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>pipeRevWrite</name></decl>;</decl_stmt>

    <comment type="block">/* Child process/thread identity info: */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uintptr_t</name></type>    <name>hThread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>threadId</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<comment type="block">/*
 * Structure to hold info passed by _beginthreadex() to the function it calls
 * via its single allowed argument.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl>;</decl_stmt>            <comment type="block">/* master database connection */</comment>
    <decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>            <comment type="block">/* this worker's parallel slot */</comment>
}</block></struct></type> <name>WorkerInfo</name>;</typedef>

<comment type="block">/* Windows implementation of pipe access */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>pgpipe</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>handles</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>piperead</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pipewrite</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>send(a,b,c,0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* !WIN32 */</comment>

<comment type="block">/* Non-Windows implementation of pipe access */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pgpipe</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>            <cpp:value>pipe(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>piperead</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>read(a,b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pipewrite</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>write(a,b,c)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * State info for archive_close_connection() shutdown callback.
 */</comment>
<typedef>typedef <type><struct>struct <name>ShutdownInformation</name>
<block>{
    <decl_stmt><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Archive</name>    <modifier>*</modifier></type><name>AHX</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShutdownInformation</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ShutdownInformation</name></type> <name>shutdown_info</name></decl>;</decl_stmt>

<comment type="block">/*
 * State info for signal handling.
 * We assume signal_info initializes to zeroes.
 *
 * On Unix, myAH is the master DB connection in the master process, and the
 * worker's own connection in worker processes.  On Windows, we have only one
 * instance of signal_info, so myAH is the master connection and the worker
 * connections must be dug out of pstate-&gt;parallelSlot[].
 */</comment>
<typedef>typedef <type><struct>struct <name>DumpSignalInformation</name>
<block>{
    <decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>myAH</name></decl>;</decl_stmt>        <comment type="block">/* database connection to issue cancel for */</comment>
    <decl_stmt><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>        <comment type="block">/* parallel state, if any */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>handler_set</name></decl>;</decl_stmt>    <comment type="block">/* signal handler set up in this process? */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>am_worker</name></decl>;</decl_stmt>        <comment type="block">/* am I a worker process? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>DumpSignalInformation</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>DumpSignalInformation</name></type> <name>signal_info</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>CRITICAL_SECTION</name></type> <name>signal_info_lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Write a simple string to stderr --- must be safe in a signal handler.
 * We ignore the write() result since there's not much we could do about it.
 * Certain compilers make that harder than it ought to be.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write_stderr</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        const char *str_ = (str); \
        int        rc_; \
        rc_ = write(fileno(stderr), str_, strlen(str_)); \
        (void) rc_; \
    } while (0)</cpp:value></cpp:define>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/* file-scope variables */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>DWORD</name></type> <name>tls_index</name></decl>;</decl_stmt>

<comment type="block">/* globally visible variables (needed by exit_nicely) */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>parallel_init_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type>        <name>mainThreadId</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modulename</name> <init>= <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"parallel archiver"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/* Local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>ParallelSlot</name> <modifier>*</modifier></type><name>GetMyPSlot</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>archive_close_connection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownWorkersHard</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitForTerminatingWorkers</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_cancel_pstate</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_cancel_slot_archive</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RunWorker</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>GetIdleWorker</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasEveryWorkerTerminated</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lockTableForWorker</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitForCommands</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ListenToWorkers</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>do_wait</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getMessageFromMaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendMessageToMaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>select_loop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxFd</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>workerset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getMessageFromWorker</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>do_wait</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendMessageToWorker</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>worker</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>readMessageFromPipe</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>messageStartsWith</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>, <parameter><type><name>prefix</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(strncmp(msg, prefix, strlen(prefix)) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>messageEquals</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(strcmp(msg, pattern) == 0)</cpp:value></cpp:define>


<comment type="block">/*
 * Shutdown callback to clean up socket access
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shutdown_parallel_dump_utils</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Call the cleanup function only from the main thread */</comment>
    <if_stmt><if>if <condition>(<expr><name>mainThreadId</name> <operator>==</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>WSACleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Initialize parallel dump support --- should be called early in process
 * startup.  (Currently, this is called whether or not we intend parallel
 * activity.)
 */</comment>
<function><type><name>void</name></type>
<name>init_parallel_dump_utils</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parallel_init_done</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WSADATA</name></type>        <name>wsaData</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>err</name></decl>;</decl_stmt>

        <comment type="block">/* Prepare for threaded operation */</comment>
        <expr_stmt><expr><name>tls_index</name> <operator>=</operator> <call><name>TlsAlloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mainThreadId</name> <operator>=</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize socket access */</comment>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsaData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WSAStartup failed: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* ... and arrange to shut it down at exit */</comment>
        <expr_stmt><expr><call><name>on_exit_nicely</name><argument_list>(<argument><expr><name>shutdown_parallel_dump_utils</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>parallel_init_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Find the ParallelSlot for the current worker process or thread.
 *
 * Returns NULL if no matching slot is found (this implies we're the master).
 */</comment>
<function><type><specifier>static</specifier> <name>ParallelSlot</name> <modifier>*</modifier></type>
<name>GetMyPSlot</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threadId</name> <operator>==</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><operator>&amp;</operator><operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A thread-local version of getLocalPQExpBuffer().
 *
 * Non-reentrant but reduces memory leakage: we'll consume one buffer per
 * thread, which is much better than one per fmtId/fmtQualifiedId call.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PQExpBuffer</name></type>
<name>getThreadLocalPQExpBuffer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * The Tls code goes awry if we use a static var, so we provide for both
     * static and auto, and omit any use of the static var when using Tls. We
     * rely on TlsGetValue() to return 0 if the value is not yet set.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PQExpBuffer</name></type> <name>s_id_return</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>id_return</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>parallel_init_done</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>id_return</name> <operator>=</operator> <operator>(</operator><name>PQExpBuffer</name><operator>)</operator> <call><name>TlsGetValue</name><argument_list>(<argument><expr><name>tls_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>id_return</name> <operator>=</operator> <name>s_id_return</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>id_return</name></expr>)</condition>                <comment type="block">/* first time through? */</comment>
    <block>{<block_content>
        <comment type="block">/* same buffer, just wipe contents */</comment>
        <expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>id_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* new buffer */</comment>
        <expr_stmt><expr><name>id_return</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>parallel_init_done</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>TlsSetValue</name><argument_list>(<argument><expr><name>tls_index</name></expr></argument>, <argument><expr><name>id_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>s_id_return</name> <operator>=</operator> <name>id_return</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>id_return</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * pg_dump and pg_restore call this to register the cleanup handler
 * as soon as they've created the ArchiveHandle.
 */</comment>
<function><type><name>void</name></type>
<name>on_exit_close_archive</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>shutdown_info</name><operator>.</operator><name>AHX</name></name> <operator>=</operator> <name>AHX</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>on_exit_nicely</name><argument_list>(<argument><expr><name>archive_close_connection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shutdown_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * on_exit_nicely handler for shutting down database connections and
 * worker processes cleanly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>archive_close_connection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ShutdownInformation</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>(</operator><name>ShutdownInformation</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>pstate</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* In parallel mode, must figure out who we are */</comment>
        <decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>GetMyPSlot</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slot</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We're the master.  Forcibly shut down workers, then close our
             * own database connection, if any.
             */</comment>
            <expr_stmt><expr><call><name>ShutdownWorkersHard</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>AHX</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>DisconnectDatabase</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>AHX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We're a worker.  Shut down our own DB connection if any.  On
             * Windows, we also have to close our communication sockets, to
             * emulate what will happen on Unix when the worker process exits.
             * (Without this, if this is a premature exit, the master would
             * fail to detect it because there would be no EOF condition on
             * the other end of the pipe.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>AH</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>DisconnectDatabase</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>AH</name><operator>-&gt;</operator><name>public</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>pipeRevRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>pipeRevWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Non-parallel operation: just kill the master DB connection */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>AHX</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>DisconnectDatabase</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>AHX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Forcibly shut down any remaining workers, waiting for them to finish.
 *
 * Note that we don't expect to come here during normal exit (the workers
 * should be long gone, and the ParallelState too).  We're only here in an
 * exit_horribly() situation, so intervening to cancel active commands is
 * appropriate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownWorkersHard</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Close our write end of the sockets so that any workers waiting for
     * commands know they can exit.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Force early termination of any commands currently in progress.
     */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <comment type="block">/* On non-Windows, send SIGTERM to each worker process. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="block">/*
     * On Windows, send query cancels directly to the workers' backends.  Use
     * a critical section to ensure worker threads don't change state.
     */</comment>
    <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>AH</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>errbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>AH</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQcancel</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Now wait for them to terminate. */</comment>
    <expr_stmt><expr><call><name>WaitForTerminatingWorkers</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for all workers to terminate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForTerminatingWorkers</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><operator>!</operator><call><name>HasEveryWorkerTerminated</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
        <comment type="block">/* On non-Windows, use wait() to wait for next worker to end */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>status</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name> <init>= <expr><call><name>wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Find dead worker's slot, and clear the PID field */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* WIN32 */</comment>
        <comment type="block">/* On Windows, we must use WaitForMultipleObjects() */</comment>
        <decl_stmt><decl><type><name>HANDLE</name>       <modifier>*</modifier></type><name>lpHandles</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nrun</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DWORD</name></type>        <name>ret</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintptr_t</name></type>    <name>hThread</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>workerStatus</name> <operator>!=</operator> <name>WRKR_TERMINATED</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>lpHandles</name><index>[<expr><name>nrun</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>hThread</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nrun</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><name>nrun</name></expr></argument>, <argument><expr><name>lpHandles</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>WAIT_FAILED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hThread</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name><name>lpHandles</name><index>[<expr><name>ret</name> <operator>-</operator> <name>WAIT_OBJECT_0</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lpHandles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Find dead worker's slot, and clear the hThread field */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>hThread</name></name> <operator>==</operator> <name>hThread</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* For cleanliness, close handles for dead threads */</comment>
                <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <name><name>slot</name><operator>-&gt;</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>hThread</name></name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>

        <comment type="block">/* On all platforms, update workerStatus and te[] as well */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>workerStatus</name></name> <operator>=</operator> <name>WRKR_TERMINATED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Code for responding to cancel interrupts (SIGINT, control-C, etc)
 *
 * This doesn't quite belong in this module, but it needs access to the
 * ParallelState data, so there's not really a better place either.
 *
 * When we get a cancel interrupt, we could just die, but in pg_restore that
 * could leave a SQL command (e.g., CREATE INDEX on a large table) running
 * for a long time.  Instead, we try to send a cancel request and then die.
 * pg_dump probably doesn't really need this, but we might as well use it
 * there too.  Note that sending the cancel directly from the signal handler
 * is safe because PQcancel() is written to make it so.
 *
 * In parallel operation on Unix, each process is responsible for canceling
 * its own connection (this must be so because nobody else has access to it).
 * Furthermore, the master process should attempt to forward its signal to
 * each child.  In simple manual use of pg_dump/pg_restore, forwarding isn't
 * needed because typing control-C at the console would deliver SIGINT to
 * every member of the terminal process group --- but in other scenarios it
 * might be that only the master gets signaled.
 *
 * On Windows, the cancel handler runs in a separate thread, because that's
 * how SetConsoleCtrlHandler works.  We make it stop worker threads, send
 * cancels on all active connections, and then return FALSE, which will allow
 * the process to die.  For safety's sake, we use a critical section to
 * protect the PGcancel structures against being changed while the signal
 * thread runs.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<comment type="block">/*
 * Signal handler (Unix only)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>errbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Some platforms allow delivery of new signals to interrupt an active
     * signal handler.  That could muck up our attempt to send PQcancel, so
     * disable the signals that setup_cancel_handler enabled.
     */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we're in the master, forward signal to all workers.  (It seems best
     * to do this before PQcancel; killing the master transaction will result
     * in invalid-snapshot errors from active workers, which maybe we can
     * quiet by killing workers first.)  Ignore any errors.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>signal_info</name><operator>.</operator><name>pstate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>signal_info</name><operator>.</operator><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name> <init>= <expr><name><name>signal_info</name><operator>.</operator><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Send QueryCancel if we have a connection to send to.  Ignore errors,
     * there's not much we can do about them anyway.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>signal_info</name><operator>.</operator><name>myAH</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>signal_info</name><operator>.</operator><name>myAH</name><operator>-&gt;</operator><name>connCancel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQcancel</name><argument_list>(<argument><expr><name><name>signal_info</name><operator>.</operator><name>myAH</name><operator>-&gt;</operator><name>connCancel</name></name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Report we're quitting, using nothing more complicated than write(2).
     * When in parallel operation, only the master process should do this.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>signal_info</name><operator>.</operator><name>am_worker</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>progname</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"terminated by user\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* And die. */</comment>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enable cancel interrupt handler, if not already done.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * When forking, signal_info.handler_set will propagate into the new
     * process, but that's fine because the signal handler state does too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>signal_info</name><operator>.</operator><name>handler_set</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>signal_info</name><operator>.</operator><name>handler_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>sigTermHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>sigTermHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>sigTermHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * Console interrupt handler --- runs in a newly-started thread.
 *
 * After stopping other threads and sending cancel requests on all open
 * connections, we return FALSE which will allow the default ExitProcess()
 * action to be taken.
 */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>consoleHandler</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>dwCtrlType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>errbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dwCtrlType</name> <operator>==</operator> <name>CTRL_C_EVENT</name> <operator>||</operator>
        <name>dwCtrlType</name> <operator>==</operator> <name>CTRL_BREAK_EVENT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Critical section prevents changing data we look at here */</comment>
        <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If in parallel mode, stop worker threads and send QueryCancel to
         * their connected backends.  The main point of stopping the worker
         * threads is to keep them from reporting the query cancels as errors,
         * which would clutter the user's screen.  We needn't stop the master
         * thread since it won't be doing much anyway.  Do this before
         * canceling the main transaction, else we might get invalid-snapshot
         * errors reported before we can stop the workers.  Ignore errors,
         * there's not much we can do about them anyway.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>signal_info</name><operator>.</operator><name>pstate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>signal_info</name><operator>.</operator><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>signal_info</name><operator>.</operator><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>AH</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>HANDLE</name></type>        <name>hThread</name> <init>= <expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <name><name>slot</name><operator>-&gt;</operator><name>hThread</name></name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Using TerminateThread here may leave some resources leaked,
                 * but it doesn't matter since we're about to end the whole
                 * process.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>hThread</name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>TerminateThread</name><argument_list>(<argument><expr><name>hThread</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>AH</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQcancel</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Send QueryCancel to master connection, if enabled.  Ignore errors,
         * there's not much we can do about them anyway.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>signal_info</name><operator>.</operator><name>myAH</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>signal_info</name><operator>.</operator><name>myAH</name><operator>-&gt;</operator><name>connCancel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQcancel</name><argument_list>(<argument><expr><name><name>signal_info</name><operator>.</operator><name>myAH</name><operator>-&gt;</operator><name>connCancel</name></name></expr></argument>,
                            <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Report we're quitting, using nothing more complicated than
         * write(2).  (We might be able to get away with using write_msg()
         * here, but since we terminated other threads uncleanly above, it
         * seems better to assume as little as possible.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>progname</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"terminated by user\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Always return FALSE to allow signal handling to continue */</comment>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Enable cancel interrupt handler, if not already done.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>signal_info</name><operator>.</operator><name>handler_set</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>signal_info</name><operator>.</operator><name>handler_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SetConsoleCtrlHandler</name><argument_list>(<argument><expr><name>consoleHandler</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>


<comment type="block">/*
 * set_archive_cancel_info
 *
 * Fill AH-&gt;connCancel with cancellation info for the specified database
 * connection; or clear it if conn is NULL.
 */</comment>
<function><type><name>void</name></type>
<name>set_archive_cancel_info</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>oldConnCancel</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Activate the interrupt handler if we didn't yet in this process.  On
     * Windows, this also initializes signal_info_lock; therefore it's
     * important that this happen at least once before we fork off any
     * threads.
     */</comment>
    <expr_stmt><expr><call><name>setup_cancel_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * On Unix, we assume that storing a pointer value is atomic with respect
     * to any possible signal interrupt.  On Windows, use a critical section.
     */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Free the old one if we have one */</comment>
    <expr_stmt><expr><name>oldConnCancel</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name></expr>;</expr_stmt>
    <comment type="block">/* be sure interrupt handler doesn't use pointer while freeing */</comment>
    <expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>oldConnCancel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>oldConnCancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Set the new one if specified */</comment>
    <if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name> <operator>=</operator> <call><name>PQgetCancel</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * On Unix, there's only ever one active ArchiveHandle per process, so we
     * can just set signal_info.myAH unconditionally.  On Windows, do that
     * only in the main thread; worker threads have to make sure their
     * ArchiveHandle appears in the pstate data, which is dealt with in
     * RunWorker().
     */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <expr_stmt><expr><name><name>signal_info</name><operator>.</operator><name>myAH</name></name> <operator>=</operator> <name>AH</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>mainThreadId</name> <operator>==</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>signal_info</name><operator>.</operator><name>myAH</name></name> <operator>=</operator> <name>AH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * set_cancel_pstate
 *
 * Set signal_info.pstate to point to the specified ParallelState, if any.
 * We need this mainly to have an interlock against Windows signal thread.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_cancel_pstate</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>signal_info</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * set_cancel_slot_archive
 *
 * Set ParallelSlot's AH field to point to the specified archive, if any.
 * We need this mainly to have an interlock against Windows signal thread.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_cancel_slot_archive</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>AH</name></name> <operator>=</operator> <name>AH</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signal_info_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * This function is called by both Unix and Windows variants to set up
 * and run a worker process.  Caller should exit the process (or thread)
 * upon return.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RunWorker</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* fetch child ends of pipes */</comment>
    <expr_stmt><expr><name><name>pipefd</name><index>[<expr><name>PIPE_READ</name></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>pipeRevRead</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pipefd</name><index>[<expr><name>PIPE_WRITE</name></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>pipeRevWrite</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Clone the archive so that we have our own state to work with, and in
     * particular our own database connection.
     *
     * We clone on Unix as well as Windows, even though technically we don't
     * need to because fork() gives us a copy in our own address space
     * already.  But CloneArchive resets the state information and also clones
     * the database connection which both seem kinda helpful.
     */</comment>
    <expr_stmt><expr><name>AH</name> <operator>=</operator> <call><name>CloneArchive</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remember cloned archive where signal handler can find it */</comment>
    <expr_stmt><expr><call><name>set_cancel_slot_archive</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Call the setup worker function that's defined in the ArchiveHandle.
     */</comment>
    <expr_stmt><expr><operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>SetupWorkerPtr</name></name><operator>)</operator> <operator>(</operator><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Execute commands until done.
     */</comment>
    <expr_stmt><expr><call><name>WaitForCommands</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pipefd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Disconnect from database and clean up.
     */</comment>
    <expr_stmt><expr><call><name>set_cancel_slot_archive</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DisconnectDatabase</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DeCloneArchive</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Thread base function for Windows
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>__stdcall</name></type>
<name>init_spawned_worker_win32</name><parameter_list>(<parameter><decl><type><name>WorkerInfo</name> <modifier>*</modifier></type><name>wi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><name><name>wi</name><operator>-&gt;</operator><name>AH</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>wi</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Don't need WorkerInfo anymore */</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Run the worker ... */</comment>
    <expr_stmt><expr><call><name>RunWorker</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Exit the thread */</comment>
    <expr_stmt><expr><call><name>_endthreadex</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * This function starts a parallel dump or restore by spawning off the worker
 * processes.  For Windows, it creates a number of threads; on Unix the
 * workers are created with fork().
 */</comment>
<function><type><name>ParallelState</name> <modifier>*</modifier></type>
<name>ParallelBackupStart</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>numWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <operator>(</operator><name>ParallelState</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>numWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>numWorkers</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>pstate</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name></name> <operator>=</operator> <operator>(</operator><name>TocEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>pg_malloc0</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name></name> <operator>=</operator> <operator>(</operator><name>ParallelSlot</name> <operator>*</operator><operator>)</operator>
        <call><name>pg_malloc0</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="block">/* Make fmtId() and fmtQualifiedId() use thread-local storage */</comment>
    <expr_stmt><expr><name>getLocalPQExpBuffer</name> <operator>=</operator> <name>getThreadLocalPQExpBuffer</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Set the pstate in shutdown_info, to tell the exit handler that it must
     * clean up workers as well as the main database connection.  But we don't
     * set this in signal_info yet, because we don't want child processes to
     * inherit non-NULL signal_info.pstate.
     */</comment>
    <expr_stmt><expr><name><name>shutdown_info</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Temporarily disable query cancellation on the master connection.  This
     * ensures that child processes won't inherit valid AH-&gt;connCancel
     * settings and thus won't try to issue cancels against the master's
     * connection.  No harm is done if we fail while it's disabled, because
     * the master connection is idle at this point anyway.
     */</comment>
    <expr_stmt><expr><call><name>set_archive_cancel_info</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Ensure stdio state is quiesced before forking */</comment>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create desired number of workers */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <decl_stmt><decl><type><name>WorkerInfo</name> <modifier>*</modifier></type><name>wi</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintptr_t</name></type>    <name>handle</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name><name>pipeMW</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>pipeWM</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* Create communication pipes for this worker */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgpipe</name><argument_list>(<argument><expr><name>pipeMW</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>pgpipe</name><argument_list>(<argument><expr><name>pipeWM</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                          <argument><expr><literal type="string">"could not create communication channels: %s\n"</literal></expr></argument>,
                          <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* just for safety */</comment>

        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>workerStatus</name></name> <operator>=</operator> <name>WRKR_IDLE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>AH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>callback_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* master's ends of the pipes */</comment>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pipeRead</name></name> <operator>=</operator> <name><name>pipeWM</name><index>[<expr><name>PIPE_READ</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pipeWrite</name></name> <operator>=</operator> <name><name>pipeMW</name><index>[<expr><name>PIPE_WRITE</name></expr>]</index></name></expr>;</expr_stmt>
        <comment type="block">/* child's ends of the pipes */</comment>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pipeRevRead</name></name> <operator>=</operator> <name><name>pipeMW</name><index>[<expr><name>PIPE_READ</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pipeRevWrite</name></name> <operator>=</operator> <name><name>pipeWM</name><index>[<expr><name>PIPE_WRITE</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <comment type="block">/* Create transient structure to pass args to worker function */</comment>
        <expr_stmt><expr><name>wi</name> <operator>=</operator> <operator>(</operator><name>WorkerInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>wi</name><operator>-&gt;</operator><name>AH</name></name> <operator>=</operator> <name>AH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>wi</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>init_spawned_worker_win32</name></expr></argument>,
                                <argument><expr><name>wi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>threadId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>hThread</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* !WIN32 */</comment>
        <expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we are the worker */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

            <comment type="block">/* this is needed for GetMyPSlot() */</comment>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* instruct signal handler that we're in a worker now */</comment>
            <expr_stmt><expr><name><name>signal_info</name><operator>.</operator><name>am_worker</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/* close read end of Worker -&gt; Master */</comment>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pipeWM</name><index>[<expr><name>PIPE_READ</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* close write end of Master -&gt; Worker */</comment>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pipeMW</name><index>[<expr><name>PIPE_WRITE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Close all inherited fds for communication of the master with
             * previously-forked workers.
             */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pipeRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pipeWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="block">/* Run the worker ... */</comment>
            <expr_stmt><expr><call><name>RunWorker</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* We can just exit(0) when done */</comment>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* fork failed */</comment>
            <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                          <argument><expr><literal type="string">"could not create worker process: %s\n"</literal></expr></argument>,
                          <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* In Master after successful fork */</comment>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>

        <comment type="block">/* close read end of Master -&gt; Worker */</comment>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pipeMW</name><index>[<expr><name>PIPE_READ</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* close write end of Worker -&gt; Master */</comment>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pipeWM</name><index>[<expr><name>PIPE_WRITE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>
    </block_content>}</block></for>

    <comment type="block">/*
     * Having forked off the workers, disable SIGPIPE so that master isn't
     * killed if it tries to send a command to a dead worker.  We don't want
     * the workers to inherit this setting, though.
     */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Re-establish query cancellation on the master connection.
     */</comment>
    <expr_stmt><expr><call><name>set_archive_cancel_info</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Tell the cancel signal handler to forward signals to worker processes,
     * too.  (As with query cancel, we did not need this earlier because the
     * workers have not yet been given anything to do; if we die before this
     * point, any already-started workers will see EOF and quit promptly.)
     */</comment>
    <expr_stmt><expr><call><name>set_cancel_pstate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close down a parallel dump or restore.
 */</comment>
<function><type><name>void</name></type>
<name>ParallelBackupEnd</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* No work if non-parallel */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* There should not be any unfinished jobs */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsEveryWorkerIdle</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Close the sockets so that the workers know they can exit */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Wait for them to exit */</comment>
    <expr_stmt><expr><call><name>WaitForTerminatingWorkers</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Unlink pstate from shutdown_info, so the exit handler will not try to
     * use it; and likewise unlink from signal_info.
     */</comment>
    <expr_stmt><expr><name><name>shutdown_info</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_cancel_pstate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release state (mere neatnik-ism, since we're about to terminate) */</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * These next four functions handle construction and parsing of the command
 * strings and response strings for parallel workers.
 *
 * Currently, these can be the same regardless of which archive format we are
 * processing.  In future, we might want to let format modules override these
 * functions to add format-specific data to a command or response.
 */</comment>

<comment type="block">/*
 * buildWorkerCommand: format a command string to send to a worker.
 *
 * The string is built in the caller-supplied buffer of size buflen.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buildWorkerCommand</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>T_Action</name></type> <name>act</name></decl></parameter>,
                   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>ACT_DUMP</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"DUMP %d"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>act</name> <operator>==</operator> <name>ACT_RESTORE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"RESTORE %d"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * parseWorkerCommand: interpret a command string in a worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseWorkerCommand</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>T_Action</name> <modifier>*</modifier></type><name>act</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DumpId</name></type>        <name>dumpId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nBytes</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>messageStartsWith</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"DUMP "</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>act</name> <operator>=</operator> <name>ACT_DUMP</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"DUMP %d%n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dumpId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nBytes</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>te</name> <operator>=</operator> <call><name>getTocEntryByDumpId</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>te</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>messageStartsWith</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"RESTORE "</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>act</name> <operator>=</operator> <name>ACT_RESTORE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"RESTORE %d%n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dumpId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nBytes</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>te</name> <operator>=</operator> <call><name>getTocEntryByDumpId</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>te</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                      <argument><expr><literal type="string">"unrecognized command received from master: \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * buildWorkerResponse: format a response string to send to the master.
 *
 * The string is built in the caller-supplied buffer of size buflen.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buildWorkerResponse</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>T_Action</name></type> <name>act</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>,
                    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"OK %d %d %d"</literal></expr></argument>,
             <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
             <argument><expr><name>status</name></expr></argument>,
             <argument><expr><ternary><condition><expr><name>status</name> <operator>==</operator> <name>WORKER_IGNORED_ERRORS</name></expr> ?</condition><then> <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * parseWorkerResponse: parse the status message returned by a worker.
 *
 * Returns the integer status code, and may update fields of AH and/or te.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parseWorkerResponse</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DumpId</name></type>        <name>dumpId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nBytes</name></decl>,
                <decl><type ref="prev"/><name>n_errors</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>status</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>messageStartsWith</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"OK "</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"OK %d %d %d%n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dumpId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_errors</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dumpId</name> <operator>==</operator> <name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nBytes</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name> <operator>+=</operator> <name>n_errors</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                      <argument><expr><literal type="string">"invalid message received from worker: \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Dispatch a job to some free worker.
 *
 * te is the TocEntry to be processed, act is the action to be taken on it.
 * callback is the function to call on completion of the job.
 *
 * If no worker is currently available, this will block, and previously
 * registered callback functions may be called.
 */</comment>
<function><type><name>void</name></type>
<name>DispatchJobForTocEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
                       <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                       <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
                       <parameter><decl><type><name>T_Action</name></type> <name>act</name></decl></parameter>,
                       <parameter><decl><type><name>ParallelCompletionPtr</name></type> <name>callback</name></decl></parameter>,
                       <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>worker</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Get a worker, waiting if none are idle */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>worker</name> <operator>=</operator> <call><name>GetIdleWorker</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NO_SLOT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>WaitForWorkers</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>WFW_ONE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* Construct and send command string */</comment>
    <expr_stmt><expr><call><name>buildWorkerCommand</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>act</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sendMessageToWorker</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>worker</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remember worker is busy, and which TocEntry it's working on */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>worker</name></expr>]</index></name><operator>.</operator><name>workerStatus</name> <operator>=</operator> <name>WRKR_WORKING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>worker</name></expr>]</index></name><operator>.</operator><name>callback</name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>worker</name></expr>]</index></name><operator>.</operator><name>callback_data</name> <operator>=</operator> <name>callback_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name><index>[<expr><name>worker</name></expr>]</index></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find an idle worker and return its slot number.
 * Return NO_SLOT if none are idle.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetIdleWorker</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>workerStatus</name> <operator>==</operator> <name>WRKR_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NO_SLOT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true iff every worker is in the WRKR_TERMINATED state.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasEveryWorkerTerminated</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>workerStatus</name> <operator>!=</operator> <name>WRKR_TERMINATED</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true iff every worker is in the WRKR_IDLE state.
 */</comment>
<function><type><name>bool</name></type>
<name>IsEveryWorkerIdle</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>workerStatus</name> <operator>!=</operator> <name>WRKR_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire lock on a table to be dumped by a worker process.
 *
 * The master process is already holding an ACCESS SHARE lock.  Ordinarily
 * it's no problem for a worker to get one too, but if anything else besides
 * pg_dump is running, there's a possible deadlock:
 *
 * 1) Master dumps the schema and locks all tables in ACCESS SHARE mode.
 * 2) Another process requests an ACCESS EXCLUSIVE lock (which is not granted
 *      because the master holds a conflicting ACCESS SHARE lock).
 * 3) A worker process also requests an ACCESS SHARE lock to read the table.
 *      The worker is enqueued behind the ACCESS EXCLUSIVE lock request.
 * 4) Now we have a deadlock, since the master is effectively waiting for
 *      the worker.  The server cannot detect that, however.
 *
 * To prevent an infinite wait, prior to touching a table in a worker, request
 * a lock in ACCESS SHARE mode but with NOWAIT.  If we don't get the lock,
 * then we know that somebody else has requested an ACCESS EXCLUSIVE lock and
 * so we have a deadlock.  We must fail the backup in that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lockTableForWorker</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qualId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <comment type="block">/* Nothing to do for BLOBS */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>qualId</name> <operator>=</operator> <call><name>fmtQualifiedId</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>remoteVersion</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE %s IN ACCESS SHARE MODE NOWAIT"</literal></expr></argument>,
                      <argument><expr><name>qualId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                      <argument><expr><literal type="string">"could not obtain lock on relation \"%s\"\n"</literal>
                      <literal type="string">"This usually means that someone requested an ACCESS EXCLUSIVE lock "</literal>
                      <literal type="string">"on the table after the pg_dump parent process had gotten the "</literal>
                      <literal type="string">"initial ACCESS SHARE lock on the table.\n"</literal></expr></argument>, <argument><expr><name>qualId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WaitForCommands: main routine for a worker process.
 *
 * Read and execute commands from the master until we see EOF on the pipe.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForCommands</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>T_Action</name></type>    <name>act</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>status</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>command</name> <operator>=</operator> <call><name>getMessageFromMaster</name><argument_list>(<argument><expr><name>pipefd</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* EOF, so done */</comment>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Decode the command */</comment>
        <expr_stmt><expr><call><name>parseWorkerCommand</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>te</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>ACT_DUMP</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Acquire lock on this table within the worker's session */</comment>
            <expr_stmt><expr><call><name>lockTableForWorker</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Perform the dump command */</comment>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>WorkerJobDumpPtr</name></name><operator>)</operator> <operator>(</operator><name>AH</name><operator>,</operator> <name>te</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>act</name> <operator>==</operator> <name>ACT_RESTORE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Perform the restore command */</comment>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>WorkerJobRestorePtr</name></name><operator>)</operator> <operator>(</operator><name>AH</name><operator>,</operator> <name>te</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Return status to master */</comment>
        <expr_stmt><expr><call><name>buildWorkerResponse</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>act</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sendMessageToMaster</name><argument_list>(<argument><expr><name>pipefd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* command was pg_malloc'd and we are responsible for free()ing it. */</comment>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check for status messages from workers.
 *
 * If do_wait is true, wait to get a status message; otherwise, just return
 * immediately if there is none available.
 *
 * When we get a status message, we pass the status code to the callback
 * function that was specified to DispatchJobForTocEntry, then reset the
 * worker status to IDLE.
 *
 * Returns true if we collected a status message, else false.
 *
 * XXX is it worth checking for more than one status message per call?
 * It seems somewhat unlikely that multiple workers would finish at exactly
 * the same time.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ListenToWorkers</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_wait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>worker</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

    <comment type="block">/* Try to collect a status message */</comment>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>getMessageFromWorker</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>do_wait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>msg</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If do_wait is true, we must have detected EOF on some socket */</comment>
        <if_stmt><if>if <condition>(<expr><name>do_wait</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"a worker process died unexpectedly\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process it and update our idea of the worker's status */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>messageStartsWith</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"OK "</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>worker</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name><index>[<expr><name>worker</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>status</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>parseWorkerResponse</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>slot</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>callback_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>workerStatus</name></name> <operator>=</operator> <name>WRKR_IDLE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name><index>[<expr><name>worker</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                      <argument><expr><literal type="string">"invalid message received from worker: \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Free the string returned from getMessageFromWorker */</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for status results from workers, waiting if necessary.
 *
 * Available wait modes are:
 * WFW_NO_WAIT: reap any available status, but don't block
 * WFW_GOT_STATUS: wait for at least one more worker to finish
 * WFW_ONE_IDLE: wait for at least one worker to be idle
 * WFW_ALL_IDLE: wait for all workers to be idle
 *
 * Any received results are passed to the callback specified to
 * DispatchJobForTocEntry.
 *
 * This function is executed in the master process.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForWorkers</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>WFW_WaitOption</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>do_wait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * In GOT_STATUS mode, always block waiting for a message, since we can't
     * return till we get something.  In other modes, we don't block the first
     * time through the loop.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>WFW_GOT_STATUS</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Assert that caller knows what it's doing */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsEveryWorkerIdle</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>do_wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Check for status messages, even if we don't need to block.  We do
         * not try very hard to reap all available messages, though, since
         * there's unlikely to be more than one.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ListenToWorkers</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>do_wait</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we got a message, we are done by definition for GOT_STATUS
             * mode, and we can also be certain that there's at least one idle
             * worker.  So we're done in all but ALL_IDLE mode.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>WFW_ALL_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check whether we must wait for new status messages */</comment>
        <switch>switch <condition>(<expr><name>mode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>WFW_NO_WAIT</name></expr>:</case>
                <return>return;</return>            <comment type="block">/* never wait */</comment>
            <case>case <expr><name>WFW_GOT_STATUS</name></expr>:</case>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* can't get here, because we waited */</comment>
                <break>break;</break>
            <case>case <expr><name>WFW_ONE_IDLE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>GetIdleWorker</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NO_SLOT</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>WFW_ALL_IDLE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>IsEveryWorkerIdle</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/* Loop back, and this time wait for something to happen */</comment>
        <expr_stmt><expr><name>do_wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Read one command message from the master, blocking if necessary
 * until one is available, and return it as a malloc'd string.
 * On EOF, return NULL.
 *
 * This function is executed in worker processes.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getMessageFromMaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>readMessageFromPipe</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><name>PIPE_READ</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a status message to the master.
 *
 * This function is executed in worker processes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendMessageToMaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pipewrite</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><name>PIPE_WRITE</name></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                      <argument><expr><literal type="string">"could not write to the communication channel: %s\n"</literal></expr></argument>,
                      <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until some descriptor in "workerset" becomes readable.
 * Returns -1 on error, else the number of readable descriptors.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>select_loop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxFd</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>workerset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>saveSet</name> <init>= <expr><operator>*</operator><name>workerset</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>workerset</name> <operator>=</operator> <name>saveSet</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxFd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>workerset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator> <call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>WSAEINTR</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>
    </block_content>}</block></for>

    <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check for messages from worker processes.
 *
 * If a message is available, return it as a malloc'd string, and put the
 * index of the sending worker in *worker.
 *
 * If nothing is available, wait if "do_wait" is true, else return NULL.
 *
 * If we detect EOF on any socket, we'll return NULL.  It's not great that
 * that's hard to distinguish from the no-data-available case, but for now
 * our one caller is okay with that.
 *
 * This function is executed in the master process.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getMessageFromWorker</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_wait</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>workerset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxFd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>nowait</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* construct bitmap of socket descriptors for select() */</comment>
    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workerset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>workerStatus</name> <operator>==</operator> <name>WRKR_TERMINATED</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeRead</name> <operator>&gt;</operator> <name>maxFd</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>maxFd</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeRead</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>do_wait</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>select_loop</name><argument_list>(<argument><expr><name>maxFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxFd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nowait</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"select() failed: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Read the message if any.  If the socket is ready because of EOF,
         * we'll return NULL instead (and the socket will stay ready, so the
         * condition will persist).
         *
         * Note: because this is a blocking read, we'll wait if only part of
         * the message is available.  Waiting a long time would be bad, but
         * since worker status messages are short and are always sent in one
         * operation, it shouldn't be a problem in practice.
         */</comment>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>readMessageFromPipe</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pipeRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>worker</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <return>return <expr><name>msg</name></expr>;</return>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a command message to the specified worker process.
 *
 * This function is executed in the master process.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendMessageToWorker</name><parameter_list>(<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pipewrite</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>parallelSlot</name><index>[<expr><name>worker</name></expr>]</index></name><operator>.</operator><name>pipeWrite</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>,
                      <argument><expr><literal type="string">"could not write to the communication channel: %s\n"</literal></expr></argument>,
                      <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read one message from the specified pipe (fd), blocking if necessary
 * until one is available, and return it as a malloc'd string.
 * On EOF, return NULL.
 *
 * A "message" on the channel is just a null-terminated string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>readMessageFromPipe</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgsize</name></decl>,
                <decl><type ref="prev"/><name>bufsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name></decl>;</decl_stmt>

    <comment type="block">/*
     * In theory, if we let piperead() read multiple bytes, it might give us
     * back fragments of multiple messages.  (That can't actually occur, since
     * neither master nor workers send more than one message without waiting
     * for a reply, but we don't wish to assume that here.)  For simplicity,
     * read a byte at a time until we get the terminating '\0'.  This method
     * is a bit inefficient, but since this is only used for relatively short
     * command and status strings, it shouldn't matter.
     */</comment>
    <expr_stmt><expr><name>bufsize</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>                <comment type="block">/* could be any number */</comment>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>msgsize</name> <operator>&lt;</operator> <name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>piperead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>msg</name> <operator>+</operator> <name>msgsize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* error or connection closure */</comment>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>msg</name><index>[<expr><name>msgsize</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>msg</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* collected whole message */</comment>

        <expr_stmt><expr><name>msgsize</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>msgsize</name> <operator>==</operator> <name>bufsize</name></expr>)</condition> <comment type="block">/* enlarge buffer if needed */</comment>
        <block>{<block_content>
            <expr_stmt><expr><name>bufsize</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>        <comment type="block">/* could be any number */</comment>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Other end has closed the connection */</comment>
    <expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<comment type="block">/*
 * This is a replacement version of pipe(2) for Windows which allows the pipe
 * handles to be used in select().
 *
 * Reads and writes on the pipe must go through piperead()/pipewrite().
 *
 * For consistency with Unix we declare the returned handles as "int".
 * This is okay even on WIN64 because system handles are not more than
 * 32 bits wide, but we do have to do some casting.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgpipe</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>handles</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>pgsocket</name></type>    <name>s</name></decl>,
                <decl><type ref="prev"/><name>tmp_sock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name></type> <name>serv_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>serv_addr</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We have to use the Unix socket invalid file descriptor value here. */</comment>
    <expr_stmt><expr><name><name>handles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>handles</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * setup listen socket
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"pgpipe: could not create socket: error code %d\n"</literal></expr></argument>,
                  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>serv_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>serv_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serv_addr</name><operator>.</operator><name>sin_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serv_addr</name><operator>.</operator><name>sin_port</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serv_addr</name><operator>.</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>INADDR_LOOPBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>SOCKADDR</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>serv_addr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"pgpipe: could not bind: error code %d\n"</literal></expr></argument>,
                  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>listen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"pgpipe: could not listen: error code %d\n"</literal></expr></argument>,
                  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>SOCKADDR</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>serv_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"pgpipe: getsockname() failed: error code %d\n"</literal></expr></argument>,
                  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * setup pipe handles
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp_sock</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"pgpipe: could not create second socket: error code %d\n"</literal></expr></argument>,
                  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handles</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>tmp_sock</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>connect</name><argument_list>(<argument><expr><name><name>handles</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SOCKADDR</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>serv_addr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"pgpipe: could not connect socket: error code %d\n"</literal></expr></argument>,
                  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>handles</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handles</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp_sock</name> <operator>=</operator> <call><name>accept</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>SOCKADDR</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>serv_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"pgpipe: could not accept connection: error code %d\n"</literal></expr></argument>,
                  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>handles</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handles</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>tmp_sock</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Windows implementation of reading from a pipe.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>piperead</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name> <init>= <expr><call><name>recv</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>WSAECONNRESET</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* EOF on the pipe! */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>
</unit>
