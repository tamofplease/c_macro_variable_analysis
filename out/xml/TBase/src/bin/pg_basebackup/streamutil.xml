<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/pg_basebackup/streamutil.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * streamutil.c - utility functions for pg_basebackup, pg_receivewal and
 *                     pg_recvlogical
 *
 * Author: Magnus Hagander &lt;magnus@hagander.net&gt;
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *          src/bin/pg_basebackup/streamutil.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<comment type="block">/* for ntohl/htonl */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>

<comment type="block">/* local includes */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"receivelog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"streamutil.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/fe_memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatype/timestamp.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_DUPLICATE_OBJECT</name></cpp:macro>  <cpp:value>"42710"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>connection_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dbhost</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dbuser</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dbport</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>dbgetpassword</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* 0=auto, -1=never, 1=always */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>have_password</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>password</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Connect to the server. Returns a valid PGconn pointer if connected,
 * or NULL on non-permanent error. On permanent error, the function will
 * call exit(1) directly.
 */</comment>
<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>GetConnection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>tmpconn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>argcount</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* dbname, replication, fallback_app_name,
                                 * host, user, port, password */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_password</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>conn_opts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>conn_opt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* pg_recvlogical uses dbname only; others use connection_string only. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dbname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>connection_string</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Merge the connection info inputs given in form of connection string,
     * options and default values (dbname=replication, replication=true, etc.)
     * Explicitly discard any dbname value in the connection string;
     * otherwise, PQconnectdbParams() would interpret that value as being
     * itself a connection string.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>connection_string</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>conn_opts</name> <operator>=</operator> <call><name>PQconninfoParse</name><argument_list>(<argument><expr><name>connection_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>conn_opts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><expr><name>conn_opt</name> <operator>=</operator> <name>conn_opts</name></expr>;</init> <condition><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>conn_opt</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>conn_opt</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn_opt</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>argcount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>keywords</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>argcount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>keywords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>argcount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>conn_opt</name> <operator>=</operator> <name>conn_opts</name></expr>;</init> <condition><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>conn_opt</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>conn_opt</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn_opt</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>conn_opt</name><operator>-&gt;</operator><name>keyword</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>conn_opt</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>keywords</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>argcount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>keywords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>argcount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"replication"</literal></expr> </then><else>: <expr><name>dbname</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"replication"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"database"</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>progname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dbhost</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dbhost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbuser</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dbuser</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbport</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dbport</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If -W was given, force prompt for password, but only the first time */</comment>
    <expr_stmt><expr><name>need_password</name> <operator>=</operator> <operator>(</operator><name>dbgetpassword</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>have_password</name><operator>)</operator></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
        <comment type="block">/* Get a new password if appropriate */</comment>
        <if_stmt><if>if <condition>(<expr><name>need_password</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>have_password</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_password</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Use (or reuse, on a subsequent connection) password if we have it */</comment>
        <if_stmt><if>if <condition>(<expr><name>have_password</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"password"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>password</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>tmpconn</name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If there is too little memory even to allocate the PGconn object
         * and PQconnectdbParams returns NULL, we call exit(1) directly.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpconn</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not connect to server\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we need a password and -w wasn't given, loop back and get one */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name> <operator>&amp;&amp;</operator>
            <call><name>PQconnectionNeedsPassword</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name>dbgetpassword</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_password</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><name>need_password</name></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not connect to server: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>conn_opts</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>conn_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Connection ok! */</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>conn_opts</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>conn_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Ensure we have the same value of integer_datetimes (now always "on") as
     * the server we are connecting to.
     */</comment>
    <expr_stmt><expr><name>tmpparam</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>, <argument><expr><literal type="string">"integer_datetimes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpparam</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not determine server setting for integer_datetimes\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tmpparam</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: integer_datetimes compile flag does not match server\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>tmpconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>tmpconn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Run IDENTIFY_SYSTEM through a given connection and give back to caller
 * some result information if requested:
 * - System identifier
 * - Current timeline ID
 * - Start LSN position
 * - Database name (NULL in servers prior to 9.4)
 */</comment>
<function><type><name>bool</name></type>
<name>RunIdentifySystem</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sysid</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>starttli</name></decl></parameter>,
                  <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>startpos</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>db_name</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hi</name></decl>,
                <decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>

    <comment type="block">/* Check connection existence */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"IDENTIFY_SYSTEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"IDENTIFY_SYSTEM"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get system identifier */</comment>
    <if_stmt><if>if <condition>(<expr><name>sysid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sysid</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get timeline ID to start streaming from */</comment>
    <if_stmt><if>if <condition>(<expr><name>starttli</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>starttli</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get LSN start position if necessary */</comment>
    <if_stmt><if>if <condition>(<expr><name>startpos</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse write-ahead log location \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>startpos</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get database name, only available in 9.4 and newer versions */</comment>
    <if_stmt><if>if <condition>(<expr><name>db_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>db_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>db_name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a replication slot for the given connection. This function
 * returns true in case of success.
 */</comment>
<function><type><name>bool</name></type>
<name>CreateReplicationSlot</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slot_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plugin</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>is_physical</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slot_exists_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>is_physical</name> <operator>&amp;&amp;</operator> <name>plugin</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
           <operator>(</operator><operator>!</operator><name>is_physical</name> <operator>&amp;&amp;</operator> <name>plugin</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot_name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build query */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_physical</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE_REPLICATION_SLOT \"%s\" PHYSICAL"</literal></expr></argument>,
                          <argument><expr><name>slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE_REPLICATION_SLOT \"%s\" LOGICAL \"%s\""</literal></expr></argument>,
                          <argument><expr><name>slot_name</name></expr></argument>, <argument><expr><name>plugin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* pg_recvlogical doesn't use an exported snapshot, so suppress */</comment>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" NOEXPORT_SNAPSHOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>slot_exists_ok</name> <operator>&amp;&amp;</operator>
            <name>sqlstate</name> <operator>&amp;&amp;</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>, <argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create replication slot \"%s\": got %d rows and %d fields, expected %d rows and %d fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>slot_name</name></expr></argument>,
                <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop a replication slot for the given connection. This function
 * returns true in case of success.
 */</comment>
<function><type><name>bool</name></type>
<name>DropReplicationSlot</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slot_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot_name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build query */</comment>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DROP_REPLICATION_SLOT \"%s\""</literal></expr></argument>,
                      <argument><expr><name>slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not drop replication slot \"%s\": got %d rows and %d fields, expected %d rows and %d fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>slot_name</name></expr></argument>,
                <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Frontend version of GetCurrentTimestamp(), since we are not linked with
 * backend code.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>feGetCurrentTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimestampTz</name><operator>)</operator> <name><name>tp</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator>
        <operator>(</operator><operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name><name>tp</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Frontend version of TimestampDifference(), since we are not linked with
 * backend code.
 */</comment>
<function><type><name>void</name></type>
<name>feTimestampDifference</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stop_time</name></decl></parameter>,
                      <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>secs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>microsecs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>diff</name> <init>= <expr><name>stop_time</name> <operator>-</operator> <name>start_time</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>secs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>microsecs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>secs</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>diff</name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>microsecs</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>diff</name> <operator>%</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Frontend version of TimestampDifferenceExceeds(), since we are not
 * linked with backend code.
 */</comment>
<function><type><name>bool</name></type>
<name>feTimestampDifferenceExceeds</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl></parameter>,
                             <parameter><decl><type><name>TimestampTz</name></type> <name>stop_time</name></decl></parameter>,
                             <parameter><decl><type><name>int</name></type> <name>msec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>diff</name> <init>= <expr><name>stop_time</name> <operator>-</operator> <name>start_time</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>diff</name> <operator>&gt;=</operator> <name>msec</name> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Converts an int64 to network byte order.
 */</comment>
<function><type><name>void</name></type>
<name>fe_sendint64</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>

    <comment type="block">/* High order half first, since we're doing MSB-first */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now the low order half */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Converts an int64 from network byte order to native format.
 */</comment>
<function><type><name>int64</name></type>
<name>fe_recvint64</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>h32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>l32</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h32</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l32</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>h32</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>h32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l32</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>l32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>h32</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>&lt;&lt;=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>|=</operator> <name>l32</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
