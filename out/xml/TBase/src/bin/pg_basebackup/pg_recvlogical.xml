<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/pg_basebackup/pg_recvlogical.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_recvlogical.c - receive data from a logical decoding slot in a streaming
 *                      fashion and write it to a local file.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *          src/bin/pg_basebackup/pg_recvlogical.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* local includes */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"streamutil.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/fe_memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>


<comment type="block">/* Time to sleep between reconnection attempts */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECONNECT_SLEEP_TIME</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* Global Options */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>outfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>verbose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>noloop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>standby_message_timeout</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* 10 sec = default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>fsync_interval</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 10 sec = default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>startpos</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>endpos</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_create_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>slot_exists_ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_start_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_drop_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>replication_slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* filled pairwise with option, value. value may be NULL */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>noptions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plugin</name> <init>= <expr><literal type="string">"test_decoding"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Global State */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>outfd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>time_to_abort</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>output_reopen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>output_isfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>output_last_fsync</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>output_needs_fsync</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>output_written_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>output_fsync_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StreamLogicalLog</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>disconnect_and_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>flushAndSendFeedback</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>now</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepareToTerminate</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endpos</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>keepalive</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s controls PostgreSQL logical decoding streams.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]...\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nAction to be performed:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --create-slot      create a new replication slot (for the slot's name see --slot)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --drop-slot        drop the replication slot (for the slot's name see --slot)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --start            start streaming in a replication slot (for the slot's name see --slot)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -E, --endpos=LSN       exit after receiving the specified LSN\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --file=FILE        receive log into this file, - for stdout\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -F  --fsync-interval=SECS\n"</literal>
             <literal type="string">"                         time between fsyncs to the output file (default: %d)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>fsync_interval</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --if-not-exists    do not error if slot already exists when creating a slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -I, --startpos=LSN     where in an existing slot should the streaming start\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --no-loop          do not loop on connection lost\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -o, --option=NAME[=VALUE]\n"</literal>
             <literal type="string">"                         pass option NAME with optional value VALUE to the\n"</literal>
             <literal type="string">"                         output plugin\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -P, --plugin=PLUGIN    use output plugin PLUGIN (default: %s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>plugin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --status-interval=SECS\n"</literal>
             <literal type="string">"                         time between status packets sent to server (default: %d)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>standby_message_timeout</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -S, --slot=SLOTNAME    name of the logical replication slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -v, --verbose          output verbose messages\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version          output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help             show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nConnection options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --dbname=DBNAME    database to connect to\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h, --host=HOSTNAME    database server host or socket directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --port=PORT        database server port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=NAME    connect as specified database user\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --no-password      never prompt for password\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --password         force password prompt (should happen automatically)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;pgsql-bugs@postgresql.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send a Standby Status Update message to server.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sendFeedback</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replyRequested</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>last_written_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>last_fsync_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name></type>        <name><name>replybuf</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * we normally don't want to send superfluous feedbacks, but if it's
     * because of a timeout we need to, otherwise wal_sender_timeout will kill
     * us.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator>
        <name>last_written_lsn</name> <operator>==</operator> <name>output_written_lsn</name> <operator>&amp;&amp;</operator>
        <name>last_fsync_lsn</name> <operator>!=</operator> <name>output_fsync_lsn</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: confirming write up to %X/%X, flush to %X/%X (slot %s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>,
                <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>output_written_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>output_written_lsn</name></expr></argument>,
                <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>output_fsync_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>output_fsync_lsn</name></expr></argument>,
                <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>output_written_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* write */</comment>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>output_fsync_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flush */</comment>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* apply */</comment>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* sendTime */</comment>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>replyRequested</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt> <comment type="block">/* replyRequested */</comment>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>     <comment type="block">/* i am just a tool, so is_all_actived is true as default value */</comment>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>startpos</name> <operator>=</operator> <name>output_written_lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last_written_lsn</name> <operator>=</operator> <name>output_written_lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last_fsync_lsn</name> <operator>=</operator> <name>output_fsync_lsn</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>replybuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send feedback packet: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>disconnect_and_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>OutputFsync</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>output_last_fsync</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>output_fsync_lsn</name> <operator>=</operator> <name>output_written_lsn</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>fsync_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>output_needs_fsync</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>output_needs_fsync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* can only fsync if it's a regular file */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>output_isfile</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><name>outfd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not fsync log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Start the log streaming
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StreamLogicalLog</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_status</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>output_written_lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>output_fsync_lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Connect in replication mode to the server
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* Error message already written in GetConnection() */</comment>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Start the replication
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: starting log streaming at %X/%X (slot %s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpos</name></expr></argument>,
                <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Initiate the replication stream at specified location */</comment>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"START_REPLICATION SLOT \"%s\" LOGICAL %X/%X"</literal></expr></argument>,
                      <argument><expr><name>replication_slot</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* print options if there are any */</comment>
    <if_stmt><if>if <condition>(<expr><name>noptions</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* separator */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* write option name */</comment>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write option value if specified */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>options</name><index>[<expr><operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" '%s'"</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>noptions</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_BOTH</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: streaming initiated\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><operator>!</operator><name>time_to_abort</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>r</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>bytes_left</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>bytes_written</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>hdr_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>cur_record_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>copybuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Potentially send a status message to the master
         */</comment>
        <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>feGetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>outfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <call><name>feTimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>output_last_fsync</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
                                         <argument><expr><name>fsync_interval</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OutputFsync</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>standby_message_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>feTimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_status</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
                                         <argument><expr><name>standby_message_timeout</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Time to send feedback! */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>last_status</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* got SIGHUP, close output file */</comment>
        <if_stmt><if>if <condition>(<expr><name>outfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>output_reopen</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>feGetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OutputFsync</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>outfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>outfd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>output_reopen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* open the output file, if not open yet */</comment>
        <if_stmt><if>if <condition>(<expr><name>outfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>outfd</name> <operator>=</operator> <call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>outfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>,
                             <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>outfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>outfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not stat file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>output_isfile</name> <operator>=</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isatty</name><argument_list>(<argument><expr><name>outfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * In async mode, and no data available. We block on reading but
             * not more than the specified timeout, so that we can send a
             * response back to the client.
             */</comment>
            <decl_stmt><decl><type><name>fd_set</name></type>        <name>input_mask</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TimestampTz</name></type> <name>message_target</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TimestampTz</name></type> <name>fsync_target</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeoutptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid socket: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Compute when we need to wakeup to send a keepalive message. */</comment>
            <if_stmt><if>if <condition>(<expr><name>standby_message_timeout</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>message_target</name> <operator>=</operator> <name>last_status</name> <operator>+</operator> <operator>(</operator><name>standby_message_timeout</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
                    <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Compute when we need to wakeup to fsync the output file. */</comment>
            <if_stmt><if>if <condition>(<expr><name>fsync_interval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>output_needs_fsync</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>fsync_target</name> <operator>=</operator> <name>output_last_fsync</name> <operator>+</operator> <operator>(</operator><name>fsync_interval</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
                    <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Now compute when to wakeup. */</comment>
            <if_stmt><if>if <condition>(<expr><name>message_target</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsync_target</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TimestampTz</name></type> <name>targettime</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type>        <name>secs</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>usecs</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>targettime</name> <operator>=</operator> <name>message_target</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>fsync_target</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fsync_target</name> <operator>&lt;</operator> <name>targettime</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>targettime</name> <operator>=</operator> <name>fsync_target</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>feTimestampDifference</name><argument_list>(<argument><expr><name>now</name></expr></argument>,
                                      <argument><expr><name>targettime</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>secs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* Always sleep at least 1 sec */</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>secs</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name>usecs</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>timeoutptr</name> <operator>=</operator> <operator>&amp;</operator><name>timeout</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>timeoutptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Got a timeout or signal. Continue the loop and either
                 * deliver a status packet to the server or just go back into
                 * blocking.
                 */</comment>
                <continue>continue;</continue>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: select() failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Else there is actually data on the socket */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not receive data from WAL stream: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* End of copy stream */</comment>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Failure while reading the copy stream */</comment>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read COPY data: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check the message type. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>replyRequested</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>walEnd</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>endposReached</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Parse the keepalive message, enclosed in the CopyData message.
             * We just check if the server requested a reply, and ignore the
             * rest.
             */</comment>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>            <comment type="block">/* skip msgtype 'k' */</comment>
            <expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>fe_recvint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>output_written_lsn</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>output_written_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>            <comment type="block">/* read walEnd */</comment>

            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>            <comment type="block">/* skip sendTime */</comment>

            <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: streaming header too small: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>replyRequested</name> <operator>=</operator> <name><name>copybuf</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>endpos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>walEnd</name> <operator>&gt;=</operator> <name>endpos</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If there's nothing to read on the socket until a keepalive
                 * we know that the server has nothing to send us; and if
                 * walEnd has passed endpos, we know nothing else can have
                 * committed before endpos.  So we can bail out now.
                 */</comment>
                <expr_stmt><expr><name>endposReached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Send a reply, if necessary */</comment>
            <if_stmt><if>if <condition>(<expr><name>replyRequested</name> <operator>||</operator> <name>endposReached</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flushAndSendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>last_status</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>endposReached</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>prepareToTerminate</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>time_to_abort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <continue>continue;</continue>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'w'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unrecognized streaming header: \"%c\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>copybuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Read the header of the XLogData message, enclosed in the CopyData
         * message. We only need the WAL location field (dataStart), the rest
         * of the header is ignored.
         */</comment>
        <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>            <comment type="block">/* msgtype 'w' */</comment>
        <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>            <comment type="block">/* dataStart */</comment>
        <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>            <comment type="block">/* walEnd */</comment>
        <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>            <comment type="block">/* sendTime */</comment>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>hdr_len</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: streaming header too small: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Extract WAL location for this block */</comment>
        <expr_stmt><expr><name>cur_record_lsn</name> <operator>=</operator> <call><name>fe_recvint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>endpos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>cur_record_lsn</name> <operator>&gt;</operator> <name>endpos</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We've read past our endpoint, so prepare to go away being
             * cautious about what happens to our output data.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flushAndSendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>prepareToTerminate</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cur_record_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>time_to_abort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>output_written_lsn</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>cur_record_lsn</name></expr></argument>, <argument><expr><name>output_written_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>bytes_left</name> <operator>=</operator> <name>r</name> <operator>-</operator> <name>hdr_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* signal that a fsync is needed */</comment>
        <expr_stmt><expr><name>output_needs_fsync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>bytes_left</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>ret</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>outfd</name></expr></argument>,
                        <argument><expr><name>copybuf</name> <operator>+</operator> <name>hdr_len</name> <operator>+</operator> <name>bytes_written</name></expr></argument>,
                        <argument><expr><name>bytes_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write %u bytes to log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>bytes_left</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>,
                        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Write was successful, advance our position */</comment>
            <expr_stmt><expr><name>bytes_written</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>bytes_left</name> <operator>-=</operator> <name>ret</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>outfd</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write %u bytes to log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>outfile</name></expr></argument>,
                    <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>endpos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>cur_record_lsn</name> <operator>==</operator> <name>endpos</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* endpos was exactly the record we just processed, we're done */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flushAndSendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>prepareToTerminate</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cur_record_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>time_to_abort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We're doing a client-initiated clean exit and have sent CopyDone to
         * the server. We've already sent replay confirmation and fsync'd so
         * we can just clean up the connection now.
         */</comment>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unexpected termination of replication stream: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>outfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>t</name> <init>= <expr><call><name>feGetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* no need to jump to error on failure here, we're finishing anyway */</comment>
        <expr_stmt><expr><call><name>OutputFsync</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>outfd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>outfd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<label><name>error</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>copybuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unfortunately we can't do sensible signal handling on windows...
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<comment type="block">/*
 * When sigint is called, just tell the system to exit at the next possible
 * moment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigint_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>time_to_abort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Trigger the output file to be reopened.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sighup_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>output_reopen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/* general options */</comment>
        <expr><block>{<expr><literal type="string">"file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"fsync-interval"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"no-loop"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
<comment type="block">/* connection options */</comment>
        <expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"no-password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
<comment type="block">/* replication options */</comment>
        <expr><block>{<expr><literal type="string">"startpos"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'I'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"endpos"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'E'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"option"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'o'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"plugin"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'P'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"status-interval"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"slot"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
<comment type="block">/* action */</comment>
        <expr><block>{<expr><literal type="string">"create-slot"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"start"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"drop-slot"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"if-not-exists"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
        <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>option_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hi</name></decl>,
                <decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>db_name</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_basebackup"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_recvlogical (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"E:f:F:nvd:h:p:U:wWI:o:P:s:S:"</literal></expr></argument>,
                            <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
<comment type="block">/* general options */</comment>
            <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                <expr_stmt><expr><name>outfile</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'F'</literal></expr>:</case>
                <expr_stmt><expr><name>fsync_interval</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fsync_interval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid fsync interval \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                <expr_stmt><expr><name>noloop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'v'</literal></expr>:</case>
                <expr_stmt><expr><name>verbose</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
<comment type="block">/* connection options */</comment>
            <case>case <expr><literal type="char">'d'</literal></expr>:</case>
                <expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'h'</literal></expr>:</case>
                <expr_stmt><expr><name>dbhost</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid port number \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>dbport</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'U'</literal></expr>:</case>
                <expr_stmt><expr><name>dbuser</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'w'</literal></expr>:</case>
                <expr_stmt><expr><name>dbgetpassword</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'W'</literal></expr>:</case>
                <expr_stmt><expr><name>dbgetpassword</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
<comment type="block">/* replication options */</comment>
            <case>case <expr><literal type="char">'I'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse start position \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>startpos</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'E'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse end position \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>endpos</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'o'</literal></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* remove =; separate data from val */</comment>
                        <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>val</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>noptions</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>noptions</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>options</name><index>[<expr><operator>(</operator><name>noptions</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>options</name><index>[<expr><operator>(</operator><name>noptions</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
                </block_content>}</block>

                <break>break;</break>
            <case>case <expr><literal type="char">'P'</literal></expr>:</case>
                <expr_stmt><expr><name>plugin</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'s'</literal></expr>:</case>
                <expr_stmt><expr><name>standby_message_timeout</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>standby_message_timeout</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid status interval \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'S'</literal></expr>:</case>
                <expr_stmt><expr><name>replication_slot</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
<comment type="block">/* action */</comment>
            <case>case <expr><literal type="number">1</literal></expr>:</case>
                <expr_stmt><expr><name>do_create_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>
                <expr_stmt><expr><name>do_start_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr>:</case>
                <expr_stmt><expr><name>do_drop_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">4</literal></expr>:</case>
                <expr_stmt><expr><name>slot_exists_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>

                <comment type="block">/*
                 * getopt_long already emitted a complaint
                 */</comment>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <comment type="block">/*
     * Any non-option arguments?
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Required arguments
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>replication_slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no slot specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>do_start_slot</name> <operator>&amp;&amp;</operator> <name>outfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no target file specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_drop_slot</name> <operator>&amp;&amp;</operator> <name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no database specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_drop_slot</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>do_create_slot</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>do_start_slot</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: at least one action needs to be specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>do_drop_slot</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>do_create_slot</name> <operator>||</operator> <name>do_start_slot</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot use --create-slot or --start together with --drop-slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>startpos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>do_create_slot</name> <operator>||</operator> <name>do_drop_slot</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot use --create-slot or --drop-slot together with --startpos\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>endpos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>do_start_slot</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: --endpos may only be specified with --start\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>sigint_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>sighup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Obtain a connection to server. This is not really necessary but it
     * helps to get more precise error messages about authentication, required
     * GUC parameters and such.
     */</comment>
    <expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* Error message already written in GetConnection() */</comment>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Run IDENTIFY_SYSTEM to make sure we connected using a database specific
     * replication connection.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RunIdentifySystem</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>db_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not establish database-specific replication connection\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Drop a replication slot. */</comment>
    <if_stmt><if>if <condition>(<expr><name>do_drop_slot</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: dropping replication slot \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DropReplicationSlot</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create a replication slot. */</comment>
    <if_stmt><if>if <condition>(<expr><name>do_create_slot</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: creating replication slot \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateReplicationSlot</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>, <argument><expr><name>plugin</name></expr></argument>,
                                   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot_exists_ok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>startpos</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_start_slot</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Stream loop */</comment>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>StreamLogicalLog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>time_to_abort</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We've been Ctrl-C'ed or reached an exit limit condition. That's
             * not an error, so exit without an errorcode.
             */</comment>
            <expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>noloop</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: disconnected\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <comment type="block">/* translator: check source for value for %d */</comment>
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: disconnected; waiting %d seconds to try again\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>RECONNECT_SLEEP_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>RECONNECT_SLEEP_TIME</name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Fsync our output data, and send a feedback message to the server.  Returns
 * true if successful, false otherwise.
 *
 * If successful, *now is updated to the current timestamp just before sending
 * feedback.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flushAndSendFeedback</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* flush data to disk, so that we send a recent flush pointer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OutputFsync</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>now</name> <operator>=</operator> <call><name>feGetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>*</operator><name>now</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to inform the server about of upcoming demise, but don't wait around or
 * retry on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepareToTerminate</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endpos</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepalive</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>keepalive</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: endpos %X/%X reached by keepalive\n"</literal></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>endpos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>endpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: endpos %X/%X reached by record at %X/%X\n"</literal></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>endpos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>endpos</name><operator>)</operator></expr></argument>,
                    <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
