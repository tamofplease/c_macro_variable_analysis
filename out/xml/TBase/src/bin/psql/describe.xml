<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/psql/describe.c"><comment type="block">/*
 * psql - the PostgreSQL interactive terminal
 *
 * Support for the various \d ("describe") commands.  Note that the current
 * expectation is that all functions in this file will succeed when working
 * with servers of versions 7.4 and up.  It's okay to omit irrelevant
 * information for an old server, but not to fail outright.
 *
 * Copyright (c) 2000-2017, PostgreSQL Global Development Group
 *
 * src/bin/psql/describe.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"describe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/mbprint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"settings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"variables.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCATOR_TYPE_REPLICATED</name></cpp:macro> <cpp:value>'R'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCATOR_TYPE_HASH</name></cpp:macro> <cpp:value>'H'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCATOR_TYPE_RROBIN</name></cpp:macro> <cpp:value>'N'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCATOR_TYPE_MODULO</name></cpp:macro> <cpp:value>'M'</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCATOR_TYPE_SHARD</name></cpp:macro> <cpp:value>'S'</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>describeOneTableDetails</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationname</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_tablespace_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name></type> <name>tablespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_role_attribute</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>listTSParsersVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>describeOneTSParser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>listTSConfigsVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>describeOneTSConfig</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cfgname</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pnspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printACLColumn</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>listOneExtensionContents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*----------------
 * Handlers for various slash commands displaying some sort of list
 * of things in the database.
 *
 * Note: try to format the queries to look nice in -E output.
 *----------------
 */</comment>


<comment type="block">/*
 * \da
 * Takes an optional regexp to select particular aggregates
 */</comment>
<function><type><name>bool</name></type>
<name>describeAggregates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  p.proname AS \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.format_type(p.prorettype, NULL) AS \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  CASE WHEN p.pronargs = 0\n"</literal>
                          <literal type="string">"    THEN CAST('*' AS pg_catalog.text)\n"</literal>
                          <literal type="string">"    ELSE pg_catalog.pg_get_function_arguments(p.oid)\n"</literal>
                          <literal type="string">"  END AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  CASE WHEN p.pronargs = 0\n"</literal>
                          <literal type="string">"    THEN CAST('*' AS pg_catalog.text)\n"</literal>
                          <literal type="string">"    ELSE\n"</literal>
                          <literal type="string">"    pg_catalog.array_to_string(ARRAY(\n"</literal>
                          <literal type="string">"      SELECT\n"</literal>
                          <literal type="string">"        pg_catalog.format_type(p.proargtypes[s.i], NULL)\n"</literal>
                          <literal type="string">"      FROM\n"</literal>
                          <literal type="string">"        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"</literal>
                          <literal type="string">"    ), ', ')\n"</literal>
                          <literal type="string">"  END AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  pg_catalog.format_type(p.proargtypes[0], NULL) AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"  pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_proc p\n"</literal>
                      <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n"</literal>
                      <literal type="string">"WHERE p.proisagg\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.proname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_function_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 4;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of aggregate functions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dA
 * Takes an optional regexp to select particular access methods
 */</comment>
<function><type><name>bool</name></type>
<name>describeAccessMethods</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support access methods.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT amname AS \"%s\",\n"</literal>
                      <literal type="string">"  CASE amtype"</literal>
                      <literal type="string">" WHEN 'i' THEN '%s'"</literal>
                      <literal type="string">" END AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Index"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  amhandler AS \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.obj_description(oid, 'pg_am') AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Handler"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_am\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of access methods"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \db
 * Takes an optional regexp to select particular tablespaces
 */</comment>
<function><type><name>bool</name></type>
<name>describeTablespaces</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80000</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support tablespaces.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT spcname AS \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.pg_get_userbyid(spcowner) AS \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.pg_tablespace_location(oid) AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT spcname AS \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.pg_get_userbyid(spcowner) AS \"%s\",\n"</literal>
                          <literal type="string">"  spclocation AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"spcacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  spcoptions AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_tablespace_size(oid)) AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  pg_catalog.shobj_description(oid, 'pg_tablespace') AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_tablespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"spcname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of tablespaces"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \df
 * Takes an optional regexp to select particular functions.
 *
 * As with \d, you can specify the kinds of functions you want:
 *
 * a for aggregates
 * n for normal
 * t for trigger
 * w for window
 *
 * and you can mix and match these in any order.
 */</comment>
<function><type><name>bool</name></type>
<name>describeFunctions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>functypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showAggregate</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showNormal</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showTrigger</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showWindow</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_where</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* No "Parallel" column before 9.6 */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns_pre_96</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strspn</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="string">"antwS+"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\df only takes [antwS+] as options\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>showWindow</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\df does not take a \"w\" option with server version %s\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showAggregate</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showNormal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showTrigger</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showWindow</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>showAggregate</name> <operator>=</operator> <name>showNormal</name> <operator>=</operator> <name>showTrigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>showWindow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  p.proname as \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  pg_catalog.pg_get_function_result(p.oid) as \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.pg_get_function_arguments(p.oid) as \"%s\",\n"</literal>
                          <literal type="string">" CASE\n"</literal>
                          <literal type="string">"  WHEN p.proisagg THEN '%s'\n"</literal>
                          <literal type="string">"  WHEN p.proiswindow THEN '%s'\n"</literal>
                          <literal type="string">"  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"</literal>
                          <literal type="string">"  ELSE '%s'\n"</literal>
                          <literal type="string">" END as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
        <comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"window"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"normal"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END ||\n"</literal>
                          <literal type="string">"  pg_catalog.format_type(p.prorettype, NULL) as \"%s\",\n"</literal>
                          <literal type="string">"  CASE WHEN proallargtypes IS NOT NULL THEN\n"</literal>
                          <literal type="string">"    pg_catalog.array_to_string(ARRAY(\n"</literal>
                          <literal type="string">"      SELECT\n"</literal>
                          <literal type="string">"        CASE\n"</literal>
                          <literal type="string">"          WHEN p.proargmodes[s.i] = 'i' THEN ''\n"</literal>
                          <literal type="string">"          WHEN p.proargmodes[s.i] = 'o' THEN 'OUT '\n"</literal>
                          <literal type="string">"          WHEN p.proargmodes[s.i] = 'b' THEN 'INOUT '\n"</literal>
                          <literal type="string">"          WHEN p.proargmodes[s.i] = 'v' THEN 'VARIADIC '\n"</literal>
                          <literal type="string">"        END ||\n"</literal>
                          <literal type="string">"        CASE\n"</literal>
                          <literal type="string">"          WHEN COALESCE(p.proargnames[s.i], '') = '' THEN ''\n"</literal>
                          <literal type="string">"          ELSE p.proargnames[s.i] || ' '\n"</literal>
                          <literal type="string">"        END ||\n"</literal>
                          <literal type="string">"        pg_catalog.format_type(p.proallargtypes[s.i], NULL)\n"</literal>
                          <literal type="string">"      FROM\n"</literal>
                          <literal type="string">"        pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)\n"</literal>
                          <literal type="string">"    ), ', ')\n"</literal>
                          <literal type="string">"  ELSE\n"</literal>
                          <literal type="string">"    pg_catalog.array_to_string(ARRAY(\n"</literal>
                          <literal type="string">"      SELECT\n"</literal>
                          <literal type="string">"        CASE\n"</literal>
                          <literal type="string">"          WHEN COALESCE(p.proargnames[s.i+1], '') = '' THEN ''\n"</literal>
                          <literal type="string">"          ELSE p.proargnames[s.i+1] || ' '\n"</literal>
                          <literal type="string">"          END ||\n"</literal>
                          <literal type="string">"        pg_catalog.format_type(p.proargtypes[s.i], NULL)\n"</literal>
                          <literal type="string">"      FROM\n"</literal>
                          <literal type="string">"        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"</literal>
                          <literal type="string">"    ), ', ')\n"</literal>
                          <literal type="string">"  END AS \"%s\",\n"</literal>
                          <literal type="string">"  CASE\n"</literal>
                          <literal type="string">"    WHEN p.proisagg THEN '%s'\n"</literal>
                          <literal type="string">"    WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"</literal>
                          <literal type="string">"    ELSE '%s'\n"</literal>
                          <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
        <comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"normal"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END ||\n"</literal>
                          <literal type="string">"  pg_catalog.format_type(p.prorettype, NULL) as \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.oidvectortypes(p.proargtypes) as \"%s\",\n"</literal>
                          <literal type="string">"  CASE\n"</literal>
                          <literal type="string">"    WHEN p.proisagg THEN '%s'\n"</literal>
                          <literal type="string">"    WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"</literal>
                          <literal type="string">"    ELSE '%s'\n"</literal>
                          <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
        <comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"normal"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n CASE\n"</literal>
                          <literal type="string">"  WHEN p.provolatile = 'i' THEN '%s'\n"</literal>
                          <literal type="string">"  WHEN p.provolatile = 's' THEN '%s'\n"</literal>
                          <literal type="string">"  WHEN p.provolatile = 'v' THEN '%s'\n"</literal>
                          <literal type="string">" END as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"immutable"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"stable"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"volatile"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Volatility"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">",\n CASE\n"</literal>
                              <literal type="string">"  WHEN p.proparallel = 'r' THEN '%s'\n"</literal>
                              <literal type="string">"  WHEN p.proparallel = 's' THEN '%s'\n"</literal>
                              <literal type="string">"  WHEN p.proparallel = 'u' THEN '%s'\n"</literal>
                              <literal type="string">" END as \"%s\""</literal></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"restricted"</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"safe"</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"unsafe"</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Parallel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n pg_catalog.pg_get_userbyid(p.proowner) as \"%s\""</literal>
                          <literal type="string">",\n CASE WHEN prosecdef THEN '%s' ELSE '%s' END AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"definer"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invoker"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Security"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.proacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n l.lanname as \"%s\""</literal>
                          <literal type="string">",\n p.prosrc as \"%s\""</literal>
                          <literal type="string">",\n pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Language"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Source code"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_proc p"</literal>
                         <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"     LEFT JOIN pg_catalog.pg_language l ON l.oid = p.prolang\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* filter by function type, if requested */</comment>
    <if_stmt><if>if <condition>(<expr><name>showNormal</name> <operator>&amp;&amp;</operator> <name>showAggregate</name> <operator>&amp;&amp;</operator> <name>showTrigger</name> <operator>&amp;&amp;</operator> <name>showWindow</name></expr>)</condition><block type="pseudo"><block_content>
         <comment type="block">/* Do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>showNormal</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showAggregate</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT p.proisagg\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showTrigger</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>have_where</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prorettype &lt;&gt; 'pg_catalog.trigger'::pg_catalog.regtype\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showWindow</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>have_where</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT p.proiswindow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>needs_or</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE (\n       "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* Note: at least one of these must be true ... */</comment>
        <if_stmt><if>if <condition>(<expr><name>showAggregate</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.proisagg\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needs_or</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>showTrigger</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>needs_or</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"       OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                 <argument><expr><literal type="string">"p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needs_or</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>showWindow</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>needs_or</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"       OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.proiswindow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needs_or</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>have_where</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.proname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_function_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 4;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of functions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns_pre_96</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns_pre_96</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * \dT
 * describe types
 */</comment>
<function><type><name>bool</name></type>
<name>describeTypes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.format_type(t.oid, NULL) AS \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  t.typname AS \"%s\",\n"</literal>
                          <literal type="string">"  CASE WHEN t.typrelid != 0\n"</literal>
                          <literal type="string">"      THEN CAST('tuple' AS pg_catalog.text)\n"</literal>
                          <literal type="string">"    WHEN t.typlen &lt; 0\n"</literal>
                          <literal type="string">"      THEN CAST('var' AS pg_catalog.text)\n"</literal>
                          <literal type="string">"    ELSE CAST(t.typlen AS pg_catalog.text)\n"</literal>
                          <literal type="string">"  END AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Internal name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"  pg_catalog.array_to_string(\n"</literal>
                             <literal type="string">"      ARRAY(\n"</literal>
                             <literal type="string">"          SELECT e.enumlabel\n"</literal>
                             <literal type="string">"          FROM pg_catalog.pg_enum e\n"</literal>
                             <literal type="string">"          WHERE e.enumtypid = t.oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                 <argument><expr><literal type="string">"          ORDER BY e.enumsortorder\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                 <argument><expr><literal type="string">"          ORDER BY e.oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"      ),\n"</literal>
                          <literal type="string">"      E'\\n'\n"</literal>
                          <literal type="string">"  ) AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Elements"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  pg_catalog.pg_get_userbyid(t.typowner) AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"t.typacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"  pg_catalog.obj_description(t.oid, 'pg_type') as \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM pg_catalog.pg_type t\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * do not include complex types (typrelid!=0) unless they are standalone
     * composite types
     */</comment>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE (t.typrelid = 0 "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OR (SELECT c.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call>
                         <literal type="string">" FROM pg_catalog.pg_class c "</literal>
                         <literal type="string">"WHERE c.oid = t.typrelid))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * do not include array types (before 8.3 we have to use the assumption
     * that their names start with underscore)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  AND t.typname !~ '^_'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Match name pattern against either internal or external name */</comment>
    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.typname"</literal></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.format_type(t.oid, NULL)"</literal></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of data types"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \do
 * Describe operators
 */</comment>
<function><type><name>bool</name></type>
<name>describeOperators</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: before Postgres 9.1, we did not assign comments to any built-in
     * operators, preferring to let the comment on the underlying function
     * suffice.  The coalesce() on the obj_description() calls below supports
     * this convention by providing a fallback lookup of a comment on the
     * operator's function.  As of 9.1 there is a policy that every built-in
     * operator should have a comment; so the coalesce() is no longer
     * necessary so far as built-in operators are concerned.  We keep it
     * anyway, for now, because (1) third-party modules may still be following
     * the old convention, and (2) we'd need to do it anyway when talking to a
     * pre-9.1 server.
     */</comment>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  o.oprname AS \"%s\",\n"</literal>
                      <literal type="string">"  CASE WHEN o.oprkind='l' THEN NULL ELSE pg_catalog.format_type(o.oprleft, NULL) END AS \"%s\",\n"</literal>
                      <literal type="string">"  CASE WHEN o.oprkind='r' THEN NULL ELSE pg_catalog.format_type(o.oprright, NULL) END AS \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.format_type(o.oprresult, NULL) AS \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Left arg type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Right arg type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  o.oprcode AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"  coalesce(pg_catalog.obj_description(o.oid, 'pg_operator'),\n"</literal>
                      <literal type="string">"           pg_catalog.obj_description(o.oprcode, 'pg_proc')) AS \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_operator o\n"</literal>
                      <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"o.oprname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_operator_is_visible(o.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 3, 4;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of operators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * listAllDbs
 *
 * for \l, \list, and -l switch
 */</comment>
<function><type><name>bool</name></type>
<name>listAllDbs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT d.datname as \"%s\",\n"</literal>
                      <literal type="string">"       pg_catalog.pg_get_userbyid(d.datdba) as \"%s\",\n"</literal>
                      <literal type="string">"       pg_catalog.pg_encoding_to_char(d.encoding) as \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Encoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"       d.datcollate as \"%s\",\n"</literal>
                          <literal type="string">"       d.datctype as \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collate"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Ctype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"       "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"d.datacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       CASE WHEN pg_catalog.has_database_privilege(d.datname, 'CONNECT')\n"</literal>
                          <literal type="string">"            THEN pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname))\n"</literal>
                          <literal type="string">"            ELSE 'No Access'\n"</literal>
                          <literal type="string">"       END as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       t.spcname as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Tablespace"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       pg_catalog.shobj_description(d.oid, 'pg_database') as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_database d\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"  JOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"d.datname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of databases"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * List Tables' Grant/Revoke Permissions
 * \z (now also \dp -- perhaps more mnemonic)
 */</comment>
<function><type><name>bool</name></type>
<name>permissionsList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * we ignore indexes and toast tables since they have no meaningful rights
     */</comment>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  c.relname as \"%s\",\n"</literal>
                      <literal type="string">"  CASE c.relkind"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" END as \"%s\",\n"</literal>
                      <literal type="string">"  "</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,    <comment type="block">/* partitioned table */</comment>
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"c.relacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  pg_catalog.array_to_string(ARRAY(\n"</literal>
                          <literal type="string">"    SELECT attname || E':\\n  ' || pg_catalog.array_to_string(attacl, E'\\n  ')\n"</literal>
                          <literal type="string">"    FROM pg_catalog.pg_attribute a\n"</literal>
                          <literal type="string">"    WHERE attrelid = c.oid AND NOT attisdropped AND attacl IS NOT NULL\n"</literal>
                          <literal type="string">"  ), E'\\n') AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Column privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  pg_catalog.array_to_string(ARRAY(\n"</literal>
                          <literal type="string">"    SELECT polname\n"</literal>
                          <literal type="string">"    || CASE WHEN polcmd != '*' THEN\n"</literal>
                          <literal type="string">"           E' (' || polcmd || E'):'\n"</literal>
                          <literal type="string">"       ELSE E':'\n"</literal>
                          <literal type="string">"       END\n"</literal>
                          <literal type="string">"    || CASE WHEN polqual IS NOT NULL THEN\n"</literal>
                          <literal type="string">"           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)\n"</literal>
                          <literal type="string">"       ELSE E''\n"</literal>
                          <literal type="string">"       END\n"</literal>
                          <literal type="string">"    || CASE WHEN polwithcheck IS NOT NULL THEN\n"</literal>
                          <literal type="string">"           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)\n"</literal>
                          <literal type="string">"       ELSE E''\n"</literal>
                          <literal type="string">"       END"</literal>
                          <literal type="string">"    || CASE WHEN polroles &lt;&gt; '{0}' THEN\n"</literal>
                          <literal type="string">"           E'\\n  to: ' || pg_catalog.array_to_string(\n"</literal>
                          <literal type="string">"               ARRAY(\n"</literal>
                          <literal type="string">"                   SELECT rolname\n"</literal>
                          <literal type="string">"                   FROM pg_catalog.pg_roles\n"</literal>
                          <literal type="string">"                   WHERE oid = ANY (polroles)\n"</literal>
                          <literal type="string">"                   ORDER BY 1\n"</literal>
                          <literal type="string">"               ), E', ')\n"</literal>
                          <literal type="string">"       ELSE E''\n"</literal>
                          <literal type="string">"       END\n"</literal>
                          <literal type="string">"    FROM pg_catalog.pg_policy pol\n"</literal>
                          <literal type="string">"    WHERE polrelid = c.oid), E'\\n')\n"</literal>
                          <literal type="string">"    AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Policies"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  pg_catalog.array_to_string(ARRAY(\n"</literal>
                          <literal type="string">"    SELECT polname\n"</literal>
                          <literal type="string">"    || CASE WHEN NOT polpermissive THEN\n"</literal>
                          <literal type="string">"       E' (RESTRICTIVE)'\n"</literal>
                          <literal type="string">"       ELSE '' END\n"</literal>
                          <literal type="string">"    || CASE WHEN polcmd != '*' THEN\n"</literal>
                          <literal type="string">"           E' (' || polcmd || E'):'\n"</literal>
                          <literal type="string">"       ELSE E':'\n"</literal>
                          <literal type="string">"       END\n"</literal>
                          <literal type="string">"    || CASE WHEN polqual IS NOT NULL THEN\n"</literal>
                          <literal type="string">"           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)\n"</literal>
                          <literal type="string">"       ELSE E''\n"</literal>
                          <literal type="string">"       END\n"</literal>
                          <literal type="string">"    || CASE WHEN polwithcheck IS NOT NULL THEN\n"</literal>
                          <literal type="string">"           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)\n"</literal>
                          <literal type="string">"       ELSE E''\n"</literal>
                          <literal type="string">"       END"</literal>
                          <literal type="string">"    || CASE WHEN polroles &lt;&gt; '{0}' THEN\n"</literal>
                          <literal type="string">"           E'\\n  to: ' || pg_catalog.array_to_string(\n"</literal>
                          <literal type="string">"               ARRAY(\n"</literal>
                          <literal type="string">"                   SELECT rolname\n"</literal>
                          <literal type="string">"                   FROM pg_catalog.pg_roles\n"</literal>
                          <literal type="string">"                   WHERE oid = ANY (polroles)\n"</literal>
                          <literal type="string">"                   ORDER BY 1\n"</literal>
                          <literal type="string">"               ), E', ')\n"</literal>
                          <literal type="string">"       ELSE E''\n"</literal>
                          <literal type="string">"       END\n"</literal>
                          <literal type="string">"    FROM pg_catalog.pg_policy pol\n"</literal>
                          <literal type="string">"    WHERE polrelid = c.oid), E'\\n')\n"</literal>
                          <literal type="string">"    AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Policies"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal>
                         <literal type="string">"WHERE c.relkind IN ("</literal>
                         <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
                         <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
                         <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
                         <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
                         <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
                         <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Unless a schema pattern is specified, we suppress system and temp
     * tables, since they normally aren't very interesting from a permissions
     * point of view.  You can see 'em by explicit request though, eg with \z
     * pg_catalog.*
     */</comment>
    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \ddp
 *
 * List Default ACLs.  The pattern can match either schema or role name.
 */</comment>
<function><type><name>bool</name></type>
<name>listDefaultACLs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90000</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support altering default privileges.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_userbyid(d.defaclrole) AS \"%s\",\n"</literal>
                      <literal type="string">"  n.nspname AS \"%s\",\n"</literal>
                      <literal type="string">"  CASE d.defaclobjtype WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' END AS \"%s\",\n"</literal>
                      <literal type="string">"  "</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>DEFACLOBJ_RELATION</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>DEFACLOBJ_SEQUENCE</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>DEFACLOBJ_FUNCTION</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"function"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>DEFACLOBJ_TYPE</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>DEFACLOBJ_NAMESPACE</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"d.defaclacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_default_acl d\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.defaclnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_get_userbyid(d.defaclrole)"</literal></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 3;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Default access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get object comments
 *
 * \dd [foo]
 *
 * Note: This command only lists comments for object types which do not have
 * their comments displayed by their own backslash commands. The following
 * types of objects will be displayed: constraint, operator class,
 * operator family, rule, and trigger.
 *
 */</comment>
<function><type><name>bool</name></type>
<name>objectDescription</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT DISTINCT tt.nspname AS \"%s\", tt.name AS \"%s\", tt.object AS \"%s\", d.description AS \"%s\"\n"</literal>
                      <literal type="string">"FROM (\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Object"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Table constraint descriptions */</comment>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"  SELECT pgc.oid as oid, pgc.tableoid AS tableoid,\n"</literal>
                      <literal type="string">"  n.nspname as nspname,\n"</literal>
                      <literal type="string">"  CAST(pgc.conname AS pg_catalog.text) as name,"</literal>
                      <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
                      <literal type="string">"  FROM pg_catalog.pg_constraint pgc\n"</literal>
                      <literal type="string">"    JOIN pg_catalog.pg_class c "</literal>
                      <literal type="string">"ON c.oid = pgc.conrelid\n"</literal>
                      <literal type="string">"    LEFT JOIN pg_catalog.pg_namespace n "</literal>
                      <literal type="string">"    ON n.oid = c.relnamespace\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table constraint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"pgc.conname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Domain constraint descriptions */</comment>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"UNION ALL\n"</literal>
                      <literal type="string">"  SELECT pgc.oid as oid, pgc.tableoid AS tableoid,\n"</literal>
                      <literal type="string">"  n.nspname as nspname,\n"</literal>
                      <literal type="string">"  CAST(pgc.conname AS pg_catalog.text) as name,"</literal>
                      <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
                      <literal type="string">"  FROM pg_catalog.pg_constraint pgc\n"</literal>
                      <literal type="string">"    JOIN pg_catalog.pg_type t "</literal>
                      <literal type="string">"ON t.oid = pgc.contypid\n"</literal>
                      <literal type="string">"    LEFT JOIN pg_catalog.pg_namespace n "</literal>
                      <literal type="string">"    ON n.oid = t.typnamespace\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"domain constraint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"pgc.conname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/*
     * pg_opclass.opcmethod only available in 8.3+
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Operator class descriptions */</comment>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"UNION ALL\n"</literal>
                          <literal type="string">"  SELECT o.oid as oid, o.tableoid as tableoid,\n"</literal>
                          <literal type="string">"  n.nspname as nspname,\n"</literal>
                          <literal type="string">"  CAST(o.opcname AS pg_catalog.text) as name,\n"</literal>
                          <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
                          <literal type="string">"  FROM pg_catalog.pg_opclass o\n"</literal>
                          <literal type="string">"    JOIN pg_catalog.pg_am am ON "</literal>
                          <literal type="string">"o.opcmethod = am.oid\n"</literal>
                          <literal type="string">"    JOIN pg_catalog.pg_namespace n ON "</literal>
                          <literal type="string">"n.oid = o.opcnamespace\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"operator class"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                                 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"o.opcname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><literal type="string">"pg_catalog.pg_opclass_is_visible(o.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * although operator family comments have been around since 8.3,
     * pg_opfamily_is_visible is only available in 9.2+
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Operator family descriptions */</comment>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"UNION ALL\n"</literal>
                          <literal type="string">"  SELECT opf.oid as oid, opf.tableoid as tableoid,\n"</literal>
                          <literal type="string">"  n.nspname as nspname,\n"</literal>
                          <literal type="string">"  CAST(opf.opfname AS pg_catalog.text) AS name,\n"</literal>
                          <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
                          <literal type="string">"  FROM pg_catalog.pg_opfamily opf\n"</literal>
                          <literal type="string">"    JOIN pg_catalog.pg_am am "</literal>
                          <literal type="string">"ON opf.opfmethod = am.oid\n"</literal>
                          <literal type="string">"    JOIN pg_catalog.pg_namespace n "</literal>
                          <literal type="string">"ON opf.opfnamespace = n.oid\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"operator family"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                                 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"opf.opfname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><literal type="string">"pg_catalog.pg_opfamily_is_visible(opf.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Rule descriptions (ignore rules for views) */</comment>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"UNION ALL\n"</literal>
                      <literal type="string">"  SELECT r.oid as oid, r.tableoid as tableoid,\n"</literal>
                      <literal type="string">"  n.nspname as nspname,\n"</literal>
                      <literal type="string">"  CAST(r.rulename AS pg_catalog.text) as name,"</literal>
                      <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
                      <literal type="string">"  FROM pg_catalog.pg_rewrite r\n"</literal>
                      <literal type="string">"       JOIN pg_catalog.pg_class c ON c.oid = r.ev_class\n"</literal>
                      <literal type="string">"       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal>
                      <literal type="string">"  WHERE r.rulename != '_RETURN'\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"rule"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"r.rulename"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Trigger descriptions */</comment>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"UNION ALL\n"</literal>
                      <literal type="string">"  SELECT t.oid as oid, t.tableoid as tableoid,\n"</literal>
                      <literal type="string">"  n.nspname as nspname,\n"</literal>
                      <literal type="string">"  CAST(t.tgname AS pg_catalog.text) as name,"</literal>
                      <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
                      <literal type="string">"  FROM pg_catalog.pg_trigger t\n"</literal>
                      <literal type="string">"       JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid\n"</literal>
                      <literal type="string">"       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.tgname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">") AS tt\n"</literal>
                         <literal type="string">"  JOIN pg_catalog.pg_description d ON (tt.oid = d.objoid AND tt.tableoid = d.classoid AND d.objsubid = 0)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 3;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"Object descriptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * describeTableDetails (for \d)
 *
 * This routine finds the tables to be displayed, and calls
 * describeOneTableDetails for each one.
 *
 * verbose: if true, this is \d+
 */</comment>
<function><type><name>bool</name></type>
<name>describeTableDetails</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT c.oid,\n"</literal>
                      <literal type="string">"  n.nspname,\n"</literal>
                      <literal type="string">"  c.relname\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_class c\n"</literal>
                      <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 2, 3;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relation named \"%s\".\n"</literal></expr></argument>,
                           <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relations.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>describeOneTableDetails</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * describeOneTableDetails (for \d)
 *
 * Unfortunately, the information presented here is so complicated that it
 * cannot be done in a single query. So we have to assemble the printed table
 * by hand and pass it to the underlying printTable() function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>describeOneTableDetails</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationname</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printTableOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>printTableInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>view_def</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name><name>headers</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>seq_values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>tmpbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <struct>struct
    <block>{
        <decl_stmt><decl><type><name>int16</name></type>        <name>checks</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>hasindex</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>hasrules</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>hastriggers</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>rowsecurity</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>forcerowsecurity</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>hasoids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>        <name>ispartition</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>tablespace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>reloptions</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>reloftype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>relpersistence</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>relreplident</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>char</name></type>        <name>relpartkind</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>            <decl><name>tableinfo</name></decl>;</struct>
    <decl_stmt><decl><type><name>bool</name></type>        <name>show_column_details</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* This output looks confusing in expanded mode. */</comment>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>expanded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get general table info */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
                          <literal type="string">"c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, "</literal>
						  <literal type="string">"c.relhasoids, c.relispartition, %s, c.reltablespace, "</literal>
                          <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                          <literal type="string">"c.relpersistence, c.relreplident, c.relpartkind\n"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                          <literal type="string">"c.relpersistence, c.relreplident\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                          <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
                          <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
                          <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
                           <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
                           <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
                           </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
                          <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
                          <literal type="string">"%s, c.reltablespace, "</literal>
                          <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
                          <literal type="string">"c.relpersistence, c.relreplident\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
                          <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
                          <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
                           <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
                           <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
                           </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
                          <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
                          <literal type="string">"%s, c.reltablespace, "</literal>
                          <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
                          <literal type="string">"c.relpersistence\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
                          <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
                          <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
                           <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
                           <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
                           </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
                          <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
                          <literal type="string">"%s, c.reltablespace, "</literal>
                          <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
                          <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
                          <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
                           <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
                           <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
                           </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
                          <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
                          <literal type="string">"%s, c.reltablespace\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
                          <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
                          <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
                           <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
                           <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
                           </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT relchecks, relkind, relhasindex, relhasrules, "</literal>
                          <literal type="string">"reltriggers &lt;&gt; 0, false, false, relhasoids, "</literal>
                          <literal type="string">"%s, reltablespace\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_class WHERE oid = '%s';"</literal></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
                           <expr><literal type="string">"pg_catalog.array_to_string(reloptions, E', ')"</literal></expr> </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT relchecks, relkind, relhasindex, relhasrules, "</literal>
                          <literal type="string">"reltriggers &lt;&gt; 0, false, false, relhasoids, "</literal>
                          <literal type="string">"'', reltablespace\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_class WHERE oid = '%s';"</literal></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT relchecks, relkind, relhasindex, relhasrules, "</literal>
                          <literal type="string">"reltriggers &lt;&gt; 0, false, false, relhasoids, "</literal>
                          <literal type="string">"'', ''\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_class WHERE oid = '%s';"</literal></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Did we get anything? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relation with OID %s.\n"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <goto>goto <name>error_return</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>checks</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hasindex</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hasrules</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hasoids</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>ispartition</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>reloptions</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>tablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>reloftype</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal> <operator>&amp;&amp;</operator>
						   <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal><operator>)</operator></expr> ?</condition><then>
		<expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal><operator>)</operator></expr> ?</condition><then>
		<expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><literal type="char">'d'</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relpartkind</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal><operator>)</operator></expr>?</condition><then>
		<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="char">'n'</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If it's a sequence, fetch its values and store into an array that will
     * be used later.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* must be separate because fmtId isn't reentrant */</comment>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">".%s;"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>seq_values</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>seq_values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>seq_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>seq_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Get column info
     *
     * You need to modify value of "firstvcol" which will be defined below if
     * you are adding column(s) preceding to verbose-only columns.
     */</comment>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attname,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n  pg_catalog.format_type(a.atttypid, a.atttypmod),"</literal>
                         <literal type="string">"\n  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)"</literal>
                         <literal type="string">"\n   FROM pg_catalog.pg_attrdef d"</literal>
                         <literal type="string">"\n   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),"</literal>
                         <literal type="string">"\n  a.attnotnull, a.attnum,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t\n"</literal>
                             <literal type="string">"   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation &lt;&gt; t.typcollation) AS attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n  NULL AS attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  a.attidentity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  ''::pg_catalog.char AS attidentity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE) AS indexdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  NULL AS indexdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  CASE WHEN attfdwoptions IS NULL THEN '' ELSE "</literal>
                             <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value)  FROM "</literal>
                             <literal type="string">"  pg_catalog.pg_options_to_table(attfdwoptions)), ', ') || ')' END AS attfdwoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  NULL AS attfdwoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  a.attstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * In 9.0+, we have column comments for: relations, views, composite
         * types, and foreign tables (c.f. CommentObject() in comment.c).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", pg_catalog.col_description(a.attrelid, a.attnum)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_attribute a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nWHERE a.attrelid = '%s' AND a.attnum &gt; 0 AND NOT a.attisdropped"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nORDER BY a.attnum;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make title */</comment>
    <switch>switch <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"View \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged materialized view \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Materialized view \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged index \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Index \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'s'</literal></expr>:</case>
            <comment type="block">/* not used as of 8.2, but keep it for backwards compatibility */</comment>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Special relation \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"TOAST table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Composite type \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Foreign table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="block">/* untranslated unknown relkind */</comment>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><literal type="string">"?%c? \"%s.%s\""</literal></expr></argument>,
                              <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Set the number of columns, and their names */</comment>
    <expr_stmt><expr><name><name>headers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>headers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cols</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Nullable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>show_column_details</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Definition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Storage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Stats target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Column comments, if the relkind supports this feature. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
            <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>title</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>cols</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>printTableInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Get view_def if table is a view or materialized view */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
         <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_viewdef('%s'::pg_catalog.oid, true);"</literal></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>view_def</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Generate table cells to be printed */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Column */</comment>
        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Type */</comment>
        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Collation, Nullable, Default */</comment>
        <if_stmt><if>if <condition>(<expr><name>show_column_details</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>identity</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>default_str</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"not null"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>identity</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>identity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* (note: above we cut off the 'default' string at 128) */</comment>
                <expr_stmt><expr><name>default_str</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>identity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>default_str</name> <operator>=</operator> <literal type="string">"generated always as identity"</literal></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>identity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_BY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>default_str</name> <operator>=</operator> <literal type="string">"generated by default as identity"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>default_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Value: for sequences only */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>seq_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Expression for index column */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* FDW options for foreign table column, only for 9.2 or later */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Storage and Description */</comment>
        <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>firstvcol</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>storage</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>firstvcol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* these strings are literal in our syntax, so not translated. */</comment>
            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr> ?</condition><then> <expr><literal type="string">"plain"</literal></expr> </then><else>:
                                      <expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr> ?</condition><then> <expr><literal type="string">"main"</literal></expr> </then><else>:
                                       <expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr> ?</condition><then> <expr><literal type="string">"extended"</literal></expr> </then><else>:
                                        <expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr> ?</condition><then> <expr><literal type="string">"external"</literal></expr> </then><else>:
                                         <expr><literal type="string">"???"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Statistics target, if the relkind supports this feature */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
				<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>firstvcol</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Column comments, if the relkind supports this feature. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
                <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>firstvcol</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Make footers */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>ispartition</name></name></expr>)</condition>
    <block>{<block_content>
		<comment type="block">/* Footer information for a partition child table */</comment>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT inhparent::pg_catalog.regclass,\n"</literal>
						  <literal type="string">"  pg_catalog.pg_get_expr(c.relpartbound, c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* If verbose, also request the partition constraint definition */</comment>
        <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">",\n  pg_catalog.pg_get_partition_constraintdef(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
                          <literal type="string">" JOIN pg_catalog.pg_inherits i"</literal>
                          <literal type="string">" ON c.oid = inhrelid"</literal>
						  <literal type="string">"\nWHERE c.oid = '%s';"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>parent_name</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partdef</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partition of: %s %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent_name</name></expr></argument>,
                              <argument><expr><name>partdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>partconstraintdef</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            	<expr_stmt><expr><name>partconstraintdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* If there isn't any constraint, show that explicitly */</comment>
			<if_stmt><if>if <condition>(<expr><name>partconstraintdef</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>partconstraintdef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No partition constraint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partition constraint: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>partconstraintdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
		<comment type="block">/* Footer information for a partitioned table (partitioning parent) */</comment>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_partkeydef('%s'::pg_catalog.oid);"</literal></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
		   <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>partkeydef</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partition key: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partkeydef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Footer information about an index */</comment>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT i.indisunique, i.indisprimary, i.indisclustered, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"i.indisvalid,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true AS indisvalid,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                 <argument><expr><literal type="string">"  (NOT i.indimmediate) AND "</literal>
                                 <literal type="string">"EXISTS (SELECT 1 FROM pg_catalog.pg_constraint "</literal>
                                 <literal type="string">"WHERE conrelid = i.indrelid AND "</literal>
                                 <literal type="string">"conindid = i.indexrelid AND "</literal>
                                 <literal type="string">"contype IN ('p','u','x') AND "</literal>
                                 <literal type="string">"condeferrable) AS condeferrable,\n"</literal>
                                 <literal type="string">"  (NOT i.indimmediate) AND "</literal>
                                 <literal type="string">"EXISTS (SELECT 1 FROM pg_catalog.pg_constraint "</literal>
                                 <literal type="string">"WHERE conrelid = i.indrelid AND "</literal>
                                 <literal type="string">"conindid = i.indexrelid AND "</literal>
                                 <literal type="string">"contype IN ('p','u','x') AND "</literal>
                                 <literal type="string">"condeferred) AS condeferred,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                 <argument><expr><literal type="string">"  false AS condeferrable, false AS condeferred,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"i.indisreplident,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"false AS indisreplident,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  a.amname, c2.relname, "</literal>
                          <literal type="string">"pg_catalog.pg_get_expr(i.indpred, i.indrelid, true)\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_index i, pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_am a\n"</literal>
                          <literal type="string">"WHERE i.indexrelid = c.oid AND c.oid = '%s' AND c.relam = a.oid\n"</literal>
                          <literal type="string">"AND i.indrelid = c2.oid;"</literal></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error_return</name>;</goto>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indisunique</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indisprimary</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indisclustered</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indisvalid</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>deferrable</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>deferred</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indisreplident</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indamname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indtable</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indpred</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisprimary</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"primary key, "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisunique</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unique, "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><name>indamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* we assume here that index and table are in same schema */</comment>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"for table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>indtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>indpred</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", predicate (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indpred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisclustered</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", clustered"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisvalid</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", invalid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", deferrable"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>deferred</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", initially deferred"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisreplident</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", replica identity"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>add_tablespace_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr></argument>,
                                  <argument><expr><name><name>tableinfo</name><operator>.</operator><name>tablespace</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Footer information about a sequence */</comment>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Get the column that owns this sequence */</comment>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.quote_ident(nspname) || '.' ||"</literal>
                          <literal type="string">"\n   pg_catalog.quote_ident(relname) || '.' ||"</literal>
                          <literal type="string">"\n   pg_catalog.quote_ident(attname),"</literal>
                          <literal type="string">"\n   d.deptype"</literal>
                          <literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
                          <literal type="string">"\nINNER JOIN pg_catalog.pg_depend d ON c.oid=d.refobjid"</literal>
                          <literal type="string">"\nINNER JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace"</literal>
                          <literal type="string">"\nINNER JOIN pg_catalog.pg_attribute a ON ("</literal>
                          <literal type="string">"\n a.attrelid=c.oid AND"</literal>
                          <literal type="string">"\n a.attnum=d.refobjsubid)"</literal>
                          <literal type="string">"\nWHERE d.classid='pg_catalog.pg_class'::pg_catalog.regclass"</literal>
                          <literal type="string">"\n AND d.refclassid='pg_catalog.pg_class'::pg_catalog.regclass"</literal>
                          <literal type="string">"\n AND d.objid='%s'"</literal>
                          <literal type="string">"\n AND d.deptype IN ('a', 'i')"</literal></expr></argument>,
                          <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><literal type="char">'a'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Owned by: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'i'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sequence for identity column: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we get no rows back, don't show anything (obviously). We should
         * never get more than one row back, but if we do, just ignore it and
         * don't print anything.
         */</comment>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
             <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
             <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
             <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Footer information about a table */</comment>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* print indexes */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hasindex</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT c2.relname, i.indisprimary, i.indisunique, i.indisclustered, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"i.indisvalid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true as indisvalid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid, 0, true),\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                     <argument><expr><literal type="string">"pg_catalog.pg_get_constraintdef(con.oid, true), "</literal>
                                     <literal type="string">"contype, condeferrable, condeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                     <argument><expr><literal type="string">"null AS constraintdef, null AS contype, "</literal>
                                     <literal type="string">"false AS condeferrable, false AS condeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", i.indisreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", false AS indisreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", c2.reltablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                     <argument><expr><literal type="string">"  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x'))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"WHERE c.oid = '%s' AND c.oid = i.indrelid AND i.indexrelid = c2.oid\n"</literal>
                              <literal type="string">"ORDER BY i.indisprimary DESC, i.indisunique DESC, c2.relname;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Indexes:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="block">/* untranslated index name */</comment>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\""</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* If exclusion constraint, print the constraintdef */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
                                          <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexdef</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>usingpos</name></decl>;</decl_stmt>

                        <comment type="block">/* Label as primary key or unique (but not both) */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PRIMARY KEY,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"u"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" UNIQUE CONSTRAINT,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" UNIQUE,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="block">/* Everything after "USING" is echoed verbatim */</comment>
                        <expr_stmt><expr><name>indexdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>usingpos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>indexdef</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>usingpos</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>indexdef</name> <operator>=</operator> <name>usingpos</name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>indexdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* Need these for deferrable PK/UNIQUE indexes */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INITIALLY DEFERRED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="block">/* Add these for all cases */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INVALID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" REPLICA IDENTITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Print tablespace of the index on the same line */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_tablespace_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>RELKIND_INDEX</name></expr></argument>,
                                              <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print table (and column) check constraints */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>checks</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT r.conname, "</literal>
                              <literal type="string">"pg_catalog.pg_get_constraintdef(r.oid, true)\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_constraint r\n"</literal>
                              <literal type="string">"WHERE r.conrelid = '%s' AND r.contype = 'c'\n"</literal>
                              <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Check constraints:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="block">/* untranslated constraint name and def */</comment>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\" %s"</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Print foreign-key constraints (there are none if no triggers,
		 * except if the table is partitioned, in which case the triggers
		 * appear in the partitions)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
        <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal> <operator>&amp;&amp;</operator>
			        <operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>ispartition</name></name> <operator>||</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
                <comment type="block">/*
                 * Put the constraints defined in this table first, followed
                 * by the constraints defined in ancestor partitioned tables.
                 */</comment>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT conrelid = '%s'::pg_catalog.regclass AS sametable,\n"</literal>
							  <literal type="string">"  conname,\n"</literal>
							  <literal type="string">"  pg_catalog.pg_get_constraintdef(oid, true) as condef,\n"</literal>
							  <literal type="string">"  conrelid::pg_catalog.regclass AS ontable\n"</literal>
							  <literal type="string">" FROM pg_catalog.pg_constraint,\n"</literal>
					          <literal type="string">"      pg_catalog.pg_partition_ancestors('%s')\n"</literal>
							  <literal type="string">" WHERE conrelid = relid AND contype = 'f'\n"</literal>
							  <literal type="string">" ORDER BY sametable DESC, conname;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
				                  <argument><expr><literal type="string">"SELECT true as sametable, conname,\n"</literal>
				                  <literal type="string">"  pg_catalog.pg_get_constraintdef(r.oid, true) as condef,\n"</literal>
				                  <literal type="string">"  conrelid::pg_catalog.regclass AS ontable\n"</literal>
				                  <literal type="string">" FROM pg_catalog.pg_constraint r\n"</literal>
				                  <literal type="string">" WHERE r.conrelid = '%s' AND r.contype = 'f'\n"</literal></expr></argument>,
				                  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>                     <name>i_sametable</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"sametable"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
                                        <decl><type ref="prev"/><name>i_conname</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
                                        <decl><type ref="prev"/><name>i_condef</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"condef"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
                                        <decl><type ref="prev"/><name>i_ontable</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"ontable"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Foreign-key constraints:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
					<comment type="block">/*
					 * Print untranslated constraint name and definition. Use
					 * a "TABLE tab" prefix when the constraint is defined in
					 * a parent partitioned table.
					 */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sametable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					 <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    TABLE \"%s\" CONSTRAINT \"%s\" %s"</literal></expr></argument>,
                                                              <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ontable</name></expr></argument>)</argument_list></call></expr></argument>,
                                                              <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>,
                                                              <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\" %s"</literal></expr></argument>,
                                                              <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>,
                                                              <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print incoming foreign-key references (none if no triggers) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT conname, conrelid::pg_catalog.regclass,\n"</literal>
                              <literal type="string">"  pg_catalog.pg_get_constraintdef(c.oid, true) as condef\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_constraint c\n"</literal>
                              <literal type="string">"WHERE c.confrelid = '%s' AND c.contype = 'f' ORDER BY 1;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Referenced by:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    TABLE \"%s\" CONSTRAINT \"%s\" %s"</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print any row-level policies */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pol.polname,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                  <argument><expr><literal type="string">" pol.polpermissive,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                  <argument><expr><literal type="string">" 't' as polpermissive,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,\n"</literal>
                              <literal type="string">"  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),\n"</literal>
                              <literal type="string">"  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),\n"</literal>
                              <literal type="string">"  CASE pol.polcmd\n"</literal>
                              <literal type="string">"    WHEN 'r' THEN 'SELECT'\n"</literal>
                              <literal type="string">"    WHEN 'a' THEN 'INSERT'\n"</literal>
                              <literal type="string">"    WHEN 'w' THEN 'UPDATE'\n"</literal>
                              <literal type="string">"    WHEN 'd' THEN 'DELETE'\n"</literal>
                              <literal type="string">"    END AS cmd\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_policy pol\n"</literal>
                              <literal type="string">"WHERE pol.polrelid = '%s' ORDER BY 1;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * Handle cases where RLS is enabled and there are policies, or
             * there aren't policies, or RLS isn't enabled but there are
             * policies
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (forced row security enabled):"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (row security enabled): (none)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (forced row security enabled): (none)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (row security disabled):"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Might be an empty set - that's ok */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    POLICY \"%s\""</literal></expr></argument>,
                                  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS RESTRICTIVE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR %s"</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n      TO %s"</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n      USING (%s)"</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n      WITH CHECK (%s)"</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            </block_content>}</block></for>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print any extended statistics */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT oid, "</literal>
                              <literal type="string">"stxrelid::pg_catalog.regclass, "</literal>
                              <literal type="string">"stxnamespace::pg_catalog.regnamespace AS nsp, "</literal>
                              <literal type="string">"stxname,\n"</literal>
                              <literal type="string">"  (SELECT pg_catalog.string_agg(pg_catalog.quote_ident(attname),', ')\n"</literal>
                              <literal type="string">"   FROM pg_catalog.unnest(stxkeys) s(attnum)\n"</literal>
                              <literal type="string">"   JOIN pg_catalog.pg_attribute a ON (stxrelid = a.attrelid AND\n"</literal>
                              <literal type="string">"        a.attnum = s.attnum AND NOT attisdropped)) AS columns,\n"</literal>
                              <literal type="string">"  (stxkind @&gt; '{d}') AS ndist_enabled,\n"</literal>
                              <literal type="string">"  (stxkind @&gt; '{f}') AS deps_enabled\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_statistic_ext stat "</literal>
                              <literal type="string">"WHERE stxrelid = '%s'\n"</literal>
                              <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Statistics objects:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>gotone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* statistics object name (qualified with namespace) */</comment>
                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\"%s\".\"%s\" ("</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* options */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ndistinct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>gotone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%sdependencies"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>gotone</name></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") ON %s FROM %s"</literal></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print rules */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hasrules</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                  <argument><expr><literal type="string">"SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true)), "</literal>
                                  <literal type="string">"ev_enabled\n"</literal>
                                  <literal type="string">"FROM pg_catalog.pg_rewrite r\n"</literal>
                                  <literal type="string">"WHERE r.ev_class = '%s' ORDER BY 1;"</literal></expr></argument>,
                                  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                  <argument><expr><literal type="string">"SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true)), "</literal>
                                  <literal type="string">"'O'::char AS ev_enabled\n"</literal>
                                  <literal type="string">"FROM pg_catalog.pg_rewrite r\n"</literal>
                                  <literal type="string">"WHERE r.ev_class = '%s' ORDER BY 1;"</literal></expr></argument>,
                                  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>have_heading</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>category</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>category</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>category</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>category</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ruledef</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type>        <name>list_rule</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                        <switch>switch <condition>(<expr><name>category</name></expr>)</condition>
                        <block>{<block_content>
                            <case>case <expr><literal type="number">0</literal></expr>:</case>
                                <if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'O'</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">1</literal></expr>:</case>
                                <if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'D'</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">2</literal></expr>:</case>
                                <if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">3</literal></expr>:</case>
                                <if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                <break>break;</break>
                        </block_content>}</block></switch>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>list_rule</name></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_heading</name></expr>)</condition>
                        <block>{<block_content>
                            <switch>switch <condition>(<expr><name>category</name></expr>)</condition>
                            <block>{<block_content>
                                <case>case <expr><literal type="number">0</literal></expr>:</case>
                                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">1</literal></expr>:</case>
                                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled rules:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">2</literal></expr>:</case>
                                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules firing always:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">3</literal></expr>:</case>
                                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules firing on replica only:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                            </block_content>}</block></switch>
                            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="block">/* Everything after "CREATE RULE" is echoed verbatim */</comment>
                        <expr_stmt><expr><name>ruledef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ruledef</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    %s"</literal></expr></argument>, <argument><expr><name>ruledef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print any publications */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT pubname\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_publication p\n"</literal>
                              <literal type="string">"JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid\n"</literal>
                              <literal type="string">"WHERE pr.prrelid = '%s'\n"</literal>
                              <literal type="string">"UNION ALL\n"</literal>
                              <literal type="string">"SELECT pubname\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_publication p\n"</literal>
                              <literal type="string">"WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('%s')\n"</literal>
                              <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Publications:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Might be an empty set - that's ok */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\""</literal></expr></argument>,
                                  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>view_def</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Footer information about a view */</comment>
        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"View definition:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>view_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print rules */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hasrules</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_rewrite r\n"</literal>
                              <literal type="string">"WHERE r.ev_class = '%s' AND r.rulename != '_RETURN' ORDER BY 1;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ruledef</name></decl>;</decl_stmt>

                    <comment type="block">/* Everything after "CREATE RULE" is echoed verbatim */</comment>
                    <expr_stmt><expr><name>ruledef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ruledef</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>ruledef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Print triggers next, if any (but only user-defined triggers).  This
     * could apply to either a table or a view.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>tuples</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT t.tgname, "</literal>
                          <literal type="string">"pg_catalog.pg_get_triggerdef(t.oid%s), "</literal>
                          <literal type="string">"t.tgenabled, %s\n"</literal>
                          <literal type="string">"FROM pg_catalog.pg_trigger t\n"</literal>
                          <literal type="string">"WHERE t.tgrelid = '%s' AND "</literal></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr> ?</condition><then> <expr><literal type="string">", true"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr> ?</condition><then> <expr><literal type="string">"t.tgisinternal"</literal></expr> </then><else>:
                           <expr><ternary><condition><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr> ?</condition><then>
                           <expr><literal type="string">"t.tgconstraint &lt;&gt; 0 AS tgisinternal"</literal></expr> </then><else>:
                           <expr><literal type="string">"false AS tgisinternal"</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* display/warn about disabled internal triggers */</comment>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(t.tgconstraint = 0 OR (t.tgconstraint &lt;&gt; 0 AND t.tgenabled = 'D'))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                                 <argument><expr><literal type="string">"(NOT tgisconstraint "</literal>
                                 <literal type="string">" OR NOT EXISTS"</literal>
                                 <literal type="string">"  (SELECT 1 FROM pg_catalog.pg_depend d "</literal>
                                 <literal type="string">"   JOIN pg_catalog.pg_constraint c ON (d.refclassid = c.tableoid AND d.refobjid = c.oid) "</literal>
                                 <literal type="string">"   WHERE d.classid = t.tableoid AND d.objid = t.oid AND d.deptype = 'i' AND c.contype = 'f'))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>have_heading</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>category</name></decl>;</decl_stmt>

            <comment type="block">/*
             * split the output into 4 different categories. Enabled triggers,
             * disabled triggers and the two special ALWAYS and REPLICA
             * configurations.
             */</comment>
            <for>for <control>(<init><expr><name>category</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>category</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>category</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>list_trigger</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgdef</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>usingpos</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgenabled</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgisinternal</name></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Check if this trigger falls into the current category
                     */</comment>
                    <expr_stmt><expr><name>tgenabled</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tgisinternal</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <switch>switch <condition>(<expr><name>category</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><literal type="number">0</literal></expr>:</case>
                            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'O'</literal> <operator>||</operator> <operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="number">1</literal></expr>:</case>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'D'</literal> <operator>||</operator> <operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'f'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                                <operator>*</operator><name>tgisinternal</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="number">2</literal></expr>:</case>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'D'</literal> <operator>||</operator> <operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'f'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                                <operator>*</operator><name>tgisinternal</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="number">3</literal></expr>:</case>
                            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="number">4</literal></expr>:</case>
                            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                    <if_stmt><if>if <condition>(<expr><name>list_trigger</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <comment type="block">/* Print the category heading once */</comment>
                    <if_stmt><if>if <condition>(<expr><name>have_heading</name> <operator>==</operator> <name>false</name></expr>)</condition>
                    <block>{<block_content>
                        <switch>switch <condition>(<expr><name>category</name></expr>)</condition>
                        <block>{<block_content>
                            <case>case <expr><literal type="number">0</literal></expr>:</case>
                                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">1</literal></expr>:</case>
                                <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled user triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">2</literal></expr>:</case>
                                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled internal triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">3</literal></expr>:</case>
                                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Triggers firing always:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">4</literal></expr>:</case>
                                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Triggers firing on replica only:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>

                        </block_content>}</block></switch>
                        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* Everything after "TRIGGER" is echoed verbatim */</comment>
                    <expr_stmt><expr><name>tgdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>usingpos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>tgdef</name></expr></argument>, <argument><expr><literal type="string">" TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>usingpos</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>tgdef</name> <operator>=</operator> <name>usingpos</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    %s"</literal></expr></argument>, <argument><expr><name>tgdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Finish printing the footer information about a table.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
        <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>tuples</name></decl>;</decl_stmt>

        <comment type="block">/* print foreign server name */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ftoptions</name></decl>;</decl_stmt>

            <comment type="block">/* Footer information about foreign table */</comment>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT s.srvname,\n"</literal>
                              <literal type="string">"  pg_catalog.array_to_string(ARRAY(\n"</literal>
                              <literal type="string">"    SELECT pg_catalog.quote_ident(option_name)"</literal>
                              <literal type="string">" || ' ' || pg_catalog.quote_literal(option_value)\n"</literal>
                              <literal type="string">"    FROM pg_catalog.pg_options_to_table(ftoptions)),  ', ')\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_foreign_table f,\n"</literal>
                              <literal type="string">"     pg_catalog.pg_foreign_server s\n"</literal>
                              <literal type="string">"WHERE f.ftrelid = '%s' AND s.oid = f.ftserver;"</literal></expr></argument>,
                              <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error_return</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Print server name */</comment>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Server: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Print per-table FDW options, if any */</comment>
            <expr_stmt><expr><name>ftoptions</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ftoptions</name> <operator>&amp;&amp;</operator> <name><name>ftoptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"FDW options: (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ftoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print inherited tables (exclude, if parent is a partitioned table) */</comment>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass"</literal>
                          <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
                          <literal type="string">" WHERE c.oid=i.inhparent AND i.inhrelid = '%s'"</literal>
                          <literal type="string">" AND c.relkind != "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call>
                          <literal type="string">" ORDER BY inhseqno;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Inherits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>sw</name> <init>= <expr><call><name>pg_wcswidth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
                                      <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s  %s"</literal></expr></argument>,
                                      <argument><expr><name>sw</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>tuples</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* print child tables (with additional info if partitions) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass,"</literal>
							  <literal type="string">"       pg_catalog.pg_get_expr(c.relpartbound, c.oid),"</literal>
							  <literal type="string">"       c.relkind"</literal>
                              <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
                              <literal type="string">" WHERE c.oid=i.inhrelid AND i.inhparent = '%s'"</literal>
							  <literal type="string">" ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT',"</literal>
							  <literal type="string">"          c.oid::pg_catalog.regclass::pg_catalog.text;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass"</literal>
                              <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
                              <literal type="string">" WHERE c.oid=i.inhrelid AND i.inhparent = '%s'"</literal>
                              <literal type="string">" ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass"</literal>
                              <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
                              <literal type="string">" WHERE c.oid=i.inhrelid AND i.inhparent = '%s'"</literal>
                              <literal type="string">" ORDER BY c.relname;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error_return</name>;</goto></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * For a partitioned table with no partitions, always print the number
		 * of partitions as zero, even when verbose output is expected.
		 * Otherwise, we will not print "Partitions" section for a partitioned
		 * table without any partitions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Number of partitions: %d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>verbose</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* print the number of child tables, if any */</comment>
            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Number of child tables: %d (Use \\d+ to list them.)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Number of partitions: %d (Use \\d+ to list them.)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* display the list of child tables */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr> ?</condition><then>
            <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Child tables"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partitions"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>ctw</name> <init>= <expr><call><name>pg_wcswidth</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
                                          <argument><expr><name>ct</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s  %s"</literal></expr></argument>,
                                          <argument><expr><name>ctw</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitioned_note</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>partitioned_note</name> <operator>=</operator> <literal type="string">", PARTITIONED"</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>partitioned_note</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s %s%s"</literal></expr></argument>,
										  <argument><expr><name>ct</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>partitioned_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s  %s %s%s"</literal></expr></argument>,
										  <argument><expr><name>ctw</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>partitioned_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>tuples</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Table type */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>reloftype</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Typed table of type: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
             <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>

        <comment type="block">/*
         * No need to display default values; we already display a REPLICA
         * IDENTITY marker on indexes.
         */</comment>
            <name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>!=</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>!=</operator> <literal type="char">'d'</literal><operator>)</operator> <operator>||</operator>
             <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>!=</operator> <literal type="char">'n'</literal><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Replica Identity"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
                              <argument><expr><name>s</name></expr></argument>,
                              <argument><expr><ternary><condition><expr><name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>==</operator> <literal type="char">'f'</literal></expr> ?</condition><then> <expr><literal type="string">"FULL"</literal></expr> </then><else>:
                              <expr><ternary><condition><expr><name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>==</operator> <literal type="char">'n'</literal></expr> ?</condition><then> <expr><literal type="string">"NOTHING"</literal></expr> </then><else>:
                              <expr><literal type="string">"???"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* OIDs, if verbose and not a materialized view */</comment>
        <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>hasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Has OIDs: yes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Tablespace info */</comment>
        <expr_stmt><expr><call><name>add_tablespace_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>tablespace</name></name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* print distribution information */</comment>
        <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>||</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <literal type="char">'p'</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <decl_stmt><decl><type><name>int32</name></type>  <name>idistype</name>   <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>  <name>idiscol</name>    <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>  <name>idiseccol</name>  <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>  <name>ilocnodes</name>  <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>  <name>icoldnodes</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>  <name>ituple</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>  <name>ivalue</name>     <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>  <name>ihotnodes</name>  <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    
            <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>strvalue</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                    <argument><expr><literal type="string">"SELECT "</literal>
                    <literal type="string">"CASE pclocatortype WHEN '%c' THEN 'ROUND ROBIN' WHEN '%c' THEN 'REPLICATION' WHEN '%c' THEN 'HASH' WHEN '%c' THEN 'SHARD' WHEN '%c' THEN 'MODULO' END as distype,    "</literal>
                    <literal type="string">"(SELECT  attname where  a.attrelid = c.pcrelid and a.attnum = c.pcattnum) as discolumn, "</literal>
                    <literal type="string">"(SELECT  attname from pg_catalog.pgxc_class x,  pg_catalog.pg_attribute a1 where  a1.attrelid = %s and a1.attnum = x.psecondattnum and x.pcrelid = %s) as disseccolumn, "</literal>
                    <literal type="string">"CASE array_length(nodeoids, 1) WHEN nc.dn_cn THEN 'ALL DATANODES' ELSE array_to_string(ARRAY( SELECT node_name FROM pg_catalog.pgxc_node WHERE oid in (SELECT unnest(nodeoids) FROM pg_catalog.pgxc_class WHERE pcrelid = '%s') ), ', ') END as loc_nodes, "</literal>
                    <literal type="string">"CASE array_length(coldnodeoids, 1) WHEN nc.dn_cn THEN 'ALL DATANODES' ELSE array_to_string(ARRAY( SELECT node_name FROM pg_catalog.pgxc_node WHERE oid in (SELECT unnest(coldnodeoids) FROM pg_catalog.pgxc_class WHERE pcrelid = '%s') ), ', ') END as cold_nodes "</literal>
                    <literal type="string">"FROM pg_catalog.pg_attribute a right join pg_catalog.pgxc_class c on a.attrelid = c.pcrelid and a.attnum = c.pcattnum, (SELECT count(*) AS dn_cn FROM pg_catalog.pgxc_node WHERE node_type = 'D') as nc WHERE pcrelid = '%s' "</literal></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_RROBIN</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_REPLICATED</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_HASH</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_MODULO</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                        <argument><expr><literal type="string">"SELECT CASE pclocatortype \n"</literal>
                            <literal type="string">"WHEN '%c' THEN 'ROUND ROBIN' \n"</literal>
                            <literal type="string">"WHEN '%c' THEN 'REPLICATION' \n"</literal>
                            <literal type="string">"WHEN '%c' THEN 'HASH' \n"</literal>
                            <literal type="string">"WHEN '%c' THEN 'SHARD' \n"</literal>
                            <literal type="string">"WHEN '%c' THEN 'MODULO' END || CASE pcattnum WHEN 0 THEN '' ELSE '('|| a.attname ||')' END as distype \n"</literal>
                            <literal type="string">", CASE array_length(nodeoids, 1) \n"</literal>
                                <literal type="string">"WHEN nc.dn_cn THEN 'ALL DATANODES' \n"</literal>
                                <literal type="string">"ELSE array_to_string(ARRAY( \n"</literal>
                                    <literal type="string">"SELECT node_name FROM pg_catalog.pgxc_node \n"</literal>
                                    <literal type="string">"WHERE oid in (SELECT unnest(nodeoids) FROM pg_catalog.pgxc_class WHERE pcrelid = '%s' union "</literal>
                                    <literal type="string">"SELECT unnest(coldnodeoids) FROM pg_catalog.pgxc_class WHERE pcrelid = '%s') \n"</literal>
                                <literal type="string">"), ', ') END as loc_nodes \n"</literal>
                        <literal type="string">"FROM pg_catalog.pg_attribute a right join pg_catalog.pgxc_class c on a.attrelid = c.pcrelid and a.attnum = c.pcattnum, \n"</literal>
                        <literal type="string">"(SELECT count(*) AS dn_cn FROM pg_catalog.pgxc_node WHERE node_type = 'D') as nc \n"</literal>
                        <literal type="string">"WHERE pcrelid = '%s'"</literal></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_RROBIN</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_REPLICATED</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_HASH</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>
                    , <argument><expr><name>LOCATOR_TYPE_MODULO</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>
                    , <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <expr_stmt><expr><name>idistype</name>   <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"distype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idiscol</name>    <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"discolumn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idiseccol</name>  <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"disseccolumn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ilocnodes</name>  <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"loc_nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>icoldnodes</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"cold_nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dist_by</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Distribute By"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loc_nodes</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Location Nodes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <comment type="block">/* Print distribution method */</comment>
                <expr_stmt><expr><name>strvalue</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idiseccol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>strvalue</name> <operator>&amp;&amp;</operator> <name><name>strvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s %s(%s,%s)"</literal></expr></argument>, <argument><expr><name>dist_by</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idistype</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idiscol</name></expr></argument>)</argument_list></call></expr></argument>, 
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idiseccol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distype</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idistype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>distype</name></expr></argument>, <argument><expr><literal type="string">"REPLICATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                        <call><name>strcmp</name><argument_list>(<argument><expr><name>distype</name></expr></argument>, <argument><expr><literal type="string">"ROUND ROBIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>dist_by</name></expr></argument>,
                                        <argument><expr><name>distype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s(%s)"</literal></expr></argument>, <argument><expr><name>dist_by</name></expr></argument>,
                                        <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idistype</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idiscol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>strvalue</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>icoldnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>strvalue</name> <operator>&amp;&amp;</operator> <name><name>strvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Print location nodes info */</comment>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    Hotnodes:%s Coldnodes:%s"</literal></expr></argument>,
                                        <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ilocnodes</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>icoldnodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Print location nodes info */</comment>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>loc_nodes</name></expr></argument>,
                                        <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ilocnodes</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* process key values */</comment>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                        <argument><expr><literal type="string">"SELECT  k.keyvalue as value, "</literal>
                        <literal type="string">"(select array_to_string(ARRAY( SELECT node_name FROM pg_catalog.pgxc_node WHERE oid in (SELECT unnest(group_members) FROM pg_catalog.pgxc_group WHERE oid = k.nodegroup) ), ', ')) as hotnodes, "</literal>
                        <literal type="string">"(select array_to_string(ARRAY( SELECT node_name FROM pg_catalog.pgxc_node WHERE oid in (SELECT unnest(group_members) FROM pg_catalog.pgxc_group WHERE oid = k.coldnodegroup) ), ', '))  as coldnodes "</literal>
                        <literal type="string">"FROM pg_catalog.pgxc_key_value k where reloid = '%s';"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>error_return</name>;</goto></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>ivalue</name>      <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ihotnodes</name>   <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"hotnodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>icoldnodes</name>  <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"coldnodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for <control>(<init><expr><name>ituple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ituple</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>ituple</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><name>strvalue</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ituple</name></expr></argument>, <argument><expr><name>icoldnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>strvalue</name> <operator>&amp;&amp;</operator> <name><name>strvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    KeyValue: %32s Hotnodes:%s Coldnodes:%s"</literal></expr></argument>, 
                                            <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ituple</name></expr></argument>, <argument><expr><name>ivalue</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ituple</name></expr></argument>, <argument><expr><name>ihotnodes</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ituple</name></expr></argument>, <argument><expr><name>icoldnodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    KeyValue: %32s Nodes:%s"</literal></expr></argument>, 
                                            <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ituple</name></expr></argument>, <argument><expr><name>ivalue</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ituple</name></expr></argument>, <argument><expr><name>ihotnodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                
                        </block_content>}</block></else></if_stmt>    
                        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <comment type="block">/* Print distribution method */</comment>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>dist_by</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Print location nodes info */</comment>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>loc_nodes</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/*print partition info*/</comment>
        <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relpartkind</name></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT 'RANGE(' || a.attname || ')', partitions_number(c.oid),"</literal>
                            <literal type="string">"p.partdatatype, p.partstartvalue_ts :: date, p.partstartvalue_int,"</literal>
                            <literal type="string">"CASE WHEN p.partinterval_type=5  THEN p.partinterval_int || ' MONTH' "</literal>
                                <literal type="string">"WHEN p.partinterval_type=4 THEN p.partinterval_int || ' DAY' "</literal>
                                <literal type="string">"ELSE p.partinterval_int || '' END as step\n"</literal>                                
                        <literal type="string">"FROM pg_class c, pg_attribute a, pg_partition_interval p\n"</literal>
                        <literal type="string">"WHERE c.oid=a.attrelid AND c.oid=p.partrelid "</literal>
                            <literal type="string">"AND p.partpartkey=a.attnum AND c.oid='%s'"</literal></expr></argument>,
                        <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error_return</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    
            <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>partdatatype</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>part_by</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partition By"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nparts</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partitions number"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start_with</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Start With"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>interv</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Interval Of Partition"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
                <comment type="block">/* Print partition method */</comment>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>part_by</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
                <comment type="block">/* Print location nodes info */</comment>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"     %s: %s"</literal></expr></argument>, <argument><expr><name>nparts</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
                <comment type="block">/* Print start value */</comment>
                <expr_stmt><expr><name>partdatatype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>partdatatype</name></expr></argument>,<argument><expr><literal type="string">"1114"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>partdatatype</name></expr></argument>,<argument><expr><literal type="string">"1184"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"     %s: %s"</literal></expr></argument>, <argument><expr><name>start_with</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>partdatatype</name></expr></argument>,<argument><expr><literal type="string">"20"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>partdatatype</name></expr></argument>,<argument><expr><literal type="string">"21"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>partdatatype</name></expr></argument>,<argument><expr><literal type="string">"23"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"     %s: %s"</literal></expr></argument>, <argument><expr><name>start_with</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"     %s: %s"</literal></expr></argument>, <argument><expr><name>start_with</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"UNKNOW"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
                <comment type="block">/* Print interval */</comment>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"     %s: %s"</literal></expr></argument>, <argument><expr><name>interv</name></expr></argument>,
                                    <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* reloptions, if verbose */</comment>
    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator>
        <name><name>tableinfo</name><operator>.</operator><name>reloptions</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>reloptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>reloptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>error_return</name>:</label>

    <comment type="block">/* clean up */</comment>
    <if_stmt><if>if <condition>(<expr><name>printTableInitialized</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>seq_values</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>seq_values</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>seq_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>view_def</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>view_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a tablespace description to a footer.  If 'newline' is true, it is added
 * in a new line; otherwise it's appended to the current value of the last
 * footer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_tablespace_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name></type> <name>tablespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* relkinds for which we support tablespaces */</comment>
    <if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
        <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
        <name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We ignore the database default tablespace so that users not using
         * tablespaces don't need to know about them.  This case also covers
         * pre-8.0 servers, for which tablespace will always be 0.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT spcname FROM pg_catalog.pg_tablespace\n"</literal>
                              <literal type="string">"WHERE oid = '%u';"</literal></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Should always be the case, but.... */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>newline</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Add the tablespace as a new footer */</comment>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Tablespace: \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Append the tablespace to the latest footer */</comment>
                    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>footer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*-------
                       translator: before this string there's an index description like
                       '"foo_pkey" PRIMARY KEY, btree (a)' */</comment>
                    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", tablespace \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printTableSetFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * \du or \dg
 *
 * Describes roles.  Any schema portion of the pattern is ignored.
 */</comment>
<function><type><name>bool</name></type>
<name>describeRoles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printTableOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ncols</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>conns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type>    <name>align</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT r.rolname, r.rolsuper, r.rolinherit,\n"</literal>
                          <literal type="string">"  r.rolcreaterole, r.rolcreatedb, r.rolcanlogin,\n"</literal>
                          <literal type="string">"  r.rolconnlimit, r.rolvaliduntil,\n"</literal>
                          <literal type="string">"  ARRAY(SELECT b.rolname\n"</literal>
                          <literal type="string">"        FROM pg_catalog.pg_auth_members m\n"</literal>
                          <literal type="string">"        JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)\n"</literal>
                          <literal type="string">"        WHERE m.member = r.oid) as memberof"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, pg_catalog.shobj_description(r.oid, 'pg_authid') AS description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ncols</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, r.rolreplication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, r.rolbypassrls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_roles r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE r.rolname !~ '^pg_'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"r.rolname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT u.usename AS rolname,\n"</literal>
                          <literal type="string">"  u.usesuper AS rolsuper,\n"</literal>
                          <literal type="string">"  true AS rolinherit, false AS rolcreaterole,\n"</literal>
                          <literal type="string">"  u.usecreatedb AS rolcreatedb, true AS rolcanlogin,\n"</literal>
                          <literal type="string">"  -1 AS rolconnlimit,"</literal>
                          <literal type="string">"  u.valuntil as rolvaliduntil,\n"</literal>
                          <literal type="string">"  ARRAY(SELECT g.groname FROM pg_catalog.pg_group g WHERE u.usesysid = ANY(g.grolist)) as memberof"</literal>
                          <literal type="string">"\nFROM pg_catalog.pg_user u\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"u.usename"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>nrows</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>attr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of roles"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Role name"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Attributes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Member of"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Superuser"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No inheritance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Create role"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Create DB"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot login"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><literal type="number">9</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Replication"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><literal type="number">11</literal></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Bypass RLS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>conns</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>conns</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>conns</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No connections"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%d connection"</literal></expr></argument>,
                                                 <argument><expr><literal type="string">"%d connections"</literal></expr></argument>,
                                                 <argument><expr><name>conns</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>conns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Password valid until "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_role_attribute</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * \drds
 */</comment>
<function><type><name>bool</name></type>
<name>listDbRoleSettings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>havewhere</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90000</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support per-database role settings.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT rolname AS \"%s\", datname AS \"%s\",\n"</literal>
                      <literal type="string">"pg_catalog.array_to_string(setconfig, E'\\n') AS \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_db_role_setting s\n"</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_database d ON d.oid = setdatabase\n"</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_roles r ON r.oid = setrole\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Role"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Database"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Settings"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>havewhere</name> <operator>=</operator> <call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"r.rolname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern2</name></expr></argument>, <argument><expr><name>havewhere</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"d.datname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Most functions in this file are content to print an empty table when
     * there are no matching objects.  We intentionally deviate from that
     * here, but only in !quiet mode, because of the possibility that the user
     * is confused about what the two pattern arguments mean.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&amp;&amp;</operator> <name>pattern2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any settings for role \"%s\" and database \"%s\".\n"</literal></expr></argument>,
                       <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any settings for role \"%s\".\n"</literal></expr></argument>,
                       <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any settings.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of settings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * listTables()
 *
 * handler for \dt, \di, etc.
 *
 * tabtypes is an array of characters, specifying what info is desired:
 * t - tables
 * i - indexes
 * v - views
 * m - materialized views
 * s - sequences
 * E - foreign table (Note: different from 'f', the relkind value)
 * (any order of the above is fine)
 */</comment>
<function><type><name>bool</name></type>
<name>listTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabtypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showTables</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showIndexes</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showViews</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showMatViews</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'m'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showSeq</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>showForeign</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If tabtypes is empty, we default to \dtvmsE (but see also command.c) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>showTables</name> <operator>||</operator> <name>showIndexes</name> <operator>||</operator> <name>showViews</name> <operator>||</operator> <name>showMatViews</name> <operator>||</operator> <name>showSeq</name> <operator>||</operator> <name>showForeign</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>showTables</name> <operator>=</operator> <name>showViews</name> <operator>=</operator> <name>showMatViews</name> <operator>=</operator> <name>showSeq</name> <operator>=</operator> <name>showForeign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: as of Pg 8.2, we no longer use relkind 's' (special), but we keep
     * it here for backwards compatibility.
     */</comment>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  c.relname as \"%s\",\n"</literal>
                      <literal type="string">"  CASE c.relkind"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN 's' THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
                      <literal type="string">" END as \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.pg_get_userbyid(c.relowner) as \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"special"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,    <comment type="block">/* partitioned table */</comment>
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr></argument>,	<comment type="block">/* partitioned index */</comment>
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n c2.relname as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * As of PostgreSQL 9.0, use pg_table_size() to show a more accurate
         * size of a table, including FSM, VM and TOAST tables.
         */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_table_size(c.oid)) as \"%s\""</literal></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_allocated_table_size(c.oid)) as \"%s\""</literal></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allocated Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_table_size(c.oid)) as \"%s\""</literal></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_relation_size(c.oid)) as \"%s\""</literal></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  pg_catalog.obj_description(c.oid, 'pg_class') as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
                         <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"\n     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid"</literal>
                             <literal type="string">"\n     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nWHERE c.relkind IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>showTables</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
                             <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>showViews</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>showMatViews</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>showSeq</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>showSystem</name> <operator>||</operator> <name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'s',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* was RELKIND_SPECIAL */</comment>
    <if_stmt><if>if <condition>(<expr><name>showForeign</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* dummy */</comment>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* do not list all child tables/indexes */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pattern</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>showTables</name> <operator>||</operator> <name>showIndexes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  AND c.relpartkind != 'c'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * TOAST objects are suppressed unconditionally.  Since we don't provide
     * any way to select RELKIND_TOASTVALUE above, we would never show toast
     * tables in any case; it seems a bit confusing to allow their indexes to
     * be shown.  Use plain \d if you really need to look at a TOAST
     * table/index.
     */</comment>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname !~ '^pg_toast'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1,2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Most functions in this file are content to print an empty table when
     * there are no matching objects.  We intentionally deviate from that
     * here, but only in !quiet mode, for historical reasons.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relation named \"%s\".\n"</literal></expr></argument>,
                       <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relations.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of relations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dP
 * Takes an optional regexp to select particular relations
 *
 * As with \d, you can specify the kinds of relations you want:
 *
 * t for tables
 * i for indexes
 *
 * And there's additional flags:
 *
 * n to list non-leaf partitioned tables
 *
 * and you can mix and match these in any order.
 */</comment>
<function><type><name>bool</name></type>
<name>listPartitionedTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showTables</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>reltypes</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showIndexes</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>reltypes</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showNested</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>reltypes</name></expr></argument>, <argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabletitle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mixed_output</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: Declarative table partitioning is only supported as of Pg 10.0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support declarative table partitioning."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If no relation kind was selected, show them all */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showTables</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>showTables</name> <operator>=</operator> <name>showIndexes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showIndexes</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showTables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tabletitle</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of partitioned indexes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* \dPi */</comment>
	<if type="elseif">else if <condition>(<expr><name>showTables</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tabletitle</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of partitioned tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* \dPt */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/* show all kinds */</comment>
		<expr_stmt><expr><name>tabletitle</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of partitioned relations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mixed_output</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  c.relname as \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(c.relowner) as \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mixed_output</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  CASE c.relkind"</literal>
						  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
						  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
						  <literal type="string">" END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"partitioned table"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"partitioned index"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>translate_columns</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showNested</name> <operator>||</operator> <name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  c3.oid::regclass as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Parent name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n c2.oid::regclass as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"On table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>showNested</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  s.dps as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Leaf partition size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  s.tps as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Total size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* Sizes of all partitions are considered in this case. */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  s.tps as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Total size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.obj_description(c.oid, 'pg_class') as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
						 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"\n     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid"</literal>
							 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showNested</name> <operator>||</operator> <name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"\n     LEFT JOIN pg_catalog.pg_inherits inh ON c.oid = inh.inhrelid"</literal>
							 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_class c3 ON c3.oid = inh.inhparent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">120000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n     LATERAL (WITH RECURSIVE d\n"</literal>
							  <literal type="string">"                AS (SELECT inhrelid AS oid, 1 AS level\n"</literal>
							  <literal type="string">"                      FROM pg_catalog.pg_inherits\n"</literal>
							  <literal type="string">"                     WHERE inhparent = c.oid\n"</literal>
							  <literal type="string">"                    UNION ALL\n"</literal>
							  <literal type="string">"                    SELECT inhrelid, level + 1\n"</literal>
							  <literal type="string">"                      FROM pg_catalog.pg_inherits i\n"</literal>
							  <literal type="string">"                           JOIN d ON i.inhparent = d.oid)\n"</literal>
							  <literal type="string">"                SELECT pg_catalog.pg_size_pretty(sum(pg_catalog.pg_table_size("</literal>
							  <literal type="string">"d.oid))) AS tps,\n"</literal>
							  <literal type="string">"                       pg_catalog.pg_size_pretty(sum("</literal>
							  <literal type="string">"\n             CASE WHEN d.level = 1"</literal>
							  <literal type="string">" THEN pg_catalog.pg_table_size(d.oid) ELSE 0 END)) AS dps\n"</literal>
							  <literal type="string">"               FROM d) s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* PostgreSQL 12 has pg_partition_tree function */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n     LATERAL (SELECT pg_catalog.pg_size_pretty(sum("</literal>
							  <literal type="string">"\n                 CASE WHEN ppt.isleaf AND ppt.level = 1"</literal>
							  <literal type="string">"\n                      THEN pg_catalog.pg_table_size(ppt.relid)"</literal>
							  <literal type="string">" ELSE 0 END)) AS dps"</literal>
							  <literal type="string">",\n                     pg_catalog.pg_size_pretty(sum("</literal>
							  <literal type="string">"pg_catalog.pg_table_size(ppt.relid))) AS tps"</literal>
							  <literal type="string">"\n              FROM pg_catalog.pg_partition_tree(c.oid) ppt) s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nWHERE c.relkind IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>showTables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* dummy */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>showNested</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr> ?</condition><then>
						 <expr><literal type="string">" AND NOT c.relispartition\n"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * TOAST objects are suppressed unconditionally.  Since we don't provide
	 * any way to select RELKIND_TOASTVALUE above, we would never show toast
	 * tables in any case; it seems a bit confusing to allow their indexes to
	 * be shown.  Use plain \d if you really need to look at a TOAST
	 * table/index.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname !~ '^pg_toast'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY \"Schema\", %s%s\"Name\";"</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>mixed_output</name></expr> ?</condition><then> <expr><literal type="string">"\"Type\" DESC, "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>showNested</name> <operator>||</operator> <name>pattern</name></expr> ?</condition><then> <expr><literal type="string">"\"Parent name\" NULLS FIRST, "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tabletitle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dL
 *
 * Describes languages.
 */</comment>
<function><type><name>bool</name></type>
<name>listLanguages</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT l.lanname AS \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"       pg_catalog.pg_get_userbyid(l.lanowner) as \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"       l.lanpltrusted AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Trusted"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       NOT l.lanispl AS \"%s\",\n"</literal>
                          <literal type="string">"       l.lanplcallfoid::pg_catalog.regprocedure AS \"%s\",\n"</literal>
                          <literal type="string">"       l.lanvalidator::pg_catalog.regprocedure AS \"%s\",\n       "</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Internal language"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Call handler"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Validator"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"l.laninline::pg_catalog.regprocedure AS \"%s\",\n       "</literal></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Inline handler"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"l.lanacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">",\n       d.description AS \"%s\""</literal>
                      <literal type="string">"\nFROM pg_catalog.pg_language l\n"</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_description d\n"</literal>
                      <literal type="string">"  ON d.classoid = l.tableoid AND d.objoid = l.oid\n"</literal>
                      <literal type="string">"  AND d.objsubid = 0\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"l.lanname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE l.lanplcallfoid != 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of languages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dD
 *
 * Describes domains.
 */</comment>
<function><type><name>bool</name></type>
<name>listDomains</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"       t.typname as \"%s\",\n"</literal>
                      <literal type="string">"       pg_catalog.format_type(t.typbasetype, t.typtypmod) as \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"       (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type bt\n"</literal>
                          <literal type="string">"        WHERE c.oid = t.typcollation AND bt.oid = t.typbasetype AND t.typcollation &lt;&gt; bt.typcollation) as \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"       CASE WHEN t.typnotnull THEN 'not null' END as \"%s\",\n"</literal>
                      <literal type="string">"       t.typdefault as \"%s\",\n"</literal>
                      <literal type="string">"       pg_catalog.array_to_string(ARRAY(\n"</literal>
                      <literal type="string">"         SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM pg_catalog.pg_constraint r WHERE t.oid = r.contypid\n"</literal>
                      <literal type="string">"       ), ' ') as \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Nullable"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Default"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Check"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"t.typacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       d.description as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_type t\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"     LEFT JOIN pg_catalog.pg_description d "</literal>
                             <literal type="string">"ON d.classoid = t.tableoid AND d.objoid = t.oid "</literal>
                             <literal type="string">"AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE t.typtype = 'd'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.typname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of domains"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dc
 *
 * Describes conversions.
 */</comment>
<function><type><name>bool</name></type>
<name>listConversions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>=
    <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
                      <literal type="string">"       c.conname AS \"%s\",\n"</literal>
                      <literal type="string">"       pg_catalog.pg_encoding_to_char(c.conforencoding) AS \"%s\",\n"</literal>
                      <literal type="string">"       pg_catalog.pg_encoding_to_char(c.contoencoding) AS \"%s\",\n"</literal>
                      <literal type="string">"       CASE WHEN c.condefault THEN '%s'\n"</literal>
                      <literal type="string">"       ELSE '%s' END AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Source"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Destination"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Default?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       d.description AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_conversion c\n"</literal>
                         <literal type="string">"     JOIN pg_catalog.pg_namespace n "</literal>
                         <literal type="string">"ON n.oid = c.connamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_description d "</literal>
                             <literal type="string">"ON d.classoid = c.tableoid\n"</literal>
                             <literal type="string">"          AND d.objoid = c.oid "</literal>
                             <literal type="string">"AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE true\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"  AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.conname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_conversion_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of conversions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dy
 *
 * Describes Event Triggers.
 */</comment>
<function><type><name>bool</name></type>
<name>listEventTriggers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>=
    <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT evtname as \"%s\", "</literal>
                      <literal type="string">"evtevent as \"%s\", "</literal>
                      <literal type="string">"pg_catalog.pg_get_userbyid(e.evtowner) as \"%s\",\n"</literal>
                      <literal type="string">" case evtenabled when 'O' then '%s'"</literal>
                      <literal type="string">"  when 'R' then '%s'"</literal>
                      <literal type="string">"  when 'A' then '%s'"</literal>
                      <literal type="string">"  when 'D' then '%s' end as \"%s\",\n"</literal>
                      <literal type="string">" e.evtfoid::pg_catalog.regproc as \"%s\", "</literal>
                      <literal type="string">"pg_catalog.array_to_string(array(select x"</literal>
                      <literal type="string">" from pg_catalog.unnest(evttags) as t(x)), ', ') as \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Event"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"replica"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"always"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"disabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Procedure"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Tags"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\npg_catalog.obj_description(e.oid, 'pg_event_trigger') as \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_event_trigger e "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"evtname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of event triggers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dC
 *
 * Describes casts.
 */</comment>
<function><type><name>bool</name></type>
<name>listCasts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We need a left join to pg_proc for binary casts; the others are just
     * paranoia.  Also note that we don't attempt to localize '(binary
     * coercible)', because there's too much risk of gettext translating a
     * function name that happens to match some string in the PO database.
     */</comment>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT pg_catalog.format_type(castsource, NULL) AS \"%s\",\n"</literal>
                      <literal type="string">"       pg_catalog.format_type(casttarget, NULL) AS \"%s\",\n"</literal>
                      <literal type="string">"       CASE WHEN castfunc = 0 THEN '(binary coercible)'\n"</literal>
                      <literal type="string">"            ELSE p.proname\n"</literal>
                      <literal type="string">"       END as \"%s\",\n"</literal>
                      <literal type="string">"       CASE WHEN c.castcontext = 'e' THEN '%s'\n"</literal>
                      <literal type="string">"            WHEN c.castcontext = 'a' THEN '%s'\n"</literal>
                      <literal type="string">"            ELSE '%s'\n"</literal>
                      <literal type="string">"       END as \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Source type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Target type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"in assignment"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Implicit?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       d.description AS \"%s\"\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"FROM pg_catalog.pg_cast c LEFT JOIN pg_catalog.pg_proc p\n"</literal>
                         <literal type="string">"     ON c.castfunc = p.oid\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_type ts\n"</literal>
                         <literal type="string">"     ON c.castsource = ts.oid\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace ns\n"</literal>
                         <literal type="string">"     ON ns.oid = ts.typnamespace\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_type tt\n"</literal>
                         <literal type="string">"     ON c.casttarget = tt.oid\n"</literal>
                         <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace nt\n"</literal>
                         <literal type="string">"     ON nt.oid = tt.typnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"     LEFT JOIN pg_catalog.pg_description d\n"</literal>
                             <literal type="string">"     ON d.classoid = c.tableoid AND d.objoid = "</literal>
                             <literal type="string">"c.oid AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE ( (true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Match name pattern against either internal or external name of either
     * castsource or casttarget
     */</comment>
    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"ns.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"ts.typname"</literal></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.format_type(ts.oid, NULL)"</literal></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(ts.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") OR (true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"nt.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"tt.typname"</literal></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.format_type(tt.oid, NULL)"</literal></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(tt.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") )\nORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of casts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dO
 *
 * Describes collations.
 */</comment>
<function><type><name>bool</name></type>
<name>listCollations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support collations.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
                      <literal type="string">"       c.collname AS \"%s\",\n"</literal>
                      <literal type="string">"       c.collcollate AS \"%s\",\n"</literal>
                      <literal type="string">"       c.collctype AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collate"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Ctype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       CASE c.collprovider WHEN 'd' THEN 'default' WHEN 'c' THEN 'libc' WHEN 'i' THEN 'icu' END AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Provider"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n       pg_catalog.obj_description(c.oid, 'pg_collation') AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n\n"</literal>
                         <literal type="string">"WHERE n.oid = c.collnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
                             <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Hide collations that aren't usable in the current database's encoding.
     * If you think to change this, note that pg_collation_is_visible rejects
     * unusable collations, so you will need to hack name pattern processing
     * somehow to avoid inconsistent behavior.
     */</comment>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catalog.getdatabaseencoding()))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.collname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_collation_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of collations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dn
 *
 * Describes schemas (namespaces)
 */</comment>
<function><type><name>bool</name></type>
<name>listSchemas</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.pg_get_userbyid(n.nspowner) AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"n.nspacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n  pg_catalog.obj_description(n.oid, 'pg_namespace') AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"\nFROM pg_catalog.pg_namespace n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"WHERE n.nspname !~ '^pg_' AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
                          <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of schemas"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dFp
 * list text search parsers
 */</comment>
<function><type><name>bool</name></type>
<name>listTSParsers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>listTSParsersVerbose</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT\n"</literal>
                      <literal type="string">"  n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  p.prsname as \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.obj_description(p.oid, 'pg_ts_parser') as \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.prsname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_ts_parser_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search parsers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * full description of parsers
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>listTSParsersVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT p.oid,\n"</literal>
                      <literal type="string">"  n.nspname,\n"</literal>
                      <literal type="string">"  p.prsname\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace\n"</literal></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.prsname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_ts_parser_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search parser named \"%s\".\n"</literal></expr></argument>,
                           <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search parsers.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>prsname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>describeOneTSParser</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>describeOneTSParser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT '%s' AS \"%s\",\n"</literal>
                      <literal type="string">"   p.prsstart::pg_catalog.regproc AS \"%s\",\n"</literal>
                      <literal type="string">"   pg_catalog.obj_description(p.prsstart, 'pg_proc') as \"%s\"\n"</literal>
                      <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">" WHERE p.oid = '%s'\n"</literal>
                      <literal type="string">"UNION ALL\n"</literal>
                      <literal type="string">"SELECT '%s',\n"</literal>
                      <literal type="string">"   p.prstoken::pg_catalog.regproc,\n"</literal>
                      <literal type="string">"   pg_catalog.obj_description(p.prstoken, 'pg_proc')\n"</literal>
                      <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">" WHERE p.oid = '%s'\n"</literal>
                      <literal type="string">"UNION ALL\n"</literal>
                      <literal type="string">"SELECT '%s',\n"</literal>
                      <literal type="string">"   p.prsend::pg_catalog.regproc,\n"</literal>
                      <literal type="string">"   pg_catalog.obj_description(p.prsend, 'pg_proc')\n"</literal>
                      <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">" WHERE p.oid = '%s'\n"</literal>
                      <literal type="string">"UNION ALL\n"</literal>
                      <literal type="string">"SELECT '%s',\n"</literal>
                      <literal type="string">"   p.prsheadline::pg_catalog.regproc,\n"</literal>
                      <literal type="string">"   pg_catalog.obj_description(p.prsheadline, 'pg_proc')\n"</literal>
                      <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">" WHERE p.oid = '%s'\n"</literal>
                      <literal type="string">"UNION ALL\n"</literal>
                      <literal type="string">"SELECT '%s',\n"</literal>
                      <literal type="string">"   p.prslextype::pg_catalog.regproc,\n"</literal>
                      <literal type="string">"   pg_catalog.obj_description(p.prslextype, 'pg_proc')\n"</literal>
                      <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">" WHERE p.oid = '%s';"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Start parse"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Method"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Get next token"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"End parse"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Get headline"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Get token types"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search parser \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search parser \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT t.alias as \"%s\",\n"</literal>
                      <literal type="string">"  t.description as \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.ts_token_type( '%s'::pg_catalog.oid ) as t\n"</literal>
                      <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Token name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Token types for parser \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Token types for parser \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dFd
 * list text search dictionaries
 */</comment>
<function><type><name>bool</name></type>
<name>listTSDictionaries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT\n"</literal>
                      <literal type="string">"  n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"  d.dictname as \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  ( SELECT COALESCE(nt.nspname, '(null)')::pg_catalog.text || '.' || t.tmplname FROM\n"</literal>
                          <literal type="string">"    pg_catalog.pg_ts_template t\n"</literal>
                          <literal type="string">"    LEFT JOIN pg_catalog.pg_namespace nt ON nt.oid = t.tmplnamespace\n"</literal>
                          <literal type="string">"    WHERE d.dicttemplate = t.oid ) AS  \"%s\",\n"</literal>
                          <literal type="string">"  d.dictinitoption as \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Template"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Init options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"  pg_catalog.obj_description(d.oid, 'pg_ts_dict') as \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM pg_catalog.pg_ts_dict d\n"</literal>
                         <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.dictnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"d.dictname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_ts_dict_is_visible(d.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search dictionaries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dFt
 * list text search templates
 */</comment>
<function><type><name>bool</name></type>
<name>listTSTemplates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT\n"</literal>
                          <literal type="string">"  n.nspname AS \"%s\",\n"</literal>
                          <literal type="string">"  t.tmplname AS \"%s\",\n"</literal>
                          <literal type="string">"  t.tmplinit::pg_catalog.regproc AS \"%s\",\n"</literal>
                          <literal type="string">"  t.tmpllexize::pg_catalog.regproc AS \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS \"%s\"\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Init"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lexize"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"SELECT\n"</literal>
                          <literal type="string">"  n.nspname AS \"%s\",\n"</literal>
                          <literal type="string">"  t.tmplname AS \"%s\",\n"</literal>
                          <literal type="string">"  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS \"%s\"\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM pg_catalog.pg_ts_template t\n"</literal>
                         <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.tmplnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.tmplname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_ts_template_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search templates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dF
 * list text search configurations
 */</comment>
<function><type><name>bool</name></type>
<name>listTSConfigs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>listTSConfigsVerbose</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT\n"</literal>
                      <literal type="string">"   n.nspname as \"%s\",\n"</literal>
                      <literal type="string">"   c.cfgname as \"%s\",\n"</literal>
                      <literal type="string">"   pg_catalog.obj_description(c.oid, 'pg_ts_config') as \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_ts_config c\n"</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.cfgname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_ts_config_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search configurations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>listTSConfigsVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT c.oid, c.cfgname,\n"</literal>
                      <literal type="string">"   n.nspname,\n"</literal>
                      <literal type="string">"   p.prsname,\n"</literal>
                      <literal type="string">"   np.nspname as pnspname\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_ts_config c\n"</literal>
                      <literal type="string">"   LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace,\n"</literal>
                      <literal type="string">" pg_catalog.pg_ts_parser p\n"</literal>
                      <literal type="string">"   LEFT JOIN pg_catalog.pg_namespace np ON np.oid = p.prsnamespace\n"</literal>
                      <literal type="string">"WHERE  p.oid = c.cfgparser\n"</literal></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.cfgname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_ts_config_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 3, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search configuration named \"%s\".\n"</literal></expr></argument>,
                           <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search configurations.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cfgname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pnspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cfgname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>prsname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pnspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>describeOneTSConfig</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>cfgname</name></expr></argument>, <argument><expr><name>pnspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>describeOneTSConfig</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cfgname</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pnspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>,
                <decl><type ref="prev"/><name>title</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT\n"</literal>
                      <literal type="string">"  ( SELECT t.alias FROM\n"</literal>
                      <literal type="string">"    pg_catalog.ts_token_type(c.cfgparser) AS t\n"</literal>
                      <literal type="string">"    WHERE t.tokid = m.maptokentype ) AS \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.btrim(\n"</literal>
                      <literal type="string">"    ARRAY( SELECT mm.mapdict::pg_catalog.regdictionary\n"</literal>
                      <literal type="string">"           FROM pg_catalog.pg_ts_config_map AS mm\n"</literal>
                      <literal type="string">"           WHERE mm.mapcfg = m.mapcfg AND mm.maptokentype = m.maptokentype\n"</literal>
                      <literal type="string">"           ORDER BY mapcfg, maptokentype, mapseqno\n"</literal>
                      <literal type="string">"    ) :: pg_catalog.text,\n"</literal>
                      <literal type="string">"  '{}') AS \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_ts_config AS c, pg_catalog.pg_ts_config_map AS m\n"</literal>
                      <literal type="string">"WHERE c.oid = '%s' AND m.mapcfg = c.oid\n"</literal>
                      <literal type="string">"GROUP BY m.mapcfg, m.maptokentype, c.cfgparser\n"</literal>
                      <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Token"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Dictionaries"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search configuration \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search configuration \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pnspname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nParser: \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>pnspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nParser: \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dew
 *
 * Describes foreign-data wrappers
 */</comment>
<function><type><name>bool</name></type>
<name>listForeignDataWrappers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support foreign-data wrappers.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT fdw.fdwname AS \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.pg_get_userbyid(fdw.fdwowner) AS \"%s\",\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"  fdw.fdwhandler::pg_catalog.regproc AS \"%s\",\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Handler"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"  fdw.fdwvalidator::pg_catalog.regproc AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Validator"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"fdwacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n CASE WHEN fdwoptions IS NULL THEN '' ELSE "</literal>
                          <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
                          <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
                          <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
                          <literal type="string">"  pg_catalog.pg_options_to_table(fdwoptions)),  ', ') || ')' "</literal>
                          <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">",\n  d.description AS \"%s\" "</literal></expr></argument>,
                              <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_foreign_data_wrapper fdw\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_description d\n"</literal>
                             <literal type="string">"       ON d.classoid = fdw.tableoid "</literal>
                             <literal type="string">"AND d.objoid = fdw.oid AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"fdwname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of foreign-data wrappers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \des
 *
 * Describes foreign servers.
 */</comment>
<function><type><name>bool</name></type>
<name>listForeignServers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support foreign servers.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT s.srvname AS \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.pg_get_userbyid(s.srvowner) AS \"%s\",\n"</literal>
                      <literal type="string">"  f.fdwname AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Foreign-data wrapper"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"s.srvacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n"</literal>
                          <literal type="string">"  s.srvtype AS \"%s\",\n"</literal>
                          <literal type="string">"  s.srvversion AS \"%s\",\n"</literal>
                          <literal type="string">"  CASE WHEN srvoptions IS NULL THEN '' ELSE "</literal>
                          <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
                          <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
                          <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
                          <literal type="string">"  pg_catalog.pg_options_to_table(srvoptions)),  ', ') || ')' "</literal>
                          <literal type="string">"  END AS \"%s\",\n"</literal>
                          <literal type="string">"  d.description AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_foreign_server s\n"</literal>
                         <literal type="string">"     JOIN pg_catalog.pg_foreign_data_wrapper f ON f.oid=s.srvfdw\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_description d\n       "</literal>
                             <literal type="string">"ON d.classoid = s.tableoid AND d.objoid = s.oid "</literal>
                             <literal type="string">"AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"s.srvname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of foreign servers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \deu
 *
 * Describes user mappings.
 */</comment>
<function><type><name>bool</name></type>
<name>listUserMappings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support user mappings.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT um.srvname AS \"%s\",\n"</literal>
                      <literal type="string">"  um.usename AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Server"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"User name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n CASE WHEN umoptions IS NULL THEN '' ELSE "</literal>
                          <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
                          <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
                          <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
                          <literal type="string">"  pg_catalog.pg_options_to_table(umoptions)),  ', ') || ')' "</literal>
                          <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_user_mappings um\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"um.srvname"</literal></expr></argument>, <argument><expr><literal type="string">"um.usename"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of user mappings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \det
 *
 * Describes foreign tables.
 */</comment>
<function><type><name>bool</name></type>
<name>listForeignTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support foreign tables.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
                      <literal type="string">"  c.relname AS \"%s\",\n"</literal>
                      <literal type="string">"  s.srvname AS \"%s\""</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Table"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Server"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",\n CASE WHEN ftoptions IS NULL THEN '' ELSE "</literal>
                          <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
                          <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
                          <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
                          <literal type="string">"  pg_catalog.pg_options_to_table(ftoptions)),  ', ') || ')' "</literal>
                          <literal type="string">"  END AS \"%s\",\n"</literal>
                          <literal type="string">"  d.description AS \"%s\""</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_foreign_table ft\n"</literal>
                         <literal type="string">"  INNER JOIN pg_catalog.pg_class c"</literal>
                         <literal type="string">" ON c.oid = ft.ftrelid\n"</literal>
                         <literal type="string">"  INNER JOIN pg_catalog.pg_namespace n"</literal>
                         <literal type="string">" ON n.oid = c.relnamespace\n"</literal>
                         <literal type="string">"  INNER JOIN pg_catalog.pg_foreign_server s"</literal>
                         <literal type="string">" ON s.oid = ft.ftserver\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                             <argument><expr><literal type="string">"   LEFT JOIN pg_catalog.pg_description d\n"</literal>
                             <literal type="string">"          ON d.classoid = c.tableoid AND "</literal>
                             <literal type="string">"d.objoid = c.oid AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of foreign tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dx
 *
 * Briefly describes installed extensions.
 */</comment>
<function><type><name>bool</name></type>
<name>listExtensions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support extensions.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT e.extname AS \"%s\", "</literal>
                      <literal type="string">"e.extversion AS \"%s\", n.nspname AS \"%s\", c.description AS \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_extension e "</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = e.extnamespace "</literal>
                      <literal type="string">"LEFT JOIN pg_catalog.pg_description c ON c.objoid = e.oid "</literal>
                      <literal type="string">"AND c.classoid = 'pg_catalog.pg_extension'::pg_catalog.regclass\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"e.extname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of installed extensions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dx+
 *
 * List contents of installed extensions.
 */</comment>
<function><type><name>bool</name></type>
<name>listExtensionContents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support extensions.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT e.extname, e.oid\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_extension e\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"e.extname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any extension named \"%s\".\n"</literal></expr></argument>,
                           <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any extensions.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>extname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>listOneExtensionContents</name><argument_list>(<argument><expr><name>extname</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>listOneExtensionContents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT pg_catalog.pg_describe_object(classid, objid, 0) AS \"%s\"\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_depend\n"</literal>
                      <literal type="string">"WHERE refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass AND refobjid = '%s' AND deptype = 'e'\n"</literal>
                      <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Object description"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Objects in extension \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dRp
 * Lists publications.
 *
 * Takes an optional regexp to select particular publications
 */</comment>
<function><type><name>bool</name></type>
<name>listPublications</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support publications.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT pubname AS \"%s\",\n"</literal>
                      <literal type="string">"  pg_catalog.pg_get_userbyid(pubowner) AS \"%s\",\n"</literal>
                      <literal type="string">"  puballtables AS \"%s\",\n"</literal>
                      <literal type="string">"  pubinsert AS \"%s\",\n"</literal>
                      <literal type="string">"  pubupdate AS \"%s\",\n"</literal>
                      <literal type="string">"  pubdelete AS \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"All tables"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Inserts"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Updates"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Deletes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"\nFROM pg_catalog.pg_publication\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"pubname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of publications"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dRp+
 * Describes publications including the contents.
 *
 * Takes an optional regexp to select particular publications
 */</comment>
<function><type><name>bool</name></type>
<name>describePublications</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support publications.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT oid, pubname,\n"</literal>
                      <literal type="string">"  pg_catalog.pg_get_userbyid(pubowner) AS owner,\n"</literal>
                      <literal type="string">"  puballtables, pubinsert, pubupdate, pubdelete\n"</literal>
                      <literal type="string">"FROM pg_catalog.pg_publication\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"pubname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any publication named \"%s\".\n"</literal></expr></argument>,
                           <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any publications.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type>    <name>align</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>ncols</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nrows</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>tables</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>tabres</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pubid</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pubname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>puballtables</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>printTableOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Publication %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>title</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"All tables"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Inserts"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Updates"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Deletes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>puballtables</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                              <argument><expr><literal type="string">"SELECT n.nspname, c.relname\n"</literal>
                              <literal type="string">"FROM pg_catalog.pg_class c,\n"</literal>
                              <literal type="string">"     pg_catalog.pg_namespace n,\n"</literal>
                              <literal type="string">"     pg_catalog.pg_publication_rel pr\n"</literal>
                              <literal type="string">"WHERE c.relnamespace = n.oid\n"</literal>
                              <literal type="string">"  AND c.oid = pr.prrelid\n"</literal>
                              <literal type="string">"  AND pr.prpubid = '%s'\n"</literal>
                              <literal type="string">"ORDER BY 1,2"</literal></expr></argument>, <argument><expr><name>pubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tabres</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tabres</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tables</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>tables</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Tables:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>tables</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s.%s\""</literal></expr></argument>,
                                  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dRs
 * Describes subscriptions.
 *
 * Takes an optional regexp to select particular subscriptions
 */</comment>
<function><type><name>bool</name></type>
<name>describeSubscriptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>,
    <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support subscriptions.\n"</literal></expr></argument>,
                   <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                      <argument><expr><literal type="string">"SELECT subname AS \"%s\"\n"</literal>
                      <literal type="string">",  pg_catalog.pg_get_userbyid(subowner) AS \"%s\"\n"</literal>
                      <literal type="string">",  subenabled AS \"%s\"\n"</literal>
                      <literal type="string">",  subpublications AS \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Publication"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">",  subsynccommit AS \"%s\"\n"</literal>
                          <literal type="string">",  subconninfo AS \"%s\"\n"</literal></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Synchronous commit"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Conninfo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Only display subscriptions in current database. */</comment>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
                         <argument><expr><literal type="string">"FROM pg_catalog.pg_subscription\n"</literal>
                         <literal type="string">"WHERE subdbid = (SELECT oid\n"</literal>
                         <literal type="string">"                 FROM pg_catalog.pg_database\n"</literal>
                         <literal type="string">"                 WHERE datname = current_database())"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"subname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of subscriptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * printACLColumn
 *
 * Helper function for consistently formatting ACL (privilege) columns.
 * The proper targetlist entry is appended to buf.  Note lack of any
 * whitespace or comma decoration.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printACLColumn</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.array_to_string(%s, E'\\n') AS \"%s\""</literal></expr></argument>,
                          <argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
                          <argument><expr><literal type="string">"pg_catalog.array_to_string(%s, '\\n') AS \"%s\""</literal></expr></argument>,
                          <argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
