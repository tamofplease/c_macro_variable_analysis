<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/bin/psql/common.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*
 * psql - the PostgreSQL interactive terminal
 *
 * Copyright (c) 2000-2017, PostgreSQL Global Development Group
 *
 * src/bin/psql/common.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>                <comment type="block">/* for write() */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>                    <comment type="block">/* for _write() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;win32.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"settings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"crosstabview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/mbprint.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecQueryUsingCursor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>elapsed_msec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>command_no_begin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_select_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * openQueryOutputFile --- attempt to open a query output file
 *
 * fname == NULL selects stdout, else an initial '|' selects a pipe,
 * else plain file.
 *
 * Returns output file pointer into *fout, and is-a-pipe flag into *is_pipe.
 * Caller is responsible for adjusting SIGPIPE state if it's a pipe.
 *
 * On error, reports suitable error message and returns FALSE.
 */</comment>
<function><type><name>bool</name></type>
<name>openQueryOutputFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier><modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_pipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fname</name> <operator>||</operator> <name><name>fname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>fout</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>is_pipe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>fname</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>fout</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>fname</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>is_pipe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>fout</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>is_pipe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>fout</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * setQFout
 * -- handler for -o command line option and \o command
 *
 * On success, updates pset with the new output file and returns true.
 * On failure, returns false without changing pset state.
 */</comment>
<function><type><name>bool</name></type>
<name>setQFout</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_pipe</name></decl>;</decl_stmt>

    <comment type="block">/* First make sure we can open the new output file/pipe */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>openQueryOutputFile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_pipe</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Close old file/pipe */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>queryFout</name></name> <operator>!=</operator> <name>stdout</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>queryFout</name></name> <operator>!=</operator> <name>stderr</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>queryFoutPipe</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name> <operator>=</operator> <name>fout</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>queryFoutPipe</name></name> <operator>=</operator> <name>is_pipe</name></expr>;</expr_stmt>

    <comment type="block">/* Adjust SIGPIPE handling appropriately: ignore signal if is_pipe */</comment>
    <expr_stmt><expr><call><name>set_sigpipe_trap_state</name><argument_list>(<argument><expr><name>is_pipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>restore_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Variable-fetching callback for flex lexer
 *
 * If the specified variable exists, return its value as a string (malloc'd
 * and expected to be freed by the caller); else return NULL.
 *
 * If "quote" isn't PQUOTE_PLAIN, then return the value suitably quoted and
 * escaped for the specified quoting requirement.  (Failure in escaping
 * should lead to printing an error and returning NULL.)
 *
 * "passthrough" is the pointer previously given to psql_scan_set_passthrough.
 * In psql, passthrough points to a ConditionalStack, which we check to
 * determine whether variable expansion is allowed.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>psql_get_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>PsqlScanQuoteType</name></type> <name>quote</name></decl></parameter>,
                  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>passthrough</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

    <comment type="block">/* In an inactive \if branch, suppress all variable substitutions */</comment>
    <if_stmt><if>if <condition>(<expr><name>passthrough</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>conditional_active</name><argument_list>(<argument><expr><operator>(</operator><name>ConditionalStack</name><operator>)</operator> <name>passthrough</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>GetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name>quote</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PQUOTE_PLAIN</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PQUOTE_SQL_LITERAL</name></expr>:</case>
        <case>case <expr><name>PQUOTE_SQL_IDENT</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * For these cases, we use libpq's quoting functions, which
                 * assume the string is in the connection's client encoding.
                 */</comment>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>escaped_value</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"cannot escape without active connection\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>quote</name> <operator>==</operator> <name>PQUOTE_SQL_LITERAL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>escaped_value</name> <operator>=</operator>
                        <call><name>PQescapeLiteral</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>escaped_value</name> <operator>=</operator>
                        <call><name>PQescapeIdentifier</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>escaped_value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Rather than complicate the lexer's API with a notion of
                 * which free() routine to use, just pay the price of an extra
                 * strdup().
                 */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>escaped_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>escaped_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>PQUOTE_SHELL_ARG</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * For this we use appendShellStringNoError, which is
                 * encoding-agnostic, which is fine since the shell probably
                 * is too.  In any case, the only special character is "'",
                 * which is not known to appear in valid multibyte characters.
                 */</comment>
                <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>appendShellStringNoError</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"shell command argument contains a newline or carriage return: \"%s\"\n"</literal></expr></argument>,
                               <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

            <comment type="block">/* No default: we want a compiler warning for missing cases */</comment>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Error reporting for scripts. Errors should look like
 *     psql:filename:lineno: message
 */</comment>
<function><type><name>void</name></type>
<name>psql_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type>        <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>queryFout</name></name> <operator>!=</operator> <name>stdout</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>inputfile</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%s:"</literal> <name>UINT64_FORMAT</name> <literal type="string">": "</literal></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>progname</name></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>inputfile</name></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * for backend Notice messages (INFO, WARNING, etc)
 */</comment>
<function><type><name>void</name></type>
<name>NoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>arg</name></expr>;</expr_stmt>                    <comment type="block">/* not used */</comment>
    <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Code to support query cancellation
 *
 * Before we start a query, we enable the SIGINT signal catcher to send a
 * cancel request to the backend. Note that sending the cancel directly from
 * the signal handler is safe because PQcancel() is written to make it
 * so. We use write() to report to stderr because it's better to use simple
 * facilities in a signal handler.
 *
 * On win32, the signal canceling happens on a separate thread, because
 * that's how SetConsoleCtrlHandler works. The PQcancel function is safe
 * for this (unlike PQrequestCancel). However, a CRITICAL_SECTION is required
 * to protect the PGcancel structure against being changed while the signal
 * thread is using it.
 *
 * SIGINT is supposed to abort all long-running psql operations, not only
 * database queries.  In most places, this is accomplished by checking
 * cancel_pressed during long-running loops.  However, that won't work when
 * blocked on user input (in readline() or fgets()).  In those places, we
 * set sigint_interrupt_enabled TRUE while blocked, instructing the signal
 * catcher to longjmp through sigint_interrupt_jmp.  We assume readline and
 * fgets are coded to handle possible interruption.  (XXX currently this does
 * not work on win32, so control-C is less useful there)
 */</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>sigint_interrupt_enabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>sigjmp_buf</name></type>    <name>sigint_interrupt_jmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PGcancel</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>cancelConn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>CRITICAL_SECTION</name></type> <name>cancelConnLock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Write a simple string to stderr --- must be safe in a signal handler.
 * We ignore the write() result since there's not much we could do about it.
 * Certain compilers make that harder than it ought to be.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write_stderr</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        const char *str_ = (str); \
        int        rc_; \
        rc_ = write(fileno(stderr), str_, strlen(str_)); \
        (void) rc_; \
    } while (0)</cpp:value></cpp:define>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_sigint</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* if we are waiting for input, longjmp out of it */</comment>
    <if_stmt><if>if <condition>(<expr><name>sigint_interrupt_enabled</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>siglongjmp</name><argument_list>(<argument><expr><name>sigint_interrupt_jmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* else, set cancel flag to stop any long-running loops */</comment>
    <expr_stmt><expr><name>cancel_pressed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* and send QueryCancel if we are processing a database query */</comment>
    <if_stmt><if>if <condition>(<expr><name>cancelConn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancelConn</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Cancel request sent\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Could not send cancel request: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>            <comment type="block">/* just in case the write changed it */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>setup_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>handle_sigint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* WIN32 */</comment>

<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>consoleHandler</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>dwCtrlType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dwCtrlType</name> <operator>==</operator> <name>CTRL_C_EVENT</name> <operator>||</operator>
        <name>dwCtrlType</name> <operator>==</operator> <name>CTRL_BREAK_EVENT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Can't longjmp here, because we are in wrong thread :-(
         */</comment>

        <comment type="block">/* set cancel flag to stop any long-running loops */</comment>
        <expr_stmt><expr><name>cancel_pressed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* and send QueryCancel if we are processing a database query */</comment>
        <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cancelConn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancelConn</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Cancel request sent\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Could not send cancel request: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <comment type="block">/* Return FALSE for any signals not being handled */</comment>
        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>setup_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SetConsoleCtrlHandler</name><argument_list>(<argument><expr><name>consoleHandler</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* WIN32 */</comment>


<comment type="block">/* ConnectionUp
 *
 * Returns whether our backend connection is still there.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ConnectionUp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_BAD</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* CheckConnection
 *
 * Verify that we still have a good connection to the backend, and if not,
 * see if it can be restored.
 *
 * Returns true if either the connection was still there, or it could be
 * restored successfully; false otherwise.  If, however, there was no
 * connection and the session is non-interactive, this will exit the program
 * with a code of EXIT_BADCONN.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckConnection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>OK</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>ConnectionUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>OK</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>cur_cmd_interactive</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"connection to server was lost\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_BADCONN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The connection to the server was lost. Attempting reset: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQreset</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>ConnectionUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Failed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnsyncVariables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"Succeeded.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * SetCancelConn
 *
 * Set cancelConn to point to the current database connection.
 */</comment>
<function><type><name>void</name></type>
<name>SetCancelConn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>oldCancelConn</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Free the old one if we have one */</comment>
    <expr_stmt><expr><name>oldCancelConn</name> <operator>=</operator> <name>cancelConn</name></expr>;</expr_stmt>
    <comment type="block">/* be sure handle_sigint doesn't use pointer while freeing */</comment>
    <expr_stmt><expr><name>cancelConn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>oldCancelConn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>oldCancelConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cancelConn</name> <operator>=</operator> <call><name>PQgetCancel</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * ResetCancelConn
 *
 * Free the current cancel connection, if any, and set to NULL.
 */</comment>
<function><type><name>void</name></type>
<name>ResetCancelConn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>oldCancelConn</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>oldCancelConn</name> <operator>=</operator> <name>cancelConn</name></expr>;</expr_stmt>
    <comment type="block">/* be sure handle_sigint doesn't use pointer while freeing */</comment>
    <expr_stmt><expr><name>cancelConn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>oldCancelConn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>oldCancelConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * AcceptResult
 *
 * Checks whether a result is valid, giving an error message if necessary;
 * and ensures that the connection to the backend is still up.
 *
 * Returns true for valid result, false for error state.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AcceptResult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>OK</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
            <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
            <case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
            <case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
            <case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
                <comment type="block">/* Fine, do nothing */</comment>
                <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PGRES_BAD_RESPONSE</name></expr>:</case>
            <case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
            <case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
                <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"unexpected PQresultStatus: %d\n"</literal></expr></argument>,
                           <argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>OK</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>CheckConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ClearOrSaveResult
 *
 * If the result represents an error, remember it for possible display by
 * \errverbose.  Otherwise, just PQclear() it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClearOrSaveResult</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
            <case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>last_error_result</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>last_error_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>last_error_result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Print microtiming output.  Always print raw milliseconds; if the interval
 * is &gt;= 1 second, also break it down into days/hours/minutes/seconds.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintTiming</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>elapsed_msec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>seconds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>minutes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>hours</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>days</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>elapsed_msec</name> <operator>&lt;</operator> <literal type="number">1000.0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* This is the traditional (pre-v10) output format */</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Time: %.3f ms\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elapsed_msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Note: we could print just seconds, in a format like %06.3f, when the
     * total is less than 1min.  But that's hard to interpret unless we tack
     * on "s" or otherwise annotate it.  Forcing the display to include
     * minutes seems like a better solution.
     */</comment>
    <expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>elapsed_msec</name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>minutes</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>seconds</name> <operator>/</operator> <literal type="number">60.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>seconds</name> <operator>-=</operator> <literal type="number">60.0</literal> <operator>*</operator> <name>minutes</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>minutes</name> <operator>&lt;</operator> <literal type="number">60.0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Time: %.3f ms (%02d:%06.3f)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>elapsed_msec</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>hours</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>minutes</name> <operator>/</operator> <literal type="number">60.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>minutes</name> <operator>-=</operator> <literal type="number">60.0</literal> <operator>*</operator> <name>hours</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hours</name> <operator>&lt;</operator> <literal type="number">24.0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Time: %.3f ms (%02d:%02d:%06.3f)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>elapsed_msec</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>hours</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>days</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>hours</name> <operator>/</operator> <literal type="number">24.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hours</name> <operator>-=</operator> <literal type="number">24.0</literal> <operator>*</operator> <name>days</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Time: %.3f ms (%.0f d %02d:%02d:%06.3f)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>elapsed_msec</name></expr></argument>, <argument><expr><name>days</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>hours</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PSQLexec
 *
 * This is the way to send "backdoor" queries (those not directly entered
 * by the user). It is subject to -E but not -e.
 *
 * Caller is responsible for handling the ensuing processing if a COPY
 * command is sent.
 *
 * Note: we don't bother to check PQclientEncoding; it is assumed that no
 * caller uses this path to issue "SET CLIENT_ENCODING".
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PSQLexec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"You are currently not connected to a database.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>echo_hidden</name></name> <operator>!=</operator> <name>PSQL_ECHO_HIDDEN_OFF</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"********* QUERY **********\n"</literal>
                 <literal type="string">"%s\n"</literal>
                 <literal type="string">"**************************\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"********* QUERY **********\n"</literal>
                      <literal type="string">"%s\n"</literal>
                      <literal type="string">"**************************\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>echo_hidden</name></name> <operator>==</operator> <name>PSQL_ECHO_HIDDEN_NOEXEC</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AcceptResult</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PSQLexecWatch
 *
 * This function is used for \watch command to send the query to
 * the server and print out the results.
 *
 * Returns 1 if the query executed successfully, 0 if it cannot be repeated,
 * e.g., because of the interrupt, -1 on error.
 */</comment>
<function><type><name>int</name></type>
<name>PSQLexecWatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>printQueryOpt</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>elapsed_msec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>before</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>after</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"You are currently not connected to a database.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AcceptResult</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>after</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>elapsed_msec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If SIGINT is sent while the query is processing, the interrupt will be
     * consumed.  The user's intention, though, is to cancel the entire watch
     * process, so detect a sent cancellation request and exit in this case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
            <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n%s\n\n"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\\watch cannot be used with an empty query\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

        <case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
        <case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
        <case>case <expr><name>PGRES_COPY_BOTH</name></expr>:</case>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\\watch cannot be used with COPY\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

        <default>default:</default>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unexpected result status for \\watch\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Possible microtiming output */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PrintTiming</name><argument_list>(<argument><expr><name>elapsed_msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PrintNotifications: check for asynchronous notifications, and print them out
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintNotifications</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>notify</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>notify</name> <operator>=</operator> <call><name>PQnotifies</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* for backward compatibility, only show payload if nonempty */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>notify</name><operator>-&gt;</operator><name>extra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Asynchronous notification \"%s\" with payload \"%s\" received from server process with PID %d.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>, <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>be_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Asynchronous notification \"%s\" received from server process with PID %d.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>be_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * PrintQueryTuples: assuming query result is OK, print its tuples
 *
 * Returns true if successful, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PrintQueryTuples</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>results</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>my_popt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* one-shot expanded output requested via \gx */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>g_expanded</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>my_popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>expanded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* write output to \g argument, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gfname</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fout</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>is_pipe</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>openQueryOutputFile</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>gfname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_pipe</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_pipe</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>disable_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>my_popt</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>is_pipe</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>restore_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>my_popt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StoreQueryTuple: assuming query result is OK, save data into variables
 *
 * Returns true if successful, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>StoreQueryTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"no rows returned for \\gset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"more than one row returned for \\gset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>PQfname</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

            <comment type="block">/* concatenate prefix and column name */</comment>
            <expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>gset_prefix</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* for NULL value, unset rather than set the variable */</comment>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecQueryTuples: assuming query result is OK, execute each query
 * result field as a SQL statement
 *
 * Returns true if successful, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecQueryTuples</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nrows</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ncolumns</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>r</name></decl>,
                <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We must turn off gexec_flag to avoid infinite recursion.  Note that
     * this allows ExecQueryUsingCursor to be applied to the individual query
     * results.  SendQuery prevents it from being applied when fetching the
     * queries-to-execute, because it can't handle recursion either.
     */</comment>
    <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>gexec_flag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <name>nrows</name></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Abandon execution if cancel_pressed */</comment>
                <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>loop_exit</name>;</goto></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * ECHO_ALL mode should echo these queries, but SendQuery
                 * assumes that MainLoop did that, so we have to do it here.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>==</operator> <name>PSQL_ECHO_ALL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pset</name><operator>.</operator><name>singlestep</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Error - abandon execution if ON_ERROR_STOP */</comment>
                    <expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>on_error_stop</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>loop_exit</name>;</goto></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

<label><name>loop_exit</name>:</label>

    <comment type="block">/*
     * Restore state.  We know gexec_flag was on, else we'd not be here. (We
     * also know it'll get turned off at end of command, but that's not ours
     * to do here.)
     */</comment>
    <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>gexec_flag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Return true if all queries were successful */</comment>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessResult: utility function for use by SendQuery() only
 *
 * When our command string contained a COPY FROM STDIN or COPY TO STDOUT,
 * PQexec() has stopped at the PGresult associated with the first such
 * command.  In that event, we'll marshal data for the COPY and then cycle
 * through any subsequent PGresult objects.
 *
 * When the command string contained no such COPY command, this function
 * degenerates to an AcceptResult() call.
 *
 * Changes its argument to point to the last PGresult of the command string,
 * or NULL if that result was for a COPY TO STDOUT.  (Returning NULL prevents
 * the command status from being printed, which we want in that case so that
 * the status line doesn't get taken as part of the COPY data.)
 *
 * Returns true on complete success, false otherwise.  Possible failure modes
 * include purely client-side problems; check the transaction status for the
 * server-side opinion.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ProcessResult</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>results</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>first_cycle</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExecStatusType</name></type> <name>result_status</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>is_copy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>next_result</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AcceptResult</name><argument_list>(<argument><expr><operator>*</operator><name>results</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Failure at this point is always a server-side failure or a
             * failure to submit the command string.  Either way, we're
             * finished with this command string.
             */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>result_status</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><operator>*</operator><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>result_status</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
            <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
            <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
                <expr_stmt><expr><name>is_copy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
            <case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
                <expr_stmt><expr><name>is_copy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <comment type="block">/* AcceptResult() should have caught anything else. */</comment>
                <expr_stmt><expr><name>is_copy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"unexpected PQresultStatus: %d\n"</literal></expr></argument>, <argument><expr><name>result_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>is_copy</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Marshal the COPY data.  Either subroutine will get the
             * connection out of its COPY state, then call PQresultStatus()
             * once and report any error.
             *
             * If pset.copyStream is set, use that as data source/sink,
             * otherwise use queryFout or cur_cmd_source as appropriate.
             */</comment>
            <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>copystream</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>copyStream</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>copy_result</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>SetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>result_status</name> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>copystream</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>copystream</name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>handleCopyOut</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>,
                                        <argument><expr><name>copystream</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>copy_result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>success</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Suppress status printing if the report would go to the same
                 * place as the COPY data just went.  Note this doesn't
                 * prevent error reporting, since handleCopyOut did that.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>copystream</name> <operator>==</operator> <name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>copy_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>copy_result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>copystream</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>copystream</name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>cur_cmd_source</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>handleCopyIn</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>,
                                       <argument><expr><name>copystream</name></expr></argument>,
                                       <argument><expr><call><name>PQbinaryTuples</name><argument_list>(<argument><expr><operator>*</operator><name>results</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>copy_result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>success</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Replace the PGRES_COPY_OUT/IN result with COPY command's exit
             * status, or with NULL if we want to suppress printing anything.
             */</comment>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><operator>*</operator><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>results</name> <operator>=</operator> <name>copy_result</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>first_cycle</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* fast path: no COPY commands; PQexec visited all results */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Check PQgetResult() again.  In the typical case of a single-command
         * string, it will return NULL.  Otherwise, we'll have other results
         * to process that may include other COPYs.  We keep the last result.
         */</comment>
        <expr_stmt><expr><name>next_result</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>next_result</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><operator>*</operator><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>results</name> <operator>=</operator> <name>next_result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>first_cycle</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* may need this to recover from conn loss during COPY */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_cycle</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CheckConnection</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PrintQueryStatus: report command status as required
 *
 * Note: Utility function for use by PrintQueryResults() only.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintQueryStatus</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>results</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>format</name></name> <operator>==</operator> <name>PRINT_HTML</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;p&gt;"</literal></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/p&gt;\n"</literal></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>PQoidValue</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"LASTOID"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PrintQueryResults: print out (or store or execute) query results as required
 *
 * Note: Utility function for use by SendQuery() only.
 *
 * Returns true if the query executed successfully, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PrintQueryResults</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>results</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>success</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdstatus</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>results</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
            <comment type="block">/* store or execute or print the data ... */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gset_prefix</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>StoreQueryTuple</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gexec_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>ExecQueryTuples</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>crosstab_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>PrintResultsInCrosstab</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>PrintQueryTuples</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <comment type="block">/* if it's INSERT/UPDATE/DELETE RETURNING, also print status */</comment>
            <expr_stmt><expr><name>cmdstatus</name> <operator>=</operator> <call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>cmdstatus</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>strncmp</name><argument_list>(<argument><expr><name>cmdstatus</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>strncmp</name><argument_list>(<argument><expr><name>cmdstatus</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PrintQueryStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
            <expr_stmt><expr><call><name>PrintQueryStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
        <case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
            <comment type="block">/* nothing to do here */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PGRES_BAD_RESPONSE</name></expr>:</case>
        <case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
        <case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"unexpected PQresultStatus: %d\n"</literal></expr></argument>,
                       <argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendQuery: send the query string to the backend
 * (and print out results)
 *
 * Note: This is the "front door" way to send a query. That is, use it to
 * send queries actually entered by the user. These queries will be subject to
 * single step mode.
 * To send "back door" queries (generated by slash commands, etc.) in a
 * controlled way, use PSQLexec().
 *
 * Returns true if the query executed successfully, false otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>SendQuery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGTransactionStatusType</name></type> <name>transaction_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>elapsed_msec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>OK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>on_error_rollback_savepoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>on_error_rollback_warning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"You are currently not connected to a database.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>sendquery_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>singlestep</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"***(Single step mode: verify command)*******************************************\n"</literal>
                 <literal type="string">"%s\n"</literal>
                 <literal type="string">"***(press return to proceed or enter x and return to cancel)********************\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>sendquery_cleanup</name>;</goto></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>sendquery_cleanup</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>==</operator> <name>PSQL_ECHO_QUERIES</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"********* QUERY **********\n"</literal>
                  <literal type="string">"%s\n"</literal>
                  <literal type="string">"**************************\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>transaction_status</name> <operator>=</operator> <call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>transaction_status</name> <operator>==</operator> <name>PQTRANS_IDLE</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>pset</name><operator>.</operator><name>autocommit</name></name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>command_no_begin</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>sendquery_cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>transaction_status</name> <operator>=</operator> <call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>transaction_status</name> <operator>==</operator> <name>PQTRANS_INTRANS</name> <operator>&amp;&amp;</operator>
        <name><name>pset</name><operator>.</operator><name>on_error_rollback</name></name> <operator>!=</operator> <name>PSQL_ERROR_ROLLBACK_OFF</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>pset</name><operator>.</operator><name>cur_cmd_interactive</name></name> <operator>||</operator>
         <name><name>pset</name><operator>.</operator><name>on_error_rollback</name></name> <operator>==</operator> <name>PSQL_ERROR_ROLLBACK_ON</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>on_error_rollback_warning</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80000</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support savepoints for ON_ERROR_ROLLBACK.\n"</literal></expr></argument>,
                       <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                             <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>on_error_rollback_warning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT pg_psql_temporary_savepoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>sendquery_cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>on_error_rollback_savepoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>fetch_count</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pset</name><operator>.</operator><name>gexec_flag</name></name> <operator>||</operator>
        <name><name>pset</name><operator>.</operator><name>crosstab_flag</name></name> <operator>||</operator> <operator>!</operator><call><name>is_select_command</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Default fetch-it-all-and-print mode */</comment>
        <decl_stmt><decl><type><name>instr_time</name></type>    <name>before</name></decl>,
                    <decl><type ref="prev"/><name>after</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* these operations are included in the timing result: */</comment>
        <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>ProcessResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>after</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>elapsed_msec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* but printing results isn't: */</comment>
        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>&amp;&amp;</operator> <name>results</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PrintQueryResults</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Fetch-in-segments mode */</comment>
        <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>ExecQueryUsingCursor</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elapsed_msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>results</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>            <comment type="block">/* PQclear(NULL) does nothing */</comment>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>OK</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>==</operator> <name>PSQL_ECHO_ERRORS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"STATEMENT:  %s\n"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If we made a temporary savepoint, possibly release/rollback */</comment>
    <if_stmt><if>if <condition>(<expr><name>on_error_rollback_savepoint</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>svptcmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>transaction_status</name> <operator>=</operator> <call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>transaction_status</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PQTRANS_INERROR</name></expr>:</case>
                <comment type="block">/* We always rollback on an error */</comment>
                <expr_stmt><expr><name>svptcmd</name> <operator>=</operator> <literal type="string">"ROLLBACK TO pg_psql_temporary_savepoint"</literal></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PQTRANS_IDLE</name></expr>:</case>
                <comment type="block">/* If they are no longer in a transaction, then do nothing */</comment>
                <break>break;</break>

            <case>case <expr><name>PQTRANS_INTRANS</name></expr>:</case>

                <comment type="block">/*
                 * Do nothing if they are messing with savepoints themselves:
                 * If the user did RELEASE or ROLLBACK, our savepoint is gone.
                 * If they issued a SAVEPOINT, releasing ours would remove
                 * theirs.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>results</name> <operator>&amp;&amp;</operator>
                    <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                     <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"RELEASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                     <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>svptcmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>svptcmd</name> <operator>=</operator> <literal type="string">"RELEASE pg_psql_temporary_savepoint"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>PQTRANS_ACTIVE</name></expr>:</case>
            <case>case <expr><name>PQTRANS_UNKNOWN</name></expr>:</case>
            <default>default:</default>
                <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <comment type="block">/* PQTRANS_UNKNOWN is expected given a broken connection. */</comment>
                <if_stmt><if>if <condition>(<expr><name>transaction_status</name> <operator>!=</operator> <name>PQTRANS_UNKNOWN</name> <operator>||</operator> <call><name>ConnectionUp</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"unexpected transaction status (%d)\n"</literal></expr></argument>,
                               <argument><expr><name>transaction_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>svptcmd</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>svptres</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>svptres</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>svptcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>svptres</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>svptres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>sendquery_cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>svptres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Possible microtiming output */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PrintTiming</name><argument_list>(<argument><expr><name>elapsed_msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for events that may occur during query execution */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>encoding</name></name> <operator>!=</operator> <call><name>PQclientEncoding</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>PQclientEncoding</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* track effects of SET CLIENT_ENCODING */</comment>
        <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name> <operator>=</operator> <call><name>PQclientEncoding</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>encoding</name></name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>encoding</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ENCODING"</literal></expr></argument>,
                    <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PrintNotifications</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* perform cleanup that should occur after any attempted query */</comment>

<label><name>sendquery_cleanup</name>:</label>

    <comment type="block">/* reset \g's output-to-filename trigger */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gfname</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>gfname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>gfname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* reset \gx's expanded-mode flag */</comment>
    <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>g_expanded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* reset \gset trigger */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gset_prefix</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>gset_prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>gset_prefix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* reset \gexec trigger */</comment>
    <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>gexec_flag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* reset \crosstabview trigger */</comment>
    <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>crosstab_flag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>ctv_args</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecQueryUsingCursor: run a SELECT-like query using a cursor
 *
 * This feature allows result sets larger than RAM to be dealt with.
 *
 * Returns true if the query executed successfully, false otherwise.
 *
 * If pset.timing is on, total query time (exclusive of result-printing) is
 * stored into *elapsed_msec.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecQueryUsingCursor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>elapsed_msec</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>OK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>printQueryOpt</name></type> <name>my_popt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_pipe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_pager</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>started_txn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ntuples</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fetch_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>fetch_cmd</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>before</name></decl>,
                <decl><type ref="prev"/><name>after</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>flush_error</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>elapsed_msec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* initialize print options for partial table output */</comment>
    <expr_stmt><expr><name><name>my_popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>start_table</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>stop_table</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>prior_records</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* if we're not in a transaction, start one */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>AcceptResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>started_txn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send DECLARE CURSOR */</comment>
    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DECLARE _psql_cursor NO SCROLL CURSOR FOR\n%s"</literal></expr></argument>,
                      <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>AcceptResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>after</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>elapsed_msec</name> <operator>+=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * In \gset mode, we force the fetch count to be 2, so that we will throw
     * the appropriate error if the query returns more than one row.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gset_prefix</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fetch_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>fetch_count</name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>fetch_count</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fetch_cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fetch_cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
             <argument><expr><literal type="string">"FETCH FORWARD %d FROM _psql_cursor"</literal></expr></argument>,
             <argument><expr><name>fetch_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* prepare to write output to \g argument, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gfname</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>openQueryOutputFile</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>gfname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_pipe</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_pipe</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>disable_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>fout</name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_pipe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* doesn't matter */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* clear any pre-existing error indication on the output stream */</comment>
    <expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* get fetch_count tuples at a time */</comment>
        <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>fetch_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>after</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>elapsed_msec</name> <operator>+=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* shut down pager before printing error message */</comment>
            <if_stmt><if>if <condition>(<expr><name>is_pager</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ClosePager</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_pager</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>AcceptResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gset_prefix</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* StoreQueryTuple will complain if not exactly one row */</comment>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>StoreQueryTuple</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Note we do not deal with \gexec or \crosstabview modes here */</comment>

        <expr_stmt><expr><name>ntuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&lt;</operator> <name>fetch_count</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* this is the last result set, so allow footer decoration */</comment>
            <expr_stmt><expr><name><name>my_popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>stop_table</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>fout</name> <operator>==</operator> <name>stdout</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_pager</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If query requires multiple result sets, hack to ensure that
             * only one pager instance is used for the whole mess
             */</comment>
            <expr_stmt><expr><name>fout</name> <operator>=</operator> <call><name>PageOutput</name><argument_list>(<argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>my_popt</name><operator>.</operator><name>topt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>is_pager</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>my_popt</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>is_pager</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* after the first result set, disallow header decoration */</comment>
        <expr_stmt><expr><name><name>my_popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>start_table</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>my_popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>prior_records</name></name> <operator>+=</operator> <name>ntuples</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Make sure to flush the output stream, so intermediate results are
         * visible to the client immediately.  We check the results because if
         * the pager dies/exits/etc, there's no sense throwing more data at
         * it.
         */</comment>
        <expr_stmt><expr><name>flush_error</name> <operator>=</operator> <call><name>fflush</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check if we are at the end, if a cancel was pressed, or if there
         * were any errors either trying to flush out the results, or more
         * generally on the output stream at all.  If we hit any errors
         * writing things to the stream, we presume $PAGER has disappeared and
         * stop bothering to pull down more data.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&lt;</operator> <name>fetch_count</name> <operator>||</operator> <name>cancel_pressed</name> <operator>||</operator> <name>flush_error</name> <operator>||</operator>
            <call><name>ferror</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>gfname</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* close \g argument file/pipe */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_pipe</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>restore_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>is_pager</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* close transient pager */</comment>
        <expr_stmt><expr><call><name>ClosePager</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We try to close the cursor on either success or failure, but on failure
     * ignore the result (it's probably just a bleat about being in an aborted
     * transaction)
     */</comment>
    <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"CLOSE _psql_cursor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>AcceptResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>started_txn</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>OK</name></expr> ?</condition><then> <expr><literal type="string">"COMMIT"</literal></expr> </then><else>: <expr><literal type="string">"ROLLBACK"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>OK</name> <operator>&amp;=</operator> <call><name>AcceptResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ClearOrSaveResult</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>timing</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>after</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>elapsed_msec</name> <operator>+=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Advance the given char pointer over white space and SQL comments.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_white_space</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cnestlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* slash-star comment nest level */</comment>

    <while>while <condition>(<expr><operator>*</operator><name>query</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>mblen</name> <init>= <expr><call><name>PQmblen</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Note: we assume the encoding is a superset of ASCII, so that for
         * example "query[0] == '/'" is meaningful.  However, we do NOT assume
         * that the second and subsequent bytes of a multibyte character
         * couldn't look like ASCII characters; so it is critical to advance
         * by mblen, not 1, whenever we haven't exactly identified the
         * character we are skipping over.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>mblen</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>query</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>cnestlevel</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>cnestlevel</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>query</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>cnestlevel</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>cnestlevel</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>query</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

            <comment type="block">/*
             * We have to skip to end of line since any slash-star inside the
             * -- comment does NOT start a slash-star comment.
             */</comment>
            <while>while <condition>(<expr><operator>*</operator><name>query</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>query</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>query</name><operator>++</operator></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>query</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>cnestlevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>mblen</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>                <comment type="block">/* found first token */</comment>
    </block_content>}</block></while>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether a command is one of those for which we should NOT start
 * a new transaction block (ie, send a preceding BEGIN).
 *
 * These include the transaction control statements themselves, plus
 * certain statements that the backend disallows inside transaction blocks.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>command_no_begin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>wordlen</name></decl>;</decl_stmt>

    <comment type="block">/*
     * First we must advance over any whitespace and comments.
     */</comment>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check word length (since "beginx" is not "begin").
     */</comment>
    <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/*
     * Transaction control commands.  These should include every keyword that
     * gives rise to a TransactionStmt in the backend grammar, except for the
     * savepoint-related commands.
     *
     * (We assume that START must be START TRANSACTION, since there is
     * presently no other "START foo" command.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"abort"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"begin"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"start"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"commit"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"end"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"rollback"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"prepare"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* PREPARE TRANSACTION is a TC command, PREPARE foo is not */</comment>
        <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">11</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"transaction"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Commands not allowed within transactions.  The statements checked for
     * here should be exactly those that call PreventTransactionChain() in the
     * backend.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"vacuum"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"cluster"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CLUSTER with any arguments is allowed in transactions */</comment>
        <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* has additional words */</comment>
        <return>return <expr><name>true</name></expr>;</return>            <comment type="block">/* it's CLUSTER without arguments */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"create"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* CREATE [UNIQUE] INDEX CONCURRENTLY isn't allowed in xacts */</comment>
        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"unique"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

            <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">12</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"concurrently"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"alter"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <comment type="block">/* ALTER SYSTEM isn't allowed in xacts */</comment>
        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"system"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Note: these tests will match DROP SYSTEM and REINDEX TABLESPACE, which
     * aren't really valid commands so we don't care much. The other four
     * possible matches are correct.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>wordlen</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"drop"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>wordlen</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"reindex"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"system"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* DROP INDEX CONCURRENTLY isn't allowed in xacts */</comment>
        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

            <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">12</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"concurrently"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* DISCARD ALL isn't allowed in xacts, but other variants are allowed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"discard"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>query</name> <operator>+=</operator> <name>wordlen</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the specified command is a SELECT (or VALUES).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_select_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>wordlen</name></decl>;</decl_stmt>

    <comment type="block">/*
     * First advance over any whitespace, comments and left parentheses.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>skip_white_space</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>query</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Check word length (since "selectx" is not "select").
     */</comment>
    <expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>wordlen</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>query</name><index>[<expr><name>wordlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"values"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Test if the current user is a database superuser.
 *
 * Note: this will correctly detect superuserness only with a protocol-3.0
 * or newer backend; otherwise it will always say "false".
 */</comment>
<function><type><name>bool</name></type>
<name>is_superuser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"is_superuser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Test if the current session uses standard string literals.
 *
 * Note: With a pre-protocol-3.0 connection this will always say "false",
 * which should be the right answer.
 */</comment>
<function><type><name>bool</name></type>
<name>standard_strings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"standard_conforming_strings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return the session user of the current connection.
 *
 * Note: this will correctly detect the session user only with a
 * protocol-3.0 or newer backend; otherwise it will return the
 * connection user.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>session_username</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"session_authorization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>val</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>PQuser</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* expand_tilde
 *
 * substitute '~' with HOME or '~username' with username's home dir
 *
 */</comment>
<function><type><name>void</name></type>
<name>expand_tilde</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>filename</name> <operator>||</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>filename</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * WIN32 doesn't use tilde expansion for file names. Also, it uses tilde
     * for short versions of long file names, though the tilde is usually
     * toward the end, not at the beginning.
     */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

    <comment type="block">/* try tilde expansion */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>filename</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>oldp</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pw</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>home</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><name>fn</name> <operator>=</operator> <operator>*</operator><name>filename</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>home</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>fn</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

        <expr_stmt><expr><name>oldp</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>fn</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>get_home_path</name><argument_list>(<argument><expr><name>home</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* ~ or ~/ only */</comment>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>pw</name> <operator>=</operator> <call><name>getpwnam</name><argument_list>(<argument><expr><name>fn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>home</name></expr></argument>, <argument><expr><name><name>pw</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>home</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* ~user */</comment>

        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>oldp</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>home</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newfn</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>newfn</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>filename</name> <operator>=</operator> <name>newfn</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if connection string starts with either of the valid URI prefix
 * designators.
 *
 * Returns the URI prefix length, 0 if the string doesn't contain a URI prefix.
 *
 * XXX This is a duplicate of the eponymous libpq function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>uri_prefix_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* The connection URI must start with either of the following designators: */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>uri_designator</name><index>[]</index></name> <init>= <expr><literal type="string">"postgresql://"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>short_uri_designator</name><index>[]</index></name> <init>= <expr><literal type="string">"postgres://"</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>uri_designator</name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>short_uri_designator</name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>short_uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>short_uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recognized connection string either starts with a valid URI prefix or
 * contains a "=" in it.
 *
 * Must be consistent with parse_connection_string: anything for which this
 * returns true should at least look like it's parseable by that routine.
 *
 * XXX This is a duplicate of the eponymous libpq function.
 */</comment>
<function><type><name>bool</name></type>
<name>recognized_connection_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>uri_prefix_length</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<function><type><name>bool</name></type> <name>is_mls_or_audit_user_front</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"is_mls_or_audit_user"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
