<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/proxy/proxy_main.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * proxy_main.c
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      $PostgreSQL$
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_proxy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/register.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_txn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_seq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_msg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_standby.h"</cpp:file></cpp:include>
<comment type="block">/* For reconnect control lock */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_opt.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>    <name>optind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>optarg</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_MAX_PATH</name></cpp:macro>            <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_PROXY_DEFAULT_HOSTNAME</name></cpp:macro>    <cpp:value>"*"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_PROXY_DEFAULT_PORT</name></cpp:macro>        <cpp:value>6666</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_PROXY_DEFAULT_WORKERS</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_PID_FILE</name></cpp:macro>            <cpp:value>"gtm_proxy.pid"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_LOG_FILE</name></cpp:macro>            <cpp:value>"gtm_proxy.log"</cpp:value></cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PROXY_CLIENT_TIMEOUT</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>GTM_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_CLIENT_TIMEOUT</name></cpp:macro>    <cpp:value>3600</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_CLIENT_TIMEOUT</name></cpp:macro>    <cpp:value>20</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>poll_timeout_ms</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name> <init>= <expr><literal type="string">"gtm_proxy"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ListenAddresses</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>GTMProxyPortNumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>GTMProxyWorkerThreads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>GTMProxyDataDir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>GTMProxyConfigFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>GTMConfigFileName</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>GTMServerHost</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>GTMServerPortNumber</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>            <name>GTMConnectRetryInterval</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__XLOG__</name></cpp:ifdef>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>recovery_file_name</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Keepalives setup for the connection with GTM server
 */</comment>
<decl_stmt><decl><type><name>int</name></type>    <name>tcp_keepalives_idle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>    <name>tcp_keepalives_interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tcp_keepalives_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>GTMProxyNodeName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTM_ThreadID</name></type>    <name>TopMostThreadID</name></decl>;</decl_stmt>

<comment type="block">/* Communication area with SIGUSR2 signal handler */</comment>
<decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>Proxy_ThreadInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type>    <name>ReadyToReconnect</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>NewGTMServerHost</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>        <name>NewGTMServerPortNumber</name></decl>;</decl_stmt>

<comment type="block">/* Status reader/reporter */</comment>
<decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>error_reporter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>status_reader</name></decl>;</decl_stmt>

<comment type="block">/* Mode */</comment>
<decl_stmt><decl><type><name>bool</name></type>    <name>isStartUp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Reconnect Control Lock */</comment>
<decl_stmt><decl><type><name>GTM_RWLock</name></type>     <name>ReconnectControlLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jmp_buf</name></type>     <name>mainThreadSIGUSR1_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>SIGUSR1Accepted</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* If this is GTM or not */</comment>
<comment type="block">/*
 * Used to determine if given Port is in GTM or in GT_Proxy.
 * If it is in GTM, we should consider to flush GTM_Conn before
 * writing anything to Port.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>isGTM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* The socket(s) we're listening to. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXLISTEN</name></cpp:macro>    <cpp:value>64</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name><name>ListenSocket</name><index>[<expr><name>MAXLISTEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pthread_key_t</name></type>    <name>threadinfo_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>        <name>GTMProxyAbortPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>GTM_Conn</name> <modifier>*</modifier></type><name>master_conn</name></decl>;</decl_stmt>


<comment type="block">/*
 * External Routines
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>InitializeGTMOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Internal Routines
 */</comment>
<function_decl><type><specifier>static</specifier> <name>Port</name> <modifier>*</modifier></type><name>ConnCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>serverFd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConnFree</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ServerLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>initMasks</name><parameter_list>(<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>rmask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>GTMProxy_ThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GTMProxyAddConnection</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTMProxy_HandshakeConnection</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTMProxy_HandleDisconnect</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTMProxy_ProxyCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
        <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
        <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>input_message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GTM_Conn</name> <modifier>*</modifier></type><name>HandleGTMError</name><parameter_list>(<parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GTM_Conn</name> <modifier>*</modifier></type><name>HandlePostCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessTransactionCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
        <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessSnapshotCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
        <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTMProxy_RegisterPGXCNode</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
                                      <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>,
                                      <parameter><decl><type><name>GTM_PGXCNodeType</name></type> <name>remote_type</name></decl></parameter>,
                                      <parameter><decl><type><name>bool</name></type> <name>is_postmaster</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessResponse</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>,
        <parameter><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Result</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTMProxy_ProcessPendingCommands</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTMProxy_CommandPending</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
        <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>GTMProxy_CommandData</name></type> <name>cmd_data</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CreateOptsFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CreateLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ChangeToDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DeleteLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterProxy</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_reconnect</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnregisterProxy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GTM_Conn</name> <modifier>*</modifier></type><name>ConnectGTM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseCmdBackup</name><parameter_list>(<parameter><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>workerThreadReconnectToGTM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsProxiedMessage</name><parameter_list>(<parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * One-time initialization. It's called immediately after the main process
 * starts
 */</comment>
<function><type><specifier>static</specifier> <name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type>
<name>MainThreadInit</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>threadinfo_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the lock protecting the global threads info
     */</comment>
    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We are called even before memory context management is setup. We must
     * use malloc
     */</comment>
    <expr_stmt><expr><name>thrinfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_ThreadInfo</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_ThreadInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>thrinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"malloc failed: %d"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>thrinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTMProxy_ThreadInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SetMyThreadInfo</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SetMyThreadInfo failed: %d"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>TopMostThreadID</name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Bare minimum supporting infrastructure. Must be called at the very beginning
 * so that further initilization can have it ready
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitGTMProxyProcess</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><call><name>MainThreadInit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>MyThreadID</name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The memory context is now set up.
     * Add the thrinfo structure in the global array
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GTMProxy_ThreadAdd</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"GTMProxy_ThreadAdd for main thread failed: %d"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>BaseInit</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>checkDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ChangeToDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>GTMLogFile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>GTMLogFile</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>GTM_MAX_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>GTMLogFile</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>GTMProxyDataDir</name></expr></argument>, <argument><expr><name>GTM_LOG_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Initialize reconnect control lock */</comment>

    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ReconnectControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Register Proxy on GTM */</comment>
    <expr_stmt><expr><call><name>RegisterProxy</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DebugFileOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next_token</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>tok</name> <operator>=</operator> <name>line</name></expr>;</init><condition>;</condition> <incr><expr><name>tok</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tok</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>tok</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tok</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>tok</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>next_token</name> <operator>=</operator> <name>tok</name></expr>;</init><condition>;</condition> <incr><expr><name>next_token</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>next_token</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>next_token</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>next_token</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator><name>tok</name><operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>next_token</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>next_token</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition>

        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>next_token</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <name>next_token</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator><name>tok</name><operator>)</operator></expr>;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* Never comes here.  Keep compiler quiet. */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Returns non-zero if failed.
 * We assume that current working directory is that specified by -D option.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXLINE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_RECONNECT_OPTION_MSG</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do{ \
        ereport(ERROR, (0, errmsg("Invalid Reconnect Option"))); \
    } while(0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>GTMProxy_ReadReconnectInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>

    <decl_stmt><decl><type><name>char</name></type> <name><name>optstr</name><index>[<expr><name>MAXLINE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>optarg_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next_token</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>optarg_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"newgtm"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>optarg_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>INVALID_RECONNECT_OPTION_MSG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>fgets</name><argument_list>(<argument><expr><name>optstr</name></expr></argument>, <argument><expr><name>MAXLINE</name></expr></argument>, <argument><expr><name>optarg_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>INVALID_RECONNECT_OPTION_MSG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>optarg_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"reconnect option = \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>next_token</name> <operator>=</operator> <name>optstr</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>option</name> <operator>=</operator> <call><name>read_token</name><argument_list>(<argument><expr><name>next_token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_token</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"-t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>    <comment type="block">/* New GTM port */</comment>
        <block>{<block_content>
            <expr_stmt><expr><name>optValue</name> <operator>=</operator> <call><name>read_token</name><argument_list>(<argument><expr><name>next_token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>optValue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>INVALID_RECONNECT_OPTION_MSG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>NewGTMServerPortNumber</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"-s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>optValue</name> <operator>=</operator> <call><name>read_token</name><argument_list>(<argument><expr><name>next_token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>optValue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>INVALID_RECONNECT_OPTION_MSG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>NewGTMServerHost</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>NewGTMServerHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>NewGTMServerHost</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>INVALID_RECONNECT_OPTION_MSG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_SigleHandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Received signal %d\n"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>signal</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>SIGKILL</name></expr>:</case>
        <case>case <expr><name>SIGTERM</name></expr>:</case>
        <case>case <expr><name>SIGQUIT</name></expr>:</case>
        <case>case <expr><name>SIGINT</name></expr>:</case>
        <case>case <expr><name>SIGHUP</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>SIGUSR1</name></expr>:</case>    <comment type="block">/* Reconnect from gtm_ctl */</comment>
            <comment type="block">/*
             * Only the main thread can distribute SIGUSR2 to avoid lock contention
             * of the thread info. If an other thread receives SIGUSR1, it will proxy
             * SIGUSR1 to the main thread.
             *
             * The mask is set to block signals.  They're blocked until all the
             * threads reconnect to the new GTM.
             */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Accepted SIGUSR1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>MyThreadID</name> <operator>!=</operator> <name>TopMostThreadID</name></expr>)</condition>
            <block>{<block_content>

                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Not on main thread, proxy the signal to the main thread."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr><name>TopMostThreadID</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * Then this is the main thread.
             */</comment>
            <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"I'm the main thread. Accepted SIGUSR1."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Set Reconnect Info
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ReadyToReconnect</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SIGUSR1 detected, but not ready to handle this. Ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SIGUSR1 detected. Set reconnect info for each worker thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>GTMProxy_ReadReconnectInfo</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Failed to read reconnect information from reconnect data file */</comment>
                <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * Send SIGUSR2 to all worker threads.
             * Check if all the worker threads can accept SIGUSR2
             */</comment>
            <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>GTMProxyWorkerThreads</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Proxy_ThreadInfo</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><name><name>Proxy_ThreadInfo</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>can_accept_SIGUSR2</name> <operator>==</operator> <name>FALSE</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Some worker thread is not ready to handle this. Retry reconnection later.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <comment type="block">/*
             * Before send SIGUSR2 to worker threads, acquire reconnect control lock in write mode
             * so that worker threads wait until main thread reconnects to new GTM and register
             * itself.
             */</comment>
            <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ReconnectControlLock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* We cannot accept the next SIGUSR1 until all the reconnect is finished. */</comment>
            <expr_stmt><expr><name>ReadyToReconnect</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Issue SIGUSR2 to all the worker threads.
             * It will not be issued to the main thread.
             */</comment>
            <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>GTMProxyWorkerThreads</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr><name><name>Proxy_ThreadInfo</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>thr_id</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SIGUSR2 issued to all the worker threads."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Note that during connection handling with backends, signals are blocked
             * so it is safe to longjump here.
             */</comment>
            <expr_stmt><expr><call><name>siglongjmp</name><argument_list>(<argument><expr><name>mainThreadSIGUSR1_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>SIGUSR2</name></expr>:</case>  <comment type="block">/* Reconnect from the main thread */</comment>
            <comment type="block">/* Main thread has nothing to do twith this signal and should not receive this. */</comment>
            <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Detected SIGUSR2, thread:%ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>MyThreadID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>MyThreadID</name> <operator>==</operator> <name>TopMostThreadID</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* This should not be reached. Just in case. */</comment>

                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SIGUSR2 received by the main thread.  Ignoring."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>reconnect_issued</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>can_longjmp</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>siglongjmp</name><argument_list>(<argument><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>longjmp_env</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>

        <default>default:</default>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown signal %d\n"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
    </block_content>}</block></switch>

    <comment type="block">/* Unregister Proxy on GTM */</comment>
    <expr_stmt><expr><call><name>UnregisterProxy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * XXX We should do a clean shutdown here.
     */</comment>
    <comment type="block">/* Delete pid file before shutting down */</comment>
    <expr_stmt><expr><call><name>DeleteLockFile</name><argument_list>(<argument><expr><name>GTM_PID_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>GTMProxyAbortPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Help display should match
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This is the GTM proxy.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n  %s [OPTION]...\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h hostname        GTM proxy hostname/IP\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p port            GTM proxy port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s hostname        GTM server hostname/IP \n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t port            GTM server port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -i nodename     GTM proxy nodename\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n count        Number of worker threads\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -D directory    GTM proxy working directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -l filename        GTM proxy log file name \n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --help          show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>opt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Variable to store option parameters
     */</comment>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>listen_addresses</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>node_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>proxy_port_number</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>proxy_worker_threads</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>data_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>log_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>gtm_host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>gtm_port</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>isStartUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/*
     * At first, initialize options.
     */</comment>
    <expr_stmt><expr><call><name>InitializeGTMOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 
     * Also initialize bare minimum supporting infrastructure such as memory
     * context and thread control structure
     */</comment>
    <expr_stmt><expr><call><name>InitGTMProxyProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Catch standard options before doing much else
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>help</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ListenAddresses</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>GTM_PROXY_DEFAULT_HOSTNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>GTMProxyPortNumber</name> <operator>=</operator> <name>GTM_PROXY_DEFAULT_PORT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>GTMProxyWorkerThreads</name> <operator>=</operator> <name>GTM_PROXY_DEFAULT_WORKERS</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>NewGTMServerHost</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Parse the command like options and set variables
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"h:i:p:n:D:l:s:t:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>opt</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'h'</literal></expr>:</case>
                <comment type="block">/* Listen address of the proxy */</comment>
                <if_stmt><if>if <condition>(<expr><name>listen_addresses</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>listen_addresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>listen_addresses</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'i'</literal></expr>:</case>
                <comment type="block">/* GTM Proxy identification name */</comment>
                <if_stmt><if>if <condition>(<expr><name>node_name</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>node_name</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'p'</literal></expr>:</case>
                <comment type="block">/* Port number for the proxy to listen on */</comment>
                <if_stmt><if>if <condition>(<expr><name>proxy_port_number</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>proxy_port_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>proxy_port_number</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                <comment type="block">/* Number of worker threads */</comment>
                <if_stmt><if>if <condition>(<expr><name>proxy_worker_threads</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>proxy_worker_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>proxy_worker_threads</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'D'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>data_dir</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>data_dir</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>data_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'l'</literal></expr>:</case>
                <comment type="block">/* The log file */</comment>
                <if_stmt><if>if <condition>(<expr><name>log_file</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>log_file</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'s'</literal></expr>:</case>
                <comment type="block">/* GTM server host name */</comment>
                <if_stmt><if>if <condition>(<expr><name>gtm_host</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>gtm_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>gtm_host</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                <comment type="block">/* GTM server port number */</comment>
                <if_stmt><if>if <condition>(<expr><name>gtm_port</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>gtm_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>gtm_port</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                             <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <comment type="block">/*
     * Setup working directory
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>data_dir</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"data_dir"</literal></expr></argument>, <argument><expr><name>data_dir</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Setup configuration file
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SelectConfigFiles</name><argument_list>(<argument><expr><name>data_dir</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Parse config file
     */</comment>
    <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>GTMC_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Override with command line options.   "data_dir" was handled in the privious line.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>listen_addresses</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>GTM_OPTNAME_LISTEN_ADDRESSES</name></expr></argument>, <argument><expr><name>listen_addresses</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>listen_addresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>listen_addresses</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>node_name</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>GTM_OPTNAME_NODENAME</name></expr></argument>, <argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>node_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>proxy_port_number</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>GTM_OPTNAME_PORT</name></expr></argument>, <argument><expr><name>proxy_port_number</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>proxy_port_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>proxy_port_number</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>proxy_worker_threads</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>GTM_OPTNAME_WORKER_THREADS</name></expr></argument>, <argument><expr><name>proxy_worker_threads</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>proxy_worker_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>proxy_worker_threads</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>log_file</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>GTM_OPTNAME_LOG_FILE</name></expr></argument>, <argument><expr><name>log_file</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>log_file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>gtm_host</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>GTM_OPTNAME_GTM_HOST</name></expr></argument>, <argument><expr><name>gtm_host</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>gtm_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>gtm_host</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>gtm_port</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>GTM_OPTNAME_GTM_PORT</name></expr></argument>, <argument><expr><name>gtm_port</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>gtm_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>gtm_port</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/*
     * Check Options
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>GTMProxyDataDir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"GTM Proxy data directory must be specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>GTMProxyNodeName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"GTM Proxy Node name must be specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ListenAddresses</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>ListenAddresses</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"GTM Proxy listen addresses must be specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>GTMProxyPortNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"GTM Proxy port number must be specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>GTMServerHost</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>GTMServerHost</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"GTM server listen address must be specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>GTMServerPortNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"GTM server port number must be specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * GTM accepts no non-option switch arguments.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument: \"%s\"\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Some basic initialization must happen before we do anything
     * useful
     */</comment>
    <expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Starting GTM proxy at (%s:%d)"</literal></expr></argument>, <argument><expr><name>ListenAddresses</name></expr></argument>, <argument><expr><name>GTMProxyPortNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Establish input sockets.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>ListenAddresses</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ListenAddresses</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>StreamServerPort</name><argument_list>(<argument><expr><name>AF_UNSPEC</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>GTMProxyPortNumber</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><name>ListenSocket</name></expr></argument>, <argument><expr><name>MAXLISTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>StreamServerPort</name><argument_list>(<argument><expr><name>AF_UNSPEC</name></expr></argument>, <argument><expr><name>ListenAddresses</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>GTMProxyPortNumber</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><name>ListenSocket</name></expr></argument>, <argument><expr><name>MAXLISTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>success</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create listen socket for \"%s\""</literal></expr></argument>,
                            <argument><expr><name>ListenAddresses</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * check that we have some socket to listen on
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no socket created for listening"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Record gtm proxy options.  We delay this till now to avoid recording
     * bogus options
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateOptsFile</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>GTMProxy_SigleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGKILL</name></expr></argument>, <argument><expr><name>GTMProxy_SigleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>GTMProxy_SigleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>GTMProxy_SigleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>GTMProxy_SigleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>GTMProxy_SigleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>GTMProxy_SigleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pqinitmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize SIGUSR2 interface area (Thread info)
     */</comment>
    <expr_stmt><expr><name>Proxy_ThreadInfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTMProxy_ThreadInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>GTMProxyWorkerThreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Pre-fork so many worker threads
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GTMProxyWorkerThreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * XXX Start the worker thread
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>GTMProxy_ThreadCreate</name><argument_list>(<argument><expr><name>GTMProxy_ThreadMain</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create a new thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>STATUS_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Accept any new connections. Add for each incoming connection to one of
     * the pre-forked threads.
     */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ServerLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * ServerLoop probably shouldn't ever return, but if it does, close down.
     */</comment>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>status</name> <operator>!=</operator> <name>STATUS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* not reached */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * ConnCreate -- create a local connection data structure
 */</comment>
<function><type><specifier>static</specifier> <name>Port</name> <modifier>*</modifier></type>
<name>ConnCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>serverFd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Port</name>       <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>port</name> <operator>=</operator> <operator>(</operator><name>Port</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Port</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><name>ENOMEM</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>StreamConnection</name><argument_list>(<argument><expr><name>serverFd</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>conn_id</name></name> <operator>=</operator> <name>InvalidGTMProxyConnID</name></expr>;</expr_stmt>

    <return>return <expr><name>port</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ConnFree -- free a local connection data structure
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConnFree</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main idle loop of postmaster
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ServerLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>readmask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nSockets</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nSockets</name> <operator>=</operator> <call><name>initMasks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>readmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>fd_set</name></type>        <name>rmask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>selres</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>mainThreadSIGUSR1_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Reconnect!
             * Use RegisterProxy() call. Before this, change connection information
             * of GTM to the new one.
             * Because this is done while ReconnectControlLock is acquired,
             * worker threads can use this change and they don't have to worry about
             * new connection point.
             *
             * Because we leave the old socket as is, there could be some waste of
             * the resource but this may not happen so many times.
             */</comment>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Main Thread reconnecting to new GTM."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RegisterProxy</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Reconnected."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If it is done, then release the lock for worker threads. */</comment>
            <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ReconnectControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * Delay the point to accept reconnect until here because
         * longjmp buffer has not been prepared.
         */</comment>
        <expr_stmt><expr><name>ReadyToReconnect</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Wait for a connection request to arrive.
         *
         * Wait at most one minute, to ensure that the other background
         * tasks handled below get done even when no requests are arriving.
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rmask</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>readmask</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>GTMProxyAbortPending</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Tell everybody that we are shutting down
             *
             * !! TODO
             */</comment>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <block>{<block_content>
            <comment type="block">/* must set timeout each time; some OSes change it! */</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>selres</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>nSockets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * Block all signals until we wait again.  (This makes it safe for our
         * signal handlers to do nontrivial work.)
         */</comment>
        <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now check the select() result */</comment>
        <if_stmt><if>if <condition>(<expr><name>selres</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"select() failed in main thread: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>STATUS_ERROR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * New connection pending on any of our sockets? If so, accept the
         * connection and add it to one of the worker threads.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>selres</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmask</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Port</name>       <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>ConnCreate</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>port</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>GTMProxyAddConnection</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Initialise the masks for select() for the ports we are listening on.
 * Return the number of sockets to listen on.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>initMasks</name><parameter_list>(<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>rmask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxsock</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>rmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>fd</name> <init>= <expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>rmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <name>maxsock</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>maxsock</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The main worker thread routine
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>GTMProxy_ThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><operator>(</operator><name>GTMProxy_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>qtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>input_message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>  <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>saved_seqno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>nrfds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>gtm_connect_string</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>first_turn</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Used only to set longjmp target at the first turn of thread loop */</comment>
    <decl_stmt><decl><type><name>GTMProxy_CommandData</name></type> <name>cmd_data</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Starting the connection helper thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the memory context we will use in the main loop.
     *
     * MessageContext is reset once per iteration of the main loop, ie, upon
     * completion of processing of each command message from the client.
     *
     * This context is thread-specific
     */</comment>
    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                           <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                           <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set up connection with the GTM server
     */</comment>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>gtm_connect_string</name></expr></argument>, <argument><expr><literal type="string">"host=%s port=%d node_name=%s remote_type=%d"</literal></expr></argument>,
            <argument><expr><name>GTMServerHost</name></expr></argument>, <argument><expr><name>GTMServerPortNumber</name></expr></argument>, <argument><expr><name>GTMProxyNodeName</name></expr></argument>, <argument><expr><name>GTM_NODE_GTM_PROXY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name> <operator>=</operator> <call><name>PQconnectGTM</name><argument_list>(<argument><expr><name>gtm_connect_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"GTM connection failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Get the input_message in the TopMemoryContext so that we don't need to
     * free/palloc it for every incoming message. Unlike Postgres, we don't
     * expect the incoming messages to be of arbitrary sizes
     */</comment>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>reconnect_issued</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize comand backup area
     */</comment>
    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>GTM_PROXY_MAX_CONNECTIONS</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_any_backup</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_qtype</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_inBufData</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * NOTE: if you are tempted to add more code in this if-block,
         * consider the high probability that it should be in
         * AbortTransaction() instead.    The only stuff done directly here
         * should be stuff that is guaranteed to apply *only* for outer-level
         * error recovery, such as adjusting the FE/BE protocol status.
         */</comment>

        <comment type="block">/* Report the error to the client and/or server log */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>connIndx</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>connIndx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                
                <comment type="block">/*
                 * Now clean up disconnected connections
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_disconnected</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>GTMProxy_ThreadRemoveConnection</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>, <argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ii</name><operator>--</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * Consume all the pending data on this connection and send
                     * error report
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>!=</operator> <name>MSG_TYPE_INVALID</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>PqRecvPointer</name></name> <operator>=</operator> <name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>PqRecvLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>MSG_TYPE_INVALID</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Now we're entering thread loop. The last work is to initialize SIGUSR2 control.
     */</comment>
    <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>can_accept_SIGUSR2</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>reconnect_issued</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>can_longjmp</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

    <comment type="block">/*--------------------------------------------------------------
     * Thread Loop
     *-------------------------------------------------------------
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>gtm_ListCell</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GTM_Result</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Release storage left over from prior query cycle, and create a new
         * query input buffer in the cleared MessageContext.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * The following block should be skipped at the first turn.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_turn</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Check if there are any changes to the connection array assigned to
             * this thread. If so, we need to rebuild the fd array.
             */</comment>
            <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>saved_seqno</name> <operator>!=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_seqno</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>saved_seqno</name> <operator>=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_seqno</name></name></expr>;</expr_stmt>

                <while>while <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * No connections assigned to the thread. Wait for at least one
                     * connection to be assigned to us
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>longjmp_env</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>GTM_CVWait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_cv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* SIGUSR2 here */</comment>
                        <expr_stmt><expr><call><name>workerThreadReconnectToGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></while>

                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Now grab all the open connections. A lock is being hold so no
                 * new connections can be added.
                 */</comment>
                <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>connIndx</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>connIndx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Detect if the connection has been dropped to avoid
                     * a segmentation fault.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_disconnected</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * If this is a newly added connection, complete the handshake
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conninfo</name><operator>-&gt;</operator><name>con_authenticated</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>GTMProxy_HandshakeConnection</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while>while <condition>(<expr><name>true</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nrfds</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name></name></expr></argument>, <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr></argument>,
                            <argument><expr><name>poll_timeout_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>nrfds</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"poll returned with error %d"</literal></expr></argument>, <argument><expr><name>nrfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></else></if_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><name>nrfds</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Initialize the lists
             */</comment>
            <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Each SIGUSR2 should return here and please note that from the beginning
         * of the outer loop, longjmp is disabled and signal handler will simply return
         * so that we don't have to be botherd with the memory context. We should be
         * sure to be in MemoryContext where siglongjmp() is issued.
         */</comment>
<label><name>setjmp_again</name>:</label>
        <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>longjmp_env</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * SIGUSR2 is detected and jumped here
             * Reconnection phase
             */</comment>
            <expr_stmt><expr><call><name>workerThreadReconnectToGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Correction of pending works.
             */</comment>
            <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>MSG_TYPE_COUNT</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>gtm_list_free_deep</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>
            <goto>goto <name>setjmp_again</name>;</goto>    <comment type="block">/* Get ready for another SIGUSR2 */</comment>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>first_turn</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>first_turn</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Just reset the input buffer to avoid repeated palloc/pfrees
         *
         * XXX We should consider resetting the MessageContext periodically to
         * handle any memory leaks
         */</comment>
        <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now, read command from each of the connections that has some data to
         * be read.
         */</comment>
        <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>connIndx</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>connIndx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name> <operator>=</operator> <name>conninfo</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLHUP</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * The fd has become invalid. The connection is broken. Add it
                 * to the remove_list and cleanup at the end of this round of
                 * cleanup.
                 */</comment>
                <expr_stmt><expr><call><name>GTMProxy_CommandPending</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr></argument>,
                            <argument><expr><name>MSG_BACKEND_DISCONNECT</name></expr></argument>, <argument><expr><name>cmd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_any_backup</name><index>[<expr><name>connIndx</name></expr>]</index></name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLIN</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * (3) read a command (loop blocks here)
                 */</comment>
                <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>ReadCommand</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_poll_fds</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <switch>switch<condition>(<expr><name>qtype</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'C'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>ProcessCommand</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr></argument>, <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>HandlePostCommand</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr></argument>, <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><literal type="char">'X'</literal></expr>:</case>
                    <case>case <expr><name>EOF</name></expr>:</case>
                        <comment type="block">/*
                         * Connection termination request
                         *
                         * Close the socket and remember the connection
                         * as disconnected. All such connections will be
                         * removed after the command processing is over. We
                         * can't remove it just yet because we pass the slot id
                         * to the server to quickly find the backend connection
                         * while processing proxied messages.
                         */</comment>
                        <expr_stmt><expr><call><name>GTMProxy_CommandPending</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr></argument>,
                                                <argument><expr><name>MSG_BACKEND_DISCONNECT</name></expr></argument>, <argument><expr><name>cmd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <comment type="block">/*
                         * Also disconnect if protocol error
                         */</comment>
                        <expr_stmt><expr><call><name>GTMProxy_HandleDisconnect</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr></argument>, <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected message, or client disconnected abruptly."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>

            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Ok. All the commands are processed. Commands which can be proxied
         * directly have been already sent to the GTM server. Now, group the
         * remaining commands, send them to the server and flush the data.
         */</comment>
        <expr_stmt><expr><call><name>GTMProxy_ProcessPendingCommands</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Add a special marker to tell the GTM server that we are done with
         * one round of messages and the GTM server should flush all the
         * pending responses after seeing this message.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_DATA_FLUSH</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending flush message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Make sure everything is on wire now
         */</comment>
        <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>gtmpqFlush</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending flush message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Read back the responses and put them on to the right backend
         * connection.
         */</comment>
        <macro><name>gtm_foreach</name><argument_list>(<argument>elem</argument>, <argument>thrinfo-&gt;thr_processed_commands</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name> <init>= <expr><operator>(</operator><name>GTMProxy_CommandInfo</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * If this is a continuation of a multi-part command response, we
             * don't need to read another result from the stream. The previous
             * result contains our response and we should just read from it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>GTMPQgetResult</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Here's another place to check GTM communication error.
                     * In this case, backup of each command will be taken care of
                     * by ProcessResponse() so if socket read/write error is recorded,
                     * disconnect GTM connection, retry connection and then if it faile,
                     * wait for reconnect from gtm_ctl.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name><operator>-&gt;</operator><name>last_errno</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Please note that error handling can end up with longjmp() and
                         * may not return here.
                         */</comment>
                        <expr_stmt><expr><call><name>HandleGTMError</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GTMPQgetResult failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>ProcessResponse</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>, <argument><expr><name>cmdinfo</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>gtm_list_free_deep</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Now clean up disconnected connections
         */</comment>
        <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>connIndx</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>connIndx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_disconnected</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>GTMProxy_ThreadRemoveConnection</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>, <argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ii</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* can't get here because the above loop never exits */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add the accepted connection to the pool
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GTMProxyAddConnection</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_ConnectionInfo</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_ConnectionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>conninfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><name>ENOMEM</name><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>STATUS_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Started new connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Add the conninfo struct to the next worker thread in round-robin manner
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GTMProxy_ThreadAddConnection</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ProcessCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>,
        <parameter><decl><type><name>StringInfo</name></type> <name>input_message</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID_AUTOVACUUM</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_PREPARE</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_START_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GID_DATA</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GET</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_INIT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_CURRENT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_NEXT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_LAST</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_SET_VAL</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RESET</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_CLOSE</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RENAME</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_ALTER</name></expr>:</case>
        <case>case <expr><name>MSG_BARRIER</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT</name></expr>:</case>
        <case>case <expr><name>MSG_REGISTER_SESSION</name></expr>:</case>
        <case>case <expr><name>MSG_REPORT_XMIN</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_REGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_UNREGISTER</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>MSG_TXN_FINISH_GID</name></expr>:</case>
        <case>case <expr><name>MSG_LIST_GTM_STORE</name></expr>:</case>
        <case>case <expr><name>MSG_LIST_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* List  gtm running sequence info */</comment>            
        <case>case <expr><name>MSG_LIST_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* List  gtm running transaction info */</comment>            
        <case>case <expr><name>MSG_CHECK_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* Check gtm sequence usage info */</comment>            
        <case>case <expr><name>MSG_CHECK_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* Check gtm transaction usage info */</comment>
        <case>case <expr><name>MSG_CLEAN_SESSION_SEQ</name></expr>:</case>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>GTMProxy_ProxyCommand</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_BEGIN</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_ROLLBACK</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GXID</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessTransactionCommand</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SNAPSHOT_GET_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GXID_GET</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSnapshotCommand</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>,
                            <argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>mtype</name></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * This funciton mainly takes care of GTM communcation error.
 *
 * Communication error was stored in last_errno chaned from GTMProxy_ConnectionInfo.
 * Note that it is set to zero if the last send/receive/read/write succeeds.
 *
 * If error is detected, then it tries to connect to GTM again, if it is
 * specified by configuration parameters.
 *
 * Relevant configuration parameters are: gtm_connect_retry_idle, gtm_connect_retry_count
 * and gtm_connect_retry_interval.
 *
 * If it is not successfull or configuration parameter does not specify it,
 * then, according to another confugration parameters, it waits "reconnect"
 * command from gtm_proxy.
 *
 * Relevant configuration parameters are: err_wait_idle, err_wait_count, and
 * err_wait_interval.
 */</comment>

<function><type><specifier>static</specifier> <name>GTM_Conn</name> <modifier>*</modifier></type>
<name>HandleGTMError</name><parameter_list>(<parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
         <argument><expr><literal type="string">"GTM communication error was detected.  Retrying connection, interval = %d."</literal></expr></argument>,
         <argument><expr><name>GTMConnectRetryInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>gtm_connect_string</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* Wait and retry reconnect */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Waiting %d secs."</literal></expr></argument>, <argument><expr><name>GTMConnectRetryInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>GTMConnectRetryInterval</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Connect retry
         * Because this proxy has been registered to current
         * GTM, we don't re-register it.
         *
         * Please note that GTM-Proxy accepts "reconnect" from gtm_ctl
         * even while it is retrying to connect to GTM.
         */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Try to reconnect to GTM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Make sure RECONNECT command would not come while we reconnecting */</comment>
        <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Close and free previous connection object if still active */</comment>
        <expr_stmt><expr><call><name>GTMPQfinish</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Reconnect */</comment>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>gtm_connect_string</name></expr></argument>, <argument><expr><literal type="string">"host=%s port=%d node_name=%s remote_type=%d"</literal></expr></argument>,
                <argument><expr><name>GTMServerHost</name></expr></argument>, <argument><expr><name>GTMServerPortNumber</name></expr></argument>, <argument><expr><name>GTMProxyNodeName</name></expr></argument>, <argument><expr><name>GTM_NODE_GTM_PROXY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>gtm_conn</name> <operator>=</operator> <call><name>PQconnectGTM</name><argument_list>(<argument><expr><name>gtm_connect_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If reconnect succeeded the connection will be ready to use out of
         * there, otherwise thr_gtm_conn will be set to NULL preventing double
         * free.
         */</comment>
        <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name> <operator>=</operator> <name>gtm_conn</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>gtm_conn</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Success, update thread info and return new connection */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"GTM connection retry succeeded."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>gtm_conn</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"GTM connection retry failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GTM_Conn</name> <modifier>*</modifier></type>
<name>HandlePostCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>        <name>connIdx</name> <init>= <expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_id</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conninfo</name> <operator>&amp;&amp;</operator> <name>gtm_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Check if the response was handled without error.
     * In this case, use last_errno to detect the error
     * because system call error is only one case to detect GTM error.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>gtm_conn</name><operator>-&gt;</operator><name>last_errno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator><call><name>HandleGTMError</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Command handled without error.  Clear the backup.
         */</comment>
        <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_inBufData</name><index>[<expr><name>connIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_any_backup</name><index>[<expr><name>connIdx</name></expr>]</index></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator><name>gtm_conn</name><operator>)</operator></expr>;</return>
    </block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsProxiedMessage</name><parameter_list>(<parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_TXN_BEGIN</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID_AUTOVACUUM</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_PREPARE</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_START_PREPARED</name></expr>:</case>
        <comment type="block">/* There are not so many 2PC from application messages, so just proxy it. */</comment>
        <case>case <expr><name>MSG_TXN_COMMIT_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GXID</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GID_DATA</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_REGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_UNREGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_REGISTER_SESSION</name></expr>:</case>
        <case>case <expr><name>MSG_REPORT_XMIN</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GXID_GET</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_INIT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_CURRENT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_NEXT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_LAST</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_SET_VAL</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RESET</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_CLOSE</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RENAME</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_ALTER</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GET</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT</name></expr>:</case>
        <case>case <expr><name>MSG_BARRIER</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>MSG_TXN_FINISH_GID</name></expr>:</case>
        <case>case <expr><name>MSG_LIST_GTM_STORE</name></expr>:</case>
        <case>case <expr><name>MSG_LIST_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* List  gtm running sequence info */</comment>            
        <case>case <expr><name>MSG_LIST_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* List  gtm running transaction info */</comment>            
        <case>case <expr><name>MSG_CHECK_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* Check gtm sequence usage info */</comment>            
        <case>case <expr><name>MSG_CHECK_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* Check gtm transaction usage info */</comment>
        <case>case <expr><name>MSG_CLEAN_SESSION_SEQ</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><name>true</name></expr>;</return>

        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessResponse</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>, <parameter><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name></decl></parameter>,
        <parameter><decl><type><name>GTM_Result</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Timestamp</name></type> <name>timestamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>status</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID</name></expr>:</case>
            <comment type="block">/*
             * This is a grouped command. We send just the transaction count to
             * the GTM server which responds back with the start GXID. We
             * derive our GXID from the start GXID and the our position in the
             * command queue
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_status</name></name> <operator>==</operator> <name>GTM_RESULT_OK</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_type</name></name> <operator>!=</operator> <name>TXN_BEGIN_GETGXID_MULTI_RESULT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_get_multi</name><operator>.</operator><name>txn_count</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too few GXIDs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>gxid</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_get_multi</name><operator>.</operator><name>txn_gxid</name><index>[<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name></expr>]</index></name></expr>;</expr_stmt>

                <comment type="block">/* Send back to each client the same timestamp value asked in this message */</comment>
                <expr_stmt><expr><name>timestamp</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_get_multi</name><operator>.</operator><name>timestamp</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>TXN_BEGIN_GETGXID_RESULT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>gxid</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_Timestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_proxy_data</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>MSG_TYPE_INVALID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_COMMIT_MULTI</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_type</name></name> <operator>!=</operator> <name>TXN_COMMIT_MULTI_RESULT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * These are grouped messages. We send an array of GXIDs to commit
             * or rollback and the server sends us back an array of status
             * codes.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_rc_multi</name><operator>.</operator><name>txn_count</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too few GXIDs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_rc_multi</name><operator>.</operator><name>status</name><index>[<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name></expr>]</index></name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>txn_count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>TXN_COMMIT_MULTI_RESULT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>txn_count</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR2</name></expr></argument>, <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Transaction commit failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>MSG_TYPE_INVALID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_ROLLBACK</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_type</name></name> <operator>!=</operator> <name>TXN_ROLLBACK_MULTI_RESULT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * These are grouped messages. We send an array of GXIDs to commit
             * or rollback and the server sends us back an array of status
             * codes.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_rc_multi</name><operator>.</operator><name>txn_count</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too few GXIDs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_rc_multi</name><operator>.</operator><name>status</name><index>[<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name></expr>]</index></name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>TXN_ROLLBACK_RESULT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_rc</name><operator>.</operator><name>gxid</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR2</name></expr></argument>, <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Transaction commit failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>MSG_TYPE_INVALID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SNAPSHOT_GET_MULTI</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>gr_type</name></name> <operator>!=</operator> <name>SNAPSHOT_GET_RESULT</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>gr_type</name></name> <operator>!=</operator> <name>SNAPSHOT_GET_MULTI_RESULT</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_snap_multi</name><operator>.</operator><name>txn_count</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too few GXIDs - %d:%d"</literal></expr></argument>, <argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name></expr></argument>,
                        <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_snap_multi</name><operator>.</operator><name>txn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_txn_snap_multi</name><operator>.</operator><name>status</name><index>[<expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name></expr>]</index></name></expr>;</expr_stmt>
               <if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>STATUS_OK</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>status</name> <operator>==</operator> <name>STATUS_NOT_FOUND</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>txn_count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>SNAPSHOT_GET_MULTI_RESULT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>txn_count</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>txn_count</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>gr_snapshot</name><operator>.</operator><name>sn_xmin</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>gr_snapshot</name><operator>.</operator><name>sn_xmax</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_snapshot</name><operator>.</operator><name>sn_xcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>res</name><operator>-&gt;</operator><name>gr_snapshot</name><operator>.</operator><name>sn_xip</name></name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>res</name><operator>-&gt;</operator><name>gr_snapshot</name><operator>.</operator><name>sn_xcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR2</name></expr></argument>, <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"snapshot request failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>MSG_TYPE_INVALID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_BEGIN</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID_AUTOVACUUM</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_PREPARE</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_START_PREPARED</name></expr>:</case>
        <comment type="block">/* There are not so many 2PC from application messages, so just proxy it. */</comment>
        <case>case <expr><name>MSG_TXN_COMMIT_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GXID</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GID_DATA</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_REGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_UNREGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_REGISTER_SESSION</name></expr>:</case>
        <case>case <expr><name>MSG_REPORT_XMIN</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GXID_GET</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_INIT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_CURRENT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_NEXT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_LAST</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_SET_VAL</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RESET</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_CLOSE</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RENAME</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_ALTER</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GET</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>MSG_TXN_FINISH_GID</name></expr>:</case>
        <case>case <expr><name>MSG_LIST_GTM_STORE</name></expr>:</case>
        <case>case <expr><name>MSG_LIST_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* List  gtm running sequence info */</comment>            
        <case>case <expr><name>MSG_LIST_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* List  gtm running transaction info */</comment>            
        <case>case <expr><name>MSG_CHECK_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* Check gtm sequence usage info */</comment>            
        <case>case <expr><name>MSG_CHECK_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* Check gtm transaction usage info */</comment>
        <case>case <expr><name>MSG_CLEAN_SESSION_SEQ</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsProxiedMessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>gr_proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>==</operator> <name>InvalidGTMProxyConnID</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>gr_proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>&gt;=</operator> <name>GTM_PROXY_MAX_CONNECTIONS</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name><name>res</name><operator>-&gt;</operator><name>gr_proxyhdr</name><operator>.</operator><name>ph_conid</name></name></expr>]</index></name> <operator>!=</operator> <name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Invalid response or synchronization loss"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * These are just proxied messages.. so just forward the response
             * back after stripping the conid part.
             *
             * !!TODO As we start adding support for message grouping for
             * messages, those message types would be removed from the above
             * and handled separately.
             */</comment>
            <switch>switch <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_status</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GTM_RESULT_OK</name></expr>:</case>
                    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_type</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_proxy_data</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_proxy_data</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
            <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>MSG_TYPE_INVALID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BARRIER</name></expr>:</case>
            <switch>switch <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_status</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GTM_RESULT_OK</name></expr>:</case>
                    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_type</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_proxy_data</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_proxy_data</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
            <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_pending_msg</name></name> <operator>=</operator> <name>MSG_TYPE_INVALID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            
        <default>default:</default>
            <expr_stmt><expr><call><name>ReleaseCmdBackup</name><argument_list>(<argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>,
                            <argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ReadCommand reads a command from either the frontend or
 *        standard input, places it in inBuf, and returns the
 *        message type code (first byte of the message).
 *        EOF is returned if end of file.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>             <name>qtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>connIdx</name> <init>= <expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_id</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>anyBackup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>anyBackup</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_any_backup</name><index>[<expr><name>connIdx</name></expr>]</index></name></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Get message type code from the frontend.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>anyBackup</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_qtype</name><index>[<expr><name>connIdx</name></expr>]</index></name> <operator>=</operator> <name>qtype</name></expr>;</expr_stmt>
        <comment type="block">/*
         * We should not update thr_any_backup here.  This should be
         * updated when the backup is consumed or command processing
         * is done.
         */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>qtype</name> <operator>=</operator> <name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_qtype</name><index>[<expr><name>connIdx</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition>            <comment type="block">/* frontend disconnected */</comment>
    <block>{<block_content>
        <comment type="block">/* don't fill up the proxy log with client disconnect messages */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>qtype</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Validate message type code before trying to read body; if we have lost
     * sync, better to say "command unknown" than to run out of memory because
     * we used garbage as a length word.
     *
     * This also gives us a place to set the doing_extended_query_message flag
     * as soon as possible.
     */</comment>
    <switch>switch <condition>(<expr><name>qtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'C'</literal></expr>:</case>
            <break>break;</break>

        <case>case <expr><literal type="char">'X'</literal></expr>:</case>
            <break>break;</break>

        <default>default:</default>

            <comment type="block">/*
             * Otherwise we got garbage from the frontend.    We treat this as
             * fatal because we have probably lost message boundary sync, and
             * there's no good way to recover.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * In protocol version 3, all frontend messages have a length word next
     * after the type code; we can read the message contents independently of
     * the type.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>anyBackup</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* suitable message already logged */</comment>

        <expr_stmt><expr><call><name>copyStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_inBufData</name><index>[<expr><name>connIdx</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * The next line is added because we added the code to clear backup
         * when the response is processed.
         */</comment>
        <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_any_backup</name><index>[<expr><name>connIdx</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>copyStringInfo</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_inBufData</name><index>[<expr><name>connIdx</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>qtype</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessTransactionCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>,
        <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_CommandData</name></type> <name>cmd_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>global_sessionid_len</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID</name></expr>:</case>
            <expr_stmt><expr><name><name>cmd_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>iso_level</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_IsolationLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cmd_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>rdonly</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>global_sessionid_len</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cmd_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>global_sessionid</name></name></expr></argument>, <argument><expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>message</name></expr></argument>,
                    <argument><expr><name>global_sessionid_len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>global_sessionid_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTMProxy_CommandPending</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>cmd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_COMMIT_MULTI</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <comment type="block">/* fall through */</comment>
        <case>case <expr><name>MSG_TXN_ROLLBACK</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>message</name></expr></argument>,
                        <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Message does not contain valid GXID"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd_data</name><operator>.</operator><name>cd_rc</name><operator>.</operator><name>gxid</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTMProxy_CommandPending</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>cmd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_BEGIN</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GXID</name></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Support not yet added for these message types"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* Shouldn't come here.. keep compiler quiet */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessSnapshotCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>,
        <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_CommandData</name></type> <name>cmd_data</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_SNAPSHOT_GET_MULTI</name></expr>:</case>
            <block>{<block_content>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

                    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>message</name></expr></argument>,
                            <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Message does not contain valid GXID"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd_data</name><operator>.</operator><name>cd_snap</name><operator>.</operator><name>gxid</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>GTMProxy_CommandPending</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>cmd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>MSG_SNAPSHOT_GXID_GET</name></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Message not yet support"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* Shouldn't come here.. keep compiler quiet */</comment>
    </block_content>}</block></switch>

</block_content>}</block></function>

<comment type="block">/*
 * Proxy the incoming message to the GTM server after adding our own identifier
 * to it. The rest of the message is forwarded as it is without even reading
 * its contents.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_ProxyCommand</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>,
        <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_ProxyMsgHeader</name></type> <name>proxyhdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unreadmsg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>unreadmsglen</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsProxiedMessage</name><argument_list>(<argument><expr><name>mtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>=</operator> <name><name>conninfo</name><operator>-&gt;</operator><name>con_id</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>unreadmsglen</name> <operator>=</operator> <call><name>pq_getmsgunreadlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>unreadmsg</name> <operator>=</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>unreadmsglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

     <comment type="block">/* Start the message. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>proxyhdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ProxyMsgHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>mtype</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name>unreadmsg</name></expr></argument>, <argument><expr><name>unreadmsglen</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending proxied message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Add the message to the pending command list
     */</comment>
    <expr_stmt><expr><name>cmdinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_CommandInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name> <operator>=</operator> <name>mtype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name></name> <operator>=</operator> <name>conninfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <call><name>gtm_lappend</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name></expr></argument>, <argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finish the message. */</comment>
    <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error finishing the message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Record the incoming message as per its type. After all messages of this type
 * are collected, they will be sent in a single message to the GTM server.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_CommandPending</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>,
        <parameter><decl><type><name>GTMProxy_CommandData</name></type> <name>cmd_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Add the message to the pending command list
     */</comment>
    <expr_stmt><expr><name>cmdinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_CommandInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name> <operator>=</operator> <name>mtype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name></name> <operator>=</operator> <name>conninfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name></name> <operator>=</operator> <name>cmd_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>mtype</name></expr>]</index></name> <operator>=</operator> <call><name>gtm_lappend</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>mtype</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register PGXC Node Connection in Proxy
 * Registery on GTM is made with MSG_NODE_REGISTER message type when node is launched.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_RegisterPGXCNode</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
                          <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>,
                          <parameter><decl><type><name>GTM_PGXCNodeType</name></type> <name>remote_type</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name></type> <name>is_postmaster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Registering PGXC Node with name %s"</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>node_name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>=</operator> <name>remote_type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>is_postmaster</name></name> <operator>=</operator> <name>is_postmaster</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_HandshakeConnection</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * We expect a startup message at the very start. The message type is
     * REGISTER_COORD, followed by the 4 byte PGXC node ID
     */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>startup_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_StartupPacket</name></type> <name>sp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>inBuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>startup_type</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>startup_type</name> <operator>!=</operator> <literal type="char">'A'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Expecting a startup message, but received %c"</literal></expr></argument>,
                     <argument><expr><name>startup_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * All frontend messages have a length word next
     * after the type code; we can read the message contents independently of
     * the type.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Expecting PGXC Node ID, but received EOF"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>,
           <argument><expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_StartupPacket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_StartupPacket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTMProxy_RegisterPGXCNode</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>sp_node_name</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>sp_remotetype</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>sp_ispostmaster</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Send a dummy authentication request message 'R' as the client
     * expects that in the current protocol
     */</comment>
    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'R'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_authenticated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Sent connection authentication message to the client"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_HandleDisconnect</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GTM_ProxyMsgHeader</name></type> <name>proxyhdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>namelen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>=</operator> <name><name>conninfo</name><operator>-&gt;</operator><name>con_id</name></name></expr>;</expr_stmt>
    <comment type="block">/* Start the message. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>proxyhdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ProxyMsgHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_BACKEND_DISCONNECT</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutc</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>is_postmaster</name></name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error proxing data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Then send node type and node number if backend is a postmaster to
     * disconnect the correct node.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>is_postmaster</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>namelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_type</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_PGXCNodeType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>namelen</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error proxing data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Finish the message. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error finishing the message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_disconnected</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process all the pending messages now.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_ProcessPendingCommands</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_ProxyMsgHeader</name></type> <name>proxyhdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>gtm_conn</name> <init>= <expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gtm_ListCell</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>MSG_TYPE_COUNT</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We process backend disconnects last! */</comment>
        <if_stmt><if>if <condition>(<expr><name>ii</name> <operator>==</operator> <name>MSG_BACKEND_DISCONNECT</name> <operator>||</operator>
                <call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Start a new group message and fill in the headers
         */</comment>
        <expr_stmt><expr><name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>=</operator> <name>InvalidGTMProxyConnID</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>proxyhdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ProxyMsgHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error proxing data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><name>ii</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>MSG_TXN_BEGIN_GETGXID</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"No pending commands of type %d"</literal></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_TXN_BEGIN_GETGXID_MULTI</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <macro><name>gtm_foreach</name> <argument_list>(<argument>elem</argument>, <argument>thrinfo-&gt;thr_pending_commands[ii]</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>cmdinfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_CommandInfo</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name> <operator>==</operator> <name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>=</operator> <name>res_index</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>iso_level</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_IsolationLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>gtmpqPutc</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>rdonly</name></name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>global_sessionid</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                            <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>global_sessionid</name></name></expr></argument>,
                            <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_beg</name><operator>.</operator><name>global_sessionid</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_id</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_ConnID</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                </block_content>}</block>

                <comment type="block">/* Finish the message. */</comment>
                <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error finishing the message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Move the entire list to the processed command
                 */</comment>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <call><name>gtm_list_concat</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name></expr></argument>,
                        <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Free the list header of the second list, unless
                 * gtm_list_concat actually returned the second list as-is
                 * because the first list was empty
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>!=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>gtm_NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>MSG_TXN_COMMIT_MULTI</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_TXN_COMMIT_MULTI</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <macro><name>gtm_foreach</name> <argument_list>(<argument>elem</argument>, <argument>thrinfo-&gt;thr_pending_commands[ii]</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>cmdinfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_CommandInfo</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name> <operator>==</operator> <name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>=</operator> <name>res_index</name><operator>++</operator></expr>;</expr_stmt>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_rc</name><operator>.</operator><name>gxid</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block>
                </block_content>}</block>

                <comment type="block">/* Finish the message. */</comment>
                <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error finishing the message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Move the entire list to the processed command
                 */</comment>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <call><name>gtm_list_concat</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name></expr></argument>,
                        <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Free the list header of the second list, unless
                 * gtm_list_concat actually returned the second list as-is
                 * because the first list was empty
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>!=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>gtm_NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>
                <break>break;</break>

                <break>break;</break>

            <case>case <expr><name>MSG_TXN_ROLLBACK</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_TXN_ROLLBACK_MULTI</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <macro><name>gtm_foreach</name> <argument_list>(<argument>elem</argument>, <argument>thrinfo-&gt;thr_pending_commands[ii]</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>cmdinfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_CommandInfo</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name> <operator>==</operator> <name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>=</operator> <name>res_index</name><operator>++</operator></expr>;</expr_stmt>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_rc</name><operator>.</operator><name>gxid</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block>
                </block_content>}</block>

                <comment type="block">/* Finish the message. */</comment>
                <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error finishing the message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


                <comment type="block">/*
                 * Move the entire list to the processed command
                 */</comment>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <call><name>gtm_list_concat</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name></expr></argument>,
                        <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Free the list header of the second list, unless
                 * gtm_list_concat actually returned the second list as-is
                 * because the first list was empty
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>!=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>gtm_NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>MSG_SNAPSHOT_GET_MULTI</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_SNAPSHOT_GET_MULTI</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <macro><name>gtm_foreach</name> <argument_list>(<argument>elem</argument>, <argument>thrinfo-&gt;thr_pending_commands[ii]</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>cmdinfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_CommandInfo</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_mtype</name></name> <operator>==</operator> <name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_res_index</name></name> <operator>=</operator> <name>res_index</name><operator>++</operator></expr>;</expr_stmt>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_data</name><operator>.</operator><name>cd_rc</name><operator>.</operator><name>gxid</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error sending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block>
                </block_content>}</block>

                <comment type="block">/* Finish the message. */</comment>
                <expr_stmt><expr><call><name>Enable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error finishing the message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>Disable_Longjmp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Move the entire list to the processed command
                 */</comment>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>=</operator> <call><name>gtm_list_concat</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name></expr></argument>,
                        <argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Free the list header of the second list, unless
                 * gtm_list_concat actually returned the second list as-is
                 * because the first list was empty
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_processed_commands</name></name> <operator>!=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>gtm_NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_pending_commands</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>gtm_NIL</name></expr>;</expr_stmt>
                <break>break;</break>


            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"This message type (%d) can not be grouped together"</literal></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <comment type="block">/* Process backend disconnect messages now */</comment>
    <macro><name>gtm_foreach</name> <argument_list>(<argument>elem</argument>, <argument>thrinfo-&gt;thr_pending_commands[MSG_BACKEND_DISCONNECT]</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cleaning up client disconnection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cmdinfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_CommandInfo</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTMProxy_HandleDisconnect</name><argument_list>(<argument><expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name></name></expr></argument>, <argument><expr><name>gtm_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Validate the proposed data directory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>retry</name>:</label>
    <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>, <argument><expr><literal type="number">0700</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>errno</name><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to create the directory \"%s\""</literal></expr></argument>,
                             <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>retry</name>;</goto>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EPERM</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read permissions of directory \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* eventual chdir would fail anyway, but let's test ... */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified data directory \"%s\" is not a directory"</literal></expr></argument>,
                        <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the directory belongs to my userid; if not, reject.
     *
     * This check is an essential part of the interlock that prevents two
     * postmasters from starting in the same directory (see CreateLockFile()).
     * Do not remove or weaken it.
     *
     * XXX can we safely enable this check on Windows?
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_uid</name></name> <operator>!=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" has wrong ownership"</literal></expr></argument>,
                        <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The server must be started by the user that owns the data directory."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Set data directory, but make sure it's an absolute path.  Use this,
 * never set DataDir directly.
 */</comment>
<function><type><name>void</name></type>
<name>SetDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

    <comment type="block">/* If presented path is relative, convert to absolute */</comment>
    <expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>errno</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to set the data directory \"%s\""</literal></expr></argument>,
                        <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>GTMProxyDataDir</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>GTMProxyDataDir</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change working directory to DataDir.  Most of the postmaster and backend
 * code assumes that we are in DataDir so it can use relative paths to access
 * stuff in and under the data directory.  For convenience during path
 * setup, however, we don't force the chdir to occur during SetDataDir.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ChangeToDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change directory to \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the data directory lockfile.
 *
 * When this is called, we must have already switched the working
 * directory to DataDir, so we can just use a relative path.  This
 * helps ensure that we are locking the directory we should be.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateDataDirLockFile</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CreateLockFile</name><argument_list>(<argument><expr><name>GTM_PID_FILE</name></expr></argument>, <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a lockfile.
 *
 * filename is the name of the lockfile to create.
 * amPostmaster is used to determine how to encode the output PID.
 * isDDLock and refName are used to determine what error message to produce.
 */</comment>
<function><type><name>void</name></type>
<name>CreateLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refName</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ntries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>encoded_pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>other_pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>my_pid</name> <init>= <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We need a loop here because of race conditions.    But don't loop forever
     * (for example, a non-writable $PGDATA directory might cause a failure
     * that won't go away).  100 tries seems like plenty.
     */</comment>
    <for>for <control>(<init><expr><name>ntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>ntries</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Try to create the lock file --- O_EXCL makes this atomic.
         *
         * Think not to make the file protection weaker than 0600.    See
         * comments below.
         */</comment>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* Success; exit the retry loop */</comment>

        <comment type="block">/*
         * Couldn't create the pid file. Probably it already exists.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>errno</name> <operator>!=</operator> <name>EEXIST</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EACCES</name><operator>)</operator> <operator>||</operator> <name>ntries</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create lock file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Read the file to get the old owner's PID.  Note race condition
         * here: file might have been deleted since we tried to create it.
         */</comment>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* race condition; try again */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open lock file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read lock file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>encoded_pid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>other_pid</name> <operator>=</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <name>encoded_pid</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"bogus data in lock file \"%s\": \"%s\""</literal></expr></argument>,
                 <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check to see if the other process still exists
         *
         * If the PID in the lockfile is our own PID or our parent's PID, then
         * the file must be stale (probably left over from a previous system
         * boot cycle).  We need this test because of the likelihood that a
         * reboot will assign exactly the same PID as we had in the previous
         * reboot.    Also, if there is just one more process launch in this
         * reboot than in the previous one, the lockfile might mention our
         * parent's PID.  We can reject that since we'd never be launched
         * directly by a competing postmaster.    We can't detect grandparent
         * processes unfortunately, but if the init script is written
         * carefully then all but the immediate parent shell will be
         * root-owned processes and so the kill test will fail with EPERM.
         *
         * We can treat the EPERM-error case as okay because that error
         * implies that the existing process has a different userid than we
         * do, which means it cannot be a competing postmaster.  A postmaster
         * cannot successfully attach to a data directory owned by a userid
         * other than its own.    (This is now checked directly in
         * checkDataDir(), but has been true for a long time because of the
         * restriction that the data directory isn't group- or
         * world-accessible.)  Also, since we create the lockfiles mode 600,
         * we'd have failed above if the lockfile belonged to another userid
         * --- which means that whatever process kill() is reporting about
         * isn't the one that made the lockfile.  (NOTE: this last
         * consideration is the only one that keeps us from blowing away a
         * Unix socket file belonging to an instance of Postgres being run by
         * someone else, at least on machines where /tmp hasn't got a
         * stickybit.)
         *
         * Windows hasn't got getppid(), but doesn't need it since it's not
         * using real kill() either...
         *
         * Normally kill() will fail with ESRCH if the given PID doesn't
         * exist.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>!=</operator> <name>my_pid</name>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
            <operator>&amp;&amp;</operator> <name>other_pid</name> <operator>!=</operator> <call><name>getppid</name><argument_list>()</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>other_pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <operator>(</operator><name>errno</name> <operator>!=</operator> <name>ESRCH</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EPERM</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* lockfile belongs to a live process */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" already exists"</literal></expr></argument>,
                                <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
                          <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another GTM proxy (PID %d) running in data directory \"%s\"?"</literal></expr></argument>,
                                  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Looks like nobody's home.  Unlink the file and try again to create
         * it.    Need a loop because of possible race condition against other
         * would-be creators.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old lock file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The file seems accidentally left over, but "</literal>
                           <literal type="string">"it could not be removed. Please remove the file "</literal>
                             <literal type="string">"by hand and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Successfully created the file, now fill it.
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d\n%s\n"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>my_pid</name></expr></argument>, <argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Create the opts file
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CreateOptsFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTS_FILE</name></cpp:macro>    <cpp:value>"gtm_proxy.opts"</cpp:value></cpp:define>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>OPTS_FILE</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>OPTS_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>OPTS_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* delete pid file */</comment>
<function><type><name>void</name></type>
<name>DeleteLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old lock file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The file seems accidentally left over, but "</literal>
                         <literal type="string">"it could not be removed. Please remove the file "</literal>
                         <literal type="string">"by hand and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unregister Proxy on GTM
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnregisterProxy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GTM_PGXCNodeType</name></type> <name>type</name> <init>= <expr><name>GTM_NODE_GTM_PROXY</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Result</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>finish_time</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>master_conn</name> <operator>||</operator> <call><name>GTMPQstatus</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>master_conn</name> <operator>=</operator> <call><name>ConnectGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>master_conn</name> <operator>||</operator> <name>GTMProxyNodeName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_NODE_UNREGISTER</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_PGXCNodeType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <comment type="block">/* Node name length */</comment>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>GTMProxyNodeName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_StrLen</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <comment type="block">/* Node name (var-len) */</comment>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name>GTMProxyNodeName</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>GTMProxyNodeName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Finish the message. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Flush to ensure backend gets it. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqFlush</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>finish_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>PROXY_CLIENT_TIMEOUT</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqWaitTimed</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>, <argument><expr><name>finish_time</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqReadData</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>GTMPQgetResult</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Check on node type and node name */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_status</name></name> <operator>==</operator> <name>GTM_RESULT_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_node</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>( <argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_node</name><operator>.</operator><name>node_name</name></name></expr></argument>, <argument><expr><name>GTMProxyNodeName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disconnect cleanly as Proxy is shutting down */</comment>
    <expr_stmt><expr><call><name>GTMPQfinish</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>

<label><name>failed</name>:</label>
    <comment type="block">/*
     * We don't deliberately write an ERROR here to ensure that proxy shutdown
     * proceeds to the end. Without that we have a danger of leaving behind a
     * stale PID file, thus causing gtm_ctl stop to wait forever for the proxy
     * to shutdown
     *
     * XXX This can happen when GTM restarts, clearing existing registration
     * information. See if this needs to fixed
     */</comment>
    <return>return <expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"can not Unregister Proxy on GTM"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register Proxy on GTM
 *
 * If reconnect is specified, then existing connection is closed
 * and the target GTM is taken from NewGTMServerHost and
 * NewGTMServerPortNumber.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterProxy</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_reconnect</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GTM_PGXCNodeType</name></type> <name>type</name> <init>= <expr><name>GTM_NODE_GTM_PROXY</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_PGXCNodePort</name></type> <name>port</name> <init>= <expr><operator>(</operator><name>GTM_PGXCNodePort</name><operator>)</operator> <name>GTMProxyPortNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Result</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>proxyname</name><index>[]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>finish_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_mcxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_reconnect</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
             <argument><expr><literal type="string">"Reconnect to new GTM, hostname=%s, port=%d"</literal></expr></argument>,
             <argument><expr><name>NewGTMServerHost</name></expr></argument>, <argument><expr><name>NewGTMServerPortNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Now reconnect.   Close the exising connection
         * and update the target host and port.
         * First, change the memory context to TopMemoryContext
         */</comment>
        <expr_stmt><expr><name>old_mcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Change the target to new GTM */</comment>
        <expr_stmt><expr><call><name>GTMPQfinish</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>GTMServerHost</name> <operator>=</operator> <name>NewGTMServerHost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>GTMServerPortNumber</name> <operator>=</operator> <name>NewGTMServerPortNumber</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>master_conn</name> <operator>=</operator> <call><name>ConnectGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>master_conn</name> <operator>||</operator> <name>GTMProxyNodeName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * As this node is itself a Proxy it registers 0 as Proxy ID on GTM
     * as it doesn't go through any other proxy.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_NODE_REGISTER</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_PGXCNodeType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>GTMProxyNodeName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name>GTMProxyNodeName</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>GTMProxyNodeName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ListenAddresses</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name>ListenAddresses</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ListenAddresses</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_PGXCNodePort</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <comment type="block">/* PGXCTODO : previously ZERO was used if the node was itself proxy, now its name is empty. */</comment>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>proxyname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name>proxyname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>proxyname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutnchar</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>GTMProxyDataDir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call><operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>NODE_CONNECTED</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_PGXCNodeStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Finish the message. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Flush to ensure backend gets it. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqFlush</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>finish_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>PROXY_CLIENT_TIMEOUT</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqWaitTimed</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>master_conn</name></expr></argument>, <argument><expr><name>finish_time</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqReadData</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot read data."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>failed</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>GTMPQgetResult</name><argument_list>(<argument><expr><name>master_conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot get result."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>failed</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>gr_status</name></name> <operator>==</operator> <name>GTM_RESULT_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_node</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>( <argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>gr_resdata</name><operator>.</operator><name>grd_node</name><operator>.</operator><name>node_name</name></name></expr></argument>, <argument><expr><name>GTMProxyNodeName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If reconnect, restore the old memory context */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_reconnect</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>

<label><name>failed</name>:</label>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can not register Proxy on GTM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GTM_Conn</name><modifier>*</modifier></type>
<name>ConnectGTM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>conn_str</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>conn_str</name></expr></argument>, <argument><expr><literal type="string">"host=%s port=%d node_name=%s remote_type=%d postmaster=1"</literal></expr></argument>,
            <argument><expr><name>GTMServerHost</name></expr></argument>, <argument><expr><name>GTMServerPortNumber</name></expr></argument>, <argument><expr><name>GTMProxyNodeName</name></expr></argument>, <argument><expr><name>GTM_NODE_GTM_PROXY_POSTMASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectGTM</name><argument_list>(<argument><expr><name>conn_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GTMPQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can not connect to GTM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTMPQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release backup command data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseCmdBackup</name><parameter_list>(<parameter><decl><type><name>GTMProxy_CommandInfo</name> <modifier>*</modifier></type><name>cmdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ConnID</name></type> <name>connIdx</name> <init>= <expr><name><name>cmdinfo</name><operator>-&gt;</operator><name>ci_conn</name><operator>-&gt;</operator><name>con_id</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_any_backup</name><index>[<expr><name>connIdx</name></expr>]</index></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_qtype</name><index>[<expr><name>connIdx</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_inBufData</name><index>[<expr><name>connIdx</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>workerThreadReconnectToGTM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>gtm_connect_string</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>   <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>saveMyClientId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * First of all, we should acquire reconnect control lock in READ mode
     * to wait for the main thread to finish reconnect.
     */</comment>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ReconnectControlLock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ReconnectControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* The lock not needed any longer */</comment>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disconnect the current connection and re-connect to the new GTM */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMostMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Before cleaning the old connection, remember the client identifier
     * issued to us by the old GTM master. We send that identifier back to the
     * new master so that it can re-establish our association with any
     * transactions currently open by us
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>saveMyClientId</name> <operator>=</operator> <name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name><operator>-&gt;</operator><name>my_id</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTMPQfinish</name><argument_list>(<argument><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>gtm_connect_string</name></expr></argument>, <argument><expr><literal type="string">"host=%s port=%d node_name=%s remote_type=%d client_id=%u"</literal></expr></argument>,
            <argument><expr><name>GTMServerHost</name></expr></argument>, <argument><expr><name>GTMServerPortNumber</name></expr></argument>, <argument><expr><name>GTMProxyNodeName</name></expr></argument>,
            <argument><expr><name>GTM_NODE_GTM_PROXY</name></expr></argument>, <argument><expr><name>saveMyClientId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Worker thread connecting to %s"</literal></expr></argument>, <argument><expr><name>gtm_connect_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name> <operator>=</operator> <call><name>PQconnectGTM</name><argument_list>(<argument><expr><name>gtm_connect_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_gtm_conn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Worker thread GTM connection failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Worker thread connection done."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize the command processing */</comment>
    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>reconnect_issued</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
