<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/proxy/proxy_thread.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * proxy_thread.c
 *
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      $PostgreSQL$
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_proxy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>GTMProxy_ThreadMainWrapper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTMProxy_ThreadCleanup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>GTMProxy_Threads</name></type>    <name>GTMProxyThreadsData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTMProxy_Threads</name> <modifier>*</modifier></type><name>GTMProxyThreads</name> <init>= <expr><operator>&amp;</operator><name>GTMProxyThreadsData</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_PROXY_MIN_THREADS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>            <comment type="block">/* Provision for minimum threads */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_PROXY_MAX_THREADS</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>        <comment type="block">/* Max threads allowed in the GTMProxy */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTMProxyThreadsFull</name></cpp:macro>    <cpp:value>(GTMProxyThreads-&gt;gt_thread_count == GTMProxyThreads-&gt;gt_array_size)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>GTMProxyWorkerThreads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>GTMProxy_ThreadInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>Proxy_ThreadInfo</name></decl>;</decl_stmt>

<comment type="block">/*
 * Add the given thrinfo structure to the global array, expanding it if
 * necessary
 */</comment>
<function><type><name>int</name></type>
<name>GTMProxy_ThreadAdd</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>GTMProxyThreadsFull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>threads</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>newsize</name></decl>;</decl_stmt>

        <comment type="block">/*
         * TODO Optimize lock management by not holding any locks during memory
         * allocation
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>==</operator> <name>GTM_PROXY_MAX_THREADS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too many threads active"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>GTM_PROXY_MIN_THREADS</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We ran out of the array size. Just double the size, bound by the
             * upper limit
             */</comment>
            <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Can't have more than GTM_PROXY_MAX_THREADS */</comment>
        <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <name>GTM_PROXY_MAX_THREADS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>GTM_PROXY_MAX_THREADS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_threads</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>threads</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_ThreadInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_ThreadInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>old_ptr</name> <init>= <expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_threads</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>threads</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_ThreadInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_ThreadInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>threads</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>,
                    <argument><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_ThreadInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_threads</name></name> <operator>=</operator> <name>threads</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now that we have free entries in the array, find a free slot and add the
     * thrinfo pointer to it.
     *
     * TODO Optimize this later by tracking few free slots and reusing them.
     * The free slots can be updated when a thread exits and reused when a new
     * thread is added to the pool.
     */</comment>
    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>thrinfo</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Track the slot information in the thrinfo. This is useful to quickly
     * find the slot given the thrinfo structure.
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_localid</name></name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
    <return>return <expr><name>ii</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GTMProxy_ThreadRemove</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * XXX To be implemeneted
     */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new thread and assign the given connection to it.
 *
 * This function is responsible for setting up the various memory contextes for
 * the thread as well as registering this thread with the Thread Manager.
 *
 * Upon successful creation, the thread will start running the given
 * "startroutine". The thread information is returned to the calling process.
 */</comment>
<function><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type>
<name>GTMProxy_ThreadCreate</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier> <name>startroutine</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We are still running in the context of the main thread. So the
     * allocation below would last as long as the main thread exists or the
     * memory is explicitely freed.
     */</comment>
    <expr_stmt><expr><name>thrinfo</name> <operator>=</operator> <operator>(</operator><name>GTMProxy_ThreadInfo</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTMProxy_ThreadInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_CVInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize communication area with SIGUSR2 signal handler (reconnect)
     */</comment>
    <expr_stmt><expr><name><name>Proxy_ThreadInfo</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>thrinfo</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The thread status is set to GTM_PROXY_THREAD_STARTING and will be changed by
     * the thread itself when it actually starts executing
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_status</name></name> <operator>=</operator> <name>GTM_PROXY_THREAD_STARTING</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Install the ThreadInfo structure in the global array. We do this before
     * starting the thread
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GTMProxy_ThreadAdd</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error starting a new thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set up memory contextes before actually starting the threads
     *
     * The TopThreadContext is a child of TopMemoryContext and it will last as
     * long as the main process or this thread lives
     *
     * Thread context is not shared between other threads
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_thread_context</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                        <argument><expr><literal type="string">"TopMemoryContext"</literal></expr></argument>,
                                                        <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                                        <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                                        <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since the thread is not yes started, TopMemoryContext still points to
     * the context of the calling thread
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_parent_context</name></name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Each thread gets its own ErrorContext and its a child of ErrorContext of
     * the main process
     *
     * This is a thread-specific context and is not shared between other
     * threads
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>,
                                                       <argument><expr><literal type="string">"ErrorContext"</literal></expr></argument>,
                                                       <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                                       <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                                       <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_startroutine</name></name> <operator>=</operator> <name>startroutine</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Now start the thread. The thread will start executing the given
     * "startroutine". The thrinfo structure is also passed to the thread. Any
     * additional parameters should be passed via the thrinfo strcuture.
     *
     * Return the thrinfo structure to the caller
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>GTMProxy_ThreadMainWrapper</name></expr></argument>,
                             <argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><name>err</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to create a new thread: error %d"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Prepare to reclaim resources used by the thread once it exits. (We used
     * to do this inside GTMProxy_ThreadMainWrapper, but its not clear if
     * thrinfo-&gt;thr_id will be set by the time the routine starts executing.
     * Its safer to do that here instead
     */</comment>
    <expr_stmt><expr><call><name>pthread_detach</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exit the current thread
 */</comment>
<function><type><name>void</name></type>
<name>GTMProxy_ThreadExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* XXX To be implemented */</comment>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GTMProxy_ThreadJoin</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>pthread_join</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>error</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get thread information for the given thread, identified by the
 * thread_id
 */</comment>
<function><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type>
<name>GTMProxy_GetThreadInfo</name><parameter_list>(<parameter><decl><type><name>GTM_ThreadID</name></type> <name>thrid</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup routine for the thread
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTMProxy_ThreadCleanup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><operator>(</operator><name>GTMProxy_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Cleaning up thread state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * TODO Close the open connection.
     */</comment>
    <expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Switch to the memory context of the main process so that we can free up
     * our memory contextes easily.
     *
     * XXX We don't setup cleanup handlers for the main process. So this
     * routine would never be called for the main process/thread
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_parent_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_message_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_message_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_thread_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_thread_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * TODO Now cleanup the thrinfo structure itself and remove it from the global
     * array.
     */</comment>


    <comment type="block">/*
     * Reset the thread-specific information. This should be done only after we
     * are sure that memory contextes are not required
     *
     * Note: elog calls need memory contextes, so no elog calls beyond this
     * point.
     */</comment>
    <expr_stmt><expr><call><name>SetMyThreadInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A wrapper around the start routine of the thread. This helps us doing any
 * initialization and setting up cleanup handlers before the main routine is
 * started
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>GTMProxy_ThreadMainWrapper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><operator>(</operator><name>GTMProxy_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pthread_detach</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SetMyThreadInfo</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_cleanup_push</name><argument_list>(<argument><expr><name>GTMProxy_ThreadCleanup</name></expr></argument>, <argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_startroutine</name></name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_cleanup_pop</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add the given connection info structure to a thread which is selected by a
 * round-robin manner. The caller is responsible for only accepting the
 * connection. Other things including the authentication is done by the worker
 * thread when it finds a new entry in the connection list.
 *
 * Return the reference to the GTMProxy_ThreadInfo structure of the thread
 * which will be serving this connection
 */</comment>
<function><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type>
<name>GTMProxy_ThreadAddConnection</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTMProxy_ConnID</name></type> <name>connIndx</name></decl>, <decl><type ref="prev"/><name>ii</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get the next thread in the queue
     */</comment>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Always start with thread 1 because thread 0 is the main thread
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_next_worker</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_next_worker</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>thrinfo</name> <operator>=</operator> <name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_next_worker</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the next worker thread before releasing the lock
     */</comment>
    <expr_stmt><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_next_worker</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_next_worker</name></name> <operator>==</operator> <name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name></expr>)</condition><block type="pseudo"><block_content>
       <expr_stmt><expr><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_next_worker</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMProxyThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lock the threadninfo structure to safely add the new connection to the
     * thread structure. The thread will see the connection when it queries the
     * socket descriptor in the next cycle
     */</comment>
    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name> <operator>&gt;=</operator> <name>GTM_PROXY_MAX_CONNECTIONS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Too many connections"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>connIndx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>GTM_PROXY_MAX_CONNECTIONS</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Great, found a free slot to track the connection
             */</comment>
            <expr_stmt><expr><name>connIndx</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>connIndx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Too many connections - could not find a free slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Save the array slotid in the conninfo structure. We send this to the GTM
     * server as an identifier which the GTM server sends us back in the
     * response. We use that information to route the response back to the
     * approrpiate connection.
     *
     * Note that the reason to use the array slotid in the messages to/from GTM
     * is to ensure that the corresponding connection can be quickly found
     * while proxying responses back to the client.
     */</comment>
    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_id</name></name> <operator>=</operator> <name>connIndx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>connIndx</name></expr>]</index></name> <operator>=</operator> <name>conninfo</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We also maintain a map of currently used array slots in a separate data
     * structure. This allows us to quickly iterate through all open
     * connections servred by a thread. So while iterating through all open
     * connections, the correct mechanism would be something as follow:
     *
     * for (ii = 0; ii &lt; thrinfo-&gt;thr_conn_count; ii++)
     * {
     *         int connIndx = thrinfo-&gt;thr_conn_map[ii];
     *          GTMProxy_ConnectionInfo *conninfo = *          thrinfo-&gt;thr_all_conns[connIndx];    
     *          .....
     * }
     */</comment>  
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>]</index></name> <operator>=</operator> <name>connIndx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Now increment the seqno since a new connection is added to the array.
     * Before we do the next poll(), the fd array will be forced to be
     * reconstructed.
     */</comment>
       <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_seqno</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Signal the worker thread if its waiting for connections to be added to
     * its Q
     *
     * XXX May be we can first check the condition that this is the first
     * connection in the array and also use signal instead of a bcast since
     * only one thread is waiting on the cv.
     */</comment>
    <expr_stmt><expr><call><name>GTM_CVBcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the connection from the array and compact the array
 */</comment>
<function><type><name>int</name></type>
<name>GTMProxy_ThreadRemoveConnection</name><parameter_list>(<parameter><decl><type><name>GTMProxy_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>, <parameter><decl><type><name>GTMProxy_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>connIndx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Lock the threadninfo structure to safely remove the connection from the
     * thread structure.
     */</comment>
    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>connIndx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>GTM_PROXY_MAX_CONNECTIONS</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>==</operator> <name>conninfo</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>connIndx</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>connIndx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"No such connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Reset command backup info
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_any_backup</name><index>[<expr><name>connIndx</name></expr>]</index></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_qtype</name><index>[<expr><name>connIndx</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_inBufData</name><index>[<expr><name>connIndx</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_all_conns</name><index>[<expr><name>connIndx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Now also removed the entry from thr_conn_map
     */</comment>
    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>==</operator> <name>connIndx</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>ii</name> <operator>&gt;=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Failed to find connection mapping to %d"</literal></expr></argument>, <argument><expr><name>connIndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If this is the last entry in the array ? If not, then copy the last
     * entry in this slot and mark the last slot an empty
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ii</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Copy the last entry in this slot */</comment>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Mark the last slot free */</comment>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* This is the last entry in the array. Just mark it free */</comment>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_map</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn_count</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Increment the seqno to ensure that the next time before we poll, the fd
     * array is reconstructed.
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_seqno</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
