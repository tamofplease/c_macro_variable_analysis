<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/xlog_test/xlog_reader.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * main.c
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      $PostgreSQL$
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/epoll.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_seq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/standby_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/register.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_txn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_seq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_msg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_backup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_time.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_store.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_</name> <name>_XLOG__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_xlog.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>    <name>optind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>optarg</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_MAX_PATH</name></cpp:macro>            <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_DEFAULT_HOSTNAME</name></cpp:macro>    <cpp:value>"*"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_DEFAULT_PORT</name></cpp:macro>        <cpp:value>6666</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_PID_FILE</name></cpp:macro>            <cpp:value>"gtm.pid"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTM_LOG_FILE</name></cpp:macro>            <cpp:value>"gtm.log"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOOPS_UNTIL_HIBERNATE</name></cpp:macro>        <cpp:value>50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIBERNATE_FACTOR</name></cpp:macro>        <cpp:value>25</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name> <init>= <expr><literal type="string">"gtm"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ListenAddresses</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>GTMPortNumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>GTMDataDir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>NodeName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>GTM_Standby_Connetion_Timeout</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>Backup_synchronously</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type><name>active_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>         <name>active_port</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>tcp_keepalives_idle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>tcp_keepalives_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>tcp_keepalives_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>error_reporter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>status_reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>isStartUp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>scale_factor_threads</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type>         <name>wal_writer_delay</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>         <name>checkpoint_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>archive_command</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>archive_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>         <name>max_reserved_wal_number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>         <name>max_wal_sender</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>synchronous_standby_names</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>application_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>first_init</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>GTM_MutexLock</name></type>   <name>control_lock</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>        <name>enable_gtm_sequence_debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>enalbe_gtm_xlog_debug</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>enalbe_gtm_xlog_replay_debug</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>enable_gtm_debug</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>enable_sync_commit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>GTM_TimerEntry</name> <modifier>*</modifier></type><name>g_timer_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32</name></type>              <name>g_used_entry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTM_RWLock</name></type>      <name>g_timer_lock</name></decl>;</decl_stmt> <comment type="block">/* We don't expect too much concurrency, so use only a big lock. */</comment>
<decl_stmt><decl><type><name>int</name></type>                <name>g_max_lock_number</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* max lock per thread can hold. init value is for main thread. it will be changed after initlize.*/</comment>
<decl_stmt><decl><type><name>int</name></type>             <name>g_max_thread_number</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* max thread number of gtm. */</comment>
<decl_stmt><decl><type><name>GTM_ThreadInfo</name>  <modifier>*</modifier></type><name>g_timekeeper_thread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTM_ThreadInfo</name>    <modifier>*</modifier></type><name>g_timebackup_thread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTM_ThreadInfo</name>  <modifier>*</modifier></type><name>g_timer_thread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTM_ThreadInfo</name>  <modifier>*</modifier></type><name>g_xlog_writer_thread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTM_ThreadInfo</name>  <modifier>*</modifier></type><name>g_checkpoint_thread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32</name>           <modifier>*</modifier></type><name>g_checkpointDirtyStart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32</name>           <modifier>*</modifier></type><name>g_checkpointDirtySize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>             <modifier>*</modifier></type><name>g_checkpointMapperBuff</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name>  <modifier>*</modifier></type><name>GTM_TimerThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>GTM_TimerRun</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>GTM_TimerInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>CheckStandbyConnect</name><parameter_list>(<parameter><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name></decl></parameter>, <parameter><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>


    <function_decl><type><specifier>static</specifier> <name>uint32</name></type> 
<name>ReaderPrintRangeOverwrite</name><parameter_list>(<parameter><decl><type><name>XLogCmdRangerOverWrite</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>uint32</name></type> 
<name>ReaderPrintCheckPoint</name><parameter_list>(<parameter><decl><type><name>XLogCmdCheckPoint</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>uint32</name></type> 
<name>ReaderPrintTimestamp</name><parameter_list>(<parameter><decl><type><name>XLogRecGts</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>extern</specifier> <name>size_t</name></type> <name>g_GTMStoreSize</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* If this is GTM or not */</comment>
<comment type="block">/*
 * Used to determine if given Port is in GTM or in GT_Proxy.
 * If it is in GTM, we should consider to flush GTM_Conn before
 * writing anything to Port.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>isGTM</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GTM_ThreadID</name></type>    <name>TopMostThreadID</name></decl>;</decl_stmt>


<comment type="block">/* The socket(s) we're listening to. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXLISTEN</name></cpp:macro>    <cpp:value>64</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name><name>ListenSocket</name><index>[<expr><name>MAXLISTEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pthread_key_t</name></type>    <name>threadinfo_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>        <name>GTMAbortPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTM_SaveVersion</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ctlf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Port</name> <modifier>*</modifier></type><name>ConnCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>serverFd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ServerLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>initMasks</name><parameter_list>(<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>rmask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>GTM_XLogTestThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>GTM_ThreadTimeKeeper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>GTM_ThreadTimeBackup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>GTM_ThreadCheckPointer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>GTM_ThreadXLogWriter</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>GTM_XLogTestThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>bind_thread_to_cores</name> <parameter_list>(<parameter><decl><type><name>cpu_set_t</name></type> <name>cpuset</name></decl></parameter>)</parameter_list> ;</function_decl>
<function_decl><type><name>void</name></type> <name>bind_timekeeper_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>bind_service_threads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GTMAddConnection</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>standby</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>input_message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessPGXCNodeCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessTransactionCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessSnapshotCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessSequenceCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessQueryCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTM_RegisterPGXCNode</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>PGXCNodeName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CreateOptsFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ChangeToDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PromoteToActive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessSyncStandbyCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessBarrierCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> 
<name>GTMInitConnection</name><parameter_list>(<parameter><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * One-time initialization. It's called immediately after the main process
 * starts
 */</comment>
<function><type><specifier>static</specifier> <name>GTM_ThreadInfo</name> <modifier>*</modifier></type>
<name>MainThreadInit</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>threadinfo_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the lock protecting the global threads info and backup lock info.
     */</comment>
    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gtm_bkup_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the next client identifier to be issued after connection
     * establishment
     */</comment>
    <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_starting_client_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_next_client_id</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * We are called even before memory context management is setup. We must
     * use malloc
     */</comment>
    <expr_stmt><expr><name>thrinfo</name> <operator>=</operator> <operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ThreadInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>thrinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"malloc failed: %d"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_ThreadInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>is_main_thread</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SetMyThreadInfo</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SetMyThreadInfo failed: %d"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* use init value of g_max_lock_number for main thread. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_max_lock_number</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>max_lock_number</name></name>     <operator>=</operator> <name>g_max_lock_number</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>backup_timer_handle</name></name> <operator>=</operator> <name>INVALID_TIMER_HANDLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>locks_hold</name></name> <operator>=</operator> <operator>(</operator><name>GTM_RWLock</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>g_max_lock_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>locks_hold</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"out of memory when init main thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>locks_hold</name></name></expr></argument>, <argument><expr><literal type="number">0x00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>g_max_lock_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <expr_stmt><expr><name>TopMostThreadID</name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Bare minimum supporting infrastructure. Must be called at the very beginning
 * so that further initilization can have it ready
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitGTMProcess</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier><name>thrinfo</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>MainThreadInit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>MyThreadID</name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The memory context is now set up.
     * Add the thrinfo structure in the global array
     */</comment>
    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>control_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>BaseInit</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Initialize standby lock before doing anything else */</comment>
    <expr_stmt><expr><call><name>Recovery_InitStandbyLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>checkDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ChangeToDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
    <expr_stmt><expr><call><name>GTM_StoreSizeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>GTM_ControlDataInit</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>GTM_STORE_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_XLogCtlDataInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>GTMLogFile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>GTMLogFile</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>GTM_MAX_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>GTMLogFile</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>GTMDataDir</name></expr></argument>, <argument><expr><name>GTM_LOG_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Save Node Register File in register.c */</comment>
    <expr_stmt><expr><call><name>Recovery_SaveRegisterFileName</name><argument_list>(<argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DebugFileOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_InitTxnManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_InitSeqManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_InitNodeManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTM_SigleHandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Received signal %d\n"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>signal</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>SIGKILL</name></expr>:</case>
        <case>case <expr><name>SIGTERM</name></expr>:</case>
        <case>case <expr><name>SIGQUIT</name></expr>:</case>
        <case>case <expr><name>SIGINT</name></expr>:</case>
        <case>case <expr><name>SIGHUP</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>SIGUSR1</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PromoteToActive</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return;</return>

        <default>default:</default>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown signal %d\n"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
    </block_content>}</block></switch>

    <comment type="block">/*
     * XXX We should do a clean shutdown here.
     */</comment>

    <comment type="block">/* Rewrite Register Information (clean up unregister records) */</comment>
    <expr_stmt><expr><call><name>Recovery_SaveRegisterInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Delete pid file before shutting down */</comment>
    <expr_stmt><expr><call><name>DeleteLockFile</name><argument_list>(<argument><expr><name>GTM_PID_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>GTMAbortPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTM_ThreadSigHandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>signal</name></expr>)</condition>
    <block>{<block_content>    
        <case>case <expr><name>SIGQUIT</name></expr>:</case>
            <expr_stmt><expr><call><name>pthread_exit</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        

        <default>default:</default>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown signal %d\n"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
    </block_content>}</block></switch>
    <return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Help display should match
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This is the GTM server.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n  %s [OPTION]...\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h hostname     GTM server hostname/IP to listen.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p port         GTM server port number to listen.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n nodename     Node name for GTM server.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -x xid          Starting GXID \n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -D directory    GTM working directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -l filename     GTM server log file name \n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c              show server status, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f              force start GTM with starting XID specified by -x option\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --help          show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options for Standby mode:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s              Start as a GTM standby server.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -i hostname     Active GTM server hostname/IP to connect.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -q port         Active GTM server port number to connect.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gtm_status</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gtm_status(): must be implemented to scan the shmem.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
<comment type="block">/*
 * Save control file info
 */</comment>
<function><type><name>void</name></type>
<name>SaveControlInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>ctlf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>control_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ctlf</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>GTMControlFileTmp</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ctlf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to create/open the control file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>control_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_SaveVersion</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_SaveTxnInfo</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_SaveSeqInfo</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>remove</name><argument_list>(<argument><expr><name>GTMControlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rename</name><argument_list>(<argument><expr><name>GTMControlFileTmp</name></expr></argument>, <argument><expr><name>GTMControlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>control_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>GTM_XLOG_SEG_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadRedoXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>cmd_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCmdHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rec</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>XLogCmdHeader</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>XLOG_CMD_RANGE_OVERWRITE</name></expr>:</case>
                <expr_stmt><expr><name>cmd_size</name> <operator>=</operator> <call><name>ReaderPrintRangeOverwrite</name><argument_list>(<argument><expr><operator>(</operator><name>XLogCmdRangerOverWrite</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>XLOG_CMD_CHECK_POINT</name></expr>:</case>
                <expr_stmt><expr><name>cmd_size</name> <operator>=</operator> <call><name>ReaderPrintCheckPoint</name><argument_list>(<argument><expr><operator>(</operator><name>XLogCmdCheckPoint</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>XLOG_REC_GTS</name></expr>:</case>
                <expr_stmt><expr><name>cmd_size</name> <operator>=</operator> <call><name>ReaderPrintTimestamp</name><argument_list>(<argument><expr><operator>(</operator><name>XLogRecGts</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr><literal type="string">"unrecognize xlog command type %d"</literal></expr></argument>,<argument><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <expr_stmt><expr><name>len</name>  <operator>-=</operator> <name>cmd_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>cmd_size</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


    <function><type><specifier>static</specifier> <name>int64</name></type> 
<name>ReadXLogToBuff</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr><literal type="string">"ReadXLog stat file:%s failed for:%s."</literal></expr></argument>, <argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr><literal type="string">"ReadXLog file %s size larger than %d"</literal></expr></argument>,<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name>GTM_XLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>nbytes</name> <operator>!=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr><literal type="string">"ReadXLog read file %s failed for:%s."</literal></expr></argument>, <argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>nbytes</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConnCreate -- create a local connection data structure
 */</comment>
<function><type><specifier>static</specifier> <name>Port</name> <modifier>*</modifier></type>
<name>ConnCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>serverFd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Port</name>       <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>port</name> <operator>=</operator> <operator>(</operator><name>Port</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Port</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><name>ENOMEM</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>StreamConnection</name><argument_list>(<argument><expr><name>serverFd</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>conn_id</name></name> <operator>=</operator> <name>InvalidGTMProxyConnID</name></expr>;</expr_stmt>
    <return>return <expr><name>port</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ConnFree -- free a local connection data structure
 */</comment>
<function><type><name>void</name></type>
<name>ConnFree</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main idle loop of postmaster
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ServerLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>readmask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nSockets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>  <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Release the lock we acquire in MainThreadInit. */</comment>    
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Report the error to the server log */</comment>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>        
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    
    
    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nSockets</name> <operator>=</operator> <call><name>initMasks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>readmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>fd_set</name></type>        <name>rmask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>selres</name></decl>;</decl_stmt>

        <comment type="line">//MemoryContextStats(TopMostMemoryContext);</comment>

        <comment type="block">/*
         * Wait for a connection request to arrive.
         *
         * We wait at most one minute, to ensure that the other background
         * tasks handled below get done even when no requests are arriving.
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rmask</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>readmask</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if timekeeper thread exit, main thread should prepare to exit. */</comment>
        <if_stmt><if>if <condition>(<expr><name>GTMAbortPending</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>g_timekeeper_thread</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * XXX We should do a clean shutdown here. For the time being, just
             * write the next GXID to be issued in the control file and exit
             * gracefully
             */</comment>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM shutting down."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/*
             * Tell GTM that we are shutting down so that no new GXIDs are
             * issued this point onwards
             */</comment>
            <expr_stmt><expr><call><name>GTM_SetShuttingDown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>            

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM timer thread exit."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><call><name>GTM_StoreShutDown</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">//TODO xlog shutdown or not?</comment>

            <comment type="block">/* Save control data */</comment>
            <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlDataLock</name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNED</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ControlDataSync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlDataLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>            
            <expr_stmt><expr><call><name>SaveControlInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM is going to exit..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <block>{<block_content>
            <comment type="block">/* must set timeout each time; some OSes change it! */</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>        


            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* No need to take the lock now. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
            <comment type="block">/*
             * Now GTM-Standby can backup current status during this region
             */</comment>
            GTM_RWLockRelease(&amp;my_threadinfo-&gt;thr_lock);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>selres</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>nSockets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

            <comment type="block">/*
             * Prohibit GTM-Standby backup from here.
             */</comment>
            GTM_RWLockAcquire(&amp;my_threadinfo-&gt;thr_lock, GTM_LOCKMODE_WRITE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>

        <comment type="block">/*
         * Block all signals until we wait again.  (This makes it safe for our
         * signal handlers to do nontrivial work.)
         */</comment>
        <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now check the select() result */</comment>
        <if_stmt><if>if <condition>(<expr><name>selres</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"select() failed in main thread: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>STATUS_ERROR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/*
         * New connection pending on any of our sockets? If so, fork a child
         * process to deal with it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>selres</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                
                <if_stmt><if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmask</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Port</name>       <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>ConnCreate</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>port</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>GTMAddConnection</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Initialise the masks for select() for the ports we are listening on.
 * Return the number of sockets to listen on.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>initMasks</name><parameter_list>(<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>rmask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxsock</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>rmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>fd</name> <init>= <expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>rmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <name>maxsock</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>maxsock</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>GTM_ConnCleanup</name><parameter_list>(<parameter><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>==</operator> <name>conn</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * Close a connection to GTM standby.
     */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Closing a connection to the GTM standby."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>GTMPQfinish</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Free the node_name in the port */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>node_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* 
             * We don't have to reset pointer to NULL her because ConnFree() 
             * frees this structure next.
             */</comment>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_host</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_port</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* Free the port */</comment>
        <expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Free the connection info structure */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>GTM_RemoveConnection</name><parameter_list>(<parameter><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Recovery_PGXCNodeDisconnect</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_ConnCleanup</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bind_thread_to_cores</name> <parameter_list>(<parameter><decl><type><name>cpu_set_t</name></type> <name>cpuset</name></decl></parameter>)</parameter_list> 
<block>{<block_content>

   <decl_stmt><decl><type><name>pthread_t</name></type> <name>current_thread</name> <init>= <expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 
   <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

   <if_stmt><if>if<condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>pthread_setaffinity_np</name><argument_list>(<argument><expr><name>current_thread</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cpu_set_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
   <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"binding threads failed for %d"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bind_timekeeper_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cpu_set_t</name></type> <name>cpuset</name></decl>;</decl_stmt>
    
    
    <expr_stmt><expr><call><name>CPU_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CPU_SET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* dedicate cpu 0 to the timekeeper thread */</comment>
    
    <expr_stmt><expr><call><name>bind_thread_to_cores</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bind_service_threads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cpu_num</name> <init>= <expr><call><name>get_nprocs</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cpu</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cpu_set_t</name></type> <name>cpuset</name></decl>;</decl_stmt>
    
    
    <expr_stmt><expr><call><name>CPU_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>cpu</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>cpu</name> <operator>&lt;</operator> <name>cpu_num</name></expr>;</condition> <incr><expr><name>cpu</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CPU_SET</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <expr_stmt><expr><call><name>bind_thread_to_cores</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* time keeper thread will not handle any signal, any signal will cause the thread exit. */</comment>
<function><type><name>void</name> 
<modifier>*</modifier></type>
<name>GTM_ThreadTimeKeeper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>  <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type>      <name>last</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type>        <name>now</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type>    <name>action</name></decl>;</decl_stmt>  
       
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>GTM_ThreadSigHandler</name></expr>;</expr_stmt>  
         
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>action</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"register thread quit handler failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"Starting the time keeper thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bind_timekeeper_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                       <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * POSTGRES main processing loop begins here
     *
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>latestGlobalTimestamp</name></decl>;</decl_stmt>            
        
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * Sync timestamp to standby.
         * Use lock to protect standby connection, in case gtm standby reconnect.
         * Also timestamp to be flushed to disk.
         */</comment>        

        <comment type="block">/* no need to lock here. */</comment>
        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name></expr>)</condition>
        <block>{<block_content>
            <goto>goto <name>shutdown</name>;</goto>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>latestGlobalTimestamp</name> <operator>=</operator> <call><name>SyncGlobalTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>GTM_TimestampGetMonotonicRaw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>                

        <comment type="line">//XLogBeginInsert(); </comment>

        <comment type="line">//if(GTM_StoreGlobalTimestamp(latestGlobalTimestamp))</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    elog(LOG, "storing global timestamp failed, going to exit!!");</comment>
        <comment type="line">//    GTM_SetShuttingDown();</comment>
        <comment type="line">//    break;</comment>
        <comment type="line">//}        </comment>

        <comment type="line">//XLogFlush(XLogInsert());</comment>
        
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>GTM_SYNC_CYCLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        

        <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GTM_TimestampGetMonotonicRaw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>now</name> <operator>-</operator> <name>last</name><operator>)</operator> <operator>&gt;</operator> <name>GTM_SYNC_TIME_LIMIT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The timekeeper thread takes too long "</literal><name>INT64_FORMAT</name> <literal type="string">" seconds to complete, going to exit"</literal></expr></argument>, <argument><expr><name>now</name> <operator>-</operator> <name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTM_SetShuttingDown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
<label><name>shutdown</name>:</label>
    <expr_stmt><expr><name>g_timekeeper_thread</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM is shuting down, timekeeper exits!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>my_threadinfo</name></expr>;</return>    
</block_content>}</block></function>


<comment type="block">/* time keeper thread will not handle any signal, any signal will cause the thread exit. */</comment>
<function><type><name>void</name> 
<modifier>*</modifier></type>
<name>GTM_ThreadTimeBackup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>  <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type>      <name>last</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type>        <name>now</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type>    <name>action</name></decl>;</decl_stmt>  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GTM_ConnectionInfo</name></type>  <name>fake_conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fake_conn</name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_ConnectionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name>fake_conn</name></expr>;</expr_stmt>     
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

       
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>GTM_ThreadSigHandler</name></expr>;</expr_stmt>  
	<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>action</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>action</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"register thread quit handler failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"Starting the time backup thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bind_timekeeper_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                       <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * POSTGRES main processing loop begins here
     *
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>            <name>lock_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>latestGlobalTimestamp</name></decl>;</decl_stmt>            
        
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * Sync timestamp to standby.
         * Use lock to protect standby connection, in case gtm standby reconnect.
         * Also timestamp to be flushed to disk.
         */</comment>        
        <expr_stmt><expr><name>latestGlobalTimestamp</name> <operator>=</operator> <call><name>GetNextGlobalTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>GTM_TimestampGetMonotonicRaw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>                
        
        <comment type="block">/* no need to lock here. */</comment>
        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name></expr>)</condition>
        <block>{<block_content>
            <goto>goto <name>shutdown</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* check standby connection before we get lock. */</comment>
        <expr_stmt><expr><call><name>CheckStandbyConnect</name><argument_list>(<argument><expr><name>my_threadinfo</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lock_result</name> <operator>=</operator> <call><name>GTM_RWLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        <if_stmt><if>if <condition>(<expr><name>lock_result</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name>bkup_global_timestamp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr></argument>, <argument><expr><name>latestGlobalTimestamp</name> <operator>+</operator> <name>GTM_GLOBAL_TIME_DELTA</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* close standby connection. */</comment>
                    <expr_stmt><expr><call><name>gtm_standby_disconnect_from_standby</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"bkup timestamp to standby failed!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Sync with standby */</comment>
                <expr_stmt><expr><call><name>gtm_sync_standby</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Now GTM-Standby can backup current status during this region
             */</comment>
            <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Time backup lock thread failed!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>        
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>GTM_SYNC_CYCLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        

        <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GTM_TimestampGetMonotonicRaw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>        
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>now</name> <operator>-</operator> <name>last</name><operator>)</operator> <operator>&gt;</operator> <name>GTM_SYNC_TIME_LIMIT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The timebackup thread takes too long "</literal><name>INT64_FORMAT</name> <literal type="string">" seconds to complete."</literal></expr></argument>, <argument><expr><name>now</name> <operator>-</operator> <name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
<label><name>shutdown</name>:</label>
    <expr_stmt><expr><name>g_timebackup_thread</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM is shuting down, timebackup thread exits!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>my_threadinfo</name></expr>;</return>    
</block_content>}</block></function>


<function><type><name>void</name> <modifier>*</modifier></type>
<name>GTM_ThreadCheckPointer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>  <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type>    <name>action</name></decl>;</decl_stmt>  
       
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>GTM_ThreadSigHandler</name></expr>;</expr_stmt>  
	<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>action</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>action</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"register thread quit handler failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                       <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * POSTGRES main processing loop begins here
     *
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>        
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no need to lock here. */</comment>
        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name></expr>)</condition>
        <block>{<block_content>
            <goto>goto <name>shutdown</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>DoCheckPoint</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></for>
<label><name>shutdown</name>:</label>
    <expr_stmt><expr><name>g_checkpoint_thread</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM is shuting down, checkpoint exits!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>my_threadinfo</name></expr>;</return>    
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>GTM_ThreadXLogWriter</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type>    <name>action</name></decl>;</decl_stmt>  
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>     <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>left_till_hibernate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cur_timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
       
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>GTM_ThreadSigHandler</name></expr>;</expr_stmt>  
	<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>action</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>action</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"register thread quit handler failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"Starting the walwriter thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                       <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * POSTGRES main processing loop begins here
     *
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>left_till_hibernate</name> <operator>=</operator> <name>LOOPS_UNTIL_HIBERNATE</name></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>        
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no need to lock here. */</comment>
        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>shutdown</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>XLogBackgroundFlush</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>left_till_hibernate</name> <operator>=</operator> <name>LOOPS_UNTIL_HIBERNATE</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>left_till_hibernate</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>left_till_hibernate</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Sleep until we are signaled or WalWriterDelay has elapsed.  If we
         * haven't done anything useful for quite some time, lengthen the
         * sleep time so as to reduce the server's idle power consumption.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>left_till_hibernate</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <name>wal_writer_delay</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* in ms */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <name>wal_writer_delay</name> <operator>*</operator> <name>HIBERNATE_FACTOR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>    

        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>cur_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
<label><name>shutdown</name>:</label>
    <expr_stmt><expr><name>g_xlog_writer_thread</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM is shuting down, walwriter exits!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>my_threadinfo</name></expr>;</return>    
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>GetRandomInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>max</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>GTM_XLogTestThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>ret</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>qtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>input_message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>  <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>efd</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name><name>struct</name> <name>epoll_event</name></name></type> <name><name>events</name><index>[<expr><name>GTM_MAX_CONNECTIONS_PER_THREAD</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type>    <name>action</name></decl>;</decl_stmt>  
       
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  
    <expr_stmt><expr><name><name>action</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>GTM_ThreadSigHandler</name></expr>;</expr_stmt>  
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
         
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>action</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"register thread quit handler failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"Starting the connection helper thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bind_service_threads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the memory context we will use in the main loop.
     *
     * MessageContext is reset once per iteration of the main loop, ie, upon
     * completion of processing of each command message from the client.
     *
     * This context is thread-specific
     */</comment>
    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                           <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                           <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>efd</name> <operator>=</operator> <call><name>epoll_create1</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>efd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create epoll"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_efd</name></name> <operator>=</operator> <name>efd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_epoll_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Acquire the thread lock to prevent connection from GTM-Standby to update
     * GTM-Standby registration.
     */</comment>

    <comment type="block">/*
     * Get the input_message in the TopMemoryContext so that we don't need to
     * free/palloc it for every incoming message. Unlike Postgres, we don't
     * expect the incoming messages to be of arbitrary sizes
     */</comment>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * POSTGRES main processing loop begins here
     *
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>    <name>report</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * NOTE: if you are tempted to add more code in this if-block,
         * consider the high probability that it should be in
         * AbortTransaction() instead.    The only stuff done directly here
         * should be stuff that is guaranteed to apply *only* for outer-level
         * error recovery, such as adjusting the FE/BE protocol status.
         */</comment>

        <comment type="block">/* Report the error to the client and/or server log */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>report</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       
        <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>GetRandomInt</name><argument_list>(<argument><expr><literal type="number">20480</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

        <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>%</operator> <literal type="number">128</literal></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>XLogRegisterRangeOverwrite</name><argument_list>(<argument><expr><name>num</name></expr></argument>,<argument><expr><name>num</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><call><name>XLogInsert</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ProcessCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>input_message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>                <name>handle_standby</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_MessageType</name></type>    <name>mtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_ProxyMsgHeader</name></type> <name>proxyhdr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>my_threadinfo</name> <operator>=</operator> <name>GetMyThreadInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr>;</expr_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>myport</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>==</operator> <name>GTM_NODE_GTM_PROXY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pq_copymsgbytes</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>proxyhdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ProxyMsgHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>=</operator> <name>InvalidGTMProxyConnID</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>myport</name><operator>-&gt;</operator><name>conn_id</name></name> <operator>=</operator> <name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The next line will have some overhead.  Better to be in
     * compile option.
     */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"mtype = %s (%d)."</literal></expr></argument>, <argument><expr><call><name>gtm_util_message_name</name><argument_list>(<argument><expr><name>mtype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>mtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
     * Get Timestamp does not need to sync with standby
     */</comment>
    <expr_stmt><expr><name>handle_standby</name> <operator>=</operator> <operator>(</operator><name>mtype</name> <operator>!=</operator> <name>MSG_GETGTS</name> <operator>&amp;&amp;</operator> 
            <name>mtype</name> <operator>!=</operator> <name>MSG_GETGTS_MULTI</name> <operator>&amp;&amp;</operator> 
            <name>mtype</name> <operator>!=</operator> <name>MSG_BEGIN_BACKUP</name> <operator>&amp;&amp;</operator> 
            <name>mtype</name> <operator>!=</operator> <name>MSG_END_BACKUP</name> <operator>&amp;&amp;</operator>
            <name>mtype</name> <operator>!=</operator> <name>MSG_LIST_GTM_STORE</name> <operator>&amp;&amp;</operator>
            <name>mtype</name> <operator>!=</operator> <name>MSG_LIST_GTM_STORE_SEQ</name> <operator>&amp;&amp;</operator>
            <name>mtype</name> <operator>!=</operator> <name>MSG_LIST_GTM_STORE_TXN</name> <operator>&amp;&amp;</operator>
            <name>mtype</name> <operator>!=</operator> <name>MSG_CHECK_GTM_STORE_SEQ</name> <operator>&amp;&amp;</operator>
            <name>mtype</name> <operator>!=</operator> <name>MSG_CHECK_GTM_STORE_TXN</name> 
            <operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>handle_standby</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Handle standby connecion staff. */</comment>
        <expr_stmt><expr><call><name>CheckStandbyConnect</name><argument_list>(<argument><expr><name>my_threadinfo</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Hold the lock, in case reset all standby connections. */</comment>
        <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_SYNC_STANDBY</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSyncStandbyCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MSG_NODE_REGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_NODE_REGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_UNREGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_NODE_UNREGISTER</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_LIST</name></expr>:</case>
        <case>case <expr><name>MSG_REGISTER_SESSION</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPGXCNodeCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MSG_BEGIN_BACKUP</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGTMBeginBackup</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MSG_END_BACKUP</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGTMEndBackup</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MSG_NODE_BEGIN_REPLICATION_INIT</name></expr>:</case>
        <case>case <expr><name>MSG_NODE_END_REPLICATION_INIT</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_BEGIN</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_BEGIN</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_GLOBAL_TIMESTAMP</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_BEGIN_GETGXID</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID_AUTOVACUUM</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_BEGIN_GETGXID_AUTOVACUUM</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_PREPARE</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_PREPARE</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_START_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_START_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_COMMIT</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_COMMIT_PREPARED</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_ROLLBACK</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_ROLLBACK</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GXID</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_GET_GXID</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_BEGIN_GETGXID_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_COMMIT_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_COMMIT_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_ROLLBACK_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_TXN_ROLLBACK_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_GID_DATA</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_NEXT_GXID</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GXID_LIST</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>MSG_REPORT_XMIN</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_REPORT_XMIN</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>MSG_TXN_FINISH_GID</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_LOG_COMMIT</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_LOG_GLOBAL_COMMIT</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_LOG_SCAN</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_LOG_GLOBAL_SCAN</name></expr>:</case>
        <case>case <expr><name>MSG_GETGTS</name></expr>:</case>
        <case>case <expr><name>MSG_GETGTS_MULTI</name></expr>:</case>
        <case>case <expr><name>MSG_CHECK_GTM_STATUS</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><call><name>ProcessTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SNAPSHOT_GET</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GXID_GET</name></expr>:</case>
        <case>case <expr><name>MSG_SNAPSHOT_GET_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSnapshotCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_INIT</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_SEQUENCE_INIT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_CURRENT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_NEXT</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_SEQUENCE_GET_NEXT</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_GET_LAST</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_SET_VAL</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_SEQUENCE_SET_VAL</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RESET</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_SEQUENCE_RESET</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_CLOSE</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_SEQUENCE_CLOSE</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_RENAME</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_SEQUENCE_RENAME</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_ALTER</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_SEQUENCE_ALTER</name></expr>:</case>
        <case>case <expr><name>MSG_SEQUENCE_LIST</name></expr>:</case>
        <case>case <expr><name>MSG_CLEAN_SESSION_SEQ</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_GET_STATUS</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_ALL_PREPARED</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessQueryCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BARRIER</name></expr>:</case>
        <case>case <expr><name>MSG_BKUP_BARRIER</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBarrierCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BACKEND_DISCONNECT</name></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"MSG_BACKEND_DISCONNECT received - removing all txn infos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTM_RemoveAllTransInfos</name><argument_list>(<argument><expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>con_client_id</name></expr></argument>, <argument><expr><name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Mark PGXC Node as disconnected if backend disconnected is postmaster */</comment>
            <expr_stmt><expr><call><name>ProcessPGXCNodeBackendDisconnect</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>MSG_GET_STORAGE</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/* process storage file transfer request */</comment>
                <expr_stmt><expr><call><name>ProcessStorageTransferCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>MSG_LIST_GTM_STORE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ProcessGetGTMHeaderCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>MSG_LIST_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* List  gtm running sequence info */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ProcessListStorageSequenceCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>MSG_LIST_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* List  gtm running transaction info */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ProcessListStorageTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>MSG_CHECK_GTM_STORE_SEQ</name></expr>:</case>            <comment type="block">/* Check gtm sequence usage info */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ProcessCheckStorageSequenceCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>MSG_CHECK_GTM_STORE_TXN</name></expr>:</case>            <comment type="block">/* Check gtm transaction usage info */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ProcessCheckStorageTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>,
                         <argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
    <if_stmt><if>if <condition>(<expr><name>handle_standby</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>    
    <if_stmt><if>if <condition>(<expr><call><name>GTM_NeedBackup</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_WriteRestorePoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>int</name></type> 
<name>GTMInitConnection</name><parameter_list>(<parameter><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_init</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"Init connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/*
         * We expect a startup message at the very start. The message type is
         * REGISTER_COORD, followed by the 4 byte Coordinator ID
         */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>startup_type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GTM_StartupPacket</name></type> <name>sp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>inBuf</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>startup_type</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>startup_type</name> <operator>!=</operator> <literal type="char">'A'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Expecting a startup message, but received %c"</literal></expr></argument>,
                    <argument><expr><name>startup_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <return>return <expr><name>STATUS_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * All frontend messages have a length word next
         * after the type code; we can read the message contents independently of
         * the type.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Expecting coordinator ID, but received EOF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>,
                <argument><expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_StartupPacket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_StartupPacket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_RegisterPGXCNode</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>sp_node_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>sp_remotetype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>is_postmaster</name></name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>sp_ispostmaster</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>remote_backend_pid</name></name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>sp_backend_pid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_client_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/*
         * If the client has resent the identifier assigned to it previously
         * (by GTM master), use that identifier. 
         * 
         * We only accept identifiers which are lesser or equal to the last
         * identifier we had seen when we were promoted. All other identifiers
         * will be overwritten by what we have assigned
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>.</operator><name>sp_client_id</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>sp</name><operator>.</operator><name>sp_client_id</name></name> <operator>&lt;=</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_starting_client_id</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_client_id</name></name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>sp_client_id</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>inBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>
        <comment type="block">/*
         * Send a dummy authentication request message 'R' as the client
         * expects that in the current protocol. Also send the client
         * identifier issued by us (or sent by the client in the startup packet
         * if we concluded to use the same)
         */</comment>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'R'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_client_id</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"Sent connection authentication message to the client"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>


    <return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
<name>SetNonBlockConnection</name><parameter_list>(<parameter><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>flags</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fcntl get errors %s sock %d"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, 
                     <argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>flags</name> <operator>|</operator> <name>O_NONBLOCK</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fcntl set errors %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>is_nonblocking</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>int</name></type>
<name>GTMAddConnection</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>standby</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conninfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name>        <modifier>*</modifier></type><name>thrinfo</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name><name>struct</name> <name>epoll_event</name></name></type> <name>event</name></decl>;</decl_stmt>


    <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <operator>(</operator><name>GTM_ConnectionInfo</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ConnectionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"Started new connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>conninfo</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Add a connection to the standby.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>standby</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>standby</name></name> <operator>=</operator> <name>standby</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Set conn to non-blocking mode for epoll wait */</comment>
    <expr_stmt><expr><call><name>SetNonBlockConnection</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"gt thread count %d"</literal></expr></argument>, <argument><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* 
         * Check whether there are enough process threads to handle connections.
         * If not, just create new threads.
         */</comment>
        <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name> <operator>&lt;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_start_thread_count</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"create threads on demand thread count %d start thread count %d"</literal></expr></argument>, 
                    <argument><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name></expr></argument>,<argument><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_start_thread_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>GTM_ThreadCreate</name><argument_list>(<argument><expr><name>GTM_XLogTestThread</name></expr></argument>, <argument><expr><name>g_max_lock_number</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Failed to create gtm thread."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></while>
        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_next_thread</name></name><operator>++</operator><operator>)</operator> <operator>%</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_start_thread_count</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>thrinfo</name> <operator>=</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>==</operator> <name>thrinfo</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"thread %d exits."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>


        <if_stmt><if>if<condition>(<expr><name>false</name> <operator>==</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_epoll_ok</name></name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>==</operator> <name>g_timekeeper_thread</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"timekeeper thread exited, should not add new connections."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>STATUS_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_thrinfo</name></name> <operator>=</operator> <name>thrinfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>event</name><operator>.</operator><name>data</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>conninfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>event</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>EPOLLIN</name> <operator>|</operator> <name>EPOLLERR</name> <operator>|</operator> <name>EPOLLHUP</name> <operator>|</operator> <name>EPOLLRDHUP</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <call><name>epoll_ctl</name> <argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_efd</name></name></expr></argument>, <argument><expr><name>EPOLL_CTL_ADD</name></expr></argument>, <argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>con_port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"failed to add socket to epoll"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
        <break>break;</break>
    </block_content>}</block></for>    
    <return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ReadCommand reads a command from either the frontend or
 *        standard input, places it in inBuf, and returns the
 *        message type code (first byte of the message).
 *        EOF is returned if end of file.
 * ----------------
 */</comment>
    <function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>             <name>qtype</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get message type code from the frontend.
     */</comment>
    <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition>            <comment type="block">/* frontend disconnected */</comment>
    <block>{<block_content>
        <comment type="block">/* don't fill up the proxy log with client disconnect messages */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Validate message type code before trying to read body; if we have lost
     * sync, better to say "command unknown" than to run out of memory because
     * we used garbage as a length word.
     *
     * This also gives us a place to set the doing_extended_query_message flag
     * as soon as possible.
     */</comment>
    <switch>switch <condition>(<expr><name>qtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'C'</literal></expr>:</case>
            <break>break;</break>

        <case>case <expr><literal type="char">'X'</literal></expr>:</case>
            <break>break;</break>

        <case>case <expr><literal type="char">'F'</literal></expr>:</case>
            <break>break;</break>

        <default>default:</default>

            <comment type="block">/*
             * Otherwise we got garbage from the frontend.    We treat this as
             * fatal because we have probably lost message boundary sync, and
             * there's no good way to recover.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * In protocol version 3, all frontend messages have a length word next
     * after the type code; we can read the message contents independently of
     * the type.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* suitable message already logged */</comment>

    <return>return <expr><name>qtype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process MSG_SYNC_STANDBY message
 */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessSyncStandbyCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>SYNC_STANDBY_RESULT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Sync standby first */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>gtm_sync_standby</name><argument_list>(<argument><expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessPGXCNodeCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_NODE_REGISTER</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPGXCNodeRegister</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_NODE_REGISTER</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPGXCNodeRegister</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_NODE_UNREGISTER</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPGXCNodeUnregister</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_NODE_UNREGISTER</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPGXCNodeUnregister</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_NODE_LIST</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPGXCNodeList</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_REGISTER_SESSION</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPGXCRegisterSession</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* Shouldn't come here.. keep compiler quite */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessTransactionCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"ProcessTransactionCommand: mtype:%d"</literal></expr></argument>, <argument><expr><name>mtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_NODE_BEGIN_REPLICATION_INIT</name></expr>:</case>
        	<expr_stmt><expr><call><name>ProcessBeginReplicaInitSyncRequest</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_NODE_END_REPLICATION_INIT</name></expr>:</case>
        	<expr_stmt><expr><call><name>ProcessEndReplicaInitSyncRequest</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_BEGIN</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBeginTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_BEGIN</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBkupBeginTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>MSG_BKUP_GLOBAL_TIMESTAMP</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBkupGlobalTimestamp</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_GETGTS</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGetGTSCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_GETGTS_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGetGTSCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_CHECK_GTM_STATUS</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessCheckGTMCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBeginTransactionGetGXIDCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_BEGIN_GETGXID</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBkupBeginTransactionGetGXIDCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID_AUTOVACUUM</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBeginTransactionGetGXIDAutovacuumCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_BEGIN_GETGXID_AUTOVACUUM</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBkupBeginTransactionGetGXIDAutovacuumCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_BEGIN_GETGXID_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBeginTransactionGetGXIDCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_BEGIN_GETGXID_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessBkupBeginTransactionGetGXIDCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_START_PREPARED</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessStartPreparedTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_START_PREPARED</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessStartPreparedTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_PREPARE</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPrepareTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_PREPARE</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessPrepareTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_COMMIT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessCommitTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_COMMIT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessCommitTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_COMMIT_PREPARED</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessCommitPreparedTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_COMMIT_PREPARED</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessCommitPreparedTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_ROLLBACK</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessRollbackTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_ROLLBACK</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessRollbackTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_COMMIT_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessCommitTransactionCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_COMMIT_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessCommitTransactionCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_ROLLBACK_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessRollbackTransactionCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_TXN_ROLLBACK_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessRollbackTransactionCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_GET_GXID</name></expr>:</case>
            <comment type="block">/*
             * Notice: we don't have corresponding functions in gtm_client.c
             *
             * Because this function is not used, GTM-standby extension is not
             * included in this function.
             */</comment>
            <expr_stmt><expr><call><name>ProcessGetGXIDTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_GET_GID_DATA</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGetGIDDataTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>MSG_TXN_FINISH_GID</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ProcessFinishGIDTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>    
        <case>case <expr><name>MSG_TXN_LOG_COMMIT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessLogTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MSG_TXN_LOG_GLOBAL_COMMIT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessLogTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MSG_TXN_LOG_SCAN</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_LOG_GLOBAL_SCAN</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessLogScanCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <case>case <expr><name>MSG_TXN_GET_NEXT_GXID</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGetNextGXIDTransactionCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_TXN_GXID_LIST</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGXIDListCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_REPORT_XMIN</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessReportXminCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_REPORT_XMIN</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessReportXminCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* Shouldn't come here.. keep compiler quite */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessSnapshotCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_SNAPSHOT_GET</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGetSnapshotCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SNAPSHOT_GET_MULTI</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGetSnapshotCommandMulti</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SNAPSHOT_GXID_GET</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessGetSnapshotCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* Shouldn't come here.. keep compiler quite */</comment>
    </block_content>}</block></switch>

</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessSequenceCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* We refuse all sequence command when sync commit is on and standby is not connected. */</comment>
    <if_stmt><if>if <condition>(<expr><name>enable_sync_commit</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"synchronus commit is on, standby must be connected."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_SEQUENCE_INIT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceInitCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_SEQUENCE_INIT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceInitCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_ALTER</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceAlterCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_SEQUENCE_ALTER</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceAlterCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_GET_CURRENT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceGetCurrentCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_GET_NEXT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceGetNextCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_SEQUENCE_GET_NEXT</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceGetNextCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_SET_VAL</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceSetValCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_SEQUENCE_SET_VAL</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceSetValCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_RESET</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceResetCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_SEQUENCE_RESET</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceResetCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_CLOSE</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceCloseCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_SEQUENCE_CLOSE</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceCloseCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_RENAME</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceRenameCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_BKUP_SEQUENCE_RENAME</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceRenameCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_SEQUENCE_LIST</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceListCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>MSG_CLEAN_SESSION_SEQ</name></expr>:</case>
            <expr_stmt><expr><call><name>ProcessSequenceCleanCommand</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* Shouldn't come here.. keep compiler quite */</comment>
    </block_content>}</block></switch>

</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessQueryCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MSG_TXN_GET_STATUS</name></expr>:</case>
        <case>case <expr><name>MSG_TXN_GET_ALL_PREPARED</name></expr>:</case>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* Shouldn't come here.. keep compiler quite */</comment>
    </block_content>}</block></switch>

</block_content>}</block></function>


    <function><type><specifier>static</specifier> <name>void</name></type>
<name>GTM_RegisterPGXCNode</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>PGXCNodeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Registering coordinator with name %s"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myport</name><operator>-&gt;</operator><name>node_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Validate the proposed data directory
 */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>checkDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>retry</name>:</label>
    <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>GTMDataDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>GTMDataDir</name></expr></argument>, <argument><expr><literal type="number">0700</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>errno</name><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to create the directory \"%s\""</literal></expr></argument>,
                             <argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>retry</name>;</goto>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EPERM</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read permissions of directory \"%s\": %m"</literal></expr></argument>,
                         <argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* eventual chdir would fail anyway, but let's test ... */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified data directory \"%s\" is not a directory"</literal></expr></argument>,
                     <argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the directory belongs to my userid; if not, reject.
     *
     * This check is an essential part of the interlock that prevents two
     * postmasters from starting in the same directory (see CreateLockFile()).
     * Do not remove or weaken it.
     *
     * XXX can we safely enable this check on Windows?
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_uid</name></name> <operator>!=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" has wrong ownership"</literal></expr></argument>,
                     <argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The server must be started by the user that owns the data directory."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Set data directory, but make sure it's an absolute path.  Use this,
 * never set DataDir directly.
 */</comment>
    <function><type><name>void</name></type>
<name>SetDataDir</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

    <comment type="block">/* If presented path is relative, convert to absolute */</comment>
    <expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>errno</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to set the data directory \"%s\""</literal></expr></argument>,
                     <argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>GTMDataDir</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>GTMDataDir</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change working directory to DataDir.  Most of the postmaster and backend
 * code assumes that we are in DataDir so it can use relative paths to access
 * stuff in and under the data directory.  For convenience during path
 * setup, however, we don't force the chdir to occur during SetDataDir.
 */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>ChangeToDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change directory to \"%s\": %m"</literal></expr></argument>,
                     <argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the data directory lockfile.
 *
 * When this is called, we must have already switched the working
 * directory to DataDir, so we can just use a relative path.  This
 * helps ensure that we are locking the directory we should be.
 */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateDataDirLockFile</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CreateLockFile</name><argument_list>(<argument><expr><name>GTM_PID_FILE</name></expr></argument>, <argument><expr><name>GTMDataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a lockfile.
 *
 * filename is the name of the lockfile to create.
 * amPostmaster is used to determine how to encode the output PID.
 * isDDLock and refName are used to determine what error message to produce.
 */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ntries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>encoded_pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>other_pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>my_pid</name> <init>= <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We need a loop here because of race conditions.    But don't loop forever
     * (for example, a non-writable $PGDATA directory might cause a failure
     * that won't go away).  100 tries seems like plenty.
     */</comment>
    <for>for <control>(<init><expr><name>ntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>ntries</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Try to create the lock file --- O_EXCL makes this atomic.
         *
         * Think not to make the file protection weaker than 0600.    See
         * comments below.
         */</comment>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* Success; exit the retry loop */</comment>

        <comment type="block">/*
         * Couldn't create the pid file. Probably it already exists.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>errno</name> <operator>!=</operator> <name>EEXIST</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EACCES</name><operator>)</operator> <operator>||</operator> <name>ntries</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create lock file \"%s\": %m"</literal></expr></argument>,
                         <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Read the file to get the old owner's PID.  Note race condition
         * here: file might have been deleted since we tried to create it.
         */</comment>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* race condition; try again */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open lock file \"%s\": %m"</literal></expr></argument>,
                         <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read lock file \"%s\": %m"</literal></expr></argument>,
                         <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>encoded_pid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>other_pid</name> <operator>=</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <name>encoded_pid</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"bogus data in lock file \"%s\": \"%s\""</literal></expr></argument>,
                    <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check to see if the other process still exists
         *
         * If the PID in the lockfile is our own PID or our parent's PID, then
         * the file must be stale (probably left over from a previous system
         * boot cycle).  We need this test because of the likelihood that a
         * reboot will assign exactly the same PID as we had in the previous
         * reboot.    Also, if there is just one more process launch in this
         * reboot than in the previous one, the lockfile might mention our
         * parent's PID.  We can reject that since we'd never be launched
         * directly by a competing postmaster.    We can't detect grandparent
         * processes unfortunately, but if the init script is written
         * carefully then all but the immediate parent shell will be
         * root-owned processes and so the kill test will fail with EPERM.
         *
         * We can treat the EPERM-error case as okay because that error
         * implies that the existing process has a different userid than we
         * do, which means it cannot be a competing postmaster.  A postmaster
         * cannot successfully attach to a data directory owned by a userid
         * other than its own.    (This is now checked directly in
         * checkDataDir(), but has been true for a long time because of the
         * restriction that the data directory isn't group- or
         * world-accessible.)  Also, since we create the lockfiles mode 600,
         * we'd have failed above if the lockfile belonged to another userid
         * --- which means that whatever process kill() is reporting about
         * isn't the one that made the lockfile.  (NOTE: this last
         * consideration is the only one that keeps us from blowing away a
         * Unix socket file belonging to an instance of Postgres being run by
         * someone else, at least on machines where /tmp hasn't got a
         * stickybit.)
         *
         * Windows hasn't got getppid(), but doesn't need it since it's not
         * using real kill() either...
         *
         * Normally kill() will fail with ESRCH if the given PID doesn't
         * exist.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>!=</operator> <name>my_pid</name>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
                <operator>&amp;&amp;</operator> <name>other_pid</name> <operator>!=</operator> <call><name>getppid</name><argument_list>()</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
           )</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>other_pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                    <operator>(</operator><name>errno</name> <operator>!=</operator> <name>ESRCH</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EPERM</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* lockfile belongs to a live process */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" already exists"</literal></expr></argument>,
                             <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another GTM (PID %d) running in data directory \"%s\"?"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Looks like nobody's home.  Unlink the file and try again to create
         * it.    Need a loop because of possible race condition against other
         * would-be creators.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old lock file \"%s\": %m"</literal></expr></argument>,
                         <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The file seems accidentally left over, but "</literal>
                         <literal type="string">"it could not be removed. Please remove the file "</literal>
                         <literal type="string">"by hand and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Successfully created the file, now fill it.
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d\n%s\n%d\n"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>my_pid</name></expr></argument>, <argument><expr><name>GTMDataDir</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the opts file
 */</comment>
    <function><type><specifier>static</specifier> <name>bool</name></type>
<name>CreateOptsFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTS_FILE</name></cpp:macro>    <cpp:value>"gtm.opts"</cpp:value></cpp:define>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>OPTS_FILE</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>OPTS_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>OPTS_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* delete pid file */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EACCES</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old lock file \"%s\": %m"</literal></expr></argument>,
                     <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The file seems accidentally left over, but "</literal>
                     <literal type="string">"it could not be removed. Please remove the file "</literal>
                     <literal type="string">"by hand and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
<name>PromoteToActive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conf_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Promote signal received. Becoming an active..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set starting and next client idendifier before promotion is complete
     */</comment>
    <comment type="line">//    GTM_SetInitialAndNextClientIdentifierAtPromote();</comment>

    <comment type="block">/*
     * Do promoting things here.
     */</comment>
    <expr_stmt><expr><call><name>Recovery_StandbySetStandby</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update the GTM config file for the next restart..
     */</comment>
    <expr_stmt><expr><name>conf_file</name> <operator>=</operator> <call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"config_file"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Config file is %s..."</literal></expr></argument>, <argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>, <argument><expr><name>PG_BINARY_A</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open GTM configuration file \"%s\": %m"</literal></expr></argument>,
                     <argument><expr><name>conf_file</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>time_t</name></type>        <name>stamp_time</name> <init>= <expr><operator>(</operator><name>time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>strfbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>strfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strfbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
                <argument><expr><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, 
                <argument><expr><literal type="string">"#===================================================\n"</literal>
                <literal type="string">"# Updated due to GTM promote request\n"</literal>
                <literal type="string">"# %s\nstartup = ACT\n"</literal>
                <literal type="string">"#===================================================\n"</literal></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close GTM configuration file \"%s\": %m"</literal></expr></argument>,
                         <argument><expr><name>conf_file</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
    <expr_stmt><expr><call><name>GTM_SetNeedBackup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_WriteRestorePoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ProcessBarrierCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>GTM_MessageType</name></type> <name>mtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>barrier_id_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>barrier_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>oldconn</name> <init>= <expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>myport</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>!=</operator> <name>GTM_NODE_GTM</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"gtm standby can't provide barrier to datanodes or coordinators."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>    

    <expr_stmt><expr><name>barrier_id_len</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>barrier_id</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>barrier_id_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Processing BARRIER %s"</literal></expr></argument>, <argument><expr><name>barrier_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mtype</name> <operator>==</operator> <name>MSG_BARRIER</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr>)</condition>
    <block>{<block_content>
<label><name>retry</name>:</label>
        <expr_stmt><expr><call><name>bkup_report_barrier</name><argument_list>(<argument><expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr></argument>, <argument><expr><name>barrier_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>gtm_standby_check_communication_error</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>oldconn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>Backup_synchronously</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>myport</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>!=</operator> <name>GTM_NODE_GTM_PROXY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>gtm_sync_standby</name><argument_list>(<argument><expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_WriteBarrierBackup</name><argument_list>(<argument><expr><name>barrier_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>==</operator> <name>MSG_BARRIER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Send a SUCCESS message back to the client
         */</comment>
        <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>BARRIER_RESULT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>myport</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>==</operator> <name>GTM_NODE_GTM_PROXY</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>GTM_ProxyMsgHeader</name></type> <name>proxyhdr</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>=</operator> <name><name>myport</name><operator>-&gt;</operator><name>conn_id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>proxyhdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ProxyMsgHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>myport</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>!=</operator> <name>GTM_NODE_GTM_PROXY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Flush standby first */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>gtmpqFlush</name><argument_list>(<argument><expr><call><name>GetMyConnection</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>standby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

    <function><type><name>void</name></type>
<name>GTM_RestoreStart</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ctlf</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>GTM_RestoreContext</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"version: %d\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Read control file version %d"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to read file version"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

    <function><type><name>void</name></type>
<name>GTM_RestoreTxnInfo</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ctlf</name></decl></parameter>, <parameter><decl><type><name>GlobalTransactionId</name></type> <name>next_gxid</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>GTM_RestoreContext</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>saved_gxid</name> <init>= <expr><name>InvalidGlobalTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type>  <name>saved_gts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctlf</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If the control file version is 20160302, then we expect to see
         * next_xid and global_xmin saved as first two lines. For older
         * versions, just the next_xid is stored
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>context</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <literal type="number">20160302</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"next_xid: %u\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_gxid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>saved_gxid</name> <operator>=</operator> <name>InvalidGlobalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"next_timestamp: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_gts</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>saved_gts</name> <operator>=</operator> <name>InvalidGlobalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%u\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_gxid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>saved_gxid</name> <operator>=</operator> <name>InvalidGlobalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the caller has supplied an explicit XID to restore, just use that.
     * This is typically only be used during initdb and in some exception
     * circumstances to recover from failures. But otherwise we must start with
     * the XIDs saved in the control file
     *
     * If the global_xmin was saved (which should be unless we are dealing with
     * an old control file), use that. Otherwise set it saved_gxid/next_xid
     * whatever is available. If we don't used the value incremented by
     * CONTROL_INTERVAL because its better to start with a conservative value
     * for the GlobalXmin
     */</comment>


    <expr_stmt><expr><call><name>SetNextGlobalTimestamp</name><argument_list>(<argument><expr><name>saved_gts</name> <operator>+</operator> <name>GTM_GLOBAL_TIME_DELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetNextGlobalTransactionId</name><argument_list>(<argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restoring last GXID to %u\n"</literal></expr></argument>, <argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restoring global xmin to %u\n"</literal></expr></argument>,
            <argument><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_recent_global_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restoring gts to "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
            <argument><expr><name>saved_gts</name> <operator>+</operator> <name>GTM_GLOBAL_TIME_DELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set this otherwise a strange snapshot might be returned for the first one */</comment>
    <expr_stmt><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_latestCompletedXid</name></name> <operator>=</operator> <name>next_gxid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>GTM_SaveVersion</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ctlf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"version: %d\n"</literal></expr></argument>, <argument><expr><name>GTM_CONTROL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

    <function><type><name>void</name></type>
<name>GTM_SaveTxnInfo</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ctlf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>next_gxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>global_xmin</name> <init>= <expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_recent_global_xmin</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type>     <name>next_gts</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>next_gts</name> <operator>=</operator> <call><name>GetNextGlobalTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>next_gxid</name> <operator>=</operator> <call><name>ReadNewGlobalTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Saving transaction info - next_gxid: %u, global_xmin: %u"</literal></expr></argument>,
            <argument><expr><name>next_gxid</name></expr></argument>, <argument><expr><name>global_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"next_xid: %u\n"</literal></expr></argument>, <argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"next_timestamp: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>next_gts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

    <function><type><name>void</name></type>
<name>GTM_WriteRestorePointXid</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>MaxGlobalTransactionId</name> <operator>-</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_nextXid</name></name><operator>)</operator> <operator>&lt;=</operator> <name>RestoreDuration</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_backedUpXid</name></name> <operator>=</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_nextXid</name></name> <operator>+</operator> <name>RestoreDuration</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_backedUpXid</name></name> <operator>=</operator> <name>FirstNormalGlobalTransactionId</name> <operator>+</operator> <operator>(</operator><name>RestoreDuration</name> <operator>-</operator> <operator>(</operator><name>MaxGlobalTransactionId</name> <operator>-</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_nextXid</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Saving transaction restoration info, backed-up gxid: %u"</literal></expr></argument>, <argument><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_backedUpXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"next_xid: %u\n"</literal></expr></argument>, <argument><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_backedUpXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"global_xmin: %u\n"</literal></expr></argument>, <argument><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_backedUpXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

    <function><type><name>void</name></type>
<name>GTM_WriteRestorePointVersion</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GTM_SaveVersion</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

    <function><type><name>void</name></type>
<name>GTM_RestoreSeqInfo</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ctlf</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>GTM_RestoreContext</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>seqname</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ctlf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>seqname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GTM_SequenceKeyData</name></type> <name>seqkey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GTM_Sequence</name></type> <name>increment_by</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GTM_Sequence</name></type> <name>minval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GTM_Sequence</name></type> <name>maxval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GTM_Sequence</name></type> <name>startval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GTM_Sequence</name></type> <name>curval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type> <name>state</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>cycle</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>called</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>boolval</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>decode_seq_key</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>curval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>startval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>increment_by</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>minval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>boolval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>cycle</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>boolval</name> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>boolval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>called</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>boolval</name> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>ctlf</name></expr></argument>, <argument><expr><literal type="string">"%x"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Corrupted control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>GTM_SeqRestore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqkey</name></expr></argument>, <argument><expr><name>increment_by</name></expr></argument>, <argument><expr><name>minval</name></expr></argument>, <argument><expr><name>maxval</name></expr></argument>, <argument><expr><name>startval</name></expr></argument>, <argument><expr><name>curval</name></expr></argument>,
                <argument><expr><name>state</name></expr></argument>, <argument><expr><name>cycle</name></expr></argument>, <argument><expr><name>called</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <function><type><name>void</name></type>
<name>GTM_RestoreStoreInfo</name><parameter_list>(<parameter><decl><type><name>GlobalTransactionId</name></type> <name>next_gxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>saved_gxid</name>            <init>= <expr><name>InvalidGlobalTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>saved_global_xmin</name>    <init>= <expr><name>InvalidGlobalTransactionId</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type>        <name>saved_gts</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>GTM_StoreRestore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>saved_gts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_gxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_global_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"GTM_RestoreStoreInfo restore data file failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
    <comment type="block">/*
     * If the caller has supplied an explicit XID to restore, just use that.
     * This is typically only be used during initdb and in some exception
     * circumstances to recover from failures. But otherwise we must start with
     * the XIDs saved in the control file
     *
     * If the global_xmin was saved (which should be unless we are dealing with
     * an old control file), use that. Otherwise set it saved_gxid/next_xid
     * whatever is available. If we don't used the value incremented by
     * CONTROL_INTERVAL because its better to start with a conservative value
     * for the GlobalXmin
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><name>saved_gxid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* 
             * Add in extra amount in case we had not gracefully stopped
             */</comment>
            <expr_stmt><expr><name>next_gxid</name> <operator>=</operator> <name>saved_gxid</name> <operator>+</operator> <name>CONTROL_INTERVAL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator>  <call><name>GTM_StoreReserveXid</name><argument_list>(<argument><expr><name>CONTROL_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"GTM_RestoreStoreInfo reserved gxid failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>SetControlXid</name><argument_list>(<argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>saved_gxid</name> <operator>=</operator> <name>next_gxid</name> <operator>=</operator> <name>InitialGXIDValue_Default</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator>  <call><name>GTM_StoreReserveXid</name><argument_list>(<argument><expr><name>CONTROL_INTERVAL</name> <operator>+</operator> <name>InitialGXIDValue_Default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"GTM_RestoreStoreInfo reserved gxid failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><name>saved_global_xmin</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_recent_global_xmin</name></name> <operator>=</operator> <name>saved_global_xmin</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_recent_global_xmin</name></name> <operator>=</operator> <name>saved_gxid</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><name>saved_gxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>GlobalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>next_gxid</name></expr></argument>, <argument><expr><name>saved_gxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>force_xid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>EINVAL</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Requested to start GTM with starting xid %d, "</literal>
                         <literal type="string">"which is lower than gxid saved in control file %d. Refusing to start"</literal></expr></argument>,
                         <argument><expr><name>next_gxid</name></expr></argument>, <argument><expr><name>saved_gxid</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you must force start GTM with a lower xid, please"</literal>
                         <literal type="string">" use -f option"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_recent_global_xmin</name></name> <operator>=</operator> <name>next_gxid</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>SetNextGlobalTransactionId</name><argument_list>(<argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>SetNextGlobalTimestamp</name><argument_list>(<argument><expr><name>saved_gts</name> <operator>+</operator> <name>GTM_GLOBAL_TIME_DELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restoring gts to "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
            <argument><expr><name>saved_gts</name> <operator>+</operator> <name>GTM_GLOBAL_TIME_DELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>    
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restoring last GXID to %u\n"</literal></expr></argument>, <argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restoring global xmin to %u\n"</literal></expr></argument>,
            <argument><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_recent_global_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set this otherwise a strange snapshot might be returned for the first one */</comment>
    <expr_stmt><expr><name><name>GTMTransactions</name><operator>.</operator><name>gt_latestCompletedXid</name></name> <operator>=</operator> <name>next_gxid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>GTM_TimerInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>g_timer_entry</name> <operator>=</operator> <operator>(</operator><name>GTM_TimerEntry</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_TimerEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>GTM_MAX_TIMER_ENTRY_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>g_timer_entry</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to create timers, out of memory."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>g_timer_entry</name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GTM_TimerEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>GTM_MAX_TIMER_ENTRY_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>g_timer_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to create timers, init lock failed for %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>    
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a timer into the timer entries. */</comment>
<function><type><name>GTM_TimerHandle</name></type> <name>GTM_AddTimer</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier> <name>func</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>GTM_TIMER_TYPE</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>para</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>bret</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>GTM_TIMER_TYPE_ONCE</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator>  <name>GTM_TIMER_TYPE_LOOP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to acquire lock invalid timer type:%d."</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>INVALID_TIMER_HANDLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to acquire lock when alloc timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>INVALID_TIMER_HANDLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* loop to find an empty entry */</comment>
    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GTM_MAX_TIMER_ENTRY_NUMBER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>balloced</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>timer_routine</name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>param</name> <operator>=</operator> <name>para</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interval</name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bactive</name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>balloced</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>g_used_entry</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to release lock when alloc timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>INVALID_TIMER_HANDLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><name>i</name></expr> </then><else>: <expr><name>INVALID_TIMER_HANDLE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove a timer from the timer entries. */</comment>
<function><type><name>int</name></type> <name>GTM_RemoveTimer</name><parameter_list>(<parameter><decl><type><name>GTM_TimerHandle</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>bret</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>handle</name> <operator>&gt;=</operator> <name>GTM_MAX_TIMER_ENTRY_NUMBER</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to remove timer for invalid handle:%d."</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to acquire lock when remove timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>timer_routine</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>param</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>interval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>bactive</name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>balloced</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_used_entry</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed to release lock when remove timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Enable a timer. */</comment>
<function><type><name>int</name></type> <name>GTM_ActiveTimer</name><parameter_list>(<parameter><decl><type><name>GTM_TimerHandle</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>bret</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>handle</name> <operator>&gt;=</operator> <name>GTM_MAX_TIMER_ENTRY_NUMBER</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to active timer for invalid handle:%d."</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to acquire lock when active timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>bactive</name>    <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to release lock when active timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Disable a timer. */</comment>
<function><type><name>int</name></type> <name>GTM_DeactiveTimer</name><parameter_list>(<parameter><decl><type><name>GTM_TimerHandle</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>bret</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>handle</name> <operator>&gt;=</operator> <name>GTM_MAX_TIMER_ENTRY_NUMBER</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to deactive timer for invalid handle:%d."</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to acquire lock when deactive timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>bactive</name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>handle</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        
    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to release lock when deactive timer. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Run the timer entries. */</comment>
<function><type><name>void</name></type> <name>GTM_TimerRun</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>bret</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>now</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>g_used_entry</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to acquire lock when timer run. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* loop to find an empty entry */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GTM_MAX_TIMER_ENTRY_NUMBER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>balloced</name> <operator>&amp;&amp;</operator> <name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bactive</name></expr>)</condition>
        <block>{<block_content>        
            <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>time_type</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GTM_TIMER_TYPE_ONCE</name></expr>:</case>
                    <block>{<block_content>        
                        <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;</operator> <name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>now</name> <operator>-</operator> <name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>&gt;=</operator> <name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interval</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>timer_routine</name><argument_list>(<argument><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bactive</name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt><comment type="block">/* Once timer will be disabled when triggered. */</comment>
                                <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* just in case. */</comment>
                            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <break>break;</break>
                    </block_content>}</block>

                <case>case <expr><name>GTM_TIMER_TYPE_LOOP</name></expr>:</case>                    
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;</operator> <name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>now</name> <operator>-</operator> <name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>&gt;=</operator> <name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interval</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>timer_routine</name><argument_list>(<argument><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Once timer will run again when timeout. */</comment>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* just in case. */</comment>
                            <expr_stmt><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <break>break;</break>
                    </block_content>}</block>
                <case>case <expr><name>GTM_TIMER_TYPE_BUTTY</name></expr>:</case>
                <default>default:</default>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid timer type: %d."</literal></expr></argument>, <argument><expr><name><name>g_timer_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>time_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>bret</name> <operator>=</operator> <call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_timer_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to release lock when timer run. reason: %s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

    <function><type><name>void</name> 
<modifier>*</modifier></type>
<name>GTM_TimerThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>  <name>local_sigjmp_buf</name></decl>;</decl_stmt>    

    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
            <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
            <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
            <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
            <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * POSTGRES main processing loop begins here
     *
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <comment type="block">/* no need to lock here. */</comment>
        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>GTM_TimerRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name>GTM_TIMER_NAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block></for>    
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM timer thread exit."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_timer_thread</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>thrinfo</name></expr>;</return>    
</block_content>}</block></function>
<comment type="block">/*
 * Check whether the standby connection is avaliable.
 */</comment>
<function><type><name>void</name></type> <name>CheckStandbyConnect</name><parameter_list>(<parameter><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name></decl></parameter>, <parameter><decl><type><name>GTM_ConnectionInfo</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_standby_ready</name></name>     <operator>&amp;&amp;</operator>
            <name>NULL</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>standby</name></name>        <operator>&amp;&amp;</operator>
            <name><name>my_threadinfo</name><operator>-&gt;</operator><name>thr_status</name></name> <operator>!=</operator> <name>GTM_THREAD_BACKUP</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Connect to GTM-Standby */</comment>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name> <operator>=</operator> <call><name>gtm_standby_connect_to_standby</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr>)</condition>
        <block>{<block_content>    
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Connect standby node failed!!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_standby_ready</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* This will make other threads to disconnect from
                                                      * the standby, if needed.*/</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_standby_ready</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Disconnect from GTM-Standby */</comment>
        <expr_stmt><expr><call><name>gtm_standby_disconnect_from_standby</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>standby</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>XLogRecPtr</name></type> <name>PrintPageHeader</name><parameter_list>(<parameter><decl><type><name>XLogPageHeaderData</name> <modifier>*</modifier></type><name>header</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>!=</operator> <name>GTM_XLOG_PAGE_MAGIC</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"xlog header magic validate fails %x\n"</literal></expr></argument>,<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_magic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"XLogPageHeaderData ptr:%lld\n"</literal></expr></argument>,<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>header</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>PrintMemory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while<condition>(<expr><name>size</name><operator>--</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d "</literal></expr></argument>,<argument><expr><operator>*</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>uint32</name></type> 
<name>ReaderPrintRangeOverwrite</name><parameter_list>(<parameter><decl><type><name>XLogCmdRangerOverWrite</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"RangeOverwrite %d %d"</literal></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdRangerOverWrite</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>uint32</name></type> 
<name>ReaderPrintCheckPoint</name><parameter_list>(<parameter><decl><type><name>XLogCmdCheckPoint</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ReaderPrintCheckPoint %lld "</literal></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>gts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdCheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>uint32</name></type> 
<name>ReaderPrintTimestamp</name><parameter_list>(<parameter><decl><type><name>XLogRecGts</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ReaderPrintCheckPoint %lld"</literal></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>gts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdCheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Read_XLogRecovery</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog_path</name></decl></parameter>,<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>,<parameter><decl><type><name>uint64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xlog_buff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xlog_rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>page_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>bytes_read</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>desired_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>read_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>cur_xlog_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>redo_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>redo_end_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>preXLogRecord</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecord</name>  <modifier>*</modifier></type><name>record_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>read_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32</name></type>    <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogPageHeaderData</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rec_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>xlog_buff</name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>

    <comment type="block">/* One record must not larger then UsableBytesInSegment */</comment>
    <expr_stmt><expr><name>xlog_rec</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>UsableBytesInSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

    <expr_stmt><expr><name>record_header</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name>  <operator>*</operator><operator>)</operator><name>xlog_rec</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>cur_xlog_size</name> <operator>=</operator> <call><name>ReadXLogToBuff</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_xlog_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>bytes_read</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>preXLogRecord</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>redo_pos</name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>redo_end_pos</name>  <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name>           <operator>=</operator> <name>offset</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>xlog_buff</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>


    <while>while<condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>cur_xlog_size</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>read_size</name>   <operator>=</operator> <name>desired_bytes</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>page_offset</name> <operator>=</operator> <name>idx</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt>

        <comment type="block">/* if we are at the head of a page,skip the page header */</comment>
        <if_stmt><if>if<condition>(<expr><name>page_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>,<argument><expr><name>xlog_buff</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PrintPageHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>xlog_buff</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name>       <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

            <expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>read_size</name></expr></argument>,<argument><expr><name>UsableBytesInPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>read_size</name></expr></argument>,<argument><expr><name>GTM_XLOG_BLCKSZ</name> <operator>-</operator> <name>page_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>redo_pos</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>redo_pos</name> <operator>=</operator> <name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xlog_rec</name> <operator>+</operator> <name>rec_offset</name></expr></argument>,<argument><expr><name>xlog_buff</name></expr></argument>,<argument><expr><name>read_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>idx</name>           <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>xlog_buff</name>     <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>desired_bytes</name> <operator>-=</operator> <name>read_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes_read</name>    <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rec_offset</name>    <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>read_header</name> <operator>&amp;&amp;</operator> <name>bytes_read</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Read header %X/%X wiht bytes %lld \n"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,<argument><expr><name>desired_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>desired_bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Get one record at %lld length %lld rec_crc: %u\n"</literal></expr></argument>,<argument><expr><name>redo_pos</name></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>xlog_rec</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>record_header</name></expr></argument>,<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>,<argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">//PrintMemory(xlog_rec + sizeof(XLogRecord),record_header-&gt;xl_tot_len);</comment>
            <comment type="line">//PrintMemory((char *)xlog_rec,offsetof(XLogRecord,xl_crc));</comment>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>redo_pos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"caled crc %lld\n"</literal></expr></argument>,<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>crc</name> <operator>!=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_crc</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Xlog %X/%X crc validation fails\n"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>preXLogRecord</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>preXLogRecord</name> <operator>!=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_prev</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Xlog %X/%X validation prelink fails recorded : %X/%X calculated: %X/%X\n"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>record_header</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>record_header</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>preXLogRecord</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>preXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>ReadRedoXLogRecord</name><argument_list>(<argument><expr><name>record_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n##############################\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>redo_end_pos</name>  <operator>=</operator> <name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><name>bytes_read</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>preXLogRecord</name> <operator>=</operator> <name>redo_pos</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>redo_pos</name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rec_offset</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"exit %d\n"</literal></expr></argument>,<argument><expr><name>cur_xlog_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

    <function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>seg</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><name>seg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Read_XLogRecovery</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>seg</name></expr></argument>,<argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Read_XLogRecovery</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>seg</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

</unit>
