<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/common/gtm_opt_handler.c"><comment type="block">/* -*-pgsql-c-*- */</comment>
<comment type="block">/*
 * Scanner for the configuration file
 *
 * Copyright (c) 2000-2011, PostgreSQL Global Development Group
 *
 * src/backend/utils/misc/guc-file.l
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_opt_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm_opt_scanner.c"</cpp:file></cpp:include>

<comment type="block">/* Avoid exit() on fatal scanner errors (a bit ugly -- see yy_fatal_error) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fprintf</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fprintf</name><parameter_list>(<parameter><type><name>file</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>ereport(ERROR, (errmsg_internal("%s", msg)))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ConfigFileLineno</name></decl>;</decl_stmt>

<comment type="block">/* flex fails to supply a prototype for GTMOPT_yylex, so provide one */</comment>
<function_decl><type><name>int</name></type> <name>GTMOPT_GTMOPT_yylex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Functions defined in this file */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>GTMOPT_scanstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>find_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_placeholders</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>gtm_opt_strdup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gtm_opt_name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namea</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>get_gtm_opt_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>build_gtm_opt_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gtm_opt_parse_bool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gtm_opt_parse_bool_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_config_sourcefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gtm_opt_var_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeOneGTMOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>gconf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReportGTMOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>_ShowOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_units</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>GTM_SendNotifyByte</name><parameter_list>()</parameter_list>;</function_decl>

<comment type="block">/*
 * Variables to bel fed by specific option definition: gtm_opt.c and gtm_proxy_opt.c
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>GTMConfigFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name>       <modifier>*</modifier></type><name>data_directory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>gtm_opt_variables</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>num_gtm_opt_variables</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>    <name>size_gtm_opt_variables</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>reporting_enabled</name></decl>;</decl_stmt>    <comment type="block">/* TRUE to enable GTMOPT_REPORT */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>config_filename</name></decl>;</decl_stmt>   <comment type="block">/* Default configuration file name */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>    <name>GTMOptUpdateCount</name></decl>;</decl_stmt> <comment type="block">/* Indicates when specific option is updated */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>isStartUp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>recovery_file_name</name></decl>;</decl_stmt>

<comment type="block">/*
 * Tables of options: to be defined in gtm_opt.c and gtm_proxy_opt.c
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>config_bool</name></name></type> <name><name>ConfigureNamesBool</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>config_int</name></name></type> <name><name>ConfigureNamesInt</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>config_real</name></name></type> <name><name>ConfigureNamesReal</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>config_string</name></name></type> <name><name>ConfigureNamesString</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>config_enum</name></name></type> <name><name>ConfigureNamesEnum</name><index>[]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * Note: MAX_BACKENDS is limited to 2^23-1 because inval.c stores the
 * backend ID as a 3-byte signed integer.  Even if that limitation were
 * removed, we still could not exceed INT_MAX/4 because some places compute
 * 4*MaxBackends without any overflow check.  This is rechecked in
 * check_maxconnections, since MaxBackends is computed as MaxConnections
 * plus autovacuum_max_workers plus one (for the autovacuum launcher).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BACKENDS</name></cpp:macro>    <cpp:value>0x7fffff</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KB_PER_MB</name></cpp:macro> <cpp:value>(1024)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KB_PER_GB</name></cpp:macro> <cpp:value>(1024*1024)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MS_PER_S</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_PER_MIN</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MS_PER_MIN</name></cpp:macro> <cpp:value>(1000 * 60)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_PER_H</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_PER_H</name></cpp:macro> <cpp:value>(60 * 60)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MS_PER_H</name></cpp:macro> <cpp:value>(1000 * 60 * 60)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_PER_D</name></cpp:macro> <cpp:value>(60 * 24)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_PER_D</name></cpp:macro> <cpp:value>(60 * 60 * 24)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MS_PER_D</name></cpp:macro> <cpp:value>(1000 * 60 * 60 * 24)</cpp:value></cpp:define>


<comment type="block">/*
 * Exported function to read and process the configuration file. The
 * parameter indicates in what context the file is being read --- either
 * postmaster startup (including standalone-backend startup) or SIGHUP.
 * All options mentioned in the configuration file are set to new values.
 * If an error occurs, no values will be changed.
 */</comment>
<function><type><name>bool</name></type>
<name>ProcessConfigFile</name><parameter_list>(<parameter><decl><type><name>GtmOptContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>elevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>head</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>tail</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>recovery_head</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>recovery_tail</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cvc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>context</name> <operator>==</operator> <name>GTMC_STARTUP</name> <operator>||</operator> <name>context</name> <operator>==</operator> <name>GTMC_SIGHUP</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>GTMC_SIGHUP</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Parse the file into a list of option names and values */</comment>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name>tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseConfigFile</name><argument_list>(<argument><expr><name>GTMConfigFileName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup_list</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>recovery_file_name</name></expr></argument>,<argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>recovery_head</name> <operator>=</operator> <name>recovery_tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ParseConfigFile</name><argument_list>(<argument><expr><name>recovery_file_name</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>elevel</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>recovery_head</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>recovery_tail</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>cleanup_list</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>recovery_head</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name>       <operator>=</operator> <name>recovery_tail</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* No custom_variable_classes now */</comment>
    <comment type="block">/*
     * This part of the code remained the same as original guc.c because
     * we might want to have custom variable class for gtm.conf.
     */</comment>
    <comment type="block">/*
     * We need the proposed new value of custom_variable_classes to check
     * custom variables with.  ParseConfigFile ensured that if it's in
     * the file, it's first in the list.  But first check to see if we
     * have an active value from the command line, which should override
     * the file in any case.  (Since there's no relevant env var, the
     * only possible nondefault sources are the file and ARGV.)
     */</comment>
    cvc_struct = (struct config_string *)
        find_option("custom_variable_classes", false, elevel);
    Assert(cvc_struct);
    if (cvc_struct-&gt;gen.reset_source &gt; GTMC_S_FILE)
    {
        cvc = gtm_opt_strdup(elevel, cvc_struct-&gt;reset_val);
        if (cvc == NULL)
            goto cleanup_list;
    }
    else if (head != NULL &amp;&amp;
             gtm_opt_name_compare(head-&gt;name, "custom_variable_classes") == 0)
    {
        <comment type="block">/*
         * Need to canonicalize the value by calling the check hook.
         */</comment>
        void   *extra = NULL;

        cvc = gtm_opt_strdup(elevel, head-&gt;value);
        if (cvc == NULL)
            goto cleanup_list;
        if (extra)
            free(extra);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Mark all extant GUC variables as not present in the config file.
     * We need this so that we can tell below which ones have been removed
     * from the file since we last processed it.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_gtm_opt_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>gtm_opt_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GTMOPT_IS_IN_FILE</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Check if all options are valid.  As a side-effect, the GTMOPT_IS_IN_FILE
     * flag is set on each GUC variable mentioned in the list.
     */</comment>
    <for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>GTMOPT_QUALIFIER_SEPARATOR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>sep</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * There is no GUC entry.  If we called set_config_option then
             * it would make a placeholder, which we don't want to do yet,
             * since we could still fail further down the list.  Do nothing
             * (assuming that making the placeholder will succeed later).
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>find_option</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <comment type="block">/*
             * 3. There is already a GUC entry (either real or placeholder) for
             * the variable.  In this case we should let set_config_option
             * check it, since the assignment could well fail if it's a real
             * entry.
             */</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_config_option</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
                               <argument><expr><name>GTMC_S_FILE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>cleanup_list</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Check for variables having been removed from the config file, and
     * revert their reset values (and perhaps also effective values) to the
     * boot-time defaults.  If such a variable can't be changed after startup,
     * just throw a warning and continue.  (This is analogous to the fact that
     * set_config_option only throws a warning for a new but different value.
     * If we wanted to make it a hard error, we'd need an extra pass over the
     * list so that we could throw the error before starting to apply
     * changes.)
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_gtm_opt_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>gtm_opt_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name> <operator>!=</operator> <name>GTMC_S_FILE</name> <operator>||</operator>
            <operator>(</operator><name><name>gconf</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;</operator> <name>GTMOPT_IS_IN_FILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>&lt;</operator> <name>GTMC_SIGHUP</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * In the original code, errcode() stores specified error code to sqlerrcode, which does not
             * exist in GTM.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                             <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                        <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                                <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Reset any "file" sources to "default", else set_config_option
         * will not override those settings.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name> <operator>==</operator> <name>GTMC_S_FILE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name> <operator>=</operator> <name>GTMC_S_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>GTMC_S_FILE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>GTMC_S_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>GTMC_S_FILE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>GTMC_S_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Now we can re-apply the wired-in default (i.e., the boot_val) */</comment>
        <expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>GTMC_S_DEFAULT</name></expr></argument>,
                          <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>GTMC_SIGHUP</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" removed from configuration file, reset to default\n"</literal></expr></argument>,
                             <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" removed from configuration file, reset to default"</literal></expr></argument>,
                                <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Restore any variables determined by environment variables or
     * dynamically-computed defaults.  This is a no-op except in the case
     * where one of these had been in the config file and is now removed.
     *
     * In particular, we *must not* do this during the postmaster's
     * initial loading of the file, since the timezone functions in
     * particular should be run only after initialization is complete.
     *
     * XXX this is an unmaintainable crock, because we have to know how
     * to set (or at least what to call to set) every variable that could
     * potentially have GTMC_S_DYNAMIC_DEFAULT or GTMC_S_ENV_VAR source.
     * However, there's no time to redesign it for 9.1.
     */</comment>

    <comment type="block">/* If we got here all the options checked out okay, so apply them. */</comment>
    <for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pre_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>set_config_option</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
                                    <argument><expr><name>GTMC_S_FILE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_config_sourcefile</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
                                  <argument><expr><name><name>item</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>pre_value</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>post_value</name> <init>= <expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>post_value</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>post_value</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pre_value</name></expr></argument>, <argument><expr><name>post_value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" changed to \"%s\"\n"</literal></expr></argument>,
                                     <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" changed to \"%s\""</literal></expr></argument>,
                                        <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>pre_value</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pre_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* PGXCTODO: configuration file reload time update */</comment>

    <expr_stmt><expr><call><name>FreeConfigVariables</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cvc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cvc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* notify the syslogger */</comment>
    <expr_stmt><expr><call><name>GTM_SendNotifyByte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>

<label><name>cleanup_list</name>:</label>
    <expr_stmt><expr><call><name>FreeConfigVariables</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cvc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cvc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * See next function for details. This one will just work with a config_file
 * name rather than an already opened File Descriptor
 */</comment>
<function><type><name>bool</name></type>
<name>ParseConfigFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>config_file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>calling_file</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
                <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>head_p</name></decl></parameter>,
                <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>OK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>abs_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Reject too-deep include nesting depth.  This is just a safety check
     * to avoid dumping core due to stack overflow if an include file loops
     * back to itself.  The maximum nesting depth is pretty arbitrary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not open configuration file \"%s\": maximum nesting depth exceeded\n"</literal></expr></argument>,
                         <argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open configuration file \"%s\": maximum nesting depth exceeded"</literal></expr></argument>,
                            <argument><expr><name>config_file</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If config_file is a relative path, convert to absolute.  We consider
     * it to be relative to the directory holding the calling file.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>calling_file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>calling_file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>abs_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>get_parent_directory</name><argument_list>(<argument><expr><name>abs_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>abs_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>config_file</name> <operator>=</operator> <name>abs_path</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * calling_file is NULL, we make an absolute path from $PGDATA
             */</comment>
            <expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>data_directory</name></expr></argument>, <argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>abs_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>config_file</name> <operator>=</operator> <name>abs_path</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not open configuration file \"%s\": %m\n"</literal></expr></argument>,
                         <argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open configuration file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>config_file</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>ParseConfigFp</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>head_p</name></expr></argument>, <argument><expr><name>tail_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read and parse a single configuration file.  This function recurses
 * to handle "include" directives.
 *
 * Input parameters:
 *    fp: file pointer from AllocateFile for the configuration file to parse
 *    config_file: absolute or relative path of file to read
 *    depth: recursion depth (used only to prevent infinite recursion)
 *    elevel: error logging level determined by ProcessConfigFile()
 * Output parameters:
 *    head_p, tail_p: head and tail of linked list of name/value pairs
 *
 * *head_p and *tail_p must be initialized to NULL before calling the outer
 * recursion level.  On exit, they contain a list of name-value pairs read
 * from the input file(s).
 *
 * Returns TRUE if successful, FALSE if an error occurred.  The error has
 * already been ereport'd, it is only necessary for the caller to clean up
 * its own state and release the name/value pairs list.
 *
 * Note: if elevel &gt;= ERROR then an error will not return control to the
 * caller, and internal state such as open files will not be cleaned up.
 * This case occurs only during postmaster or standalone-backend startup,
 * where an error will lead to immediate process exit anyway; so there is
 * no point in contorting the code so it can clean up nicely.
 */</comment>
<function><type><name>bool</name></type>
<name>ParseConfigFp</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>config_file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
              <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>head_p</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail_p</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>OK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>lex_buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>token</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Parse
     */</comment>
    <expr_stmt><expr><name>lex_buffer</name> <operator>=</operator> <call><name>GTMOPT_yy_create_buffer</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>YY_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTMOPT_yy_switch_to_buffer</name><argument_list>(<argument><expr><name>lex_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ConfigFileLineno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* This loop iterates once per logical line */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>token</name> <operator>=</operator> <call><name>GTMOPT_yylex</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>opt_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>opt_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>GTMOPT_EOL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* empty or comment line */</comment>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* first token on line is option name */</comment>
        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>!=</operator> <name>GTMOPT_ID</name> <operator>&amp;&amp;</operator> <name>token</name> <operator>!=</operator> <name>GTMOPT_QUALIFIED_ID</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>opt_name</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>GTMOPT_yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* next we have an optional equal sign; discard if present */</comment>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>GTMOPT_yylex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>GTMOPT_EQUALS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>GTMOPT_yylex</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* now we must have the option value */</comment>
        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>!=</operator> <name>GTMOPT_ID</name> <operator>&amp;&amp;</operator>
            <name>token</name> <operator>!=</operator> <name>GTMOPT_STRING</name> <operator>&amp;&amp;</operator>
            <name>token</name> <operator>!=</operator> <name>GTMOPT_INTEGER</name> <operator>&amp;&amp;</operator>
            <name>token</name> <operator>!=</operator> <name>GTMOPT_REAL</name> <operator>&amp;&amp;</operator>
            <name>token</name> <operator>!=</operator> <name>GTMOPT_UNQUOTED_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>GTMOPT_STRING</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* strip quotes and escapes */</comment>
            <expr_stmt><expr><name>opt_value</name> <operator>=</operator> <call><name>GTMOPT_scanstr</name><argument_list>(<argument><expr><name>GTMOPT_yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>opt_value</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>GTMOPT_yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* now we'd like an end of line, or possibly EOF */</comment>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>GTMOPT_yylex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>!=</operator> <name>GTMOPT_EOL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>token</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
            <comment type="block">/* treat EOF like \n for line numbering purposes, cf bug 4752 */</comment>
            <expr_stmt><expr><name>ConfigFileLineno</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* OK, process the option name and value */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>gtm_opt_name_compare</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>, <argument><expr><literal type="string">"include"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * An include directive isn't a variable and should be processed
             * immediately.
             */</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>save_ConfigFileLineno</name> <init>= <expr><name>ConfigFileLineno</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseConfigFile</name><argument_list>(<argument><expr><name>opt_value</name></expr></argument>, <argument><expr><name>config_file</name></expr></argument>,
                                 <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
                                 <argument><expr><name>head_p</name></expr></argument>, <argument><expr><name>tail_p</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opt_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <goto>goto <name>cleanup_exit</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GTMOPT_yy_switch_to_buffer</name><argument_list>(<argument><expr><name>lex_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ConfigFileLineno</name> <operator>=</operator> <name>save_ConfigFileLineno</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opt_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>gtm_opt_name_compare</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>, <argument><expr><literal type="string">"custom_variable_classes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * This variable must be processed first as it controls
             * the validity of other variables; so it goes at the head
             * of the result list.  If we already found a value for it,
             * replace with this one.
             */</comment>
            <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>*</operator><name>head_p</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>item</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <call><name>gtm_opt_name_compare</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"custom_variable_classes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* replace existing head item */</comment>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>opt_name</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>opt_value</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <name>ConfigFileLineno</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* prepend to list */</comment>
                <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>opt_name</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>opt_value</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <name>ConfigFileLineno</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>head_p</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>head_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tail_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>tail_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* ordinary variable, append to list */</comment>
            <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>opt_name</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>opt_value</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <name>ConfigFileLineno</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>head_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>head_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail_p</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>tail_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* break out of loop if read EOF, else loop for next line */</comment>
        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* successful completion of parsing */</comment>
    <goto>goto <name>cleanup_exit</name>;</goto>

 <label><name>parse_error</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>GTMOPT_EOL</name> <operator>||</operator> <name>token</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"syntax error in file \"%s\" line %u, near end of line\n"</literal></expr></argument>,
                         <argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>ConfigFileLineno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error in file \"%s\" line %u, near end of line"</literal></expr></argument>,
                            <argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>ConfigFileLineno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"syntax error in file \"%s\" line %u, near token \"%s\"\n"</literal></expr></argument>,
                         <argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>ConfigFileLineno</name></expr></argument>, <argument><expr><name>GTMOPT_yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error in file \"%s\" line %u, near token \"%s\""</literal></expr></argument>,
                            <argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>ConfigFileLineno</name></expr></argument>, <argument><expr><name>GTMOPT_yytext</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<label><name>cleanup_exit</name>:</label>
    <expr_stmt><expr><call><name>GTMOPT_yy_delete_buffer</name><argument_list>(<argument><expr><name>lex_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Free a list of ConfigVariables, including the names and the values
 */</comment>
<function><type><name>void</name></type>
<name>FreeConfigVariables</name><parameter_list>(<parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>item</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>item</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 *        scanstr
 *
 * Strip the quotes surrounding the given string, and collapse any embedded
 * '' sequences and backslash escapes.
 *
 * the string returned is malloc'd and should eventually be free'd by the
 * caller.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GTMOPT_scanstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newStr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Skip the leading quote; we'll handle the trailing quote below */</comment>
    <expr_stmt><expr><name>s</name><operator>++</operator></expr><operator>,</operator> <expr><name>len</name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* Since len still includes trailing quote, this is enough space */</comment>
    <expr_stmt><expr><name>newStr</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                    <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                    <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                    <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                    <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                    <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'0'</literal></expr>:</case>
                <case>case <expr><literal type="char">'1'</literal></expr>:</case>
                <case>case <expr><literal type="char">'2'</literal></expr>:</case>
                <case>case <expr><literal type="char">'3'</literal></expr>:</case>
                <case>case <expr><literal type="char">'4'</literal></expr>:</case>
                <case>case <expr><literal type="char">'5'</literal></expr>:</case>
                <case>case <expr><literal type="char">'6'</literal></expr>:</case>
                <case>case <expr><literal type="char">'7'</literal></expr>:</case>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>long</name></type>        <name>octVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
                             <condition><expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'7'</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition>
                             <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>octVal</name> <operator>=</operator> <operator>(</operator><name>octVal</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>)</operator> <name>octVal</name><operator>)</operator></expr>;</expr_stmt>
                    </block_content>}</block>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>                    <comment type="block">/* switch */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* doubled quote becomes just one quote */</comment>
            <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>newStr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* We copied the ending quote to newStr, so replace with \0 */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newStr</name><index>[<expr><operator>--</operator><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><name>newStr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The following code includes most of the code ported from guc.c.
 * Because they should be shared by gtm_opt.c and gtm_proxy_opt.c, they are placed here.
 */</comment>

<comment type="block">/*
 * Some infrastructure for checking malloc/strdup/realloc calls
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>gtm_opt_malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* PGXCTODO: this will be used for future extensions */</comment>
static void *
gtm_opt_realloc(int elevel, void *old, size_t size)
{
    void       *data;

    data = realloc(old, size);
    if (data == NULL)
    {
        if (isStartUp)
        {
            write_stderr("out of memory\n");
        }
        else
        {
            ereport(elevel,
                    (0,
                     errmsg("out of memory")));
        }
    }
    return data;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>gtm_opt_strdup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether strval is referenced anywhere in a GTM string item
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>string_field_used</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type> <name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strval</name> <operator>==</operator> <operator>*</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator> <operator>||</operator>
        <name>strval</name> <operator>==</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>||</operator>
        <name>strval</name> <operator>==</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>strval</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name> <operator>||</operator>
            <name>strval</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Support for assigning to a field of a string GTM item.  Free the prior
 * value if it's not referenced anywhere else in the item (including stacked
 * states).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_string_field</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type> <name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oldval</name> <init>= <expr><operator>*</operator><name>field</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Do the assignment */</comment>
    <expr_stmt><expr><operator>*</operator><name>field</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>

    <comment type="block">/* Free old value if it's not NULL and isn't referenced anymore */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>string_field_used</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Detect whether an "extra" struct is referenced anywhere in a GTM item
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extra_field_used</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>gconf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name> <operator>||</operator>
            <name>extra</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>extra</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Support for assigning to an "extra" field of a GTM item.  Free the prior
 * value if it's not referenced anywhere else in the item (including stacked
 * states).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_extra_field</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>gconf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>oldval</name> <init>= <expr><operator>*</operator><name>field</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Do the assignment */</comment>
    <expr_stmt><expr><operator>*</operator><name>field</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>

    <comment type="block">/* Free old value if it's not NULL and isn't referenced anymore */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Support for copying a variable's active value into a stack entry.
 * The "extra" field associated with the active value is copied, too.
 *
 * NB: be sure stringval and extra fields of a new stack entry are
 * initialized to NULL before this is used, else we'll try to free() them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_stack_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>gconf</name></decl></parameter>, <parameter><decl><type><name>config_var_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolval</name></name> <operator>=</operator>
                <operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>intval</name></name> <operator>=</operator>
                <operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>realval</name></name> <operator>=</operator>
                <operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>stringval</name></name><operator>)</operator></expr></argument>,
                             <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>enumval</name></name> <operator>=</operator>
                <operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* PGXCTODO: This is let for future extension support */</comment>
<comment type="block">/*
 * Support for discarding a no-longer-needed value in a stack entry.
 * The "extra" field associated with the stack entry is cleared, too.
 */</comment>
static void
discard_stack_value(struct config_generic * gconf, config_var_value *val)
{
    switch (gconf-&gt;vartype)
    {
        case GTMC_BOOL:
        case GTMC_INT:
        case GTMC_REAL:
        case GTMC_ENUM:
            <comment type="block">/* no need to do anything */</comment>
            break;
        case GTMC_STRING:
            set_string_field((struct config_string *) gconf,
                             &amp;(val-&gt;val.stringval),
                             NULL);
            break;
    }
    set_extra_field(gconf, &amp;(val-&gt;extra), NULL);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Fetch the sorted array pointer (exported for help_config.c's use ONLY)
 */</comment>
<function><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type>
<name>get_gtm_opt_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>gtm_opt_variables</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the sorted array.    This is split out so that it could be
 * re-executed after startup (eg, we could allow loadable modules to
 * add vars, and then we'd need to re-sort).
 */</comment>
<function><type><name>void</name></type>
<name>build_gtm_opt_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>size_vars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_vars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>gtm_opt_vars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Rather than requiring vartype to be filled in by hand, do this: */</comment>
        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>GTMC_BOOL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>GTMC_INT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>GTMC_REAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>GTMC_STRING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>GTMC_ENUM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Create table with 20% slack
     */</comment>
    <expr_stmt><expr><name>size_vars</name> <operator>=</operator> <name>num_vars</name> <operator>+</operator> <name>num_vars</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>gtm_opt_vars</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>gtm_opt_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>size_vars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>num_vars</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>gtm_opt_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>gtm_opt_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>gtm_opt_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>gtm_opt_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>gtm_opt_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>gtm_opt_variables</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>gtm_opt_variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>gtm_opt_variables</name> <operator>=</operator> <name>gtm_opt_vars</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_gtm_opt_variables</name> <operator>=</operator> <name>num_vars</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size_gtm_opt_variables</name> <operator>=</operator> <name>size_vars</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>gtm_opt_variables</name></expr></argument>, <argument><expr><name>num_gtm_opt_variables</name></expr></argument>,
          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>gtm_opt_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* PGXCTODO: This is let for future extension support */</comment>
<comment type="block">/*
 * Add a new GTM variable to the list of known variables. The
 * list is expanded if needed.
 */</comment>
static bool
add_gtm_opt_variable(struct config_generic * var, int elevel)
{
    if (num_gtm_opt_variables + 1 &gt;= size_gtm_opt_variables)
    {
        <comment type="block">/*
         * Increase the vector by 25%
         */</comment>
        int            size_vars = size_gtm_opt_variables + size_gtm_opt_variables / 4;
        struct config_generic **gtm_opt_vars;

        if (size_vars == 0)
        {
            size_vars = 100;
            gtm_opt_vars = (struct config_generic **)
                gtm_opt_malloc(elevel, size_vars * sizeof(struct config_generic *));
        }
        else
        {
            gtm_opt_vars = (struct config_generic **)
                gtm_opt_realloc(elevel, gtm_opt_variables, size_vars * sizeof(struct config_generic *));
        }

        if (gtm_opt_vars == NULL)
            return false;        <comment type="block">/* out of memory */</comment>

        gtm_opt_variables = gtm_opt_vars;
        size_gtm_opt_variables = size_vars;
    }
    gtm_opt_variables[num_gtm_opt_variables++] = var;
    qsort((void *) gtm_opt_variables, num_gtm_opt_variables,
          sizeof(struct config_generic *), gtm_opt_var_compare);
    return true;
}


<comment type="block">/*
 * Create and add a placeholder variable. It's presumed to belong
 * to a valid custom variable class at this point.
 */</comment>
static struct config_generic *
add_placeholder_variable(const char *name, int elevel)
{
    size_t        sz = sizeof(struct config_string) + sizeof(char *);
    struct config_string *var;
    struct config_generic *gen;

    var = (struct config_string *) gtm_opt_malloc(elevel, sz);
    if (var == NULL)
        return NULL;
    memset(var, 0, sz);
    gen = &amp;var-&gt;gen;

    gen-&gt;name = gtm_opt_strdup(elevel, name);
    if (gen-&gt;name == NULL)
    {
        free(var);
        return NULL;
    }

    gen-&gt;context = GTMC_USERSET;
    gen-&gt;short_desc = "GTM placeholder variable";
    gen-&gt;flags = GTMOPT_NO_SHOW_ALL | GTMOPT_NOT_IN_SAMPLE | GTMOPT_CUSTOM_PLACEHOLDER;
    gen-&gt;vartype = GTMC_STRING;

    <comment type="block">/*
     * The char* is allocated at the end of the struct since we have no
     * 'static' place to point to.    Note that the current value, as well as
     * the boot and reset values, start out NULL.
     */</comment>
    var-&gt;variable = (char **) (var + 1);

    if (!add_gtm_opt_variable((struct config_generic *) var, elevel))
    {
        free((void *) gen-&gt;name);
        free(var);
        return NULL;
    }

    return gen;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Look up option NAME.  If it exists, return a pointer to its record,
 * else return NULL.  If create_placeholders is TRUE, we'll create a
 * placeholder record for a valid-looking custom variable name.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>find_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_placeholders</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>key</name> <init>= <expr><operator>&amp;</operator><name>name</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * By equating const char ** with struct config_generic *, we are assuming
     * the name field is first in config_generic.
     */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>gtm_opt_variables</name></expr></argument>,
                                             <argument><expr><name>num_gtm_opt_variables</name></expr></argument>,
                                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                                             <argument><expr><name>gtm_opt_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>*</operator><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Unknown name */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * comparator for qsorting and bsearching gtm_opt_variables array
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gtm_opt_var_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confa</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confb</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>gtm_opt_name_compare</name><argument_list>(<argument><expr><name><name>confa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>confb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * the bare comparison function for GTM names
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gtm_opt_name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namea</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameb</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * The temptation to use strcasecmp() here must be resisted, because the
     * array ordering has to remain stable across setlocale() calls. So, build
     * our own with a simple ASCII-only downcasing.
     */</comment>
    <while>while <condition>(<expr><operator>*</operator><name>namea</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nameb</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name>cha</name> <init>= <expr><operator>*</operator><name>namea</name><operator>++</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>chb</name> <init>= <expr><operator>*</operator><name>nameb</name><operator>++</operator></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>cha</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>cha</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cha</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>chb</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>chb</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>chb</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cha</name> <operator>!=</operator> <name>chb</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>cha</name> <operator>-</operator> <name>chb</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>namea</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* a is longer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>nameb</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* b is longer */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize GTM options during program startup.
 *
 * Note that we cannot read the config file yet, since we have not yet
 * processed command-line switches.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeGTMOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Build sorted array of all GTM variables.
     */</comment>
    <expr_stmt><expr><call><name>build_gtm_opt_variables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Load all variables with their compiled-in defaults, and initialize
     * status fields as needed.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_gtm_opt_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitializeOneGTMOption</name><argument_list>(<argument><expr><name><name>gtm_opt_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>reporting_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></function>


<comment type="block">/*
 * Initialize one GTM option variable to its compiled-in default.
 *
 * Note: the reason for calling check_hooks is not that we think the boot_val
 * might fail, but that the hooks might wish to compute an "extra" struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeOneGTMOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name> <operator>=</operator> <name>GTMC_S_DEFAULT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>GTMC_S_DEFAULT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&gt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&lt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name></type>        <name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&gt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&lt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* non-NULL boot_val must always get strdup'd */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>gtm_opt_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
    </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Select the configuration files and data directory to be used, and
 * do the initial read of postgresql.conf.
 *
 * This is called after processing command-line switches.
 *        userDoption is the -D switch value if any (NULL if unspecified).
 *        progname is just for use in error messages.
 *
 * Returns true on success; on failure, prints a suitable error message
 * to stderr and returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>SelectConfigFiles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userDoption</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>configdir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

    <comment type="block">/* configdir is -D option, or $PGDATA if no -D */</comment>
    <if_stmt><if>if <condition>(<expr><name>userDoption</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>configdir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>configdir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Find the configuration file: if config_file was specified on the
     * command line, use it, else use configdir/postgresql.conf.  In any case
     * ensure the result is an absolute path, so that it will be interpreted
     * the same way by future backends.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>GTMConfigFileName</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>GTMConfigFileName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>GTMConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>configdir</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>gtm_opt_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                                       <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>GTMConfigFileName</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>GTMConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>GTMConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>gtm_opt_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                           <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>config_filename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>config_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the server configuration file.\n"</literal>
                     <literal type="string">"You must specify the --config-file or -D invocation "</literal>
                     <literal type="string">"option or set the PGDATA environment variable.\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Set the GTMConfigFileName GTM variable to its final value, ensuring that
     * it can't be overridden later.
     */</comment>
    <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"config_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>GTMC_STARTUP</name></expr></argument>, <argument><expr><name>GTMC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__XLOG__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>configdir</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>recovery_file_name</name> <operator>=</operator> <call><name>gtm_opt_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                               <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>RECOVERY_CONF_NAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>recovery_file_name</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>RECOVERY_CONF_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>recovery_file_name</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>RECOVERY_CONF_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Now read the config file for the first time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>GTMConfigFileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s cannot access the server configuration file \"%s\": %s\n"</literal></expr></argument>,
                     <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>GTMConfigFileName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>GTMC_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reset all options to their saved default values (implements RESET ALL)
 */</comment>
<function><type><name>void</name></type>
<name>ResetAllOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_gtm_opt_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>gtm_opt_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Don't reset if special exclusion from RESET ALL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_NO_RESET_ALL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* No need to reset if wasn't SET */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>GTMC_S_OVERRIDE</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>
            <case>case <expr><name>GTMC_INT</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>
            <case>case <expr><name>GTMC_REAL</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>
            <case>case <expr><name>GTMC_STRING</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>
            <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>
        </block_content>}</block></switch>

        <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_REPORT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReportGTMOption</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block">/*
 * push_old_value
 *        Push previous state during transactional assignment to a GTM variable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_old_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

    <comment type="block">/* If we're not inside a nest level, do nothing */</comment>
    <if_stmt><if>if <condition>(<expr><name>GTMOptUpdateCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Do we already have a stack entry of the current nest level? */</comment>
    <expr_stmt><expr><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>stack</name> <operator>&amp;&amp;</operator> <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&gt;=</operator> <name>GTMOptUpdateCount</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Push a new stack entry
     *
     * We keep all the stack entries in TopTransactionContext for simplicity.
     */</comment>
    <expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>(</operator><name>GtmOptStack</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GtmOptStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name>GTMOptUpdateCount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Enter a new nesting level for GTM values.  This is called at subtransaction
 * start and when entering a function that has proconfig settings.    NOTE that
 * we must not risk error here, else subtransaction start will be unhappy.
 */</comment>
<function><type><name>int</name></type>
<name>NewGTMNestLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>++</operator><name>GTMOptUpdateCount</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to parse value as an integer.  The accepted formats are the
 * usual decimal, octal, or hexadecimal formats, optionally followed by
 * a unit name if "flags" indicates a unit is allowed.
 *
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 * If not okay and hintmsg is not NULL, *hintmsg is set to a suitable
 *    HINT message, or NULL if no hint provided.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>hintmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

    <comment type="block">/* To suppress compiler warnings, always set output params */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We assume here that int64 is at least as wide as long */</comment>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* no HINT for integer syntax error */</comment>

    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>val</name> <operator>!=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int32</name><operator>)</operator> <name>val</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Value exceeds integer range."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* allow whitespace between integer and unit */</comment>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* Handle possible unit */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Note: the multiple-switch coding technique here is a bit tedious,
         * but seems necessary to avoid intermediate-value overflows.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_MEMORY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Set hint for use if no match or trailing garbage */</comment>
            <if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid units for this parameter are \"kB\", \"MB\", and \"GB\"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name><name>BLCKSZ</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1024</literal> <operator>||</operator> <name>BLCKSZ</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> BLCKSZ must be between 1KB and 1MB</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name><name>XLOG_BLCKSZ</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1024</literal> <operator>||</operator> <name>XLOG_BLCKSZ</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> XLOG_BLCKSZ must be between 1KB and 1MB</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_MEMORY</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_BLOCKS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>/=</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_XBLOCKS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>/=</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"MB"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_MEMORY</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_KB</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>KB_PER_MB</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_BLOCKS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>KB_PER_MB</name> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_XBLOCKS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>KB_PER_MB</name> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"GB"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_MEMORY</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_KB</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>KB_PER_GB</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_BLOCKS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>KB_PER_GB</name> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_XBLOCKS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>KB_PER_GB</name> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Set hint for use if no match or trailing garbage */</comment>
            <if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid units for this parameter are \"ms\", \"s\", \"min\", \"h\", and \"d\"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_S</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>/=</operator> <name>MS_PER_S</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_MIN</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>/=</operator> <name>MS_PER_MIN</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_MS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>MS_PER_S</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_MIN</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>/=</operator> <name>S_PER_MIN</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_MS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>MS_PER_MIN</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_S</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>S_PER_MIN</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"h"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_MS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>MS_PER_H</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_S</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>S_PER_H</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_MIN</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>MIN_PER_H</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GTMOPT_UNIT_MS</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>MS_PER_D</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_S</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>S_PER_D</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>GTMOPT_UNIT_MIN</name></expr>:</case>
                        <expr_stmt><expr><name>val</name> <operator>*=</operator> <name>MIN_PER_D</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* allow whitespace after unit */</comment>
        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* appropriate hint, if any, already set */</comment>

        <comment type="block">/* Check for overflow due to units conversion */</comment>
        <if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int32</name><operator>)</operator> <name>val</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Value exceeds integer range."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Try to parse value as a floating point number in the usual format.
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_real</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>            <comment type="block">/* suppress compiler warning */</comment>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* allow whitespace after number */</comment>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Lookup the value for an enum option with the selected name
 * (case-insensitive).
 * If the enum option is found, sets the retval value and returns
 * true. If it's not found, return FALSE and retval is set to 0.
 */</comment>
<function><type><name>bool</name></type>
<name>config_enum_lookup_by_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type> <name>record</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
            <return>return <expr><name>TRUE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Return a list of all available options for an enum, excluding
 * hidden ones, separated by the given separator.
 * If prefix is non-NULL, it is added before the first enum value.
 * If suffix is non-NULL, it is added to the end of the string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>config_enum_get_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type> <name>record</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>separator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>retstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>seplen</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>seplen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>hidden</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * All the entries may have been hidden, leaving the string empty if no
     * prefix was given. This indicates a broken GTM setup, since there is no
     * use for an enum without any values, so we just check to make sure we
     * don't write to invalid memory instead of actually trying to do
     * something smart with it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <name>seplen</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Replace final separator */</comment>
        <expr_stmt><expr><name><name>retstr</name><operator>.</operator><name>data</name><index>[<expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>seplen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <name>seplen</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>retstr</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Sets option `name' to given value. The value should be a string
 * which is going to be parsed and converted to the appropriate data
 * type.  The context and source parameters indicate in which context this
 * function is being called so it can apply the access restrictions
 * properly.
 *
 * If value is NULL, set the option to its default value (normally the
 * reset_val, but if source == GTMC_S_DEFAULT we instead use the boot_val).
 *
 * action indicates whether to set the value globally in the session, locally
 * to the current top transaction, or just for the duration of a function call.
 *
 * If changeVal is false then don't really set the option but do all
 * the checks to see if it would work.
 *
 * If there is an error (non-existing option, invalid value) then an
 * ereport(ERROR) is thrown *unless* this is called in a context where we
 * don't want to ereport (currently, startup or SIGHUP config file reread).
 * In that case we write a suitable error message via ereport(LOG) and
 * return false. This is working around the deficiencies in the ereport
 * mechanism, so don't blame me.  In all other cases, the function
 * returns true, including cases where the input is valid but we chose
 * not to apply it because of context or source-priority considerations.
 *
 * See also SetConfigOption for an external interface.
 */</comment>
<function><type><name>bool</name></type>
<name>set_config_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
                  <parameter><decl><type><name>GtmOptContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GtmOptSource</name></type> <name>source</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>changeVal</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>elevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>prohibitValueChange</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>makeDefault</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>GTMC_SIGHUP</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>GTMC_S_DEFAULT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * To avoid cluttering the log, only the postmaster bleats loudly
         * about problems with the config file.
         */</comment>
        <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG3</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>GTMC_S_DATABASE</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>GTMC_S_USER</name> <operator>||</operator>
             <name>source</name> <operator>==</operator> <name>GTMC_S_DATABASE_USER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If source is postgresql.conf, mark the found record with
     * GTMOPT_IS_IN_FILE. This is for the convenience of ProcessConfigFile.  Note
     * that we do it even if changeVal is false, since ProcessConfigFile wants
     * the marking to occur during its testing pass.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>GTMC_S_FILE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GTMOPT_IS_IN_FILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check if the option can be set at this time. See guc.h for the precise
     * rules.
     */</comment>
    <switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_DEFAULT</name></expr>:</case>
        <case>case <expr><name>GTMC_STARTUP</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>GTMC_SIGHUP</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We are re-reading a GTMC_POSTMASTER variable from
                 * postgresql.conf.  We can't change the setting, so we should
                 * give a warning if the DBA tries to change it.  However,
                 * because of variant formats, canonicalization by check
                 * hooks, etc, we can't just compare the given string directly
                 * to what's stored.  Set a flag to check below after we have
                 * the final storable value.
                 *
                 * During the "checking" pass we just do nothing, to avoid
                 * printing the warning twice.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>changeVal</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>prohibitValueChange</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>context</name> <operator>!=</operator> <name>GTMC_STARTUP</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server\n"</literal></expr></argument>,
                                 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                            <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                                    <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>GTMC_SIGHUP</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>GTMC_SIGHUP</name> <operator>&amp;&amp;</operator> <name>context</name> <operator>!=</operator> <name>GTMC_STARTUP</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed now\n"</literal></expr></argument>,
                                 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                            <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed now"</literal></expr></argument>,
                                    <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Hmm, the idea of the SIGHUP context is "ought to be global, but
             * can be changed after postmaster start". But there's nothing
             * that prevents a crafty administrator from sending SIGHUP
             * signals to individual backends only.
             */</comment>
            <break>break;</break>
        <default>default:</default>
            <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"GtmOptContext invalid (%d)\n"</literal></expr></argument>,
                             <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                        <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GtmOptContext invalid (%d)"</literal></expr></argument>,
                                <argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Should we set reset/stacked values?    (If so, the behavior is not
     * transactional.)    This is done either when we get a default value from
     * the database's/user's/client's default settings or when we reset a
     * value to its default.
     */</comment>
    <expr_stmt><expr><name>makeDefault</name> <operator>=</operator> <name>changeVal</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>source</name> <operator>&lt;=</operator> <name>GTMC_S_OVERRIDE</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>(</operator><name>value</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <name>source</name> <operator>==</operator> <name>GTMC_S_DEFAULT</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Ignore attempted set if overridden by previously processed setting.
     * However, if changeVal is false then plow ahead anyway since we are
     * trying to find out if the value is potentially good, not actually use
     * it. Also keep going if makeDefault is true, since we may want to set
     * the reset/stacked values even if we can't set the variable itself.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>source</name></name> <operator>&gt;</operator> <name>source</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>changeVal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>makeDefault</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"\"%s\": setting ignored because previous source is higher priority\n"</literal></expr></argument>,
                             <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"\"%s\": setting ignored because previous source is higher priority"</literal></expr></argument>,
                     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>changeVal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Evaluate value and set variable.
     */</comment>
    <switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>newval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gtm_opt_parse_bool</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value"</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>GTMC_S_DEFAULT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Save old value to support transaction abort */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call>(<modifier>*</modifier><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name>) <argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
                                        <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>boolval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                            <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
                <if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>newval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hintmsg</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\"\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>newval</name> <argument_list type="generic">&lt; <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name> <operator>||</operator> <name>newval</name></expr></argument> &gt;</argument_list></name> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%d is outside the valid range for parameter \"%s\" (%d .. %d)\n"</literal></expr></argument>,
                                         <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d is outside the valid range for parameter \"%s\" (%d .. %d)"</literal></expr></argument>,
                                            <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>GTMC_S_DEFAULT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Save old value to support transaction abort */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call>(<modifier>*</modifier><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name>) <argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
                                        <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>intval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                            <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
                <if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name></type>        <name>newval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_real</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a numeric value\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a numeric value"</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>newval</name> <argument_list type="generic">&lt; <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name> <operator>||</operator> <name>newval</name></expr></argument> &gt;</argument_list></name> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%g is outside the valid range for parameter \"%s\" (%g .. %g)\n"</literal></expr></argument>,
                                         <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%g is outside the valid range for parameter \"%s\" (%g .. %g)"</literal></expr></argument>,
                                            <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>GTMC_S_DEFAULT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Save old value to support transaction abort */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call>(<modifier>*</modifier><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name>) <argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
                                        <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>realval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                            <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
                <if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * The value passed by the caller could be transient, so
                     * we always strdup it.
                     */</comment>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>gtm_opt_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>GTMC_S_DEFAULT</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* non-NULL boot_val must always get strdup'd */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>gtm_opt_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>newval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * strdup not needed, since reset_val is already under
                     * guc.c's control
                     */</comment>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* newval shouldn't be NULL, so we're a bit sloppy here */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                        <call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Save old value to support transaction abort */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call>(<modifier>*</modifier><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name>) <argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
                                        <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>,
                                             <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                            <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Perhaps we didn't install newval anywhere */</comment>
                <if_stmt><if>if <condition>(<expr><name>newval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>string_field_used</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
                <if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>newval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>config_enum_lookup_by_name</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>hintmsg</name> <operator>=</operator> <call><name>config_enum_get_options</name><argument_list>(<argument><expr><name>conf</name></expr></argument>,
                                                        <argument><expr><literal type="string">"Available values: "</literal></expr></argument>,
                                                          <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\". %s\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>GTMC_S_DEFAULT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server\n"</literal></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Save old value to support transaction abort */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call>(<modifier>*</modifier><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name>) <argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                    <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GtmOptStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
                                        <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>enumval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
                                            <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
                <if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>changeVal</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_REPORT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReportGTMOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>




<comment type="block">/*
 * Set the fields for source file and line number the setting came from.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_config_sourcefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>elevel</name></decl>;</decl_stmt>

    <comment type="block">/*
     * To avoid cluttering the log, only the postmaster bleats loudly about
     * problems with the config file.
     */</comment>
    <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG3</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* should not happen */</comment>
    <if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>sourcefile</name> <operator>=</operator> <call><name>gtm_opt_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>=</operator> <name>sourcefile</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <name>sourceline</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Set a config option to the given value. See also set_config_option,
 * this is just the wrapper to be called from outside GTM.    NB: this
 * is used only for non-transactional operations.
 *
 * Note: there is no support here for setting source file/line, as it
 * is currently not needed.
 */</comment>
<function><type><name>void</name></type>
<name>SetConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
                <parameter><decl><type><name>GtmOptContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GtmOptSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>,
                             <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<comment type="block">/*
 * Fetch the current value of the option `name'. If the option doesn't exist,
 * throw an ereport and don't return.
 *
 * If restrict_superuser is true, we also enforce that only superusers can
 * see GTMOPT_SUPERUSER_ONLY variables.  This should only be passed as true
 * in user-driven calls.
 *
 * The string is *not* allocated for modification and is really only
 * valid until the next call to configuration related functions.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restrict_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <return>return <expr><ternary><condition><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</return>

        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
                     <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>buffer</name></expr>;</return>

        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
                     <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>buffer</name></expr>;</return>

        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</return>

        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <return>return <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>,
                                 <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get the RESET value associated with the given option.
 *
 * Note: this is not re-entrant, due to use of static result buffer;
 * not to mention that a string variable could have its reset_val changed.
 * Beware of assuming the result value is good for very long.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetConfigOptionResetString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</return>

        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>buffer</name></expr>;</return>

        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>buffer</name></expr>;</return>

        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <return>return <expr><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr>;</return>

        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <return>return <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>,
                                 <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>EmitWarningsOnPlaceholders</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>className</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>classLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_gtm_opt_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>gtm_opt_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_CUSTOM_PLACEHOLDER</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>strncmp</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>classLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>var</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>classLen</name></expr>]</index></name> <operator>==</operator> <name>GTMOPT_QUALIFIER_SEPARATOR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\"\n"</literal></expr></argument>,
                             <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
                                <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Return GTM variable value by name; optionally return canonical
 * form of name.  Return value is malloc'd.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetConfigOptionByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><literal type="number">0</literal><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>varname</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call><name>_ShowOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return GTM variable value by variable number; optionally return canonical
 * form of name.  Return value is malloc'd.
 */</comment>
<function><type><name>void</name></type>
<name>GetConfigOptionByNum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>varnum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>noshow</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name></decl>;</decl_stmt>

    <comment type="block">/* check requested variable number valid */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varnum</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>varnum</name> <operator>&lt;</operator> <name>num_gtm_opt_variables</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>conf</name> <operator>=</operator> <name><name>gtm_opt_variables</name><index>[<expr><name>varnum</name></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>noshow</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_NO_SHOW_ALL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>noshow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>noshow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* first get the generic attributes */</comment>

    <comment type="block">/* name */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

    <comment type="block">/* setting : use _ShowOption in order to avoid duplicating the logic */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_ShowOption</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* unit */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>GTMC_INT</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>GTMOPT_UNIT_MEMORY</name> <operator>|</operator> <name>GTMOPT_UNIT_TIME</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GTMOPT_UNIT_KB</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"kB"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>GTMOPT_UNIT_BLOCKS</name></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%dkB"</literal></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>GTMOPT_UNIT_XBLOCKS</name></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%dkB"</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>GTMOPT_UNIT_MS</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"ms"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>GTMOPT_UNIT_S</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"s"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>GTMOPT_UNIT_MIN</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"min"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* PGXCTODO: Group parameters are not used yet */</comment>
    <comment type="block">/* group */</comment>
    values[3] = config_group_names[conf-&gt;group];
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* short_desc */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>short_desc</name></name></expr>;</expr_stmt>

    <comment type="block">/* extra_desc */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>long_desc</name></name></expr>;</expr_stmt>

    <comment type="block">/* context */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>GtmOptContext_Names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>context</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* vartype */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>config_type_names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* source */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>GtmOptSource_Names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>source</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* now get the type specifc attributes */</comment>
    <switch>switch <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* min_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* max_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* enumvals */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* boot_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* reset_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* min_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* max_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* enumvals */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* boot_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* reset_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* min_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* max_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* enumvals */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* boot_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* reset_val */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* min_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* max_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* enumvals */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* boot_val */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/* reset_val */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* min_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* max_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* enumvals */</comment>

                <comment type="block">/*
                 * NOTE! enumvals with double quotes in them are not
                 * supported!
                 */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>config_enum_get_options</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></argument>,
                                                     <argument><expr><literal type="string">"{\""</literal></expr></argument>, <argument><expr><literal type="string">"\"}"</literal></expr></argument>, <argument><expr><literal type="string">"\",\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* boot_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>lconf</name></expr></argument>,
                                                           <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* reset_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>lconf</name></expr></argument>,
                                                          <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <default>default:</default>
            <block>{<block_content>
                <comment type="block">/*
                 * should never get here, but in case we do, set 'em to NULL
                 */</comment>

                <comment type="block">/* min_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* max_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* enumvals */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* boot_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* reset_val */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * If the setting came from a config file, set the source location. For
     * security reasons, we don't show source file/line number for
     * non-superusers.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>GTMC_S_FILE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the total number of GTM variables
 */</comment>
<function><type><name>int</name></type>
<name>GetNumConfigOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>num_gtm_opt_variables</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_ShowOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_units</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GTMC_BOOL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_INT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Use int64 arithmetic to avoid overflows in units
                 * conversion.
                 */</comment>
                <decl_stmt><decl><type><name>int64</name></type>        <name>result</name> <init>= <expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>use_units</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_UNIT_MEMORY</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_UNIT_MEMORY</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>GTMOPT_UNIT_BLOCKS</name></expr>:</case>
                            <expr_stmt><expr><name>result</name> <operator>*=</operator> <name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>GTMOPT_UNIT_XBLOCKS</name></expr>:</case>
                            <expr_stmt><expr><name>result</name> <operator>*=</operator> <name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>

                    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>%</operator> <name>KB_PER_GB</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>/=</operator> <name>KB_PER_GB</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"GB"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>result</name> <operator>%</operator> <name>KB_PER_MB</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>/=</operator> <name>KB_PER_MB</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"MB"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"kB"</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>use_units</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                         <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GTMOPT_UNIT_TIME</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>GTMOPT_UNIT_S</name></expr>:</case>
                            <expr_stmt><expr><name>result</name> <operator>*=</operator> <name>MS_PER_S</name></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>GTMOPT_UNIT_MIN</name></expr>:</case>
                            <expr_stmt><expr><name>result</name> <operator>*=</operator> <name>MS_PER_MIN</name></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>

                    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>%</operator> <name>MS_PER_D</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>/=</operator> <name>MS_PER_D</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"d"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>result</name> <operator>%</operator> <name>MS_PER_H</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>/=</operator> <name>MS_PER_H</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"h"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>result</name> <operator>%</operator> <name>MS_PER_MIN</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>/=</operator> <name>MS_PER_MIN</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"min"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>result</name> <operator>%</operator> <name>MS_PER_S</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>/=</operator> <name>MS_PER_S</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"s"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">"ms"</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">"%s"</literal></expr></argument>,
                         <argument><expr><name>result</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_REAL</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
                         <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_STRING</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

                 <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GTMC_ENUM</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* just to keep compiler quiet */</comment>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * A little "long argument" simulation, although not quite GNU
 * compliant. Takes a string of the form "some-option=some value" and
 * returns name = "some_option" and value = "some value" in malloc'ed
 * storage. Note that '-' is converted to '_' in the option name. If
 * there is no '=' in the input string then value will be NULL.
 */</comment>
<function><type><name>void</name></type>
<name>ParseLongOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>equal_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>equal_pos</name> <operator>=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>string</name><index>[<expr><name>equal_pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>gtm_opt_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>gtm_opt_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>string</name><index>[<expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* no equal sign in string */</comment>
        <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>gtm_opt_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <operator>*</operator><name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
 * keep-alive related APIs will be used in future extensions
 */</comment>
void
gtm_assign_tcp_keepalives_idle(int newval, void *extra)
{
    <comment type="block">/*
     * The kernel API provides no way to test a value without setting it; and
     * once we set it we might fail to unset it.  So there seems little point
     * in fully implementing the check-then-assign GTM API for these
     * variables.  Instead we just do the assignment on demand.  pqcomm.c
     * reports any problems via elog(LOG).
     *
     * This approach means that the GTM value might have little to do with the
     * actual kernel value, so we use a show_hook that retrieves the kernel
     * value rather than trusting GTM's copy.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    (void) pq_setkeepalivesidle(newval, MyProcPort);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    (void) pq_setkeepalivesidle_all(newval);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

const char *
gtm_show_tcp_keepalives_idle(void)
{
    <comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
    static char nbuf[16];

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    snprintf(nbuf, sizeof(nbuf), "%d", pq_getkeepalivesidle(MyProcPort));
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    snprintf(nbuf, sizeof(nbuf), "%d", pq_getkeepalivesidle_all());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    return nbuf;
}

void
gtm_assign_tcp_keepalives_interval(int newval, void *extra)
{
    <comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    (void) pq_setkeepalivesinterval(newval, MyProcPort);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    (void) pq_setkeepalivesinterval_all(newval);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

const char *
gtm_show_tcp_keepalives_interval(void)
{
    <comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
    static char nbuf[16];

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    snprintf(nbuf, sizeof(nbuf), "%d", pq_getkeepalivesinterval(MyProcPort));
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    snprintf(nbuf, sizeof(nbuf), "%d", pq_getkeepalivesinterval_all());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    return nbuf;
}

void
gtm_assign_tcp_keepalives_count(int newval, void *extra)
{
    <comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    (void) pq_setkeepalivescount(newval, MyProcPort);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    (void) pq_setkeepalivescount_all(newval);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

const char *
gtm_show_tcp_keepalives_count(void)
{
    <comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
    static char nbuf[16];

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    snprintf(nbuf, sizeof(nbuf), "%d", pq_getkeepalivescount(MyProcPort));
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    snprintf(nbuf, sizeof(nbuf), "%d", pq_getkeepalivescount_all());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    return nbuf;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Try to interpret value as boolean value.  Valid values are: true,
 * false, yes, no, on, off, 1, 0; as well as unique prefixes thereof.
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gtm_opt_parse_bool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>gtm_opt_parse_bool_with_len</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gtm_opt_parse_bool_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><operator>*</operator><name>value</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'t'</literal></expr>:</case>
        <case>case <expr><literal type="char">'T'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'f'</literal></expr>:</case>
        <case>case <expr><literal type="char">'F'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'y'</literal></expr>:</case>
        <case>case <expr><literal type="char">'Y'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'n'</literal></expr>:</case>
        <case>case <expr><literal type="char">'N'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'o'</literal></expr>:</case>
        <case>case <expr><literal type="char">'O'</literal></expr>:</case>
            <comment type="block">/* 'o' is not unique enough */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'1'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'0'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* suppress compiler warning */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReportGUCOption: if appropriate, transmit option value to frontend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReportGTMOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type> <name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* So far, it is empty. */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup the name for an enum option with the selected value.
 * Should only ever be called with known-valid values, so throws
 * an elog(ERROR) if the enum option is not found.
 *
 * The returned string is a pointer to static data and not
 * allocated for modification.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>config_enum_lookup_by_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type> <name>record</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>isStartUp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not find enum option %d for %s\n"</literal></expr></argument>,
                     <argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find enum option %d for %s"</literal></expr></argument>,
             <argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>                <comment type="block">/* silence compiler */</comment>
</block_content>}</block></function>
</unit>
