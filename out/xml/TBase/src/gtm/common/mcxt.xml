<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/common/mcxt.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * mcxt.c
 *      POSTGRES memory context management code.
 *
 * This module handles context management operations that are independent
 * of the particular kind of context being operated on.  It calls
 * context-type-specific operations via the function pointers in a
 * context's MemoryContextMethods struct.
 *
 *
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      $PostgreSQL: pgsql/src/backend/utils/mmgr/mcxt.c,v 1.65 2008/06/28 16:45:22 tgl Exp $
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm.h"</cpp:file></cpp:include>


<comment type="block" format="doxygen">/*****************************************************************************
 *      GLOBAL MEMORY                                                             *
 *****************************************************************************/</comment>

<comment type="block">/*
 * Standard top-level contexts. For a description of the purpose of each
 * of these contexts, refer to src/backend/utils/mmgr/README
 */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MemoryContextStatsInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MemoryContextDeleteInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parent_locked</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>allocTopMemCxt</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>MemoryContext</name></type>    <name>TopMostMemoryContext</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/*****************************************************************************
 *      EXPORTED ROUTINES                                                         *
 *****************************************************************************/</comment>


<comment type="block">/*
 * MemoryContextInit
 *        Start up the memory-context subsystem.
 *
 * This must be called before creating contexts or allocating memory in
 * contexts.  TopMemoryContext and ErrorContext are initialized here;
 * other contexts must be created afterwards.
 *
 * In normal multi-backend operation, this is called once during
 * postmaster startup, and not at all by individual backend startup
 * (since the backends inherit an already-initialized context subsystem
 * by virtue of being forked off the postmaster).
 *
 * In a standalone backend this must be called during backend startup.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>TopMemoryContext</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize TopMemoryContext as an AllocSetContext with slow growth rate
     * --- we don't really expect much to be allocated in it.
     *
     * (There is special-case code in MemoryContextCreate() for this call.)
     *
     * This context is shared between different threads and must be made
     * thread-safe
     */</comment>
    <expr_stmt><expr><name>TopMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContext</name><operator>)</operator> <name>NULL</name></expr></argument>,
                                             <argument><expr><literal type="string">"TopMemoryContext"</literal></expr></argument>,
                                             <argument><expr><literal type="number">0</literal></expr></argument>,
                                             <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                             <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                             <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>TopMostMemoryContext</name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Not having any other place to point CurrentMemoryContext, make it point
     * to TopMemoryContext.  Caller should change this soon!
     */</comment>
    <expr_stmt><expr><name>CurrentMemoryContext</name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize ErrorContext as an AllocSetContext with slow growth rate ---
     * we don't really expect much to be allocated in it. More to the point,
     * require it to contain at least 8K at all times. This is the only case
     * where retained memory in a context is *essential* --- we want to be
     * sure ErrorContext still has some memory even if we've run out
     * elsewhere!
     *
     * Similar to TopMostMemoryContext, this context may as well be shared
     * between threads
     */</comment>
    <expr_stmt><expr><name>ErrorContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                         <argument><expr><literal type="string">"ErrorContext"</literal></expr></argument>,
                                         <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                         <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                         <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                         <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextReset
 *        Release all space allocated within a context and its descendants,
 *        but don't delete the contexts themselves.
 *
 * The type-specific reset routine handles the context itself, but we
 * have to do the recursion for the children.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextReset</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextLock</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* save a function call in common case where there are no children */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextResetChildren</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextUnlock</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>reset</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextResetChildren
 *        Release all space allocated within a context's descendants,
 *        but don't delete the contexts themselves.  The named context
 *        itself is not touched.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextResetChildren</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For a shared context, lock the parent context before resetting the
     * children contextes
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextLock</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextUnlock</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextDelete
 *        Delete a context and its descendants, and release all space
 *        allocated therein.
 *
 * The type-specific delete routine removes all subsidiary storage
 * for the context, but we have to delete the context node itself,
 * as well as recurse to get the children.    We must also delink the
 * node from its parent, if it has one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MemoryContextDeleteInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parent_locked</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We had better not be deleting TopMemoryContext ... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>TopMostMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* And not CurrentMemoryContext, either */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We delink the context from its parent before deleting it, so that if
     * there's an error we won't have deleted/busted contexts still attached
     * to the context tree.  Better a leak than a crash.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>parent</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the parent context is shared and is already locked by the caller,
         * no need to relock again. In fact, that's not the right thing to do
         * since it will lead to a self-deadlock
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>parent_locked</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextLock</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>parent_locked</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextUnlock</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>delete</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>MemoryContextDelete</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>MemoryContextDeleteInternal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextDeleteChildren
 *        Delete all the descendants of the named context and release all
 *        space allocated therein.  The named context itself is not touched.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextDeleteChildren</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextLock</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/*
     * MemoryContextDelete will delink the child from me, so just iterate as
     * long as there is a child.
     *
     * Since the parent is already locked, pass that information to the child
     * which would then not attempt to relock the parent
     */</comment>
    <while>while <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextDeleteInternal</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextUnlock</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextResetAndDeleteChildren
 *        Release all space allocated within a context and delete all
 *        its descendants.
 *
 * This is a common combination case where we want to preserve the
 * specific context but get rid of absolutely everything under it.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextResetAndDeleteChildren</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>reset</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetMemoryChunkSpace
 *        Given a currently-allocated chunk, determine the total space
 *        it occupies (including all memory-allocation overhead).
 *
 * This is useful for measuring the total space occupied by a set of
 * allocated chunks.
 */</comment>
<function><type><name>Size</name></type>
<name>GetMemoryChunkSpace</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StandardChunkHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to detect bogus pointers handed to us, poorly though we can.
     * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an
     * allocated chunk.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * OK, it's probably safe to look at the chunk header.
     */</comment>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>StandardChunkHeader</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name> <operator>-</operator> <name>STANDARDCHUNKHEADERSIZE</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call>(<modifier>*</modifier><name><name>header</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>get_chunk_space</name></name>) <argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                                                         <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetMemoryChunkContext
 *        Given a currently-allocated chunk, determine the context
 *        it belongs to.
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>GetMemoryChunkContext</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StandardChunkHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to detect bogus pointers handed to us, poorly though we can.
     * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an
     * allocated chunk.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * OK, it's probably safe to look at the chunk header.
     */</comment>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>StandardChunkHeader</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name> <operator>-</operator> <name>STANDARDCHUNKHEADERSIZE</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextIsEmpty
 *        Is a memory context empty of any allocated space?
 */</comment>
<function><type><name>bool</name></type>
<name>MemoryContextIsEmpty</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For now, we consider a memory context nonempty if it has any children;
     * perhaps this should be changed later.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Otherwise use the type-specific inquiry */</comment>
    <return>return <expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>is_empty</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStats
 *        Print statistics about the named context and all its descendants.
 *
 * This is just a debugging utility, so it's not fancy.  The statistics
 * are merely sent to stderr.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextStats</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MemoryContextStatsInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>stats</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextCheck
 *        Check all chunks in the named context.
 *
 * This is just a debugging utility, so it's not fancy.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>MemoryContextCheck</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>check</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextCheck</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * MemoryContextContains
 *        Detect whether an allocated chunk of memory belongs to a given
 *        context or not.
 *
 * Caution: this test is reliable as long as 'pointer' does point to
 * a chunk of memory allocated from *some* context.  If 'pointer' points
 * at memory obtained in some other way, there is a small chance of a
 * false-positive result, since the bits right before it might look like
 * a valid chunk header by chance.
 */</comment>
<function><type><name>bool</name></type>
<name>MemoryContextContains</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StandardChunkHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to detect bogus pointers handed to us, poorly though we can.
     * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an
     * allocated chunk.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pointer</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>pointer</name> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * OK, it's probably safe to look at the chunk header.
     */</comment>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>StandardChunkHeader</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name> <operator>-</operator> <name>STANDARDCHUNKHEADERSIZE</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * If the context link doesn't match then we certainly have a non-member
     * chunk.  Also check for a reasonable-looking size as extra guard against
     * being fooled by bogus pointers.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>context</name> <operator>&amp;&amp;</operator> <call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*--------------------
 * MemoryContextCreate
 *        Context-type-independent part of context creation.
 *
 * This is only intended to be called by context-type-specific
 * context creation routines, not by the unwashed masses.
 *
 * The context creation procedure is a little bit tricky because
 * we want to be sure that we don't leave the context tree invalid
 * in case of failure (such as insufficient memory to allocate the
 * context node itself).  The procedure goes like this:
 *    1.    Context-type-specific routine first calls MemoryContextCreate(),
 *        passing the appropriate tag/size/methods values (the methods
 *        pointer will ordinarily point to statically allocated data).
 *        The parent and name parameters usually come from the caller.
 *    2.    MemoryContextCreate() attempts to allocate the context node,
 *        plus space for the name.  If this fails we can ereport() with no
 *        damage done.
 *    3.    We fill in all of the type-independent MemoryContext fields.
 *    4.    We call the type-specific init routine (using the methods pointer).
 *        The init routine is required to make the node minimally valid
 *        with zero chance of failure --- it can't allocate more memory,
 *        for example.
 *    5.    Now we have a minimally valid node that can behave correctly
 *        when told to reset or delete itself.  We link the node to its
 *        parent (if any), making the node part of the context tree.
 *    6.    We return to the context-type-specific routine, which finishes
 *        up type-specific initialization.  This routine can now do things
 *        that might fail (like allocate more memory), so long as it's
 *        sure the node is left in a state that delete will handle.
 *
 * This protocol doesn't prevent us from leaking memory if step 6 fails
 * during creation of a top-level context, since there's no parent link
 * in that case.  However, if you run out of memory while you're building
 * a top-level context, you might as well go home anyway...
 *
 * Normally, the context node and the name are allocated from
 * TopMemoryContext (NOT from the parent context, since the node must
 * survive resets of its parent context!).    However, this routine is itself
 * used to create TopMemoryContext!  If we see that TopMemoryContext is NULL,
 * we assume we are creating TopMemoryContext and use malloc() to allocate
 * the node.
 *
 * Note that the name field of a MemoryContext does not point to
 * separately-allocated storage, so it should not be freed at context
 * deletion.
 *--------------------
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>MemoryContextCreate</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContextMethods</name> <modifier>*</modifier></type><name>methods</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContext</name></type> <name>parent</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>needed</name> <init>= <expr><name>size</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>


    <comment type="block">/* Get space for node and name */</comment>
    <if_stmt><if>if <condition>(<expr><name>TopMemoryContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Normal case: allocate the node in TopMemoryContext */</comment>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>MemoryContext</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                  <argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Special case for startup: use good ol' malloc */</comment>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>MemoryContext</name><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Initialize the node as best we can */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <name>methods</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* for the moment */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Type-specific routine finishes any other essential initialization */</comment>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>node</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>init</name></name>) <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lock the parent context if the it is shared and must be made thread-safe
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>parent</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextLock</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OK to link node to parent (if any) */</comment>
    <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>parent</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MemoryContextIsShared</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextUnlock</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Return to type-specific creation routine to finish up */</comment>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAlloc
 *        Allocate space within the specified context.
 *
 * This could be turned into a macro, but we'd have to import
 * nodes/memnodes.h into postgres.h which seems a bad idea.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAlloc</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %lu"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocZero
 *        Like MemoryContextAlloc, but clears allocated memory
 *
 *    We could just call MemoryContextAlloc then clear the memory, but this
 *    is a very common combination, so we provide the combined operation.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocZero</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %lu"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocZeroAligned
 *        MemoryContextAllocZero where length is suitable for MemSetLoop
 *
 *    This might seem overly specialized, but it's not because newNode()
 *    is so often called with compile-time-constant sizes.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocZeroAligned</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %lu"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemSetLoop</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pfree
 *        Release an allocated chunk.
 */</comment>
<function><type><name>void</name></type>
<name>pfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StandardChunkHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to detect bogus pointers handed to us, poorly though we can.
     * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an
     * allocated chunk.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * OK, it's probably safe to look at the chunk header.
     */</comment>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>StandardChunkHeader</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name> <operator>-</operator> <name>STANDARDCHUNKHEADERSIZE</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>header</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>free_p</name></name>) <argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * repalloc
 *        Adjust the size of a previously allocated chunk.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>repalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StandardChunkHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to detect bogus pointers handed to us, poorly though we can.
     * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an
     * allocated chunk.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pointer</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * OK, it's probably safe to look at the chunk header.
     */</comment>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>StandardChunkHeader</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name> <operator>-</operator> <name>STANDARDCHUNKHEADERSIZE</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %lu"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call>(<modifier>*</modifier><name><name>header</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>realloc</name></name>) <argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                                                 <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextSwitchTo
 *        Returns the current context; installs the given context.
 *
 * This is inlined when using GCC.
 *
 * TODO: investigate supporting inlining for some non-GCC compilers.
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>MemoryContextSwitchTo</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>old</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentMemoryContext</name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
    <return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStrdup
 *        Like strdup(), but allocate from the specified context
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>MemoryContextStrdup</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>nstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nstr</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>nstr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pnstrdup
 *        Like pstrdup(), but append null byte to a
 *        not-necessarily-null-terminated input string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pnstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 *    Memory support routines for libpgport on Win32
 *
 *    Win32 can't load a library that PGDLLIMPORTs a variable
 *    if the link object files also PGDLLIMPORT the same variable.
 *    For this reason, libpgport can't reference CurrentMemoryContext
 *    in the palloc macro calls.
 *
 *    To fix this, we create several functions here that allow us to
 *    manage memory without doing the inline in libpgport.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>pgport_palloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>palloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>char</name> <modifier>*</modifier></type>
<name>pgport_pstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Doesn't reference a PGDLLIMPORT variable, but here for completeness. */</comment>
<function><type><name>void</name></type>
<name>pgport_pfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gen_alloc.h"</cpp:file></cpp:include>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>current_memcontext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name> <modifier>*</modifier></type><name>current_memcontext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return<expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>CurrentMemoryContext</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>allocTopMemCxt</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMostMemoryContext</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>Gen_Alloc</name></type> <name>genAlloc_class</name> <init>= <expr><block>{<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>MemoryContextAlloc</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>MemoryContextAllocZero</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>repalloc</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pfree</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>current_memcontext</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>allocTopMemCxt</name></expr>}</block></expr></init></decl>;</decl_stmt>
</unit>
