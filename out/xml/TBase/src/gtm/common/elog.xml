<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/common/elog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * elog.c
 *      error logging and reporting
 *
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      $PostgreSQL: pgsql/src/backend/utils/error/elog.c,v 1.212 2009/01/19 15:34:23 mha Exp $
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_msg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/syslogger.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>x</cpp:value></cpp:define>

<comment type="block">/*
 * Change this to something which is more appropriate.
 *
 * XXX The GTM should take command like argument to set the log file
 */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>GTMLogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC parameters */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>Log_destination</name> <init>= <expr><name>LOG_DESTINATION_STDERR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>	<name>exit_flag</name> <init>= <expr><name>GTM_DEFAULT_EXIT_FLAG</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Macro for checking errordata_stack_depth is reasonable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STACK_DEPTH</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        if (errordata_stack_depth &lt; 0) \
        { \
            errordata_stack_depth = -1; \
            ereport(ERROR, (errmsg_internal("errstart was not called"))); \
        } \
    } while (0)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>errlog_collection_hook_type</name></type> <name>errlog_collection_func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>send_message_to_server_log</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>send_message_to_frontend</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>expand_fmt_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>useful_strerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_severity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_with_tabs</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_log_level_output</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_min_level</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>int</name></type>	<name>log_min_messages</name> <init>= <expr><name>WARNING</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Log_line_prefix</name> <init>= <expr><literal type="string">"%p:%m -"</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* format for extra log line info */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORMATTED_TS_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>formatted_start_time</name><index>[<expr><name>FORMATTED_TS_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>formatted_log_time</name><index>[<expr><name>FORMATTED_TS_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_line_prefix</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_formatted_log_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * setup formatted_log_time, for consistent times between CSV and regular logs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_formatted_log_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type>    <name>stamp_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>msbuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>   <name>timeinfo</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stamp_time</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>timeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>formatted_log_time</name></expr></argument>, <argument><expr><name>FORMATTED_TS_LEN</name></expr></argument>,
                <comment type="block">/* leave room for milliseconds... */</comment>
                <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S     %Z"</literal></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>timeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 'paste' milliseconds into place... */</comment>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="string">".%03d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>formatted_log_time</name> <operator>+</operator> <literal type="number">19</literal></expr></argument>, <argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Format tag info for log lines; append to the provided buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_line_prefix</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* static counter for line numbers */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>log_line_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* has counter been reset in current process? */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>log_my_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>            <name>format_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This is one of the few places where we'd rather not inherit a static
     * variable's value from the postmaster.  But since we will, reset it when
     * MyProcPid changes. MyStartTime also changes when MyProcPid does, so
     * reset the formatted start timestamp too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>log_my_pid</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>MyThreadID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>log_line_number</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>log_my_pid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>MyThreadID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>formatted_start_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>log_line_number</name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>Log_line_prefix</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* in case guc hasn't run yet */</comment>

    <expr_stmt><expr><name>format_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>Log_line_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>format_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Log_line_prefix</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* literal char, just copy */</comment>
            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>Log_line_prefix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* go to char after '%' */</comment>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>format_len</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* format error - ignore it */</comment>

        <comment type="block">/* process the option */</comment>
        <switch>switch <condition>(<expr><name><name>Log_line_prefix</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MyThreadID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'l'</literal></expr>:</case>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name>log_line_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'m'</literal></expr>:</case>
                <expr_stmt><expr><call><name>setup_formatted_log_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>formatted_log_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <comment type="block">/* format error - ignore it */</comment>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * errstart --- begin an error-reporting cycle
 *
 * Create a stack entry and store the given parameters in it.  Subsequently,
 * errmsg() and perhaps other routines will be called to further populate
 * the stack entry.  Finally, errfinish() will be called to actually process
 * the error report.
 *
 * Returns TRUE in normal case.  Returns FALSE to short-circuit the error
 * report (if it's a warning or lower and not to be reported anywhere).
 */</comment>
<function><type><name>bool</name></type>
<name>errstart</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>,
         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ErrorData</name>    <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>output_to_server</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>output_to_client</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check some cases in which we want to promote an error into a more
     * severe error.  None of this logic applies for non-error messages.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we are inside a critical section, all errors become PANIC
         * errors.    See miscadmin.h.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>PANIC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check reasons for treating ERROR as FATAL:
         *
         * 1. we have no handler to pass the error to (implies we are in the
         * postmaster or in backend startup).
         *
         * 2. ExitOnAnyError mode switch is set (initdb uses this).
         *
         * 3. the error occurred after proc_exit has begun to run.    (It's
         * proc_exit's responsibility to see that this doesn't turn into
         * infinite recursion!)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>ERROR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>PG_exception_stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>FATAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the error level is ERROR or more, errfinish is not going to
         * return to caller; therefore, if there is any stacked error already
         * in progress it will be lost.  This is more or less okay, except we
         * do not want to have a FATAL or PANIC error downgraded because the
         * reporting process was interrupted by a lower-grade error.  So check
         * the stack and make sure we panic if panic is warranted.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>errordata_stack_depth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>elevel</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name><name>errordata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>output_to_server</name> <operator>=</operator> <call><name>is_log_level_output</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>log_min_messages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>output_to_client</name> <operator>=</operator> <operator>(</operator><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Skip processing effort if non-error message will not be output */</comment>
    <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&lt;</operator> <name>ERROR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>output_to_server</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>output_to_client</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Okay, crank up a stack entry to store the info in.
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>recursion_depth</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Ooops, error during error processing.  Clear ErrorContext as
         * discussed at top of file.  We will not return to the original
         * error's reporter or handler, so we don't need it.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>++</operator><name>errordata_stack_depth</name> <operator>&gt;=</operator> <name>ERRORDATA_STACK_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Wups, stack not big enough.    We treat this as a PANIC condition
         * because it suggests an infinite loop of errors during error
         * recovery.
         */</comment>
        <expr_stmt><expr><name>errordata_stack_depth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* make room on stack */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"ERRORDATA_STACK_SIZE exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Initialize data for this error frame */</comment>
    <expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>=</operator> <name>output_to_server</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name> <operator>=</operator> <name>output_to_client</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>
    <comment type="block">/* errno is saved here so that error parameter eval can't change it */</comment>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errfinish --- end an error-reporting cycle
 *
 * Produce the appropriate error report(s) and pop the error stack.
 *
 * If elevel is ERROR or worse, control does not return to the caller.
 * See elog.h for the error level definitions.
 */</comment>
<function><type><name>void</name></type>
<name>errfinish</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dummy</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>elevel</name> <init>= <expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do processing in ErrorContext, which we hope has enough reserved space
     * to report an error.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/*
     * If ERROR (not more nor less) we pass it off to the current handler.
     * Printing it and popping the stack is the responsibility of the handler.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>ERROR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We do some minimal cleanup before longjmp'ing so that handlers can
         * execute in a reasonably sane state.
         */</comment>
        <expr_stmt><expr><name>CritSectionCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* should be unnecessary, but... */</comment>

        <comment type="block">/*
         * Note that we leave CurrentMemoryContext set to ErrorContext. The
         * handler should reset it to something else soon.
         */</comment>

        <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Emit the message to the right places */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name><operator>-&gt;</operator><name>con_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
    <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Now free up subsidiary data attached to stack entry, and release it */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>errordata_stack_depth</name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* Exit error-handling context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform error recovery action as specified by elevel.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>FATAL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * fflush here is just to improve the odds that we get to see the
         * error message, in case things are so hosed that proc_exit crashes.
         * Any other code you might be tempted to add here should probably be
         * in an on_proc_exit or on_shmem_exit callback instead.
         */</comment>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Do normal process-exit cleanup, then return exit code 1 to indicate
         * FATAL termination.  The postmaster may or may not consider this
         * worthy of panic, depending on which subprocess returns it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsMainThread</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pthread_exit</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>PANIC</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We reach here if elevel &lt;= WARNING. OK to return to caller.
     */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * This macro handles expansion of a format string and associated parameters;
 * it's common code for errmsg(), errdetail(), etc.  Must be called inside
 * a routine that is declared like "const char *fmt, ..." and has an edata
 * pointer set up.    The message is assigned to edata-&gt;targetfield, or
 * appended to it if appendval is true.  The message is subject to translation
 * if translateit is true.
 *
 * Note: we pstrdup the buffer rather than just transferring its storage
 * to the edata field because the buffer might be considerably larger than
 * really necessary.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVALUATE_MESSAGE</name><parameter_list>(<parameter><type><name>targetfield</name></type></parameter>, <parameter><type><name>appendval</name></type></parameter>, <parameter><type><name>translateit</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>{ \
        char           *fmtbuf; \
        StringInfoData    buf; \
        <comment type="block">/* Expand %m in format string */</comment> \
        fmtbuf = expand_fmt_string(fmt, edata); \
        initStringInfo(&amp;buf); \
        if ((appendval) &amp;&amp; edata-&gt;targetfield) \
            appendStringInfo(&amp;buf, "%s\n", edata-&gt;targetfield); \
        <comment type="block">/* Generate actual output --- have to use appendStringInfoVA */</comment> \
        for (;;) \
        { \
            va_list        args; \
            bool        success; \
            va_start(args, fmt); \
            success = appendStringInfoVA(&amp;buf, fmtbuf, args); \
            va_end(args); \
            if (success) \
                break; \
            enlargeStringInfo(&amp;buf, buf.maxlen); \
        } \
        <comment type="block">/* Done with expanded fmt */</comment> \
        pfree(fmtbuf); \
        <comment type="block">/* Save the completed message into the stack item */</comment> \
        if (edata-&gt;targetfield) \
            pfree(edata-&gt;targetfield); \
        edata-&gt;targetfield = pstrdup(buf.data); \
        pfree(buf.data); \
    }</cpp:value></cpp:define>


<comment type="block">/*
 * errmsg --- add a primary error message text to the current error
 *
 * In addition to the usual %-escapes recognized by printf, "%m" in
 * fmt is replaced by the error message for the caller's value of errno.
 *
 * Note: no newline is needed at the end of the fmt string, since
 * ereport will provide one for the output methods that need it.
 */</comment>
<function><type><name>int</name></type>
<name>errmsg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errmsg_internal --- add a primary error message text to the current error
 *
 * This is exactly like errmsg() except that strings passed to errmsg_internal
 * are not translated, and are customarily left out of the
 * internationalization message dictionary.  This should be used for "can't
 * happen" cases that are probably not worth spending translation effort on.
 * We also use this for certain cases where we *must* not try to translate
 * the message because the translation would fail and result in infinite
 * error recursion.
 */</comment>
<function><type><name>int</name></type>
<name>errmsg_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errdetail --- add a detail error message text to the current error
 */</comment>
<function><type><name>int</name></type>
<name>errdetail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name>detail</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errdetail_log --- add a detail_log error message text to the current error
 */</comment>
<function><type><name>int</name></type>
<name>errdetail_log</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name>detail_log</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errhint --- add a hint error message text to the current error
 */</comment>
<function><type><name>int</name></type>
<name>errhint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name>hint</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>



<comment type="block">/*
 * errfunction --- add reporting function name to the current error
 *
 * This is used when backwards compatibility demands that the function
 * name appear in messages sent to old-protocol clients.  Note that the
 * passed string is expected to be a non-freeable constant string.
 */</comment>
<function><type><name>int</name></type>
<name>errfunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>show_funcname</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * elog_start --- startup for old-style API
 *
 * All that we do here is stash the hidden filename/lineno/funcname
 * arguments into a stack entry.
 *
 * We need this to be separate from elog_finish because there's no other
 * portable way to deal with inserting extra arguments into the elog call.
 * (If macros with variable numbers of arguments were portable, it'd be
 * easy, but they aren't.)
 */</comment>
<function><type><name>void</name></type>
<name>elog_start</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>++</operator><name>errordata_stack_depth</name> <operator>&gt;=</operator> <name>ERRORDATA_STACK_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Wups, stack not big enough.    We treat this as a PANIC condition
         * because it suggests an infinite loop of errors during error
         * recovery.  Note that the message is intentionally not localized,
         * else failure to convert it to client encoding could cause further
         * recursion.
         */</comment>
        <expr_stmt><expr><name>errordata_stack_depth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* make room on stack */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"ERRORDATA_STACK_SIZE exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>
    <comment type="block">/* errno is saved now so that error parameter eval can't change it */</comment>
    <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * elog_finish --- finish up for old-style API
 */</comment>
<function><type><name>void</name></type>
<name>elog_finish</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do errstart() to see if we actually want to report the message.
     */</comment>
    <expr_stmt><expr><name>errordata_stack_depth</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>errstart</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>

    <comment type="block">/*
     * Format error message just like errmsg_internal().
     */</comment>
    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * And let errfinish() finish up.
     */</comment>
    <expr_stmt><expr><call><name>errfinish</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Actual output of the top-of-stack error message
 *
 * In the ereport(ERROR) case this is called from GTM_ThreadMain(or not at all,
 * if the error is caught by somebody).  For all other severity levels this
 * is called by errfinish.
 */</comment>
<function><type><name>void</name></type>
<name>EmitErrorReport</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name><init>= <expr><operator>(</operator><name>Port</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Send to server log, if enabled */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>send_message_to_server_log</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Send to client, if enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>myport</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>send_message_to_frontend</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FlushErrorState --- flush the error state after error recovery
 *
 * This should be called by an error handler after it's done processing
 * the error; or as soon as it's done CopyErrorData, if it intends to
 * do stuff that is likely to provoke another error.  You are not "out" of
 * the error subsystem until you have done this.
 */</comment>
<function><type><name>void</name></type>
<name>FlushErrorState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Reset stack to empty.  The only case where it would be more than one
     * deep is if we serviced an error that interrupted construction of
     * another message.  We assume control escaped out of that message
     * construction and won't ever go back.
     */</comment>
    <expr_stmt><expr><name>errordata_stack_depth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>recursion_depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Delete all data in ErrorContext */</comment>
    <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * pg_re_throw --- out-of-line implementation of PG_RE_THROW() macro
 */</comment>
<function><type><name>void</name></type>
<name>pg_re_throw</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* If possible, throw the error to the next outer setjmp handler */</comment>
    <if_stmt><if>if <condition>(<expr><name>PG_exception_stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>siglongjmp</name><argument_list>(<argument><expr><operator>*</operator><name>PG_exception_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If we get here, elog(ERROR) was thrown inside a PG_TRY block, which
         * we have now exited only to discover that there is no outer setjmp
         * handler to pass the error to.  Had the error been thrown outside
         * the block to begin with, we'd have promoted the error to FATAL, so
         * the correct behavior is to make it FATAL now; that is, emit it and
         * then call proc_exit.
         */</comment>
        <decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>errordata_stack_depth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>FATAL</name></expr>;</expr_stmt>

        <comment type="block">/*
         * At least in principle, the increase in severity could have changed
         * where-to-output decisions, so recalculate.  This should stay in
         * sync with errstart(), which see for comments.
         */</comment>
        <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>=</operator> <call><name>is_log_level_output</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                                                      <argument><expr><name>log_min_messages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>errfinish</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* We mustn't return... */</comment>
    <expr_stmt><expr><call><name>ExceptionalCondition</name><argument_list>(<argument><expr><literal type="string">"pg_re_throw tried to return"</literal></expr></argument>, <argument><expr><literal type="string">"FailedAssertion"</literal></expr></argument>,
                         <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since ExceptionalCondition isn't declared noreturn because of
     * TrapMacro(), we need this to keep gcc from complaining.
     */</comment>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Send data to the syslogger using the chunked protocol
 *
 * Note: when there are multiple backends writing into the syslogger pipe,
 * it's critical that each write go into the pipe indivisibly, and not
 * get interleaved with data from other processes.  Fortunately, the POSIX
 * spec requires that writes to pipes be atomic so long as they are not
 * more than PIPE_BUF bytes long.  So we divide long messages into chunks
 * that are no more than that length, and send one chunk per write() call.
 * The collector process knows how to reassemble the chunks.
 *
 * Because of the atomic write requirement, there are only two possible
 * results from write() here: -1 for failure, or the requested number of
 * bytes.  There is not really anything we can do about a failure; retry would
 * probably be an infinite loop, and we can't even report the error usefully.
 * (There is noplace else we could send it!)  So we might as well just ignore
 * the result from write().  However, on some platforms you get a compiler
 * warning from ignoring write()'s result, so do a little dance with casting
 * rc to void to shut up the compiler.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_pipe_chunks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PipeProtoChunk</name></type> <name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>nuls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>nuls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>exit_flag</name> <operator>==</operator> <name>GTM_DEFAULT_EXIT_FLAG</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ThreadId</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* write all but the last chunk */</comment>
    <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>PIPE_MAX_PAYLOAD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>is_last</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>dest</name> <operator>==</operator> <name>LOG_DESTINATION_CSVLOG</name></expr> ?</condition><then> <expr><literal type="char">'F'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>PIPE_MAX_PAYLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>PIPE_HEADER_SIZE</name> <operator>+</operator> <name>PIPE_MAX_PAYLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* if we are interruppted, just return */</comment>
        <if_stmt><if>if <condition>(<expr><name>EINTR</name> <operator>==</operator> <name>errno</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* write the last chunk */</comment>
    <expr_stmt><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>is_last</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>dest</name> <operator>==</operator> <name>LOG_DESTINATION_CSVLOG</name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'t'</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>proto</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>PIPE_HEADER_SIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* if we are interruppted, just return */</comment>
    <if_stmt><if>if <condition>(<expr><name>EINTR</name> <operator>==</operator> <name>errno</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Initialization of error output file
 */</comment>
<function><type><name>void</name></type>
<name>DebugFileOpen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>,
                <decl><type ref="prev"/><name>istty</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>GTMLogFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * A debug-output file name was given.
         *
         * Make sure we can write the file, and find out if it's a tty.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>GTMLogFile</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>O_WRONLY</name></expr></argument>,
                       <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>errno</name><operator>,</operator>
                  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>GTMLogFile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>istty</name> <operator>=</operator> <call><name>isatty</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Redirect our stderr to the debug output file.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>freopen</name><argument_list>(<argument><expr><name>GTMLogFile</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>errno</name><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not reopen file \"%s\" as stderr: %m"</literal></expr></argument>,
                            <argument><expr><name>GTMLogFile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If the file is a tty and we're running under the postmaster, try to
         * send stdout there as well (if it isn't a tty then stderr will block
         * out stdout, so we may as well let stdout go wherever it was going
         * before).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>istty</name></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>freopen</name><argument_list>(<argument><expr><name>GTMLogFile</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>errno</name><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not reopen file \"%s\" as stdout: %m"</literal></expr></argument>,
                                <argument><expr><name>GTMLogFile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write error report to server's log
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>send_message_to_server_log</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>formatted_log_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s:  "</literal></expr></argument>, <argument><expr><call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing error text"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"DETAIL:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"DETAIL:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HINT:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONTEXT:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* assume no newlines in funcname or filename... */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"LOCATION:  %s, %s:%d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
						 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"LOCATION:  %s:%d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* If in the syslogger thread, try to write messages direct to file */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>am_syslogger</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>write_pipe_chunks</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>errlog_collection_func</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>errlog_collection_func</name>) <argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write error report to client
 *
 * At present, this function is not used within GTM.   Because this flushes
 * message back to the client, GTM should consider to flush backup to the
 * standby.  However, we cannot simply refer to isGTM because this module
 * can be included in Coordinator backends.  If this can really be called
 * from any GTM module, we need a solution to determine that the Port is
 * in GTM or not, without direct reference to isGTM.
 *
 * K.Suzuki, Jan, 2012
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>send_message_to_frontend</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgbuf</name></decl>;</decl_stmt>

    <comment type="block">/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */</comment>
    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&lt;</operator> <name>ERROR</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'N'</literal></expr> </then><else>: <expr><literal type="char">'E'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>myport</name><operator>-&gt;</operator><name>remote_type</name></name> <operator>==</operator> <name>GTM_NODE_GTM_PROXY</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GTM_ProxyMsgHeader</name></type> <name>proxyhdr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>proxyhdr</name><operator>.</operator><name>ph_conid</name></name> <operator>=</operator> <name><name>myport</name><operator>-&gt;</operator><name>conn_id</name></name></expr>;</expr_stmt>
        <comment type="block">/* Send the GTM Proxy header if we are dealing with a proxy */</comment>
        <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>proxyhdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ProxyMsgHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* M field is required per protocol, so always send something */</comment>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing error text"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* detail_log is intentionally not used here */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* terminator */</comment>

    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * This flush is normally not necessary, since postgres.c will flush out
     * waiting data when control returns to the main loop. But it seems best
     * to leave it here, so that the client has some clue what happened if the
     * backend dies before getting back to the main loop ... error/notice
     * messages should not be a performance-critical path anyway, so an extra
     * flush won't hurt much ...
     */</comment>
    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support routines for formatting error messages.
 */</comment>


<comment type="block">/*
 * expand_fmt_string --- process special format codes in a format string
 *
 * We must replace %m with the appropriate strerror string, since vsnprintf
 * won't know what to do with it.
 *
 * The result is a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>expand_fmt_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>fmt</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Replace %m by system error string.  If there are any %'s in
                 * the string, we'd better double them so that vsnprintf won't
                 * misinterpret.
                 */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp2</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>cp2</name> <operator>=</operator> <call><name>useful_strerror</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>cp2</name></expr>;</condition> <incr><expr><name>cp2</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp2</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>cp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* copy % and next char --- this avoids trouble with %%m */</comment>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * A slightly cleaned-up version of strerror()
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>useful_strerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* this buffer is only used if errno has a bogus value */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>errorstr_buf</name><index>[<expr><literal type="number">48</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strerror</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Some strerror()s return an empty string for out-of-range errno. This is
     * ANSI C spec compliant, but not exactly useful.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errorstr_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errorstr_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
        <comment type="block">/*------
          translator: This string will be truncated at 47
          characters expanded. */</comment>
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"operating system error %d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <name>errorstr_buf</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * error_severity --- get localized string representing elevel
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>error_severity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>DEBUG1</name></expr>:</case>
        <case>case <expr><name>DEBUG2</name></expr>:</case>
        <case>case <expr><name>DEBUG3</name></expr>:</case>
        <case>case <expr><name>DEBUG4</name></expr>:</case>
        <case>case <expr><name>DEBUG5</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"DEBUG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOG</name></expr>:</case>
        <case>case <expr><name>COMMERROR</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"LOG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>INFO</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>NOTICE</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"NOTICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WARNING</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"WARNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ERROR</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ERROR2</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"ERROR2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FATAL</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PANIC</name></expr>:</case>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"PANIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>prefix</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *    append_with_tabs
 *
 *    Append the string to the StringInfo buffer, inserting a tab after any
 *    newline.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_with_tabs</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>ch</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <operator>*</operator><name>str</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Write errors to stderr (or by equal means when stderr is
 * not available). Used before ereport/elog can be used
 * safely (memory context, GUC load etc)
 */</comment>
<function><type><name>void</name></type>
<name>write_stderr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type>        <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* On Unix, we just fprintf to stderr */</comment>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * is_log_level_output -- is elevel logically &gt;= log_min_level?
 *
 * We use this for tests that should consider LOG to sort out-of-order,
 * between ERROR and FATAL.  Generally this is the right thing for testing
 * whether a message should go to the postmaster log, whereas a simple &gt;=
 * test is correct for testing whether the message should go to the client.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_log_level_output</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_min_level</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>LOG</name> <operator>||</operator> <name>elevel</name> <operator>==</operator> <name>COMMERROR</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>log_min_level</name> <operator>==</operator> <name>LOG</name> <operator>||</operator> <name>log_min_level</name> <operator>&lt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>log_min_level</name> <operator>==</operator> <name>LOG</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* elevel != LOG */</comment>
        <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>FATAL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Neither is LOG */</comment>
    <if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>log_min_level</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
