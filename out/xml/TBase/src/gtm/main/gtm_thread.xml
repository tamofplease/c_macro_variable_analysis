<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/main/gtm_thread.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gtm_thread.c
 *    Thread handling
 *
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      $PostgreSQL$
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_txn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_stat_error.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_store.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>GTM_ThreadMainWrapper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTM_ThreadCleanup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>GTM_Threads</name></type>    <name>GTMThreadsData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTM_Threads</name> <modifier>*</modifier></type><name>GTMThreads</name> <init>= <expr><operator>&amp;</operator><name>GTMThreadsData</name></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTMThreadsFull</name></cpp:macro>    <cpp:value>(GTMThreads-&gt;gt_thread_count == GTMThreads-&gt;gt_array_size)</cpp:value></cpp:define>

<comment type="block">/*
 * Add the given thrinfo structure to the global array, expanding it if
 * necessary
 */</comment>
<function><type><name>int</name></type>
<name>GTM_ThreadAdd</name><parameter_list>(<parameter><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_block_new_connection</name></name> <operator>==</operator> <name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>GTMThreadsFull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type> <name>newsize</name></decl>;</decl_stmt>

        <comment type="block">/*
         * TODO Optimize lock management by not holding any locks during memory
         * allocation.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>==</operator> <name>GTM_MAX_THREADS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Too many threads active"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>GTM_MIN_THREADS</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We ran out of the array size. Just double the size, bound by the
             * upper limit
             */</comment>
            <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Can't have more than GTM_MAX_THREADS */</comment>
        <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <name>GTM_MAX_THREADS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>GTM_MAX_THREADS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name></name> <operator>=</operator> <operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ThreadInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>old_ptr</name> <init>= <expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name></name> <operator>=</operator> <operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ThreadInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name></name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>,
                    <argument><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ThreadInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now that we have free entries in the array, find a free slot and add the
     * thrinfo pointer to it.
     *
     * TODO Optimize this later by tracking few free slots and reusing them.
     * The free slots can be updated when a thread exits and reused when a new
     * thread is added to the pool.
     */</comment>
    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>thrinfo</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_localid</name></name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"add thread %d"</literal></expr></argument>, <argument><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Lastly, assign a unique, monotonically increasing identifier to the
     * remote client. This is sent back to the client and client will resend it
     * in case of reconnect
     *
     * Since all open transactions are tracked in a single linked list on the
     * GTM, we need a mechanism to identify transactions associated with a
     * specific client connection so that they can be removed if the client
     * disconnects abrubptly. We could have something like a pthread_id given
     * that there is one GTM thread per connection, but that is not sufficient
     * when GTM is failed over to a standby. The pthread_id on the old master
     * will make no sense on the new master and it will be hard to re-establish
     * the association of open transactions and the client connections (note
     * that all of this applies only when backends are connecting to GTM via a
     * GTM proxy. Otherwise those open transactions will be aborted when GTM
     * failover happens)
     *
     * So we use a unique identifier for each incoming connection to the GTM.
     * GTM assigns the identifier and also sends it back to the client as part
     * of the connection establishment process. In case of GTM failover, and
     * when GTM proxies reconnect to the new master, they also send back the
     * identifier issued to them by the previous master. The new GTM master
     * then uses that identifier to associate open transactions with the client
     * connection. Of course, for this to work, GTM must store client
     * identifier in each transaction info structure and also replicate that
     * information to the standby when new transactions are backed up.
     *
     * Since GTM does not backup the action of assinging new identifiers, at
     * failover, it may happen that the new master hasn't yet seen an
     * identifier which is already assigned my the old master (say because the
     * client has not started any transaction yet). To handle this case, we
     * track the latest identifier as seen my the new master upon failover. If
     * a client sends an identifier which is newer than that, that identifier
     * is discarded and new master will issue a new identifier that client will
     * accept.
     */</comment>

    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Track the slot information in the thrinfo. This is useful to quickly
     * find the slot given the thrinfo structure.
     */</comment>
    
    <return>return <expr><name>ii</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GTM_ThreadRemove</name><parameter_list>(<parameter><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>==</operator> <name>thrinfo</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>ii</name> <operator>==</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Thread (%p) %d not found "</literal></expr></argument>, <argument><expr><name>thrinfo</name></expr></argument>, <argument><expr><name>ThreadId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_thread_count</name></name><operator>--</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Thread %d exits."</literal></expr></argument>, <argument><expr><name>ThreadId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new thread and assign the given connection to it.
 *
 * This function is responsible for setting up the various memory contextes for
 * the thread as well as registering this thread with the Thread Manager.
 *
 * Upon successful creation, the thread will start running the given
 * "startroutine". The thread information is returned to the calling process.
 */</comment>
<function><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type>
<name>GTM_ThreadCreate</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier> <name>startroutine</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>max_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We are still running in the context of the main thread. So the
     * allocation below would last as long as the main thread exists or the
     * memory is explicitely freed.
     */</comment>
    <expr_stmt><expr><name>thrinfo</name> <operator>=</operator> <operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_ThreadInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The thread status is set to GTM_THREAD_STARTING and will be changed by
     * the thread itself when it actually starts executing
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_status</name></name> <operator>=</operator> <name>GTM_THREAD_STARTING</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Install the ThreadInfo structure in the global array. We do this before
     * starting the thread
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GTM_ThreadAdd</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_RWLockDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Set up memory contextes before actually starting the threads
     *
     * The TopThreadContext is a child of TopMemoryContext and it will last as
     * long as the main process or this thread lives
     *
     * Thread context is not shared between other threads
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_thread_context</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                        <argument><expr><literal type="string">"TopMemoryContext"</literal></expr></argument>,
                                                        <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                                        <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                                        <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>,
                                                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since the thread is not yes started, TopMemoryContext still points to
     * the context of the calling thread
     */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_parent_context</name></name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>max_lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>max_lock_number</name></name> <operator>=</operator> <name>max_lock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>backup_timer_handle</name></name> <operator>=</operator> <name>INVALID_TIMER_HANDLE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>max_lock</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>locks_hold</name></name> <operator>=</operator> <operator>(</operator><name>GTM_RWLock</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>write_locks_hold</name></name> <operator>=</operator> <operator>(</operator><name>GTM_RWLock</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>write_counters</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>locks_hold</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>write_locks_hold</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>write_counters</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>current_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>current_write_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>xlog_inserting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>insert_lock_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>insert_try_lock_id</name></name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call> <operator>%</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>register_buff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>last_sync_gts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>stat_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>datapump_buff</name></name> <operator>=</operator> <call><name>GTM_BuildDataPumpBuf</name><argument_list>(<argument><expr><name>GTM_THREAD_ERRLOG_DATAPUMP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Each thread gets its own ErrorContext and its a child of ErrorContext of
	 * the main process
	 *
	 * This is a thread-specific context and is not shared between other
	 * threads
	 */</comment>
	<expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>,
													   <argument><expr><literal type="string">"ErrorContext"</literal></expr></argument>,
													   <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
													   <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
													   <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_startroutine</name></name> <operator>=</operator> <name>startroutine</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now start the thread. The thread will start executing the given
	 * "startroutine". The thrinfo structure is also passed to the thread. Any
	 * additional parameters should be passed via the thrinfo strcuture.
	 *
	 * Return the thrinfo structure to the caller
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>GTM_ThreadMainWrapper</name></expr></argument>,
							  <argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><name>err</name><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to create a new thread: error %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>GTM_ThreadRemove</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_thread_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>GTM_RWLockDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>GTM_DestroyDataPumpBuf</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>datapump_buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ensure that the resources are released when the thread exits. (We used
	 * to do this inside GTM_ThreadMainWrapper, but thrinfo-&gt;thr_id may not set
	 * by the time GTM_ThreadMainWrapper starts executing, this possibly
	 * calling the function on an invalid thr_id
	 */</comment>
	<expr_stmt><expr><call><name>pthread_detach</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exit the current thread
 */</comment>
<function><type><name>void</name></type>
<name>GTM_ThreadExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* XXX To be implemented */</comment>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GTM_ThreadJoin</name><parameter_list>(<parameter><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>pthread_join</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>error</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get thread information for the given thread, identified by the
 * thread_id
 */</comment>
<function><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type>
<name>GTM_GetThreadInfo</name><parameter_list>(<parameter><decl><type><name>GTM_ThreadID</name></type> <name>thrid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Cleanup routine for the thread
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTM_ThreadCleanup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Cleaning up thread state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
        <decl_stmt><decl><type><name>int</name></type>             <name>ii</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>thrinfo</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>thr_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    <expr_stmt><expr><call><name>GTM_ConnCleanup</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__XLOG__</name></cpp:ifndef>
    <if_stmt><if>if<condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>standby</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTMPQfinish</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>standby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>standby</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>GTM_ThreadRemove</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>RWLockCleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>locks_hold</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>locks_hold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>write_locks_hold</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>write_locks_hold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>thrinfo</name><operator>-&gt;</operator><name>datapump_buff</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>GTM_DestroyDataPumpBuf</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>datapump_buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Switch to the memory context of the main process so that we can free up
     * our memory contextes easily.
     *
     * XXX We don't setup cleanup handlers for the main process. So this
     * routine would never be called for the main process/thread.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_parent_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_message_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_message_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_thread_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_thread_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* temporarily set error context, in case coredump when elog. */</comment>
    <expr_stmt><expr><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_error_context</name></name> <operator>=</operator> <name><name>thrinfo</name><operator>-&gt;</operator><name>thr_parent_context</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>SetMyThreadInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reset the thread-specific information. This should be done only after we
     * are sure that memory contextes are not required.
     *
     * Note: elog calls need memory contextes, so no elog calls beyond this
     * point.
     */</comment>
    <expr_stmt><expr><call><name>SetMyThreadInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A wrapper around the start routine of the thread. This helps us doing any
 * initialization and setting up cleanup handlers before the main routine is
 * started.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>GTM_ThreadMainWrapper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thrinfo</name> <init>= <expr><operator>(</operator><name>GTM_ThreadInfo</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SetMyThreadInfo</name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_cleanup_push</name><argument_list>(<argument><expr><name>GTM_ThreadCleanup</name></expr></argument>, <argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>thrinfo</name><operator>-&gt;</operator><name>thr_startroutine</name></name><argument_list>(<argument><expr><name>thrinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_cleanup_pop</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thrinfo</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__XLOG__</name></cpp:ifndef>
<function><type><name>void</name></type>
<name>GTM_LockAllOtherThreads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>my_threadinfo</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>thr_lock</name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>GTM_UnlockAllOtherThreads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>my_threadinfo</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>thr_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>GTM_DoForAllOtherThreads</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier> <name>process_routine</name>)<parameter_list>(<parameter><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>my_threadinfo</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_array_size</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name>my_threadinfo</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name>process_routine</name><operator>)</operator><operator>(</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_threads</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Get the latest client identifier from the list of open transactions and set
 * the next client identifier to be issued by us appropriately. Also remember
 * the latest client identifier separately since it will be used to check any
 * stale identifiers once we take over and old clients reconnect
 */</comment>
<function><type><name>void</name></type>
<name>GTM_SetInitialAndNextClientIdentifierAtPromote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_starting_client_id</name></name> <operator>=</operator> <call><name>GTMGetLastClientIdentifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_next_client_id</name></name> <operator>=</operator>
        <call><name>GTM_CLIENT_ID_NEXT</name><argument_list>(<argument><expr><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_starting_client_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>GTMThreads</name><operator>-&gt;</operator><name>gt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
