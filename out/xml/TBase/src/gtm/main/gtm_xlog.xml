<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/gtm/main/gtm_xlog.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * gtm_xlog.c
 *        Functionalities of GTM Standby
 *
 * Portions Copyright (c) 1996-2010, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *        src/gtm/main/gtm_xlog.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/timeb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/epoll.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gtm/gtm_standby.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gtm/gtm_xlog_internal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gtm/standby_utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gtm/gtm_c.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_crc.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &lt; (b) ? (a) : (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLANK_CHARACTERS</name></cpp:macro> <cpp:value>" \t\n"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>enalbe_gtm_xlog_debug</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>GTM_ThreadInfo</name>    <modifier>*</modifier></type><name>g_basebackup_thread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type>                 <name>enable_sync_commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type>              <name>first_init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>               <name>max_wal_sender</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int32</name></type>             <name>g_GTMStoreMapFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>size_t</name></type>            <name>g_GTMStoreSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>GTMControlHeader</name>  <modifier>*</modifier></type><name>g_GTM_Store_Header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>GTM_RWLock</name>        <modifier>*</modifier></type><name>g_GTM_Store_Head_Lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name>              <modifier>*</modifier></type><name>g_GTMStoreMapAddr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name>  <modifier>*</modifier></type><name>synchronous_standby_names</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name>   <modifier>*</modifier></type><name>g_checkpointMapperBuff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>uint32</name> <modifier>*</modifier></type><name>g_checkpointDirtyStart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>uint32</name> <modifier>*</modifier></type><name>g_checkpointDirtySize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name>            <modifier>*</modifier></type><name>recovery_target_timestamp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>GlobalTimestamp</name></type>  <name>recovery_timestamp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type>             <name>recovery_pitr_mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>  <name>GTMStartupGTSDelta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>      <name>g_recovery_finish</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name>     <modifier>*</modifier></type><name>g_GTMStoreDirtyMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>GTM_MutexLock</name></type> <name>g_CheckPointLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>enum</name> <name>GTM_PromoteStatus</name></name></type> <name>promote_status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>XLogCtlData</name>     <modifier>*</modifier></type><name>XLogCtl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XLogSyncStandby</name> <modifier>*</modifier></type><name>XLogSync</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XLogSyncConfig</name>  <modifier>*</modifier></type><name>SyncConfig</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type>  <name>SyncReady</name></decl>;</decl_stmt>
<comment type="block">/* Protects ControlData */</comment>
<decl_stmt><decl><type><name>GTM_RWLock</name></type>       <name>ControlDataLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ControlFileData</name> <modifier>*</modifier></type><name>ControlData</name></decl>;</decl_stmt>

<comment type="block">/* The size of ControlData */</comment>
<decl_stmt><decl><type><name>ssize_t</name></type>          <name>g_GTMControlDataSize</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>XLogRecPtrCompLess</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>XLogRecPtrCompGreater</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> ;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint64</name></type>     <name>XLogRecPtrToBytePos</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogBytePosToStartRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>byte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogBytePosToEndRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>byte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type>     <name>XLogRecPtrToBuffIdx</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type>     <name>XLogRecPtrToFileOffset</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogPtrToPageEnd</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogPtrToNextPageHead</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>XLogDistance</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lhs</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WALInsertLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseXLogInsertLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateInsertInfo</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type></decl></parameter> ,<parameter><decl><type><name>XLogRecPtr</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>XLogAssemble</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>RedoXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>RedoRangeOverwrite</name><parameter_list>(<parameter><decl><type><name>XLogCmdRangerOverWrite</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>RedoCheckPoint</name><parameter_list>(<parameter><decl><type><name>XLogCmdCheckPoint</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list> ;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>RedoTimestamp</name><parameter_list>(<parameter><decl><type><name>XLogRecGts</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>ReadXLogToBuff</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>XLogDataAddPageHeader</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>  <name>XLogWrite</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>req</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>  <name>InitXLogCmdHeader</name><parameter_list>(<parameter><decl><type><name>XLogCmdHeader</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,<parameter><decl><type><name>uint32</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>WaitXLogInsertionsToFinish</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>upto</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogCheckPointInsert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GenerateStatusFile</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddXLogGts</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>OpenXLogFile</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segment_no</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>flush</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseXLogRegisterBuff</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>GetReplicationSendRequestPtr</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>  <name>GTM_GetXLogDataFromXLogWriteBuff</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>max_len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendXLogRegisterBuff</name><parameter_list>(<parameter><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>,<parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTM_PrintControlData</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseXLogRecordWriteLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NotifyWaitingQueue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gtm_init_replication_data</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GTM_RecoveryUpdateMetaData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_end_pos</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>preXLogRecord</name></decl></parameter>,<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckSyncStandbyInList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>application_name</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* string process tools */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>strip</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_contain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>skip_to_next</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>start_with_ignore_case</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_notify_queue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_standby_replication</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_syncconfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_xlogsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_syncconfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_syncconfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_xlogsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_sync_structures</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>long</name> <name>long</name></type>
<name>getSystemTime</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeb</name></name></type> <name>t</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ftime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1000</literal> <operator>*</operator> <name><name>t</name><operator>.</operator><name>time</name></name> <operator>+</operator> <name><name>t</name><operator>.</operator><name>millitm</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetFormatedCommandLine</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ans</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>file_name</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relative_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>meet_percent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cmd</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>MAX_COMMAND_LEN</name> <operator>||</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>size</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"command line %s too long"</literal></expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <switch>switch<condition>(<expr><name><name>cmd</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                <if_stmt><if>if<condition>(<expr><name>meet_percent</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>ans</name> <operator>+</operator> <name>offset</name></expr></argument> ,<argument><expr><name>MAX_COMMAND_LEN</name> <operator>-</operator> <name>offset</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>ans</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cmd</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><name>meet_percent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>
                <if_stmt><if>if<condition>(<expr><name>meet_percent</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>ans</name> <operator>+</operator> <name>offset</name></expr></argument> ,<argument><expr><name>MAX_COMMAND_LEN</name> <operator>-</operator> <name>offset</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name>relative_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>ans</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cmd</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><name>meet_percent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'%'</literal></expr>:</case>
                <if_stmt><if>if<condition>(<expr><name>meet_percent</name> <operator>==</operator> <name>true</name></expr>)</condition>
                <block>{<block_content>
                   <expr_stmt><expr><name>meet_percent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* use %% to transferred meaning */</comment>
                   <expr_stmt><expr><name><name>ans</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>meet_percent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>
            <default>default:</default>
                <if_stmt><if>if<condition>(<expr><name>meet_percent</name> <operator>==</operator> <name>true</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"unknow format %%%c"</literal></expr></argument>,<argument><expr><name><name>cmd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>ans</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cmd</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>ans</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>ans</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTM_UpdateReplicationPos</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>TimeLineID</name></type> <name>timeline</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>write_ptr</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>flush_ptr</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>replay_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_status_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>flush_ptr</name></name>   <operator>&lt;=</operator> <name>flush_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>write_ptr</name></name>   <operator>&lt;=</operator> <name>write_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>replay_ptr</name></name>  <operator>&lt;=</operator> <name>replay_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>replay_ptr</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_ptr</name>  <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flush_ptr</name>  <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>flush_ptr</name></name>   <operator>=</operator> <name>flush_ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>write_ptr</name></name>   <operator>=</operator> <name>write_ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>replay_ptr</name></name>  <operator>=</operator> <name>replay_ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>time_line</name></name>   <operator>=</operator> <name>timeline</name></expr>;</expr_stmt>

    <comment type="block">/* update send_ptr to current send pos when replication first started */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name> <operator>=</operator> <name>write_ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_status_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CheckSyncReplication</name><argument_list>(<argument><expr><name>replication</name></expr></argument>,<argument><expr><name>flush_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * Check the waiting queue with given replication result
 */</comment>
<function><type><name>void</name></type>
<name>CheckSyncReplication</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>notify_queue_already</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>replication</name><operator>-&gt;</operator><name>is_sync</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>
    
    <comment type="block">/* compare with local buff */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>next_sync_pos</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name><name>replication</name><operator>-&gt;</operator><name>next_sync_pos</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>check_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* wakeup pending threads in case of invalid XLogSync-&gt;head_ptr */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>XLogSync</name><operator>-&gt;</operator><name>head_ptr</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NotifyWaitingQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>notify_queue_already</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* save XLogSync-&gt;head_ptr to local buff to avoid lock contention */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>next_sync_pos</name></name> <operator>!=</operator> <name><name>XLogSync</name><operator>-&gt;</operator><name>head_ptr</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>next_sync_pos</name></name> <operator>=</operator> <name><name>XLogSync</name><operator>-&gt;</operator><name>head_ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>sync_hint</name></name>     <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* increase the counter and remember that we have added for the current XLogSync-&gt;head */</comment>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name><name>replication</name><operator>-&gt;</operator><name>next_sync_pos</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>replication</name><operator>-&gt;</operator><name>sync_hint</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>head_xlog_hints</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>sync_hint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* wakeup pending threads */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>notify_queue_already</name> <operator>&amp;&amp;</operator> <name><name>XLogSync</name><operator>-&gt;</operator><name>head_xlog_hints</name></name> <operator>&gt;=</operator> <name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>NotifyWaitingQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>check_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>XLogRecPtrCompLess</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>

   <return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <name>lhs</name><operator>)</operator> <operator>&lt;</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <name>rhs</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * XLogPtr compare function used in heap.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>XLogRecPtrCompGreater</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <name>lhs</name><operator>)</operator> <operator>&gt;</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <name>rhs</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get max sync xlog position with the given number of sync standbys
 * you have to lock check_mutex lock beforce you call it.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>GetMaxSyncStandbyCompletePtr</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <comment type="block">/* static variables , avoid frequent memory allocation */</comment>
    <decl_stmt><decl><type><specifier>static</specifier>  <name>XLogRecPtr</name></type>  <name><name>ptrs</name><index>[<expr><name>GTM_MAX_WALSENDER</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier>  <name>XLogRecPtr</name>  <modifier>*</modifier></type><name>temp_key</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier>  <name>XLogRecPtr</name>  <modifier>*</modifier></type><name>temp_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>gtm_ListCell</name>   <modifier>*</modifier></type><name>cell</name>                <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>heap_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>heap</name></type> <name>h</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We used heap the calculate the n-th greatest sync xlog position in replication
     * and n is SyncConfig-&gt;required_sync_num which ensure xlog is flush to n standbys.
     */</comment>
    <expr_stmt><expr><call><name>heap_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>XLogRecPtrCompGreater</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>gtm_foreach</name><argument_list>(<argument>cell</argument>,<argument>XLogSync-&gt;sync_standbys</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>replication</name> <operator>=</operator> <operator>(</operator><name>GTM_StandbyReplication</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ptrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>GetReplicationFlushPtr</name><argument_list>(<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><name>ptrs</name> <operator>+</operator> <name>i</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"GetMaxSyncStandbyCompletePtr standby: %s heap insert %X/%X"</literal></expr></argument>
                    ,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>heap_count</name> <operator>&gt;=</operator> <name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_delmin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>temp_key</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>temp_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>heap_count</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* if there is not engouh stanndbys,return InvalidXLogRecPtr. */</comment>
    <if_stmt><if>if <condition>(<expr><name>heap_count</name> <operator>&lt;</operator> <name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"GetMaxSyncStandbyCompletePtr no enough standby count:%d required:%d"</literal></expr></argument>,<argument><expr><name>heap_count</name></expr></argument>,<argument><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pop until the last one */</comment>
    <while>while<condition>(<expr><call><name>heap_delmin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>temp_key</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>temp_value</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> <empty_stmt>;</empty_stmt> </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>temp_key</name></expr>)</condition><block type="pseudo"><block_content>
	        	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"GetMaxSyncStandbyCompletePtr result %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>temp_key</name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>temp_key</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
	        	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"GetMaxSyncStandbyCompletePtr result 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			
    </block_content>}</block></if></if_stmt>

    <return>return <expr><ternary><condition><expr><name>temp_key</name></expr> ?</condition><then> <expr><operator>*</operator><name>temp_key</name></expr> </then><else>: <expr><name>InvalidXLogRecPtr</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Notify waiting threads
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NotifyWaitingQueue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>check_ptr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>key</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogWaiter</name> <modifier>*</modifier></type><name>waiter</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>      <name>notify_one</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>       <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    

    <comment type="block">/* get max sync xlog position */</comment>
    <expr_stmt><expr><name>check_ptr</name> <operator>=</operator> <call><name>GetMaxSyncStandbyCompletePtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>check_ptr</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"NotifyWaitingQueue check_ptr is null,skip"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>synced_lsn</name></name> <operator>=</operator> <ternary><condition><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>synced_lsn</name></name> <operator>&gt;</operator> <name>check_ptr</name></expr> ?</condition><then> <expr><name><name>XLogSync</name><operator>-&gt;</operator><name>synced_lsn</name></name></expr> </then><else>: <expr><name>check_ptr</name></expr></else></ternary></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>ret</name> <operator>=</operator> <call><name>heap_min</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>waiter</name></expr></argument>)</argument_list></call></expr><operator>,</operator><expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>*</operator><name>key</name> <operator>&gt;</operator> <name>check_ptr</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"NotifyWaitingQueue notify %X/%X "</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>key</name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>key</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>heap_delmin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>waiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>notify_one</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>waiter</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_CVSignal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>notify_one</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>head_ptr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>head_ptr</name></name> <operator>=</operator> <operator>*</operator><name>key</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>head_xlog_hints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>GetReplicationSendRequestPtr</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>ptr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>replication</name><operator>-&gt;</operator><name>send_request</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>GetReplicationFlushPtr</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_status_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>replication</name><operator>-&gt;</operator><name>flush_ptr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_status_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>NotifyReplication</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_sender</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>g_StandbyReplication</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_use</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_StandbyReplication</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>send_request_lck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>g_StandbyReplication</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>send_ptr</name> <operator>&lt;</operator> <name>ptr</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_StandbyReplication</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>send_request</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTM_CVSignal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_StandbyReplication</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xlog_to_send</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_StandbyReplication</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>send_request_lck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until required xlog position is flushed to standbys.
 */</comment><function><type><name>void</name></type>
<name>WaitSyncComplete</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogWaiter</name> <modifier>*</modifier></type><name>waiter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>enable_sync_commit</name></expr>)</condition><block type="pseudo"><block_content>
       <return>return ;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"WaitSyncComplete %X/%X wait"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>waiter</name> <operator>=</operator> <operator>&amp;</operator><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>xlog_waiter</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>waiter</name><operator>-&gt;</operator><name>pos</name></name>      <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>waiter</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* avoid reload changes which will cause hug up*/</comment>
    <if_stmt><if>if<condition>(<expr><name><name>XLogSync</name><operator>-&gt;</operator><name>synced_lsn</name></name> <operator>&gt;=</operator> <name>ptr</name></expr>)</condition>
	<block>{<block_content>
	    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"WaitSyncComplete %X/%X early finished"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return ;</return>
	</block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,<argument><expr><name>waiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* wait could already finished,if we don't check now, we might wait forever. */</comment>
    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>waiter</name><operator>-&gt;</operator><name>finished</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* make sure finished flag is set to true.  */</comment>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_CVWait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>waiter</name><operator>-&gt;</operator><name>finished</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"WaitSyncComplete %X/%X finished"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return ;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>GetStandbyWriteBuffPos</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>write_buff_pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>GetStandbyApplyPos</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>apply</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UpdateStandbyWriteBuffPos</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"update write buff pos to %X/%X"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>pos</name> <operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>write_buff_pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UpdateStandbyApplyPos</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"update apply pos to %X/%X"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>pos</name> <operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>apply</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>standby_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>GetXLogFlushRecPtr</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ProcessStartReplicationCommand</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>myport</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name>  <modifier>*</modifier></type><name>thr</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>namelen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>      <modifier>*</modifier></type><name>node_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>      <modifier>*</modifier></type><name>replication_name</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>namelen</name>          <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>message</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>node_name</name>        <operator>=</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>message</name></expr></argument>,<argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>namelen</name>          <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>message</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>replication_name</name> <operator>=</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>message</name></expr></argument>,<argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* disconnect from current thread */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>epoll_ctl</name><argument_list>(<argument><expr><name><name>thr</name><operator>-&gt;</operator><name>thr_efd</name></name></expr></argument>,<argument><expr><name>EPOLL_CTL_DEL</name></expr></argument>,<argument><expr><name><name>myport</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"epoll delete fails %s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>fail_process</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* transfer to walsender thread */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>gtm_standby_resign_to_walsender</name><argument_list>(<argument><expr><name>myport</name></expr></argument>,<argument><expr><name>node_name</name></expr></argument>,<argument><expr><name>replication_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"not enough walsender thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>fail_process</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"replication %s connected"</literal></expr></argument>,<argument><expr><name>replication_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>MSG_REPLICATION_START_RESULT_SUCCESS</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return ;</return>

<label><name>fail_process</name>:</label>
    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>MSG_REPLICATION_START_RESULT_FAIL</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name>myport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_flush</name><argument_list>(<argument><expr><name>myport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>GTM_SendGetReplicationStatusRequest</name><parameter_list>(<parameter><decl><type><name>GTM_Conn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Start the message. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>gtmpqPutInt</name><argument_list>(<argument><expr><name>MSG_GET_REPLICATION_STATUS</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GTM_MessageType</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>send_failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Finish the message. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>send_failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Flush to ensure backend gets it. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>gtmpqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>send_failed</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"send requst replication status command to standby"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <label><name>send_failed</name>:</label>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Error couldn't send request replication status command to standby"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>GTM_GetXLogDataFromXLogWriteBuff</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* lock the segment in case of segment switch */</comment>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check whether current segment is what we want */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>XLogInCurrentSegment</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Send_Data_Not_Found</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name> <operator>+</operator> <call><name>XLogRecPtrToBuffIdx</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>Send_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GTM_GetReplicationResultIfAny</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>epoll_event</name></name></type> <name><name>events</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>efd</name> <init>= <expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>thr_efd</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>input_message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>qtype</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>pq_hasdataleft</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* immediate return if not data */</comment>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>epoll_wait</name><argument_list>(<argument><expr><name>efd</name></expr></argument>,<argument><expr><name>events</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name><name>events</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>EPOLLIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get message type code from the frontend.
     */</comment>
    <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition>            <comment type="block">/* frontend disconnected */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><name>EPROTO</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>qtype</name> <operator>==</operator> <literal type="char">'C'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>write_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>flush_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>replay_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimeLineID</name></type>  <name>timeline</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>value</name>   <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>write_ptr</name>  <operator>=</operator> <operator>(</operator><name>XLogRecPtr</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flush_ptr</name>  <operator>=</operator> <operator>(</operator><name>XLogRecPtr</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>replay_ptr</name> <operator>=</operator> <operator>(</operator><name>XLogRecPtr</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>timeline</name>   <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeLineID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Get replication result : write %X/%X,flush %X/%X, replay_ptr %X/%X ,timeline %d value:%d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>write_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>write_ptr</name></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>flush_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flush_ptr</name></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>replay_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>replay_ptr</name></expr></argument>,
                 <argument><expr><name>timeline</name></expr></argument>,
                 <argument><expr><name>value</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_UpdateReplicationPos</name><argument_list>(<argument><expr><name>replication</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>write_ptr</name></expr></argument>,<argument><expr><name>flush_ptr</name></expr></argument>,<argument><expr><name>replay_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadXLogFileToBuffIntern</name><parameter_list>(<parameter><decl><type><name>GTM_XLogSegmentBuff</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>,<parameter><decl><type><name>TimeLineID</name></type> <name>timeline</name></decl></parameter>,<parameter><decl><type><name>XLogSegNo</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>     <name><name>path</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>  <name>bytes</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Fail to open xlog %s : %s"</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Send_Error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name></expr></argument>,<argument><expr><name>GTM_XLOG_SEG_SIZE</name> <operator>-</operator> <name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>bytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Read xlog file %s fails : %s"</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>Send_Error</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>segment_no</name></name> <operator>=</operator> <name>segment_no</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"read xlog file %s with bytes %d"</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>,<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>Send_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadXLogFileToBuff</name><parameter_list>(<parameter><decl><type><name>GTM_XLogSegmentBuff</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>,<parameter><decl><type><name>TimeLineID</name></type> <name>timeline</name></decl></parameter>,<parameter><decl><type><name>XLogSegNo</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetCurrentSegmentNo</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"read xlog file %s for replication"</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ReadXLogFileToBuffIntern</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* forward time line */</comment>
    <expr_stmt><expr><name>timeline</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"xlog file %s not found ,that is not support to happen."</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* need to tell the standby that the required xlog is not available */</comment>
        <return>return <expr><name>Send_XlogFile_Not_Found</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"read xlog file %s for replication"</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call><name>ReadXLogFileToBuffIntern</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendXLogFileData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out_buff</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>start_pos</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLOG_MAX_PER_SEND</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>int</name></type> <name>send_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>loop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>end_pos</name> <init>= <expr><name>start_pos</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"send xlog from %X/%X to %X/%X %d"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>start_pos</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>start_pos</name></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>end_pos</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>end_pos</name></expr></argument>,
             <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">//dump_data(start_pos,data,len);</comment>

    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name>out_buff</name></expr></argument>,<argument><expr><name>start_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><name>out_buff</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>loop</name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator> <name>XLOG_MAX_PER_SEND</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><name>out_buff</name></expr></argument>,<argument><expr><name>loop</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>loop</name></expr> ;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>send_bytes</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>send_bytes</name> <operator>&gt;</operator> <name>XLOG_MAX_PER_SEND</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>send_bytes</name> <operator>=</operator> <name>XLOG_MAX_PER_SEND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><name>out_buff</name></expr></argument>,<argument><expr><name>send_bytes</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><name>out_buff</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><name>send_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>len</name>  <operator>-=</operator> <name>send_bytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>send_bytes</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>SendXLogDataFromFileBuffInternal</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>StringInfo</name></type> <name>out_buff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>         <name>send_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>offset</name></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>XLogRecPtr</name></type>            <name>pos</name> <init>= <expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_XLogSegmentBuff</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>xlog_read_buff</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>offset</name>  <operator>=</operator> <call><name>XLogRecPtrToBuffIdx</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name> <operator>&gt;=</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>send_size</name> <operator>=</operator> <name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"send pos %X/%X size seg:%ld file_length: %d offset :%d "</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>pos</name><operator>)</operator></expr></argument>,<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>segment_no</name></name></expr></argument>,<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name></expr></argument>,<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>send_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SendXLogFileData</name><argument_list>(<argument><expr><name>out_buff</name></expr></argument>,<argument><expr><name>pos</name></expr></argument>,<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name>offset</name></expr></argument>,<argument><expr><name>send_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>Send_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetXLogFileSize</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>timeline</name></decl></parameter>,<parameter><decl><type><name>XLogSegNo</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* forward time line */</comment>
    <expr_stmt><expr><name>timeline</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SendXLogDataFromFileBuff</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>StringInfo</name></type> <name>message_buff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>Send_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_XLogSegmentBuff</name> <modifier>*</modifier></type><name>local_buff</name>      <init>= <expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>xlog_read_buff</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>            <name>request_segment</name> <init>= <expr><call><name>GetSegmentNo</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if we have reach the end */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>GetXLogFileSize</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>time_line</name></name></expr></argument>,<argument><expr><name>request_segment</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>XLogRecPtrToBuffIdx</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>request_segment</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name> <operator>=</operator> <name>request_segment</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

        <return>return <expr><name>Send_Data_Not_Found</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReadXLogFileToBuff</name><argument_list>(<argument><expr><name>local_buff</name></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>time_line</name></name></expr></argument>,<argument><expr><name>request_segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>Send_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SendXLogDataFromFileBuffInternal</name><argument_list>(<argument><expr><name>replication</name></expr></argument>,<argument><expr><name>message_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>request_segment</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name> <operator>=</operator> <name>request_segment</name>  <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <return>return <expr><name>Send_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>XLogLeftDistanceToSegEnd</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>GTM_XLOG_SEG_SIZE</name> <operator>-</operator> <operator>(</operator><name>pos</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SendXLogDataFromXLogBuff</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>StringInfo</name></type> <name>out_message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type>      <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>           <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len</name>  <operator>=</operator> <call><name>XLogDistance</name><argument_list>(<argument><expr><call><name>GetReplicationSendRequestPtr</name><argument_list>(<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>len</name> <operator>&gt;</operator> <call><name>XLogLeftDistanceToSegEnd</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>XLogLeftDistanceToSegEnd</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name>  <operator>=</operator> <call><name>GTM_GetXLogDataFromXLogWriteBuff</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>xlog_read_buff</name><operator>.</operator><name>buff</name></name></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>==</operator> <name>Send_Data_Not_Found</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SendXLogFileData</name><argument_list>(<argument><expr><name>out_message</name></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>xlog_read_buff</name><operator>.</operator><name>buff</name></name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <return>return <expr><name>Send_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SendXLogData</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>  <name>ret</name></decl>;</decl_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>XLogInCurrentSegment</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SendXLogDataFromXLogBuff</name><argument_list>(<argument><expr><name>replication</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>Send_Data_Not_Found</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"request data %X/%X not found in xlog buff"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SendXLogDataFromFileBuff</name><argument_list>(<argument><expr><name>replication</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>==</operator> <name>Send_Data_Not_Found</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>SendXLogContext</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>,<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>out_message</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><name>MSG_REPLICATION_CONTENT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* send the processing result status to the standby */</comment>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><name>Send_OK</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><call><name>GetReplicationSendRequestPtr</name><argument_list>(<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* request send reply */</comment>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>SendXLogData</name><argument_list>(<argument><expr><name>replication</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>==</operator> <name>Send_XlogFile_Not_Found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>out_message</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out_message</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><name>MSG_REPLICATION_CONTENT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* send the processing result status to the standby */</comment>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>, <argument><expr><name>Send_XlogFile_Not_Found</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>bytes</name> <operator>==</operator> <name>Send_Error</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>send_fail</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name>port</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>out_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>pq_flush</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>send_fail</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>==</operator> <name>Send_XlogFile_Not_Found</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>

<label><name>send_fail</name>:</label>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"send fails"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whehter there is any xlog to send
 */</comment>
<function><type><name>bool</name></type>
<name>GTM_HasXLogToSend</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>send_request</name></name> <operator>&lt;=</operator> <name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>GTM_CVTimeWait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>xlog_to_send</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>ETIMEDOUT</name></expr>)</condition>
        <block>{<block_content>
           <comment type="block">/* acquire the lastest flush ptr in case of nobody updates it. */</comment>
           <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_request</name></name> <operator>=</operator>  <call><name>GetXLogFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
           <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogSegNo</name></type>
<name>GetSegmentNo</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>ptr</name> <operator>/</operator> <name>GTM_XLOG_SEG_SIZE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Init xlog file and relative data structure */</comment>
<function><type><name>void</name></type>
<name>GTM_XLogFileInit</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>flush</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>     <name>segment_no</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>fd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>flush</name>      <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>segment_no</name> <operator>=</operator> <name>flush</name> <operator>/</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>g_GTMStoreDirtyMap</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>g_GTMStoreSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>g_GTMStoreDirtyMap</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>g_GTMStoreSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>first_init</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NewXLogFile</name><argument_list>(<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>flush</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>segment_no</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NewXLogFile</name><argument_list>(<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OpenXLogFile</name><argument_list>(<argument><expr><name>segment_no</name></expr></argument>,<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name> <operator>=</operator> <name>segment_no</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Init Xlog Ctl structure during startup */</comment>
<function><type><name>void</name></type>
<name>GTM_XLogCtlDataInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>flush</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>XLogCtl</name> <operator>=</operator> <operator>(</operator><name>XLogCtlData</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCtlData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>XLogCtl</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"memory insufficicent."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>flush</name> <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name>        <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>thisTimeLineID</name></name> <operator>=</operator> <name><name>ControlData</name><operator>-&gt;</operator><name>thisTimeLineID</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name> <operator>=</operator> <name>flush</name> <operator>/</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>flush</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>flush</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>timeline_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_gts_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_gts</name></name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name>   <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Insert section */</comment>
    <expr_stmt><expr><name>Insert</name> <operator>=</operator> <operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name><name>ControlData</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name><name>ControlData</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>g_checkpointMapperBuff</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>g_GTMStoreSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_checkpointDirtySize</name>  <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>g_GTMStoreSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_checkpointDirtyStart</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>g_GTMStoreSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name> <operator>||</operator> <name>enable_gtm_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Read ControlData CurrBytePos to %"</literal><name>PRIu64</name><literal type="string">" PrevBytePos to %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Read ControlData EndOfXLog to %X/%X PreEndOfXLog to %X/%X"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_CheckPointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Use to commit modification for mapper file */</comment>
<function><type><name>void</name></type>
<name>BeforeReplyToClientXLogTrigger</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thr</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>endPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>start_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>end_time</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ReleaseXLogRecordWriteLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>thr</name><operator>-&gt;</operator><name>register_buff</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>thr</name><operator>-&gt;</operator><name>register_buff</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseXLogRegisterBuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>getSystemTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* release thread lock ,so that we don't block GTM_StoreLock in xlog flush waiting. */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>thr</name><operator>-&gt;</operator><name>handle_standby</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thr</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>endPos</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>endPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WaitSyncComplete</name><argument_list>(<argument><expr><name>endPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>thr</name><operator>-&gt;</operator><name>handle_standby</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thr</name><operator>-&gt;</operator><name>thr_lock</name></name></expr></argument>, <argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>getSystemTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>end_time</name> <operator>-</operator> <name>start_time</name> <operator>&gt;</operator> <name>warnning_time_cost</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"BeforeReplyToClientXLogTrigger lsn %X/%X cost %lld ms"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>endPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>endPos</name></expr></argument>, <argument><expr><name>end_time</name> <operator>-</operator> <name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Read xlog file to buff */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>ReadXLogToBuff</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>xlog_path</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>thisTimeLineID</name></name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ReadXLogToBuff: Fail to open xlog %s, err_msg:%s"</literal></expr></argument>, <argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReadXLog stat file:%s failed for:%s."</literal></expr></argument>, <argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReadXLog file %s size larger than %d"</literal></expr></argument>,<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name>GTM_XLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>nbytes</name> <operator>!=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReadXLog read file %s failed for:%s."</literal></expr></argument>, <argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>nbytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* truncate xlog file to remove dirty data during crash */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TruncateXLogFile</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>,<parameter><decl><type><name>offset_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>xlog_path</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>thisTimeLineID</name></name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"TruncateXLogFile: Fail to open xlog %s, err_msg:%s"</literal></expr></argument>, <argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReadXLog stat file:%s failed for:%s."</literal></expr></argument>, <argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReadXLog file %s size larger than %d"</literal></expr></argument>,<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><name>GTM_XLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"fail to truncate file %s : %s"</literal></expr></argument>,<argument><expr><name>xlog_path</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Open mapper file which uesd in recovery */</comment>
<function><type><name>void</name></type>
<name>OpenMapperFile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>  <name><name>path</name><index>[<expr><name>NODE_STRING_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NODE_STRING_MAX_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>data_dir</name></expr></argument>, <argument><expr><name>GTM_MAP_FILE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_GTMStoreMapFile</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>GTM_MAP_FILE_NAME</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_GTMStoreMapFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"OpenMapperFile open file:%s failed for:%s exit"</literal></expr></argument>, <argument><expr><name>GTM_MAP_FILE_NAME</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"OpenMapperFile stat file:%s failed for:%s."</literal></expr></argument>, <argument><expr><name>GTM_MAP_FILE_NAME</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>!=</operator> <name>g_GTMStoreSize</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"OpenMapperFile stat file:%s size:%zu not equal required size:%zu, file maybe corrupted, try to create a new file."</literal></expr></argument>, <argument><expr><name>GTM_MAP_FILE_NAME</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>g_GTMStoreSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Close mapper file after the recovery */</comment>
<function><type><name>void</name></type>
<name>CloseMapperFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>g_GTMStoreMapFile</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>GTM_RedoerWaitForData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>current</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Redo wait for %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>pos</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while<condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>GetStandbyWriteBuffPos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>current</name> <operator>&gt;=</operator> <name>pos</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Redo finish wait for %X/%X get current pos %X/%X"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>pos</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pos</name></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name> <operator>)</operator><operator>(</operator><name>current</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>current</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name> <operator>||</operator> <call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>


    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogUsageBytesAdd</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>ori</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>bytes</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>UsableBytesInPage</name></expr></argument>,<argument><expr><name>GTM_XLOG_BLCKSZ</name> <operator>-</operator> <name>start</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>left</name> <operator>&gt;=</operator> <name>bytes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>start</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>offset</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <name>start</name> <operator>-</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>start</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"start %X/%X bytes %d Result: %X/%X"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ori</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <name>ori</name></expr></argument>,
                     <argument><expr><name>bytes</name></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>start</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>start</name></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>bytes</name> <operator>-=</operator> <name>left</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name>start</name> <operator>-</operator> <name>start</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>+</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="line">//unreachable code</comment>
    <return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recovery xlog online and apply to mapper file .
 * you have to guarantee that no dirty data given
 */</comment>
<function><type><name>void</name></type>
<name>GTM_ThreadWalRedoer_Internal</name><parameter_list>()</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xlog_buff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xlog_rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>segment_no</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>page_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>bytes_read</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>desired_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>read_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>cur_xlog_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>redo_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>redo_end_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>preXLogRecord</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>startPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>xlog_processed_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecord</name>  <modifier>*</modifier></type><name>record_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>read_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32</name></type>    <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>rec_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogPageHeaderData</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>current_buff_size</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>UsableBytesInSegment</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>xlog_buff</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>xlog_rec</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>current_buff_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>xlog_rec</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"GTM_XLogRecovery insufficient memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>fail_process</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>record_header</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name>  <operator>*</operator><operator>)</operator><name>xlog_rec</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><name>startPos</name>      <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>apply</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>segment_no</name>    <operator>=</operator> <name>startPos</name> <operator>/</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <comment type="block">/* how many bytes we currently want to read */</comment>
    <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="block">/* how many bytes we have read */</comment>
    <expr_stmt><expr><name>bytes_read</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* have we read the XLogRecord header? */</comment>
    <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* last xlog position  */</comment>
    <expr_stmt><expr><name>preXLogRecord</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <comment type="block">/* current reading  xlog record */</comment>
    <expr_stmt><expr><name>redo_pos</name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <comment type="block">/* last complete xlog record */</comment>
    <expr_stmt><expr><name>redo_end_pos</name>  <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <comment type="block">/* offset of the current reading xlog position */</comment>
    <expr_stmt><expr><name>idx</name>           <operator>=</operator> <name>startPos</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>xlog_buff</name> <operator>+=</operator> <name>idx</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"start redo thread from %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>startPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>startPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_RedoerWaitForData</name><argument_list>(<argument><expr><name>startPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>cur_xlog_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* there are still bytes to read */</comment>
        <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>xlog_processed_pos</name>  <operator>=</operator> <name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>UpdateStandbyApplyPos</name><argument_list>(<argument><expr><name>xlog_processed_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name> <operator>||</operator> <call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>cur_xlog_size</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* we wait for at least one page or bytes we desire */</comment>
                <if_stmt><if>if<condition>(<expr><name>xlog_processed_pos</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>xlog_processed_pos</name> <operator>+=</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>xlog_processed_pos</name> <operator>=</operator> <call><name>XLogPtrToNextPageHead</name><argument_list>(<argument><expr><name>xlog_processed_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/* we wait for desired bytes */</comment>
                <expr_stmt><expr><name>xlog_processed_pos</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>xlog_processed_pos</name></expr></argument>,<argument><expr><call><name>XLogUsageBytesAdd</name><argument_list>(<argument><expr><name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr></argument> ,<argument><expr><name>desired_bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>xlog_processed_pos</name> <operator>=</operator> <call><name>GTM_RedoerWaitForData</name><argument_list>(<argument><expr><name>xlog_processed_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><name>xlog_processed_pos</name>  <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>cur_xlog_size</name> <operator>=</operator> <call><name>XLogRecPtrToBuffIdx</name><argument_list>(<argument><expr><name>xlog_processed_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><call><name>GetCurrentSegmentNo</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>segment_no</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name> <operator>||</operator> <call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break ;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>read_size</name>   <operator>=</operator> <name>desired_bytes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>page_offset</name> <operator>=</operator> <name>idx</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt>

            <comment type="block">/* if we are at the head of a page,skip the page header */</comment>
            <if_stmt><if>if<condition>(<expr><name>page_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>,<argument><expr><name>xlog_buff</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>xlog_buff</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name>idx</name>       <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><name><name>header</name><operator>.</operator><name>xlp_magic</name></name> <operator>!=</operator> <name>GTM_XLOG_PAGE_MAGIC</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"xlog %X/%X page header validation fails"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* read to the end of the page if we can */</comment>
                <expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>read_size</name></expr></argument>,<argument><expr><name>UsableBytesInPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* read to the end of the page if we can */</comment>
                <expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>read_size</name></expr></argument>,<argument><expr><name>GTM_XLOG_BLCKSZ</name> <operator>-</operator> <name>page_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>read_size</name></expr></argument>,<argument><expr><name>cur_xlog_size</name> <operator>-</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* first readable byte means it's the start */</comment>
            <if_stmt><if>if<condition>(<expr><name>redo_pos</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>redo_pos</name> <operator>=</operator> <name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xlog_rec</name> <operator>+</operator> <name>rec_offset</name></expr></argument>,<argument><expr><name>xlog_buff</name></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>read_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>idx</name>           <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>xlog_buff</name>     <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>desired_bytes</name> <operator>-=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>bytes_read</name>    <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rec_offset</name>    <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>

            <comment type="block">/* we have read the XLogRecord struct */</comment>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>read_header</name> <operator>&amp;&amp;</operator> <name>bytes_read</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <comment type="block">/* update bytes we want to read */</comment>
                <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><name>desired_bytes</name> <operator>&gt;</operator> <name>current_buff_size</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_buff</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>desired_bytes</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_buff</name></expr></argument>,<argument><expr><name>xlog_rec</name></expr></argument>,<argument><expr><name>cur_xlog_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cur_xlog_size</name> <operator>=</operator> <name>desired_bytes</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xlog_rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>xlog_rec</name> <operator>=</operator> <name>new_buff</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %X/%X get size %lu"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,<argument><expr><name>desired_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* we have finish read the current xlog record */</comment>
            <if_stmt><if>if<condition>(<expr><name>desired_bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* compose crc */</comment>
                <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>xlog_rec</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>record_header</name></expr></argument>,<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>,<argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>redo_pos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* validate */</comment>
                <if_stmt><if>if<condition>(<expr><name>crc</name> <operator>!=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_crc</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %X/%X crc validation fails cal:%u recorded: %u"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,<argument><expr><name>crc</name></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><name>preXLogRecord</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>preXLogRecord</name> <operator>!=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_prev</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %X/%X validation prelink fails should be %X/%X ,"</literal>
                                 <literal type="string">"but read %X/%X"</literal></expr></argument>
                            ,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>
                            ,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>preXLogRecord</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>preXLogRecord</name><operator>)</operator></expr></argument>
                            ,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>record_header</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>record_header</name><operator>-&gt;</operator><name>xl_prev</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Recovery xlog at position %X/%X with pre %X/%X"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,
                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>preXLogRecord</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>preXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>RedoXLogRecord</name><argument_list>(<argument><expr><name>record_header</name></expr></argument>,<argument><expr><name>redo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* calculate the end of current xlog */</comment>
                <expr_stmt><expr><name>redo_end_pos</name>  <operator>=</operator> <name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

                <comment type="block">/* clear to read next xlog record */</comment>
                <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name>bytes_read</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>preXLogRecord</name> <operator>=</operator> <name>redo_pos</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>redo_pos</name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rec_offset</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name> <operator>=</operator> <call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><name>redo_end_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name> <operator>=</operator> <call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><name>preXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if<condition>(<expr><name>GTM_SHUTTING_DOWN</name> <operator>==</operator> <name><name>GTMTransactions</name><operator>.</operator><name>gt_gtm_state</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"redoer shutting down"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* if we promote a slave ,we first do checkpoint ,so it must reach here */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"promote slave,redo thread finish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>segment_no</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>xlog_buff</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>redo_end_pos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"redo exit,recovery finish upto %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_end_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument> ,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_end_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"XLogRecovery to CurrBytePos to %"</literal><name>PRIu64</name><literal type="string">" PrevBytePos to %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"XLogRecovery to EndOfXLog to %X/%X PreEndOfXLog to %X/%X"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name> <operator>=</operator> <name>segment_no</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>last_write_idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>redo_end_pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>redo_end_pos</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>xlog_rec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xlog_rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_GTMStoreSize</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>g_GTMStoreDirtyMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DoSlaveCheckPoint</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DoCheckPoint</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return ;</return>

    <label><name>fail_process</name>:</label>

    <if_stmt><if>if<condition>(<expr><name>xlog_rec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xlog_rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"gtm recovery fails"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>GTM_RecoveryUpdateMetaData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_end_pos</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>preXLogRecord</name></decl></parameter>,<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>redo_end_pos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"recovery finish upto %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_end_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument> ,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_end_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>redo_end_pos</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"recovery fails"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>TruncateXLogFile</name><argument_list>(<argument><expr><name>segment_no</name></expr></argument>,<argument><expr><name>redo_end_pos</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        
    <comment type="block">/* update byte pos */</comment>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name> <operator>=</operator> <call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><name>redo_end_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name> <operator>=</operator> <call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><name>preXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"XLogRecovery to CurrBytePos to %"</literal><name>PRIu64</name><literal type="string">" PrevBytePos to %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"XLogRecovery to EndOfXLog to %X/%X PreEndOfXLog to %X/%X"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name> <operator>=</operator> <name>segment_no</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>last_write_idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>redo_end_pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>redo_end_pos</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>prevCheckPoint</name></name> <operator>=</operator> <name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name>     <operator>=</operator> <name>preXLogRecord</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>

    <return>return ;</return>
</block_content>}</block></function>

<comment type="block">/* Recovery Xlog and apply to mapper file */</comment>
<function><type><name>void</name></type>
<name>GTM_XLogRecovery</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>startPos</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xlog_buff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xlog_rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>segment_no</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>page_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>bytes_read</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>desired_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>read_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type>     <name>cur_xlog_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>redo_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>redo_end_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>preXLogRecord</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecord</name>  <modifier>*</modifier></type><name>record_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>read_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32</name></type>    <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>rec_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogPageHeaderData</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_error</name>       <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>validate_mode</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>validate_count</name> <init>= <expr><name>GTM_XLOG_RECOVERY_GTS_VALIDATE_NUM</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>last_validate_gts</name> <init>= <expr><name>InvalidGTS</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* return if no xlog when firstly inited */</comment>
    <if_stmt><if>if<condition>(<expr><name>startPos</name> <operator>==</operator> <name>FIRST_XLOG_REC</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>xlog_buff</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"start recovery from %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>startPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>startPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OpenMapperFile</name><argument_list>(<argument><expr><name>data_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* One record must not larger then UsableBytesInSegment */</comment>
    <expr_stmt><expr><name>xlog_rec</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>UsableBytesInSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>xlog_rec</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"GTM_XLogRecovery insufficient memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit_process</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>record_header</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name>  <operator>*</operator><operator>)</operator><name>xlog_rec</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>segment_no</name>    <operator>=</operator> <name>startPos</name> <operator>/</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>cur_xlog_size</name> <operator>=</operator> <call><name>ReadXLogToBuff</name><argument_list>(<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>cur_xlog_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>exit_process</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* how many bytes we currently want to read */</comment>
    <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="block">/* how many bytes we have read */</comment>
    <expr_stmt><expr><name>bytes_read</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* have we read the XLogRecord header? */</comment>
    <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* last xlog postion  */</comment>
    <expr_stmt><expr><name>preXLogRecord</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <comment type="block">/* current reading  xlog record */</comment>
    <expr_stmt><expr><name>redo_pos</name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <comment type="block">/* last complete xlog recored */</comment>
    <expr_stmt><expr><name>redo_end_pos</name>  <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <comment type="block">/* offset of the current reading xlog position */</comment>
    <expr_stmt><expr><name>idx</name>           <operator>=</operator> <name>startPos</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>xlog_buff</name> <operator>+=</operator> <name>idx</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>g_recovery_finish</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* there are still bytes to read */</comment>
        <while>while<condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>cur_xlog_size</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>read_size</name>   <operator>=</operator> <name>desired_bytes</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>page_offset</name> <operator>=</operator> <name>idx</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt>

            <comment type="block">/* if we are at the head of a page,skip the page header */</comment>
            <if_stmt><if>if<condition>(<expr><name>page_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>,<argument><expr><name>xlog_buff</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>xlog_buff</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name>idx</name>       <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><name><name>header</name><operator>.</operator><name>xlp_magic</name></name> <operator>!=</operator> <name>GTM_XLOG_PAGE_MAGIC</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %X/%X page header validation fails"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>has_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* read to the end of the page if we can */</comment>
                <expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>read_size</name></expr></argument>,<argument><expr><name>UsableBytesInPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* read to the end of the page if we can */</comment>
                <expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>read_size</name></expr></argument>,<argument><expr><name>GTM_XLOG_BLCKSZ</name> <operator>-</operator> <name>page_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* first readable byte means it's the start */</comment>
            <if_stmt><if>if<condition>(<expr><name>redo_pos</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>redo_pos</name> <operator>=</operator> <name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xlog_rec</name> <operator>+</operator> <name>rec_offset</name></expr></argument>,<argument><expr><name>xlog_buff</name></expr></argument>,<argument><expr><name>read_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>idx</name>            <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>xlog_buff</name>      <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>desired_bytes</name> <operator>-=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>bytes_read</name>     <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rec_offset</name>     <operator>+=</operator> <name>read_size</name></expr>;</expr_stmt>

            <comment type="block">/* we have read the XLogRecord struct */</comment>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>read_header</name> <operator>&amp;&amp;</operator> <name>bytes_read</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <comment type="block">/* update bytes we want to read */</comment>
                <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* we have finish read the current xlog record */</comment>
            <if_stmt><if>if<condition>(<expr><name>desired_bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* compose crc */</comment>
                <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>xlog_rec</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>record_header</name></expr></argument>,<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>,<argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>redo_pos</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Recovey xlog at position %X/%X with pre %X/%X length %u "</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,
                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>preXLogRecord</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>preXLogRecord</name></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* validate */</comment>
                <if_stmt><if>if<condition>(<expr><name>crc</name> <operator>!=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_crc</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %X/%X crc validation fails cal:%u recorded: %u"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,<argument><expr><name>crc</name></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>has_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><name>preXLogRecord</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>preXLogRecord</name> <operator>!=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_prev</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %X/%X validation prelink fails"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>has_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><name>validate_mode</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>last_validate_gts</name> <operator>&gt;</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,<argument><expr><literal type="string">"gts reverse in recovery founded from %ld to %ld at %X/%X"</literal></expr></argument>,
                            <argument><expr><name>last_validate_gts</name></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>last_validate_gts</name> <operator>=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"validate xlog at %X/%X has gts %ld"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>redo_pos</name></expr></argument>,<argument><expr><name><name>record_header</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>validate_count</name><operator>--</operator></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><name>validate_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>exit_process</name>;</goto></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>RedoXLogRecord</name><argument_list>(<argument><expr><name>record_header</name></expr></argument>,<argument><expr><name>redo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><name>g_recovery_finish</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>GTM_RecoveryUpdateMetaData</name><argument_list>(<argument><expr><name>redo_end_pos</name></expr></argument>,<argument><expr><name>preXLogRecord</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>validate_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>last_validate_gts</name> <operator>=</operator> <name><name>record_header</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* calculate the end of current xlog */</comment>
                <expr_stmt><expr><name>redo_end_pos</name>  <operator>=</operator> <name>segment_no</name> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

                <comment type="block">/* clear to read next xlog record */</comment>
                <expr_stmt><expr><name>desired_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name>bytes_read</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>read_header</name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>preXLogRecord</name> <operator>=</operator> <name>redo_pos</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>redo_pos</name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rec_offset</name>    <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><name>cur_xlog_size</name> <operator>=</operator> <call><name>ReadXLogToBuff</name><argument_list>(<argument><expr><name>segment_no</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>cur_xlog_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//crash recovery to the end of file</comment>
            <if_stmt><if>if<condition>(<expr><name>recovery_timestamp</name> <operator>==</operator> <name>InvalidGTS</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GTM_RecoveryUpdateMetaData</name><argument_list>(<argument><expr><name>redo_end_pos</name></expr></argument>,<argument><expr><name>preXLogRecord</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>g_recovery_finish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>exit_process</name>;</goto>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name>has_error</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Recovery ends with an error,probably a bug"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>segment_no</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>xlog_buff</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

<label><name>exit_process</name>:</label>

    <expr_stmt><expr><call><name>CloseMapperFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>xlog_rec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xlog_rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>g_recovery_finish</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>validate_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,<argument><expr><literal type="string">"gtm recovery finished, but due to lack of xlog,validation could not complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return ;</return>
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"gtm recovery fails"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GTM_PrintControlData</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData context:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;gtm_control_version    = %d"</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>gtm_control_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;xlog_seg_size          = %d"</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_seg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;xlog_blcksz            = %d"</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_blcksz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;state                  = %d"</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;CurrBytePos            = %"</literal><name>PRIu64</name></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;PrevBytePos            = %"</literal><name>PRIu64</name></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;thisTimeLineID         = %d"</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>thisTimeLineID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;prevCheckPoint         = %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>ControlData</name><operator>-&gt;</operator><name>prevCheckPoint</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ControlData</name><operator>-&gt;</operator><name>prevCheckPoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;checkPoint             = %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;gts                    = %lu"</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>gts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ControlData-&gt;time                   = %lu"</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Init ControlData during startup */</comment>
<function><type><name>int</name></type>
<name>GTM_ControlDataInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32</name></type> <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type> <name>nbytes</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>g_GTMControlDataSize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlDataLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlData</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ControlData</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>g_GTMControlDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ControlData</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit control file:%s failed for:%s."</literal></expr></argument>, <argument><expr><name>GTM_CONTROL_FILE</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>GTM_STORE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>GTM_CONTROL_FILE</name></expr></argument>,<argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* it means the first time we start gtm */</comment>
    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>gtm_control_version</name></name> <operator>=</operator> <name>GTM_CONTROL_VERSION</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_seg_size</name></name>       <operator>=</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_blcksz</name></name>         <operator>=</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>state</name></name>               <operator>=</operator> <name>DB_SHUTDOWNED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>CurrBytePos</name></name>         <operator>=</operator> <name>FIRST_USABLE_BYTE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>PrevBytePos</name></name>         <operator>=</operator> <name>FIRST_USABLE_BYTE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>thisTimeLineID</name></name>      <operator>=</operator> <name>FIRST_TIMELINE_ID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>prevCheckPoint</name></name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name>          <operator>=</operator> <name>FIRST_XLOG_REC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>gts</name></name>                 <operator>=</operator> <name>FirstGlobalTimestamp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>time</name></name>                <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ControlDataSync</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>first_init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit stat file:%s failed for:%s."</literal></expr></argument>, <argument><expr><name>GTM_CONTROL_FILE</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>GTM_STORE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>!=</operator> <name>g_GTMControlDataSize</name> <operator>&amp;&amp;</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>!=</operator> <literal type="number">80</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit stat file:%s size:%zu not equal required size:%zu, file maybe corrupted, try to create a new file."</literal></expr></argument>, <argument><expr><name>GTM_CONTROL_FILE</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>g_GTMControlDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>GTM_STORE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ControlData</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit read file:%s failed for:%s, reqiured size:%zu, read size:%zu."</literal></expr></argument>, <argument><expr><name>GTM_CONTROL_FILE</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>g_GTMControlDataSize</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fail_process</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>ControlData</name></expr></argument>,<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>,<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>ControlData</name><operator>-&gt;</operator><name>crc</name></name> <operator>!=</operator> <name>crc</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit crc validate fails (recorded: %u file: %u) ."</literal></expr></argument>, <argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>,<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fail_process</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_seg_size</name></name> <operator>!=</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit GTM_XLOG_SEG_SIZE validate fails (recorded: %u file: %u) ."</literal></expr></argument>, <argument><expr><name>GTM_XLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_seg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fail_process</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_blcksz</name></name> <operator>!=</operator> <name>GTM_XLOG_BLCKSZ</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit GTM_XLOG_BLCKSZ validate fails (recorded: %u file: %u) ."</literal></expr></argument>,<argument><expr><name>GTM_XLOG_BLCKSZ</name></expr></argument>, <argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>xlog_blcksz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fail_process</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>ControlData</name><operator>-&gt;</operator><name>gtm_control_version</name></name> <operator>!=</operator> <name>GTM_CONTROL_VERSION</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"GTM_ControlDataInit gtm_control_version validate fails (recorded: %d file: %d) ."</literal></expr></argument>,<argument><expr><name>GTM_CONTROL_VERSION</name></expr></argument>, <argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>gtm_control_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fail_process</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>first_init</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>GTM_PrintControlData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>GTM_STORE_OK</name></expr>;</return>

    <label><name>fail_process</name>:</label>
    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ControlData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>GTM_STORE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* sync control data to disk */</comment>
<function><type><name>void</name></type>
<name>ControlDataSync</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>update_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nbyte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32</name></type> <name>crc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>update_time</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>time</name></name>  <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>gts</name></name>   <operator>=</operator> <call><name>GetNextGlobalTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,<argument><expr><name>ControlData</name></expr></argument>,<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>,<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <name>crc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>GTM_CONTROL_FILE_TMP</name></expr></argument>,<argument><expr><name>O_WRONLY</name><operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ControlDataSync: fail to open file %s, err_msg %s"</literal></expr></argument>, <argument><expr><name>GTM_CONTROL_FILE_TMP</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nbyte</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ControlData</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>nbyte</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"write control data fails"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rename</name><argument_list>(<argument><expr><name>GTM_CONTROL_FILE_TMP</name></expr></argument>,<argument><expr><name>GTM_CONTROL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"rename control data file fails"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ControlDataSync ok current_bytes: %"</literal><name>PRIu64</name><literal type="string">" pre_bytes %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>ControlData</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>strip</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name><name>s</name><index>[<expr><name>head</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isblank</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>head</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>head</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>head</name> <operator>==</operator> <name>len</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <return>return <expr><name>s</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>tail</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>tail</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isblank</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>tail</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tail</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <name>head</name></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>tail</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>s</name><index>[<expr><name>p</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name><name>s</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_contain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <while>while<condition>(<expr><operator>*</operator><name>pattern</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pattern</name> <operator>!=</operator> <name>ch</name></expr>)</condition>
   <block>{<block_content>
        <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
   </block_content>}</block></while>

    <return>return <expr><operator>*</operator><name>pattern</name> <operator>==</operator> <name>ch</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_to_next</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while<condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>is_contain</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
       <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>start_with_ignore_case</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>pattern</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>toupper</name><argument_list>(<argument><expr><name><name>pattern</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>toupper</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name><name>pattern</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Init sync replication data */</comment>
<function><type><name>void</name></type>
<name>GTM_StandbyBaseinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>init_sync_structures</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>load_sync_structures</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Print xlog command for debug */</comment>
<function><type><name>uint32</name></type>
<name>PrintRedoRangeOverwrite</name><parameter_list>(<parameter><decl><type><name>XLogCmdRangerOverWrite</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"RangeOverwrite %d %d"</literal></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdRangerOverWrite</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32</name></type>
<name>PrintRedoCheckPoint</name><parameter_list>(<parameter><decl><type><name>XLogCmdCheckPoint</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"PrintRedoCheckPoint %"</literal><name>PRIu64</name><literal type="string">" "</literal></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>gts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdCheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32</name></type>
<name>PrintRedoTimestamp</name><parameter_list>(<parameter><decl><type><name>XLogRecGts</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"PrintRedoCheckPoint %"</literal><name>PRIu64</name><literal type="string">" "</literal></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>gts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdCheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Redo relative xlog command */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>RedoRangeOverwrite</name><parameter_list>(<parameter><decl><type><name>XLogCmdRangerOverWrite</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PrintRedoRangeOverwrite</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>recovery_pitr_mode</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>promote_status</name> <operator>==</operator> <name>GTM_PRPMOTE_NORMAL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>g_GTMStoreMapAddr</name> <operator>+</operator> <name><name>cmd</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GTMControlHeader</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SetNextGlobalTimestamp</name><argument_list>(<argument><expr><name><name>g_GTM_Store_Header</name><operator>-&gt;</operator><name>m_next_gts</name></name> <operator>+</operator> <name>GTM_GTS_ONE_SECOND</name> <operator>*</operator> <name>GTMStartupGTSDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"redo header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>GTM_PrintControlHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not seek map file for: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name> <operator>!=</operator> <name>nbytes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write map for: %s, required bytes:%d, return bytes:%zu"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdRangerOverWrite</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>RedoCheckPoint</name><parameter_list>(<parameter><decl><type><name>XLogCmdCheckPoint</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PrintRedoCheckPoint</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SetCurrentTimeLineID</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>recovery_pitr_mode</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>promote_status</name> <operator>==</operator> <name>GTM_PRPMOTE_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DoCheckPoint</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdCheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>RedoTimestamp</name><parameter_list>(<parameter><decl><type><name>XLogRecGts</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PrintRedoTimestamp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecGts</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Redo one xlog record */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RedoXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>cmd_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCmdHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>GlobalTimestamp</name></type> <name>last_timestamp</name> <init>= <expr><name>InvalidGTS</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>recovery_timestamp</name> <operator>!=</operator> <name>InvalidGTS</name> <operator>&amp;&amp;</operator>  <name><name>rec</name><operator>-&gt;</operator><name>xl_timestamp</name></name> <operator>&gt;</operator> <name>recovery_timestamp</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"recovery finish upto gts: %ld"</literal></expr></argument>,<argument><expr><name>last_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>g_recovery_finish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>last_timestamp</name> <operator>&gt;</operator> <name><name>rec</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,<argument><expr><literal type="string">"timestamp reverse in recovery from %lu to %lu"</literal></expr></argument>,<argument><expr><name>last_timestamp</name></expr></argument>,<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"recovery timestamp %lu"</literal></expr></argument>,<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>last_timestamp</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rec</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>XLogCmdHeader</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>XLOG_CMD_RANGE_OVERWRITE</name></expr>:</case>
                <expr_stmt><expr><name>cmd_size</name> <operator>=</operator> <call><name>RedoRangeOverwrite</name><argument_list>(<argument><expr><operator>(</operator><name>XLogCmdRangerOverWrite</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>XLOG_CMD_CHECK_POINT</name></expr>:</case>
                <expr_stmt><expr><name>cmd_size</name> <operator>=</operator> <call><name>RedoCheckPoint</name><argument_list>(<argument><expr><operator>(</operator><name>XLogCmdCheckPoint</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>,<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>XLOG_REC_GTS</name></expr>:</case>
                <expr_stmt><expr><name>cmd_size</name> <operator>=</operator> <call><name>RedoTimestamp</name><argument_list>(<argument><expr><operator>(</operator><name>XLogRecGts</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unrecognize xlog command type %d"</literal></expr></argument>,<argument><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <expr_stmt><expr><name>len</name>  <operator>-=</operator> <name>cmd_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>cmd_size</name></expr>;</expr_stmt>
    </block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DoCheckPoint</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_CheckPointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DoSlaveCheckPoint</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DoMasterCheckPoint</name><argument_list>(<argument><expr><name>shutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_CheckPointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DoSlaveCheckPoint</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>write_check_point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>flush_ptr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>flush_ptr</name> <operator>=</operator> <call><name>GetStandbyWriteBuffPos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not seek map file for: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>, <argument><expr><name>g_GTMStoreMapAddr</name></expr></argument>, <argument><expr><name>g_GTMStoreSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_GTMStoreSize</name> <operator>!=</operator> <name>nbytes</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write map for: %s, required bytes:%d, return bytes:%d"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"couldn't sync file %s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>write_check_point</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlDataLock</name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>prevCheckPoint</name></name>  <operator>=</operator> <name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name>      <operator>=</operator> <name>flush_ptr</name> <operator>-</operator> <name>flush_ptr</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr> ;</expr_stmt>  <comment type="line">// point to the head of segment</comment>

        <expr_stmt><expr><call><name>ControlDataSync</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlDataLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Do checkpoint */</comment>
<function><type><name>void</name></type>
<name>DoMasterCheckPoint</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>write_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>flush_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Start to dump checkpoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* lock all the write of mapper file */</comment>
    <expr_stmt><expr><call><name>GTM_StoreLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>WALInsertLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we lock header lock here ,because we want to shorten the interval of header lock holding */</comment>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><name>g_GTM_Store_Head_Lock</name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>g_checkpointMapperBuff</name></expr></argument>,<argument><expr><name>g_GTMStoreMapAddr</name></expr></argument>,<argument><expr><name>g_GTMStoreSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_GTMStoreSize</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <while>while<condition>(<expr><name>i</name> <operator>&lt;</operator> <name>g_GTMStoreSize</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>g_GTMStoreDirtyMap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

        <expr_stmt><expr><name>write_start</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>i</name> <operator>==</operator> <name>g_GTMStoreSize</name></expr> )</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>i</name> <operator>&lt;</operator> <name>g_GTMStoreSize</name> <operator>&amp;&amp;</operator> <name><name>g_GTMStoreDirtyMap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_GTMStoreDirtyMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><name><name>g_checkpointDirtySize</name><index>[<expr><name>idx</name></expr>]</index></name>    <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_checkpointDirtyStart</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>write_start</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>XLogRegisterCheckPoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* checkpoint command always starts at the beginning of xlog */</comment>
    <expr_stmt><expr><call><name>SwitchXLogFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* insert checkpoint record to the xlog */</comment>
    <expr_stmt><expr><name>flush_ptr</name> <operator>=</operator> <call><name>XLogCheckPointInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we are about to shutdown then we hold the lock to the end */</comment>
    <comment type="block">/* in case of there are someone still writes */</comment>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>shutdown</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><name>g_GTM_Store_Head_Lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_StoreUnLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* writes all dirty section */</comment>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>idx</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>write_start</name> <operator>=</operator> <name><name>g_checkpointDirtyStart</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name>        <operator>=</operator> <name><name>g_checkpointDirtySize</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>, <argument><expr><name>write_start</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>write_start</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not seek map file for: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>, <argument><expr><name>g_checkpointMapperBuff</name> <operator>+</operator> <name>write_start</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>nbytes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write map for: %s, required bytes:%d, return bytes:%d"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>g_GTMStoreMapFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not fsync map file for: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseXLogInsertLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>flush_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* save checkpoint position to ControlData */</comment>
    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlDataLock</name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>thisTimeLineID</name></name> <operator>=</operator> <call><name>GetCurrentTimeLineID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>prevCheckPoint</name></name> <operator>=</operator> <name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>checkPoint</name></name>      <operator>=</operator> <name>flush_ptr</name> <operator>-</operator> <name>flush_ptr</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr> ;</expr_stmt>  <comment type="line">// point to the head of segment</comment>

    <expr_stmt><expr><call><name>ControlDataSync</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Checkpoint done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlDataLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* wait until all the xlog before upto to copy to the buff */</comment>
<comment type="block">/* and returns the last xlog positon that we can flush */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>WaitXLogInsertionsToFinish</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>upto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>bytepos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>reservedUpto</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>finishedUpto</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogInsertLock</name> <modifier>*</modifier></type><name>XLogInsertLocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCtlInsert</name>  <modifier>*</modifier></type><name>Insert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>      <name>insertingat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lock_id</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>XLogInsertLocks</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Insert</name> <operator>=</operator> <operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr>;</expr_stmt>

    <comment type="block">/* Read the current insert position */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reservedUpto</name> <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop through all the locks, sleeping on any in-progress insert older
     * than 'upto'.
     *
     * finishedUpto is our return value, indicating the point upto which all
     * the WAL insertions have been finished. Initialize it to the head of
     * reserved WAL, and as we iterate through the insertion locks, back it
     * out for any insertion that's still in progress.
     */</comment>
    <expr_stmt><expr><name>finishedUpto</name> <operator>=</operator> <name>reservedUpto</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>lock_id</name> <operator>=</operator> <name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>i</name> <operator>==</operator> <name>lock_id</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>insertingat</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

        <do>do
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>GTM_MutexLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>insertingat</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>insertingat</name> <operator>=</operator> <name><name>XLogInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block> while <condition>(<expr><name>insertingat</name> <operator>&lt;</operator> <name>upto</name></expr>)</condition>;</do>

        <if_stmt><if>if <condition>(<expr><name>insertingat</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>insertingat</name> <operator>&lt;</operator> <name>finishedUpto</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insertingat</name> <operator>&gt;=</operator> <name>upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>finishedUpto</name> <operator>=</operator> <name>insertingat</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* we can only flush to the end of the segment at most*/</comment>
    <if_stmt><if>if<condition>(<expr><call><name>GetSegmentNo</name><argument_list>(<argument><expr><name>finishedUpto</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>GetSegmentNo</name><argument_list>(<argument><expr><name>upto</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>upto</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>finishedUpto</name> <operator>&gt;=</operator> <name>upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>finishedUpto</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an "usable byte position" to the start of XLogRecPtr.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogBytePosToStartRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>byte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>page_offset</name> <init>= <expr><name>byte</name> <operator>%</operator> <name>UsableBytesInPage</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><name>byte</name> <operator>/</operator> <name>UsableBytesInPage</name><operator>)</operator> <operator>*</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>+</operator> <name>page_offset</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>page_offset</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator></expr>;</return><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an "usable byte position" to the end of XLogRecPtr.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogBytePosToEndRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>byte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>page_offset</name> <init>= <expr><name>byte</name> <operator>%</operator> <name>UsableBytesInPage</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><name>byte</name> <operator>/</operator> <name>UsableBytesInPage</name><operator>)</operator> <operator>*</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>+</operator> <name>page_offset</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>page_offset</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an XLogRecPtr to an "usable byte position".
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>XLogRecPtrToBytePos</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>page_offset</name> <init>= <expr><name>ptr</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>page_offset</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>ptr</name> <operator>/</operator> <name>GTM_XLOG_BLCKSZ</name><operator>)</operator> <operator>*</operator> <name>UsableBytesInPage</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>ptr</name> <operator>/</operator> <name>GTM_XLOG_BLCKSZ</name><operator>)</operator> <operator>*</operator> <name>UsableBytesInPage</name> <operator>+</operator> <name>page_offset</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an XLogRecPtr to a offset in segment.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>XLogRecPtrToBuffIdx</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>ptr</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>XLogRecPtrToFileOffset</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>ptr</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Begin constructing a WAL record. This must be called before the
 * XLogRegister* functions and XLogInsert().
 * regiseter_buff will be freed in writer thread.
 */</comment>
<function><type><name>void</name></type>
<name>XLogBeginInsert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thr</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>registered_buffer</name></decl>;</decl_stmt>

    <comment type="line">//ReleaseXLogRegisterBuff();</comment>

    <expr_stmt><expr><name>registered_buffer</name> <operator>=</operator> <operator>(</operator><name>XLogRegisterBuff</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRegisterBuff</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>registered_buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>registered_buffer</name><operator>-&gt;</operator><name>rdata_head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>registered_buffer</name><operator>-&gt;</operator><name>rdata_rear</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>registered_buffer</name><operator>-&gt;</operator><name>rdata_len</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>thr</name><operator>-&gt;</operator><name>register_buff</name></name> <operator>=</operator> <name>registered_buffer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Init xlog command header 
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitXLogCmdHeader</name><parameter_list>(<parameter><decl><type><name>XLogCmdHeader</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,<parameter><decl><type><name>uint32</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendXLogRegisterBuff</name><parameter_list>(<parameter><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>,<parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>+=</operator> <name><name>data</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>buff</name><operator>-&gt;</operator><name>rdata_head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>rdata_head</name></name> <operator>=</operator> <name><name>buff</name><operator>-&gt;</operator><name>rdata_rear</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>rdata_rear</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>rdata_rear</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a overwrite action with specific range in map file with the WAL record being constructed.
 * This must be called for any map file modification.
 */</comment>
<function><type><name>void</name></type>
<name>XLogRegisterRangeOverwrite</name><parameter_list>(<parameter><decl><type><name>offset_t</name></type> <name>offset</name></decl></parameter>,
                           <parameter><decl><type><name>int32_t</name></type> <name>len</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rec_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCmdRangerOverWrite</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>reg_buff</name> <init>= <expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rec_data</name> <operator>=</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>rec_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <operator>(</operator><name>XLogCmdRangerOverWrite</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdRangerOverWrite</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>bytes</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InitXLogCmdHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>,<argument><expr><name>XLOG_CMD_RANGE_OVERWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rec_data</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_data</name><operator>-&gt;</operator><name>len</name></name>  <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdRangerOverWrite</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AppendXLogRegisterBuff</name><argument_list>(<argument><expr><name>reg_buff</name></expr></argument>,<argument><expr><name>rec_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"%lu %d"</literal></expr></argument>,<argument><expr><name>offset</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>len</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_GTMStoreDirtyMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

</block_content>}</block></function>

<comment type="block">/*
 * Register a overwrite action with specific range in map file with the WAL record being constructed.
 * This must be called for any map file modification.
 */</comment>
<function><type><name>void</name></type>
<name>XLogRegisterCheckPoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rec_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCmdCheckPoint</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>reg_buff</name> <init>= <expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rec_data</name> <operator>=</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>rec_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <operator>(</operator><name>XLogCmdCheckPoint</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdCheckPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>InitXLogCmdHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>,<argument><expr><name>XLOG_CMD_CHECK_POINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>gts</name></name>      <operator>=</operator> <call><name>GetNextGlobalTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name> <operator>=</operator> <call><name>GetCurrentTimeLineID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>time</name></name>     <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rec_data</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_data</name><operator>-&gt;</operator><name>len</name></name>  <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogCmdCheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AppendXLogRegisterBuff</name><argument_list>(<argument><expr><name>reg_buff</name></expr></argument>,<argument><expr><name>rec_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a overwrite action with specific range in map file with the WAL record being constructed.
 * This must be called for any map file modification.
 */</comment>
<function><type><name>void</name></type>
<name>XLogRegisterTimeStamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rec_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecGts</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>reg_buff</name> <init>= <expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rec_data</name> <operator>=</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>rec_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <operator>(</operator><name>XLogRecGts</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecGts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>InitXLogCmdHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>,<argument><expr><name>XLOG_REC_GTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>gts</name></name>       <operator>=</operator> <call><name>GetNextGlobalTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rec_data</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec_data</name><operator>-&gt;</operator><name>len</name></name>  <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecGts</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AppendXLogRegisterBuff</name><argument_list>(<argument><expr><name>reg_buff</name></expr></argument>,<argument><expr><name>rec_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogSegmentGtsMaxUpdate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>raw_xlog_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator><name>raw_xlog_data</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_timestamp</name></name> <operator>!=</operator> <name>InvalidGTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_gts_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_gts</name></name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr>)</condition>
    <block>{<block_content>   
        <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_gts</name></name>        <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_timestamp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_timestamp</name></name>  <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_time</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_gts_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * insert xlog checkpoint record into xlog
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogCheckPointInsert</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data_with_pageheader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>startbytepos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>endbytepos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>prevbytepos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>size</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>byte_left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>StartPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>EndPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>reg_buff</name> <init>= <expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reg_buff</name> <operator>&amp;&amp;</operator> <name><name>reg_buff</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>reg_buff</name><operator>-&gt;</operator><name>rdata_len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogAssemble</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The duration the spinlock needs to be held is minimized by minimizing
     * the calculations that have to be done while holding the lock. The
     * current tip of reserved WAL is kept in CurrBytePos, as a byte position
     * that only counts "usable" bytes in WAL, that is, it excludes all WAL
     * page headers. The mapping between "usable" byte positions and physical
     * positions (XLogRecPtrs) can be done outside the locked region, and
     * because the usable byte position doesn't include any headers, reserving
     * X bytes from WAL is almost as simple as "CurrBytePos += X".
     */</comment>
    <expr_stmt><expr><name>rec</name>  <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Begin byte size %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>byte_left</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>%</operator> <name>UsableBytesInSegment</name></expr>;</expr_stmt>
    

    <if_stmt><if>if<condition>(<expr><name>byte_left</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>startbytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>endbytepos</name>   <operator>=</operator> <name>startbytepos</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prevbytepos</name>  <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name>endbytepos</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name>startbytepos</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>startbytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>-</operator> <name>byte_left</name> <operator>+</operator> <name>UsableBytesInSegment</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>endbytepos</name>   <operator>=</operator> <name>startbytepos</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prevbytepos</name>  <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name>endbytepos</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name>startbytepos</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_timestamp</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_gts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_time</name></name>      <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"End byte size %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>StartPos</name> <operator>=</operator> <call><name>XLogBytePosToStartRecPtr</name><argument_list>(<argument><expr><name>startbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>EndPos</name>   <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>endbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UpdateInsertInfo</name><argument_list>(<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>=</operator> <call><name>XLogBytePosToStartRecPtr</name><argument_list>(<argument><expr><name>prevbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/* Finish crc calculation */</comment>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>, <argument><expr><name>rec</name></expr></argument>,<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"StartPos: %X/%X Prelink: %X/%X Size:%d crc:%u"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>StartPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>StartPos</name></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
             <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>,
             <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>XLogSegmentGtsMaxUpdate</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get xlog record with page header added */</comment>
    <expr_stmt><expr><name>data_with_pageheader</name> <operator>=</operator> <call><name>XLogDataAddPageHeader</name><argument_list>(<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* copy xlog record to xlog buff */</comment>
    <expr_stmt><expr><call><name>CopyXLogRecordToBuff</name><argument_list>(<argument><expr><name>data_with_pageheader</name></expr></argument>,<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>EndPos</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseXLogRegisterBuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data_with_pageheader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"return %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>EndPos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseXLogRecordWriteLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thr</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl> ;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>thr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>thr</name><operator>-&gt;</operator><name>xlog_inserting</name></name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>thr</name><operator>-&gt;</operator><name>xlog_inserting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>thr</name><operator>-&gt;</operator><name>current_write_number</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>

        <if_stmt><if>if<condition>(<expr><name><name>thr</name><operator>-&gt;</operator><name>write_counters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><name><name>thr</name><operator>-&gt;</operator><name>write_locks_hold</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if<condition>(<expr><name><name>thr</name><operator>-&gt;</operator><name>write_counters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,<argument><expr><literal type="string">"write counts too many"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>thr</name><operator>-&gt;</operator><name>current_write_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a xlog record into xlog buff 
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XLogInsert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data_with_pageheader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>startbytepos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>endbytepos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>prevbytepos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>size</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecord</name>    <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>StartPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>EndPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>reg_buff</name> <init>= <expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reg_buff</name> <operator>&amp;&amp;</operator> <name><name>reg_buff</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>reg_buff</name><operator>-&gt;</operator><name>rdata_len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogAssemble</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>WALInsertLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The duration the spinlock needs to be held is minimized by minimizing
     * the calculations that have to be done while holding the lock. The
     * current tip of reserved WAL is kept in CurrBytePos, as a byte position
     * that only counts "usable" bytes in WAL, that is, it excludes all WAL
     * page headers. The mapping between "usable" byte positions and physical
     * positions (XLogRecPtrs) can be done outside the locked region, and
     * because the usable byte position doesn't include any headers, reserving
     * X bytes from WAL is almost as simple as "CurrBytePos += X".
     */</comment>
    <expr_stmt><expr><name>rec</name>  <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Begin byte size %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>startbytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endbytepos</name>   <operator>=</operator> <name>startbytepos</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prevbytepos</name>  <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name>endbytepos</name></expr>  ;</expr_stmt>
    <expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name>startbytepos</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_timestamp</name></name> <operator>=</operator> <call><name>GetNextGlobalTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_time</name></name>      <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"End byte size %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">" %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>,<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>StartPos</name> <operator>=</operator> <call><name>XLogBytePosToStartRecPtr</name><argument_list>(<argument><expr><name>startbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>EndPos</name>   <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>endbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>StartPos</name> <operator>+</operator> <name>size</name> <operator>&lt;=</operator> <name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UpdateInsertInfo</name><argument_list>(<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    

    <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>=</operator> <call><name>XLogBytePosToStartRecPtr</name><argument_list>(<argument><expr><name>prevbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>, <argument><expr><name>rec</name></expr></argument>,<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>ori</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"before xlog StartPos: %"</literal><name>PRIu64</name><literal type="string">" xlog EndPos: %"</literal><name>PRIu64</name><literal type="string">" ori_size: %"</literal><name>PRIu64</name><literal type="string">" with_header_size: %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>EndPos</name></expr></argument>,<argument><expr><name>ori</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>XLogSegmentGtsMaxUpdate</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_with_pageheader</name> <operator>=</operator> <call><name>XLogDataAddPageHeader</name><argument_list>(<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"after xlog StartPos: %"</literal><name>PRIu64</name><literal type="string">" xlog EndPos: %"</literal><name>PRIu64</name><literal type="string">" ori_size: %"</literal><name>PRIu64</name><literal type="string">" with_header_size: %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>EndPos</name></expr></argument>,<argument><expr><name>ori</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"StartPos: %X/%X Prelink: %X/%X Size:%d crc:%u"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>StartPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>StartPos</name></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
             <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>,
             <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>XLogInCurrentSegment</name><argument_list>(<argument><expr><name>StartPos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>CopyXLogRecordToBuff</name><argument_list>(<argument><expr><name>data_with_pageheader</name></expr></argument>,<argument><expr><name>StartPos</name></expr></argument>,<argument><expr><name>EndPos</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseXLogInsertLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseXLogRegisterBuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data_with_pageheader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>EndPos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Move xlog ptr to the end of page
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogPtrToPageEnd</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator> <name>ptr</name> <operator>/</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>+</operator> <literal type="number">1</literal> <operator>)</operator> <operator>*</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Move xlog ptr to the next page head
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogPtrToNextPageHead</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>left</name> <init>= <expr><name>ptr</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><name>left</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>ptr</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator> <name>ptr</name> <operator>/</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>+</operator> <literal type="number">1</literal> <operator>)</operator> <operator>*</operator> <name>GTM_XLOG_BLCKSZ</name></expr> ;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calaulate bytes between xlog
 */</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>XLogDistance</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lhs</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>lhs</name> <operator>&gt;</operator> <name>rhs</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return  <expr><name>lhs</name> <operator>-</operator> <name>rhs</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>rhs</name> <operator>-</operator> <name>lhs</name></expr> ;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate xlog len with pageheader
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>GetXLogRecLenWithPageHeader</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>page_left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>start_offset</name> <init>= <expr><name>start</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>addition</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>use_page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>start_offset</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>page_left</name> <operator>=</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>-</operator> <name>start_offset</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>page_left</name> <operator>=</operator> <name>UsableBytesInPage</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>start_offset</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>start_offset</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>addition</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>page_left</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>len</name> <operator>+</operator> <name>addition</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>use_page</name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>-</operator> <name>page_left</name><operator>)</operator> <operator>/</operator> <name>UsableBytesInPage</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>len</name> <operator>-</operator> <name>page_left</name><operator>)</operator> <operator>%</operator> <name>UsableBytesInPage</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>use_page</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>addition</name> <operator>+</operator> <name>len</name> <operator>+</operator> <name>use_page</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add page header for a xlog record
 */</comment>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>XLogDataAddPageHeader</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>ans_offset</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type> <name>data_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>actual_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type> <name>nleft</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogPageHeaderData</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>next_page_head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ans</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>start</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>start</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>actual_size</name> <operator>=</operator> <call><name>GetXLogRecLenWithPageHeader</name><argument_list>(<argument><expr><name>start</name></expr></argument>,<argument><expr><operator>*</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ans</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>ans</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"memory insufficient"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>header</name><operator>.</operator><name>xlp_magic</name></name>    <operator>=</operator> <name>GTM_XLOG_PAGE_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>header</name><operator>.</operator><name>xlp_info</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>header</name><operator>.</operator><name>xlp_pageaddr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nleft</name> <operator>=</operator> <operator>*</operator><name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>next_page_head</name> <operator>=</operator> <call><name>XLogPtrToNextPageHead</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if start is not head of page,then we copy to the end of page */</comment>
    <if_stmt><if>if<condition>(<expr><name>start</name> <operator>!=</operator> <name>next_page_head</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>XLogPtrToPageEnd</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;</operator> <name>nleft</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>nleft</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ans</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ans_offset</name>  <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_offset</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nleft</name>       <operator>-=</operator> <name>size</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nleft</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>nleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>nleft</name></expr></argument>,<argument><expr><name>UsableBytesInPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>header</name><operator>.</operator><name>xlp_pageaddr</name></name> <operator>=</operator> <name>next_page_head</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ans</name> <operator>+</operator> <name>ans_offset</name></expr></argument> ,<argument><expr><operator>&amp;</operator><name>header</name></expr></argument> ,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ans_offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ans</name> <operator>+</operator> <name>ans_offset</name></expr></argument> ,<argument><expr><name>data</name> <operator>+</operator> <name>data_offset</name></expr></argument> ,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ans_offset</name>  <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_offset</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nleft</name>       <operator>-=</operator> <name>size</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>next_page_head</name> <operator>+=</operator> <name>GTM_XLOG_BLCKSZ</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>actual_size</name> <operator>==</operator> <name>ans_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>actual_size</name></expr>;</expr_stmt>
    <return>return <expr><name>ans</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * Release register buff for thr current thread 
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseXLogRegisterBuff</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name> <modifier>*</modifier></type><name>reg_buff</name> <init>= <expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>save</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>reg_buff</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <for>for<control>(<init><expr><name>head</name> <operator>=</operator> <name><name>reg_buff</name><operator>-&gt;</operator><name>rdata_head</name></name></expr>;</init> <condition><expr><name>head</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>save</name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>save</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>reg_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogSegNo</name></type>
<name>GetCurrentSegmentNo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogSegNo</name></type> <name>currentSegment</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>currentSegment</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether pos is in current open segment file
 */</comment>
<function><type><name>bool</name></type>
<name>XLogInCurrentSegment</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>currentSegment</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><ternary><condition><expr><name>currentSegment</name> <operator>==</operator> <call><name>GetSegmentNo</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Writer request position to xlog file 
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWrite</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint64</name></type>  <name>nleft</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>  <name>total_write</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>  <name>start_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>written</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>  <name>end_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>flush_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name> <name>long</name></type>  <name>start_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name> <name>long</name></type>  <name>end_time</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>end_pos</name> <operator>=</operator> <call><name>XLogRecPtrToFileOffset</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flush_pos</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>flush_pos</name> <operator>&gt;=</operator> <name>req</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,<argument><expr><literal type="string">"XLogWrite request %"</literal><name>PRIu64</name><literal type="string">" but already %"</literal><name>PRIu64</name><literal type="string">" return "</literal></expr></argument>,<argument><expr><name>req</name></expr></argument>,<argument><expr><name>flush_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>start_pos</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>last_write_idx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>end_pos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nleft</name>  <operator>=</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>-</operator> <name>start_pos</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_pos</name> <operator>&lt;=</operator> <name>end_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nleft</name>  <operator>=</operator> <name>end_pos</name> <operator>-</operator> <name>start_pos</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>total_write</name> <operator>=</operator> <name>nleft</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nleft</name> <operator>&lt;=</operator> <name>GTM_XLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>nleft</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"XLogWrite req write to %X/%X  %"</literal><name>PRIu64</name><literal type="string">" bytes"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>req</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>req</name></expr></argument>,<argument><expr><name>nleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>getSystemTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name></expr></argument>, <argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name> <operator>+</operator> <name>start_pos</name></expr></argument>, <argument><expr><name>nleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>written</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"write fails %s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>nleft</name>     <operator>-=</operator> <name>written</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start_pos</name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>nleft</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"write fails %s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>nleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>last_write_idx</name></name> <operator>=</operator> <name>end_pos</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>getSystemTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>end_time</name> <operator>-</operator> <name>start_time</name> <operator>&gt;</operator> <name>warnning_time_cost</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"XLogWrite size %ld lsn %X/%X cost %lld ms"</literal></expr></argument>, <argument><expr><name>total_write</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>req</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>req</name></expr></argument>, <argument><expr><name>end_time</name> <operator>-</operator> <name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Write</name></name>  <operator>&lt;=</operator> <name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>req</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>req</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* To make sure xlog flush to disk as much as we can  */</comment>
<function><type><name>bool</name></type>
<name>XLogBackgroundFlush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//TODO</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* To make sure xlog ptr lower than ptr -1 have successfully been flush to disk */</comment>
<function><type><name>void</name></type>
<name>XLogFlush</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>flush_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>write_pos</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"flush to %X/%X"</literal></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>ptr</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flush_pos</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>flush_pos</name> <operator>&gt;=</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>write_pos</name> <operator>=</operator> <call><name>WaitXLogInsertionsToFinish</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>write_pos</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Only now we can notify flush because we can guarantee all the xlog data are in buff */</comment>
    <expr_stmt><expr><call><name>NotifyReplication</name><argument_list>(<argument><expr><name>write_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogWrite</name><argument_list>(<argument><expr><name>write_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assemble xlog record for register buff
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>XLogAssemble</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecord</name>  <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rec_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32c</name></type> <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRegisterBuff</name><modifier>*</modifier></type> <name>registered_buffer</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>registered_buffer</name> <operator>=</operator> <name><name>GetMyThreadInfo</name><operator>-&gt;</operator><name>register_buff</name></name></expr>;</expr_stmt>

    <comment type="block">/* total length of xlog record including XLogRecord header */</comment>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>registered_buffer</name><operator>-&gt;</operator><name>rdata_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p_data</name> <operator>=</operator> <name>data</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> <comment type="block">/* skip XlogRecord header */</comment>

    <comment type="block">/*
     * Calculate CRC of the data
     *
     * Note that the record header isn't added into the CRC initially since we
     * don't know the prev-link yet.  Thus, the CRC will represent the CRC of
     * the whole record in the order: rdata , then record header.
     */</comment>

    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>rec_data</name> <operator>=</operator> <name><name>registered_buffer</name><operator>-&gt;</operator><name>rdata_head</name></name></expr>;</init> <condition><expr><name>rec_data</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>rec_data</name> <operator>=</operator> <name><name>rec_data</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>rec_data</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>rec_data</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_data</name></expr></argument>,<argument><expr><name><name>rec_data</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>rec_data</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>p_data</name> <operator>+=</operator> <name><name>rec_data</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_crc</name></name> <operator>=</operator> <name>crc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>=</operator> <name><name>registered_buffer</name><operator>-&gt;</operator><name>rdata_len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_timestamp</name></name> <operator>=</operator> <name>InvalidGTS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a wal insert lock which is held during copy xlog to buff
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WALInsertLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thr</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name> <operator>=</operator> <name><name>thr</name><operator>-&gt;</operator><name>insert_try_lock_id</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GTM_MutexLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>l</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>l</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"mutex acquire fault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>thr</name><operator>-&gt;</operator><name>insert_try_lock_id</name></name> <operator>=</operator> <operator>(</operator> <name><name>thr</name><operator>-&gt;</operator><name>insert_try_lock_id</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>)</operator> <operator>%</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * After finishing copy xlog record to the buff,we release wal insert lock
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseXLogInsertLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thr</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>start</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>end</name>   <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * While holding wal insert lock ,once we know our insert position then we update it,
 * so that others will know how far to can flush
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateInsertInfo</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_ThreadInfo</name> <modifier>*</modifier></type><name>thr</name> <init>= <expr><name>GetMyThreadInfo</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>start</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>end</name>   <operator>=</operator> <name>end</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"UpdateInsertInfo lock id : %d upadte to rec %"</literal><name>PRIu64</name><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>insert_lck</name><index>[<expr><name><name>thr</name><operator>-&gt;</operator><name>insert_lock_id</name></name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TimeLineID</name></type>
<name>GetCurrentTimeLineID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimeLineID</name></type> <name>current</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>timeline_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>thisTimeLineID</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>timeline_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>current</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetCurrentTimeLineID</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>timeline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>timeline_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>thisTimeLineID</name></name> <operator>=</operator> <name>timeline</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>timeline_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Open a already-exist xlog file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>OpenXLogFile</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segment_no</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>flush</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path_buff</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type> <name>timeline</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>timeline</name> <operator>=</operator> <call><name>GetCurrentTimeLineID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>path_buff</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path_buff</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %s fails to open : %s"</literal></expr></argument>,<argument><expr><name>path_buff</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>flush</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %s fails to read %d : %s"</literal></expr></argument>,<argument><expr><name>path_buff</name></expr></argument>,<argument><expr><name>offset</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr></argument>,<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>offset</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %s fails to read %d : %s"</literal></expr></argument>,<argument><expr><name>path_buff</name></expr></argument>,<argument><expr><name>offset</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>last_write_idx</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * New an empty xlog file 
 */</comment>
<function><type><name>void</name></type>
<name>NewXLogFile</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path_buff</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type> <name>timeline</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>timeline</name> <operator>=</operator> <call><name>GetCurrentTimeLineID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileName</name><argument_list>(<argument><expr><name>path_buff</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path_buff</name></expr></argument>, <argument><expr><name>O_WRONLY</name><operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Xlog %s fails to create : %s"</literal></expr></argument>,<argument><expr><name>path_buff</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"switch last_write_idx from %"</literal><name>PRIu64</name><literal type="string">" to 0"</literal></expr></argument>,<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>last_write_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>last_write_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlog_fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name> <operator>=</operator> <name>segment_no</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"switch to xlog %s"</literal></expr></argument>,<argument><expr><name>path_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwrite_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GenerateStatusFile</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>archiveStatusPath</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type> <name>timeline</name>  <init>= <expr><name>FIRST_TIMELINE_ID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name>             <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>timeline</name> <operator>=</operator> <call><name>GetCurrentTimeLineID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileStatusReadyName</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"could not create archive status file \"%s\": %s"</literal></expr></argument>,<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"could not write archive status file \"%s\": %s"</literal></expr></argument>,<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddXLogGts</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segment_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>archiveStatusPath</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type> <name>timeline</name>  <init>= <expr><name>FIRST_TIMELINE_ID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name>             <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type>      <name>gts</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>pg_time_t</name></type>            <name>time</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>timeline</name> <operator>=</operator> <call><name>GetCurrentTimeLineID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTMXLogFileGtsName</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><name>timeline</name></expr></argument>,<argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"could not create archive status file \"%s\": %s"</literal></expr></argument>,<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_gts_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>gts</name>  <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_gts</name></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>time</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_max_timestamp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_gts_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"global_timestamp:%lu\n"</literal></expr></argument>,<argument><expr><name>gts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"gtm_time:%lu"</literal></expr></argument>,<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"could not write archive status file \"%s\": %s"</literal></expr></argument>,<argument><expr><name>archiveStatusPath</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Only one thread could call this */</comment>
<comment type="block">/* You have to make sure all the data in current segment have been flush */</comment>
<function><type><name>void</name></type>
<name>SwitchXLogFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>current_segment</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type> <name>allocated_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>allocated</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>current_segment</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>currentSegment</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>allocated</name> <operator>=</operator> <call><name>GetStandbyWriteBuffPos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>AddXLogGts</name><argument_list>(<argument><expr><name>current_segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>allocated_bytes</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>allocated</name> <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>allocated_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><operator>(</operator><name>current_segment</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>GTM_XLOG_SEG_SIZE</name></expr></argument>,<argument><expr><name>allocated</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>GenerateStatusFile</name><argument_list>(<argument><expr><name>current_segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"wait for apply complete apply next_segment %ld"</literal></expr></argument>,<argument><expr><name>current_segment</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* wait for redo thread to finish data fetch */</comment>
        <while>while<condition>(<expr><call><name>GetStandbyApplyPos</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>allocated</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"finish wait for apply complete apply next_segment %ld"</literal></expr></argument>,<argument><expr><name>current_segment</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>


    <expr_stmt><expr><call><name>GTM_RWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>,<argument><expr><name>GTM_LOCKMODE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NewXLogFile</name><argument_list>(<argument><expr><name>current_segment</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_RWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>segment_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ShutDown xlog relative global structure for gtm shutdown */</comment>
<function><type><name>void</name></type>
<name>XLogCtlShutDown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ControlData</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * Copy one xlog record to xlog buff
 * Switch xlog file if necessary
 */</comment>
<function><type><name>bool</name></type>
<name>CopyXLogRecordToBuff</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>start</name></decl></parameter>,<parameter><decl><type><name>XLogRecPtr</name></type> <name>end</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint64</name></type>     <name>write_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>     <name>write_byte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>finish_write_pos</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>start</name> <operator>%</operator> <name>GTM_XLOG_BLCKSZ</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>start</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>write_pos</name>        <operator>=</operator> <call><name>XLogRecPtrToBuffIdx</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>finish_write_pos</name> <operator>=</operator> <name>start</name></expr> ;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"CopyXLogRecordToBuff start_ptr:%X/%X end_ptr:%X/%X size:%ld"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <operator>(</operator><name>start</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <operator>(</operator><name>start</name><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <operator>(</operator><name>end</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <operator>(</operator><name>end</name><operator>)</operator></expr></argument>,
             <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while<condition>(<expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* calculate bytes left for the current segment. */</comment>
        <expr_stmt><expr><name>write_byte</name> <operator>=</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>-</operator> <name>write_pos</name></expr> ;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>write_byte</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>write_byte</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_pos</name> <operator>+</operator> <name>write_byte</name> <operator>&lt;=</operator> <name>GTM_XLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>writerBuff</name></name> <operator>+</operator> <name>write_pos</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><name>write_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>size</name>             <operator>-=</operator> <name>write_byte</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>write_pos</name>        <operator>+=</operator> <name>write_byte</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name>             <operator>+=</operator> <name>write_byte</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>finish_write_pos</name> <operator>+=</operator> <name>write_byte</name></expr>;</expr_stmt>

        <comment type="block">/* as the last record at current segment ,we have to switch xlog */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>Recovery_IsStandby</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>write_pos</name> <operator>==</operator> <name>GTM_XLOG_SEG_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"CopyXLogRecordToBuff start_ptr:%X/%X switch xlog"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>start</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>SwitchXLogFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>write_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_pos</name> <operator>%</operator> <name>GTM_XLOG_SEG_SIZE</name> <operator>==</operator> <call><name>XLogRecPtrToBuffIdx</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>gtm_init_replication_data</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_XLogSegmentBuff</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_status_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_CVInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_update_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>flush_ptr</name></name>         <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>replay_ptr</name></name>        <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>write_ptr</name></name>         <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>time_line</name></name>         <operator>=</operator> <name>FIRST_TIMELINE_ID</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name>          <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_CVInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>xlog_to_send</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_request</name></name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>walsender_thread</name></name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>port</name></name>              <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>buff</name> <operator>=</operator> <operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>xlog_read_buff</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>segment_no</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_sync</name></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gtm_close_replication</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GTM_XLogSegmentBuff</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_status_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>flush_ptr</name></name>         <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>replay_ptr</name></name>        <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>write_ptr</name></name>         <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>time_line</name></name>         <operator>=</operator> <name>FIRST_TIMELINE_ID</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>pos_status_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_ptr</name></name>          <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>send_request</name></name>      <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>send_request_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buff</name> <operator>=</operator> <operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>xlog_read_buff</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>total_length</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>segment_no</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_sync</name></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>gtm_standby_resign_to_walsender</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replication_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_sender</name></expr> ;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>replication</name> <operator>=</operator> <name>g_StandbyReplication</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>is_use</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
	    	<if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"gtm_standby_resign_to_walsender node_name:%s replication_name:%s"</literal></expr></argument>,<argument><expr><name>node_name</name></expr></argument>,<argument><expr><name>replication_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			
            <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_use</name></name>  <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>port</name></name>    <operator>=</operator> <name>port</name></expr> ;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>,<argument><expr><name>replication_name</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>replication_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>,<argument><expr><name>node_name</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>enable_sync_commit</name> <operator>&amp;&amp;</operator> <call><name>IsInSyncStandbyList</name><argument_list>(<argument><expr><name>replication_name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_sync</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>check_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RegisterNewSyncStandby</name><argument_list>(<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>check_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_sync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Error not enough wal sender ,please increase max_wal_sender to proper a number."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type>
<name>register_self_to_standby_replication</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_sender</name></expr> ;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>replication</name> <operator>=</operator> <name>g_StandbyReplication</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>walsender_thread</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>walsender_thread</name></name> <operator>=</operator> <name>GetMyThreadInfo</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>replication</name></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogwrtResult</name></type>
<name>GetCurrentXLogwrtResult</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogwrtResult</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>walwirte_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsXLogFileExist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><ternary><condition><expr><call><name>access</name><argument_list>(<argument><expr><name>file</name></expr></argument>,<argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ValidXLogRecoveryCondition</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>recovery_target_timestamp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>recovery_timestamp</name> <operator>=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name>recovery_target_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">//        if(ControlData-&gt;gts  &gt; recovery_timestamp)</comment>
<comment type="line">//        {</comment>
<comment type="line">//            elog(LOG,"Base file time time stamp %ld is older than %ld",ControlData-&gt;gts,recovery_timestamp);</comment>
<comment type="line">//            exit(1);</comment>
<comment type="line">//        }</comment>
<comment type="line">//</comment>
        <return>return ;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"error recovery_target_timestamp is not provided."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>GetMinReplicationRequiredLocation</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_StandbyReplication</name>  <modifier>*</modifier></type><name>replication</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>ret</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>tmp</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_sender</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>replication</name> <operator>=</operator> <name>g_StandbyReplication</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>replication</name><operator>-&gt;</operator><name>is_use</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>GetReplicationSendRequestPtr</name><argument_list>(<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>==</operator> <name>InvalidXLogRecPtr</name> <operator>||</operator> <name>tmp</name> <operator>&lt;</operator> <name>ret</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether it's a sync standby.
 */</comment>
<function><type><name>bool</name></type>
<name>IsInSyncStandbyList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>application_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>gtm_ListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"IsInSyncStandbyList %s"</literal></expr></argument>,<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SyncConfig</name><operator>-&gt;</operator><name>lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>gtm_foreach</name><argument_list>(<argument>cell</argument>,<argument>SyncConfig-&gt;sync_application_targets</argument>)</argument_list></macro>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"IsInSyncStandbyList target %s"</literal></expr></argument>,<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>application_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        	
			<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SyncConfig</name><operator>-&gt;</operator><name>lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

	<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SyncConfig</name><operator>-&gt;</operator><name>lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>CheckSyncStandbyInList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>application_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>gtm_ListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>gtm_foreach</name><argument_list>(<argument>cell</argument>,<argument>XLogSync-&gt;sync_standbys</argument>)</argument_list></macro>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><name>GTM_StandbyReplication</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>application_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register a new sync standby to XLogSync-&gt;sync_standbys.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterNewSyncStandby</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMostMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>CheckSyncStandbyInList</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"Standby %s already exist in sync list"</literal></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name> <operator>=</operator> <call><name>gtm_lappend</name><argument_list>(<argument><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name></expr></argument>,<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>SyncReady</name> <operator>=</operator> <operator>(</operator><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"add SyncReady %d current lenth %d requireed %d"</literal></expr></argument>,<argument><expr><name>SyncReady</name></expr></argument>,<argument><expr><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"RegisterNewSyncStandby %s"</literal></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove a sync standby from XLogSync-&gt;sync_standbys.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveSyncStandby</name><parameter_list>(<parameter><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMostMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"RemoveSyncStandby %s"</literal></expr></argument>,<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name> <operator>=</operator> <call><name>gtm_list_delete</name><argument_list>(<argument><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name></expr></argument>,<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>SyncReady</name> <operator>=</operator> <operator>(</operator><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enalbe_gtm_xlog_debug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"remove SyncReady %d current lenth %d requireed %d"</literal></expr></argument>,<argument><expr><name>SyncReady</name></expr></argument>,<argument><expr><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>clear_notify_queue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>key</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogWaiter</name> <modifier>*</modifier></type><name>waiter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>ret</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
	<while>while<condition>(<expr><name>ret</name> <operator>=</operator> <call><name>heap_min</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>waiter</name></expr></argument>)</argument_list></call></expr><operator>,</operator><expr><name>ret</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_delmin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>waiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>waiter</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_CVSignal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiter</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>init_standby_replication</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>g_StandbyReplication</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>max_wal_sender</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GTM_StandbyReplication</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>g_StandbyReplication</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"memory insufficient"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_sender</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>gtm_init_replication_data</name><argument_list>(<argument><expr><name>g_StandbyReplication</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>init_syncconfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>SyncConfig</name> <operator>=</operator> <operator>(</operator><name>XLogSyncConfig</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogSyncConfig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>SyncConfig</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"memory insufficient"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>sync_application_targets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SyncConfig</name><operator>-&gt;</operator><name>lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>init_xlogsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>XLogSync</name>  <operator>=</operator> <operator>(</operator><name>XLogSyncStandby</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogSyncStandby</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>XLogSync</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"memory insufficient"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>head_xlog_hints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>head_ptr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>XLogRecPtrCompLess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>check_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GTM_MutexLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>clear_syncconfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>gtm_ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		
	<macro><name>gtm_foreach</name><argument_list>(<argument>lc</argument>, <argument>SyncConfig-&gt;sync_application_targets</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gtm_lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>gtm_list_free</name><argument_list>(<argument><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>sync_application_targets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>sync_application_targets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return ;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>load_syncconfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sync_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>original_sync_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>sync_standby_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>any_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SyncConfig</name><operator>-&gt;</operator><name>lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>clear_syncconfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>enable_sync_commit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SyncConfig</name><operator>-&gt;</operator><name>lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return ;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMostMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>original_sync_names</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>synchronous_standby_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sync_names</name> <operator>=</operator> <call><name>strip</name><argument_list>(<argument><expr><name>original_sync_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>start_with_ignore_case</name><argument_list>(<argument><expr><name>sync_names</name></expr></argument>,<argument><expr><literal type="string">"any"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>any_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sync_names</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>sync_names</name> <operator>=</operator> <call><name>strip</name><argument_list>(<argument><expr><name>sync_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>sync_names</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>stop</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>stop</name> <operator>==</operator> <name>sync_names</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"expect a number after any in synchronous_standby_names"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>sync_names</name> <operator>=</operator> <name>stop</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"sync mode any %d"</literal></expr></argument>,<argument><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>sync_names</name> <operator>=</operator> <call><name>skip_to_next</name><argument_list>(<argument><expr><name>sync_names</name></expr></argument>,<argument><expr><literal type="string">"("</literal><name>BLANK_CHARACTERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>stop</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>sync_names</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>sync_names</name></expr></argument>,<argument><expr><literal type="string">",)"</literal><name>BLANK_CHARACTERS</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>stop</name></expr></argument>)</argument_list></call></expr><operator>,</operator><expr><name>sync_names</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>sync_application_targets</name></name> <operator>=</operator> <call><name>gtm_lappend</name><argument_list>(<argument><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>sync_application_targets</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>strdup</name><argument_list>(<argument><expr><name>sync_names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"sync target %s"</literal></expr></argument>,<argument><expr><name>sync_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sync_standby_num</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>sync_names</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>any_mode</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name> <operator>=</operator> <name>sync_standby_num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"sync slave number %d"</literal></expr></argument>,<argument><expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>enable_sync_commit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>original_sync_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SyncConfig</name><operator>-&gt;</operator><name>lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>load_xlogsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GTM_StandbyReplication</name> <modifier>*</modifier></type><name>replication</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>check_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_sender</name></expr> ;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>replication</name> <operator>=</operator> <name>g_StandbyReplication</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>replication</name><operator>-&gt;</operator><name>is_use</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>GTM_MutexLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>next_sync_pos</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>sync_hint</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><call><name>IsInSyncStandbyList</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>CheckSyncStandbyInList</name><argument_list>(<argument><expr><name><name>replication</name><operator>-&gt;</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_sync</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>RegisterNewSyncStandby</name><argument_list>(<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>replication</name><operator>-&gt;</operator><name>is_sync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoveSyncStandby</name><argument_list>(<argument><expr><name>replication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>enable_sync_commit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>clear_notify_queue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>wait_queue_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>NotifyWaitingQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SyncReady</name> <operator>=</operator> <operator>(</operator><call><name>gtm_list_length</name><argument_list>(<argument><expr><name><name>XLogSync</name><operator>-&gt;</operator><name>sync_standbys</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>SyncConfig</name><operator>-&gt;</operator><name>required_sync_num</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GTM_MutexLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogSync</name><operator>-&gt;</operator><name>check_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>init_sync_structures</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMostMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_standby_replication</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_syncconfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_xlogsync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>load_sync_structures</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>load_syncconfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>load_xlogsync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
