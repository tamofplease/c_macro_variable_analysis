<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/test/isolation/isolationtester.c"><comment type="block">/*
 * src/test/isolation/isolationtester.c
 *
 * isolationtester.c
 *        Runs an isolation test specified by a spec file.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatype/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"isolationtester.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREP_WAITING</name></cpp:macro> <cpp:value>"isolationtester_waiting"</cpp:value></cpp:define>

<comment type="block">/*
 * conns[0] is the global setup, teardown, and watchdog connection.  Additional
 * connections represent spec-defined sessions.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier><modifier>*</modifier></type><name>conns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>backend_pids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>nconns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* In dry run only output permutations to be run by the tester. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>dry_run</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_testspec</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_all_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_all_permutations_recurse</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>,
                             <parameter><decl><type><name>Step</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_named_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_permutation</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>, <parameter><decl><type><name>Step</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP_NONBLOCK</name></cpp:macro>    <cpp:value>0x1</cpp:value></cpp:define>        <comment type="block">/* return 0 as soon as cmd waits for a lock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP_RETRY</name></cpp:macro>        <cpp:value>0x2</cpp:value></cpp:define>        <comment type="block">/* this is a retry of a previously-waiting cmd */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>try_complete_step</name><parameter_list>(<parameter><decl><type><name>Step</name> <modifier>*</modifier></type><name>step</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>step_qsort_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>step_bsearch_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printResultSet</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>get_connection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_connection_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* close all connections and exit */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exit_nicely</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TestSpec</name>   <modifier>*</modifier></type><name>testspec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>wait_query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>opt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nallsteps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Step</name>      <modifier>*</modifier><modifier>*</modifier></type><name>allsteps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_conn_conf</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"nV"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>opt</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                <expr_stmt><expr><name>dry_run</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'V'</literal></expr>:</case>
                <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"isolationtester (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <default>default:</default>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: isolationtester [-n] [CONNINFO]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <comment type="block">/*
     * Make stdout unbuffered to match stderr; and ensure stderr is unbuffered
     * too, which it should already be everywhere except sometimes in Windows.
     */</comment>
    <expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the user supplies a non-option parameter on the command line, use it
     * as the conninfo string; otherwise default to setting dbname=postgres
     * and using environment variables or defaults for all other connection
     * parameters.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <name>optind</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <literal type="string">"dbname = postgres"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Read the test spec from stdin */</comment>
    <expr_stmt><expr><call><name>spec_yyparse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>testspec</name> <operator>=</operator> <operator>&amp;</operator><name>parseresult</name></expr>;</expr_stmt>

    <comment type="block">/* Create a lookup table of all steps. */</comment>
    <expr_stmt><expr><name>nallsteps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nallsteps</name> <operator>+=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>allsteps</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>nallsteps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>allsteps</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>steps</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>allsteps</name></expr></argument>, <argument><expr><name>nallsteps</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>step_qsort_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testspec</name><operator>-&gt;</operator><name>nallsteps</name></name> <operator>=</operator> <name>nallsteps</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testspec</name><operator>-&gt;</operator><name>allsteps</name></name> <operator>=</operator> <name>allsteps</name></expr>;</expr_stmt>

    <comment type="block">/* Verify that all step names are unique */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nallsteps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>allsteps</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,
                   <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>allsteps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"duplicate step name: %s\n"</literal></expr></argument>,
                    <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>allsteps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * In dry-run mode, just print the permutations that would be run, and
     * exit.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dry_run</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>run_testspec</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Parsed test spec with %d sessions\n"</literal></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>has_conn_conf</name> <operator>=</operator> <call><name>parse_connection_conf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/*
     * Establish connections to the database, one for each session and an
     * extra for lock wait detection and global work.
     */</comment>
    <expr_stmt><expr><name>nconns</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>conns</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nconns</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGconn</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>backend_pids</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nconns</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>backend_pids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>has_conn_conf</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <call><name>get_connection</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Connection %d to database failed: %s"</literal></expr></argument>,
                    <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Suppress NOTIFY messages, which otherwise pop into results at odd
         * places.
         */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"SET client_min_messages = warning;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"message level setup failed: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Get the backend pid for lock wait checking. */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_backend_pid()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>backend_pids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"backend pid query returned %d rows and %d columns, expected 1 row and 1 column"</literal></expr></argument>,
                        <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"backend pid query failed: %s"</literal></expr></argument>,
                    <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Set the session index fields in steps. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Session</name>    <modifier>*</modifier></type><name>session</name> <init>= <expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>stepindex</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>stepindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stepindex</name> <operator>&lt;</operator> <name><name>session</name><operator>-&gt;</operator><name>nsteps</name></name></expr>;</condition> <incr><expr><name>stepindex</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>stepindex</name></expr>]</index></name><operator>-&gt;</operator><name>session</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></for>

    <comment type="block">/*
     * Build the query we'll use to detect lock contention among sessions in
     * the test specification.  Most of the time, we could get away with
     * simply checking whether a session is waiting for *any* lock: we don't
     * exactly expect concurrent use of test tables.  However, autovacuum will
     * occasionally take AccessExclusiveLock to truncate a table, and we must
     * ignore that transient wait.
     */</comment>
    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>,
                         <argument><expr><literal type="string">"SELECT pg_catalog.pg_isolation_test_session_is_blocked($1, '{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The spec syntax requires at least one session; assume that here. */</comment>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>, <argument><expr><name><name>backend_pids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>, <argument><expr><name><name>backend_pids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>, <argument><expr><literal type="string">"}')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQprepare</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>PREP_WAITING</name></expr></argument>, <argument><expr><name><name>wait_query</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"prepare of lock wait query failed: %s"</literal></expr></argument>,
                <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Run the permutations specified in the spec, or all if none were
     * explicitly specified.
     */</comment>
    <expr_stmt><expr><call><name>run_testspec</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up and exit */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>piles</name></decl>;</decl_stmt>

<comment type="block">/*
 * Run the permutations specified in the spec, or all if none were
 * explicitly specified.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_testspec</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>permutations</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>run_named_permutations</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>run_all_permutations</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run all permutations of the steps and sessions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_all_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>nsteps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Step</name>      <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl>;</decl_stmt>

    <comment type="block">/* Count the total number of steps in all sessions */</comment>
    <expr_stmt><expr><name>nsteps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nsteps</name> <operator>+=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>steps</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nsteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * To generate the permutations, we conceptually put the steps of each
     * session on a pile. To generate a permutation, we pick steps from the
     * piles until all piles are empty. By picking steps from piles in
     * different order, we get different permutations.
     *
     * A pile is actually just an integer which tells how many steps we've
     * already picked from this pile.
     */</comment>
    <expr_stmt><expr><name>piles</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>run_all_permutations_recurse</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_all_permutations_recurse</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>, <parameter><decl><type><name>Step</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* If there's any more steps in this pile, pick it and recurse */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>steps</name><index>[<expr><name>nsteps</name></expr>]</index></name> <operator>=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>steps</name><index>[<expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>run_all_permutations_recurse</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>nsteps</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If all the piles were empty, this permutation is completed. Run it */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>run_permutation</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>nsteps</name></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run permutations given in the test spec
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_named_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>npermutations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Permutation</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>testspec</name><operator>-&gt;</operator><name>permutations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Step</name>      <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>steps</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nsteps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Find all the named steps using the lookup table */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nsteps</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Step</name>      <modifier>*</modifier><modifier>*</modifier></type><name>this</name> <init>= <expr><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>stepnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>allsteps</name></name></expr></argument>,
                                                 <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>nallsteps</name></name></expr></argument>,
                                                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>step_bsearch_cmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"undefined step \"%s\" specified in permutation\n"</literal></expr></argument>,
                        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stepnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>steps</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* And run them */</comment>
        <expr_stmt><expr><call><name>run_permutation</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nsteps</name></name></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>step_qsort_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Step</name>       <modifier>*</modifier></type><name>stepa</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Step</name>       <modifier>*</modifier></type><name>stepb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stepa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stepb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>step_bsearch_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>stepname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Step</name>       <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>stepname</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If a step caused an error to be reported, print it out and clear it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_error_message</name><parameter_list>(<parameter><decl><type><name>Step</name> <modifier>*</modifier></type><name>step</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * As above, but reports messages possibly emitted by multiple steps.  This is
 * useful when we have a blocked command awakened by another one; we want to
 * report all messages identically, for the case where we don't care which
 * one fails due to a timeout such as deadlock timeout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_multiple_error_messages</name><parameter_list>(<parameter><decl><type><name>Step</name> <modifier>*</modifier></type><name>step</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nextra</name></decl></parameter>, <parameter><decl><type><name>Step</name> <modifier>*</modifier><modifier>*</modifier></type><name>extrastep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nextra</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>report_error_message</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nextra</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>extrastep</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"error in steps %s: %s\n"</literal></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>,
                <argument><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nextra</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>extrastep</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>errormsg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"error in steps %s: %s\n"</literal></expr></argument>,
                <argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>extrastep</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>extrastep</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>extrastep</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run one permutation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_permutation</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>, <parameter><decl><type><name>Step</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>w</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nwaiting</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nerrorstep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Step</name>      <modifier>*</modifier><modifier>*</modifier></type><name>waiting</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Step</name>      <modifier>*</modifier><modifier>*</modifier></type><name>errorstep</name></decl>;</decl_stmt>

    <comment type="block">/*
     * In dry run mode, just display the permutation in the same format used
     * by spec files, and return.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dry_run</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"permutation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name><name>steps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>waiting</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errorstep</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nstarting permutation:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>steps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Perform setup */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsetupsqls</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>setupsqls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setup failed: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Perform per-session setup */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>setupsql</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>setupsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setup of session %s failed: %s"</literal></expr></argument>,
                        <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,
                        <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Perform steps */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Step</name>       <modifier>*</modifier></type><name>step</name> <init>= <expr><name><name>steps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>conns</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Step</name>       <modifier>*</modifier></type><name>oldstep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>mustwait</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Check whether the session that needs to perform the next step is
         * still blocked on an earlier step.  If so, wait for it to finish.
         *
         * (In older versions of this tool, we allowed precisely one session
         * to be waiting at a time.  If we reached a step that required that
         * session to execute the next command, we would declare the whole
         * permutation invalid, cancel everything, and move on to the next
         * one.  Unfortunately, that made it impossible to test the deadlock
         * detector using this framework, unless the number of processes
         * involved in the deadlock was precisely two.  We now assume that if
         * we reach a step that is still blocked, we need to wait for it to
         * unblock itself.)
         */</comment>
        <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <name>nwaiting</name></expr>;</condition> <incr><expr><operator>++</operator><name>w</name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>session</name></name> <operator>==</operator> <name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name><operator>-&gt;</operator><name>session</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>oldstep</name> <operator>=</operator> <name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr>;</expr_stmt>

                <comment type="block">/* Wait for previous step on this connection. */</comment>
                <expr_stmt><expr><call><name>try_complete_step</name><argument_list>(<argument><expr><name>oldstep</name></expr></argument>, <argument><expr><name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Remove that step from the waiting[] array. */</comment>
                <if_stmt><if>if <condition>(<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>(</operator><name>nwaiting</name> <operator>-</operator> <operator>(</operator><name>w</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>nwaiting</name><operator>--</operator></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>oldstep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Check for completion of any steps that were previously waiting.
             * Remove any that have completed from waiting[], and include them
             * in the list for report_multiple_error_messages().
             */</comment>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>nerrorstep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>w</name> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>try_complete_step</name><argument_list>(<argument><expr><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><name>STEP_NONBLOCK</name> <operator>|</operator> <name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Still blocked on a lock, leave it alone. */</comment>
                    <expr_stmt><expr><name>w</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* This one finished, too! */</comment>
                    <expr_stmt><expr><name><name>errorstep</name><index>[<expr><name>nerrorstep</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                <argument><expr><operator>(</operator><name>nwaiting</name> <operator>-</operator> <operator>(</operator><name>w</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>nwaiting</name><operator>--</operator></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>

            <comment type="block">/* Report all errors together. */</comment>
            <expr_stmt><expr><call><name>report_multiple_error_messages</name><argument_list>(<argument><expr><name>oldstep</name></expr></argument>, <argument><expr><name>nerrorstep</name></expr></argument>, <argument><expr><name>errorstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Send the query for this step. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"failed to send query for step %s: %s\n"</literal></expr></argument>,
                    <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Try to complete this step without blocking.  */</comment>
        <expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>try_complete_step</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>STEP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check for completion of any steps that were previously waiting. */</comment>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nerrorstep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>w</name> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>try_complete_step</name><argument_list>(<argument><expr><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><name>STEP_NONBLOCK</name> <operator>|</operator> <name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>w</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>errorstep</name><index>[<expr><name>nerrorstep</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>(</operator><name>nwaiting</name> <operator>-</operator> <operator>(</operator><name>w</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>nwaiting</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Report any error from this step, and any steps that it unblocked. */</comment>
        <expr_stmt><expr><call><name>report_multiple_error_messages</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>nerrorstep</name></expr></argument>, <argument><expr><name>errorstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If this step is waiting, add it to the array of waiters. */</comment>
        <if_stmt><if>if <condition>(<expr><name>mustwait</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>waiting</name><index>[<expr><name>nwaiting</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>step</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Wait for any remaining queries. */</comment>
    <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <name>nwaiting</name></expr>;</condition> <incr><expr><operator>++</operator><name>w</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>try_complete_step</name><argument_list>(<argument><expr><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>report_error_message</name><argument_list>(<argument><expr><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Perform per-session teardown */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>teardownsql</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>teardownsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"teardown of session %s failed: %s"</literal></expr></argument>,
                        <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,
                        <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* don't exit on teardown failure */</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Perform teardown */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>teardownsql</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>teardownsql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"teardown failed: %s"</literal></expr></argument>,
                    <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* don't exit on teardown failure */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>waiting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>errorstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Our caller already sent the query associated with this step.  Wait for it
 * to either complete or (if given the STEP_NONBLOCK flag) to block while
 * waiting for a lock.  We assume that any lock wait will persist until we
 * have executed additional steps in the permutation.
 *
 * When calling this function on behalf of a given step for a second or later
 * time, pass the STEP_RETRY flag.  This only affects the messages printed.
 *
 * If the query returns an error, the message is saved in step-&gt;errormsg.
 * Caller should call report_error_message shortly after this, to have it
 * printed and cleared.
 *
 * If the STEP_NONBLOCK flag was specified and the query is waiting to acquire
 * a lock, returns true.  Otherwise, returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>try_complete_step</name><parameter_list>(<parameter><decl><type><name>Step</name> <modifier>*</modifier></type><name>step</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>conns</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>read_set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>canceled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid socket: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>read_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>    <comment type="block">/* Check for lock waits every 10ms. */</comment>

        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>sock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_set</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>            <comment type="block">/* error in select() */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"select failed: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>        <comment type="block">/* select() timeout: check for lock wait */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>current_time</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64</name></type>        <name>td</name></decl>;</decl_stmt>

            <comment type="block">/* If it's OK for the step to block, check whether it has. */</comment>
            <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STEP_NONBLOCK</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>waiting</name></decl>;</decl_stmt>
<comment type="block">/*
                res = PQexecPrepared(conns[0], PREP_WAITING, 1,
                                     &amp;backend_pids[step-&gt;session + 1],
                                     NULL, NULL, 0);
                if (PQresultStatus(res) != PGRES_TUPLES_OK ||
                    PQntuples(res) != 1)
                {
                    fprintf(stderr, "lock wait query failed: %s",
                            PQerrorMessage(conn));
                    exit_nicely();
                }
                waiting = ((PQgetvalue(res, 0, 0))[0] == 't');
                PQclear(res);
*/</comment>
                <expr_stmt><expr><name>waiting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>waiting</name></expr>)</condition>    <comment type="block">/* waiting to acquire a lock */</comment>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STEP_RETRY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: %s &lt;waiting ...&gt;\n"</literal></expr></argument>,
                               <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* else, not waiting */</comment>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Figure out how long we've been waiting for this step. */</comment>
            <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>td</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>current_time</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>start_time</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>td</name> <operator>*=</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>td</name> <operator>+=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>current_time</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>start_time</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * After 60 seconds, try to cancel the query.
             *
             * If the user tries to test an invalid permutation, we don't want
             * to hang forever, especially when this is running in the
             * buildfarm.  So try to cancel it after a minute.  This will
             * presumably lead to this permutation failing, but remaining
             * permutations and tests should still be OK.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>td</name> <operator>&gt;</operator> <literal type="number">60</literal> <operator>*</operator> <name>USECS_PER_SEC</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>canceled</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>cancel</name> <init>= <expr><call><name>PQgetCancel</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQcancel %s.\n"</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>cancel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>canceled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQcancel failed: %s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * After 75 seconds, just give up and die.
             *
             * Since cleanup steps won't be run in this case, this may cause
             * later tests to fail.  That stinks, but it's better than waiting
             * forever for the server to respond to the cancel.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>td</name> <operator>&gt;</operator> <literal type="number">75</literal> <operator>*</operator> <name>USECS_PER_SEC</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"step %s timed out after 75 seconds\n"</literal></expr></argument>,
                        <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* select(): data available */</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQconsumeInput failed: %s\n"</literal></expr></argument>,
                    <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STEP_RETRY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: &lt;... completed&gt;\n"</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: %s\n"</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
                <break>break;</break>
            <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
                <expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"WARNING: this step had a leftover error message\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Detail may contain XID values, so we want to just show
                 * primary.  Beware however that libpq-generated error results
                 * may not contain subfields, only an old-style message.
                 */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sev</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
                                                         <argument><expr><name>PG_DIAG_SEVERITY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
                                                         <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>sev</name> <operator>&amp;&amp;</operator> <name>msg</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s:  %s"</literal></expr></argument>, <argument><expr><name>sev</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>errormsg</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unexpected result status: %s\n"</literal></expr></argument>,
                       <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printResultSet</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>nFields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/* first, print out the attribute names */</comment>
    <expr_stmt><expr><name>nFields</name> <operator>=</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nFields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-15s"</literal></expr></argument>, <argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* next, print out the rows */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nFields</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-15s"</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECTION_CONF_FILENAME</name></cpp:macro> <cpp:value>"isolation_test.conf"</cpp:value></cpp:define>   
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CONNECTION</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>g_connections</name><index>[<expr><name>MAX_CONNECTION</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>    <name>g_conn_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type> <name>inputdir</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>parse_connection_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>infile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>inputbuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>   
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>inputstr</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"./%s"</literal></expr></argument>, <argument><expr><name>CONNECTION_CONF_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>fp</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  
    <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>inputbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>, <argument><expr><literal type="string">"connect:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"connect:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>inputstr</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>inputstr</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fail to malloc for connection, len:%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>inputstr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>inputstr</name></expr></argument>, <argument><expr><name>inputbuf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"connect:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>g_connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>inputstr</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>MAX_CONNECTION</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"too many connection for isolation test, max is %d\n"</literal></expr></argument>, <argument><expr><name>MAX_CONNECTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit_nicely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>i</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>g_conn_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>get_connection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>id</name> <operator>%</operator> <name>g_conn_count</name></expr>;</expr_stmt>
        
    <return>return <expr><name><name>g_connections</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
