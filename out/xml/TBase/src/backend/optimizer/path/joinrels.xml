<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/optimizer/path/joinrels.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * joinrels.c
 *      Routines to determine which relations should be joined
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/optimizer/path/joinrels.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/joininfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_rels_by_clause_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                          <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>,
                          <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>other_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_rels_by_clauseless_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                              <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>,
                              <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>other_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_join_restriction</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_legal_joinclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_dummy_rel</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>restriction_is_constant_false</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>,
                              <parameter><decl><type><name>bool</name></type> <name>only_pushed_down</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_joinrel_with_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>,
                            <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
                            <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>try_partition_wise_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						<parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>parent_sjinfo</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_restrictlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>match_expr_to_partition_keys</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>strict_op</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * join_search_one_level
 *      Consider ways to produce join relations containing exactly 'level'
 *      jointree items.  (This is one step of the dynamic-programming method
 *      embodied in standard_join_search.)  Join rel nodes for each feasible
 *      combination of lower-level rels are created and returned in a list.
 *      Implementation paths are created for each such joinrel, too.
 *
 * level: level of rels we want to make this time
 * root-&gt;join_rel_level[j], 1 &lt;= j &lt; level, is a list of rels containing j items
 *
 * The result is returned in root-&gt;join_rel_level[level].
 */</comment>
<function><type><name>void</name></type>
<name>join_search_one_level</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>      <modifier>*</modifier><modifier>*</modifier></type><name>joinrels</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>joinrels</name><index>[<expr><name>level</name></expr>]</index></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set join_cur_level so that new joinrels are added to proper list */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_cur_level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>

    <comment type="block">/*
     * First, consider left-sided and right-sided plans, in which rels of
     * exactly level-1 member relations are joined against initial relations.
     * We prefer to join using join clauses, but if we find a rel of level-1
     * members that has no join clauses, we will generate Cartesian-product
     * joins against all initial rels not already contained in it.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>r</argument>, <argument>joinrels[level - <literal type="number">1</literal>]</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>old_rel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>old_rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>||</operator>
            <call><name>has_join_restriction</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * There are join clauses or join order restrictions relevant to
             * this rel, so consider joins between this rel and (only) those
             * initial rels it is linked to by a clause or restriction.
             *
             * At level 2 this condition is symmetric, so there is no need to
             * look at initial rels before this one in the list; we already
             * considered such joins when we were at the earlier rel.  (The
             * mirror-image joins are handled automatically by make_join_rel.)
             * In later passes (level &gt; 2), we join rels of the previous level
             * to each initial rel they don't already include but have a join
             * clause or restriction with.
             */</comment>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>other_rels</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>        <comment type="block">/* consider remaining initial rels */</comment>
                <expr_stmt><expr><name>other_rels</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>                <comment type="block">/* consider all initial rels */</comment>
                <expr_stmt><expr><name>other_rels</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>joinrels</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><call><name>make_rels_by_clause_joins</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                      <argument><expr><name>old_rel</name></expr></argument>,
                                      <argument><expr><name>other_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Oops, we have a relation that is not joined to any other
             * relation, either directly or by join-order restrictions.
             * Cartesian product time.
             *
             * We consider a cartesian product with each not-already-included
             * initial rel, whether it has other join clauses or not.  At
             * level 2, if there are two or more clauseless initial rels, we
             * will redundantly consider joining them in both directions; but
             * such cases aren't common enough to justify adding complexity to
             * avoid the duplicated effort.
             */</comment>
            <expr_stmt><expr><call><name>make_rels_by_clauseless_joins</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><name>old_rel</name></expr></argument>,
                                          <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>joinrels</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Now, consider "bushy plans" in which relations of k initial rels are
     * joined to relations of level-k initial rels, for 2 &lt;= k &lt;= level-2.
     *
     * We only consider bushy-plan joins for pairs of rels where there is a
     * suitable join clause (or join order restriction), in order to avoid
     * unreasonable growth of planning time.
     */</comment>
    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init><condition>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>other_level</name> <init>= <expr><name>level</name> <operator>-</operator> <name>k</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Since make_join_rel(x, y) handles both x,y and y,x cases, we only
         * need to go as far as the halfway point.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>other_level</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <macro><name>foreach</name><argument_list>(<argument>r</argument>, <argument>joinrels[k]</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>other_rels</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>r2</name></decl>;</decl_stmt>

            <comment type="block">/*
             * We can ignore relations without join clauses here, unless they
             * participate in join-order restrictions --- then we might have
             * to force a bushy join plan.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>old_rel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>old_rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>has_join_restriction</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <name>other_level</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>other_rels</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* only consider remaining rels */</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>other_rels</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>joinrels</name><index>[<expr><name>other_level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <macro><name>for_each_cell</name><argument_list>(<argument>r2</argument>, <argument>other_rels</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>new_rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * OK, we can build a rel of the right level from this
                     * pair of rels.  Do so if there is at least one relevant
                     * join clause or join order restriction.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>have_relevant_joinclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>new_rel</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>have_join_order_restriction</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>new_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>make_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>new_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block>
    </block_content>}</block></for>

    <comment type="block">/*----------
     * Last-ditch effort: if we failed to find any usable joins so far, force
     * a set of cartesian-product joins to be generated.  This handles the
     * special case where all the available rels have join clauses but we
     * cannot use any of those clauses yet.  This can only happen when we are
     * considering a join sub-problem (a sub-joinlist) and all the rels in the
     * sub-problem have only join clauses with rels outside the sub-problem.
     * An example is
     *
     *        SELECT ... FROM a INNER JOIN b ON TRUE, c, d, ...
     *        WHERE a.w = c.x and b.y = d.z;
     *
     * If the "a INNER JOIN b" sub-problem does not get flattened into the
     * upper level, we must be willing to make a cartesian join of a and b;
     * but the code above will not have done so, because it thought that both
     * a and b have joinclauses.  We consider only left-sided and right-sided
     * cartesian joins in this case (no bushy).
     *----------
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>joinrels</name><index>[<expr><name>level</name></expr>]</index></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This loop is just like the first one, except we always call
         * make_rels_by_clauseless_joins().
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>r</argument>, <argument>joinrels[level - <literal type="number">1</literal>]</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>make_rels_by_clauseless_joins</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><name>old_rel</name></expr></argument>,
                                          <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>joinrels</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/*----------
         * When special joins are involved, there may be no legal way
         * to make an N-way join for some values of N.  For example consider
         *
         * SELECT ... FROM t1 WHERE
         *     x IN (SELECT ... FROM t2,t3 WHERE ...) AND
         *     y IN (SELECT ... FROM t4,t5 WHERE ...)
         *
         * We will flatten this query to a 5-way join problem, but there are
         * no 4-way joins that join_is_legal() will consider legal.  We have
         * to accept failure at level 4 and go on to discover a workable
         * bushy plan at level 5.
         *
         * However, if there are no special joins and no lateral references
         * then join_is_legal() should never fail, and so the following sanity
         * check is useful.
         *----------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>joinrels</name><index>[<expr><name>level</name></expr>]</index></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
            <name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to build any %d-way joins"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * make_rels_by_clause_joins
 *      Build joins between the given relation 'old_rel' and other relations
 *      that participate in join clauses that 'old_rel' also participates in
 *      (or participate in join-order restrictions with it).
 *      The join rels are returned in root-&gt;join_rel_level[join_cur_level].
 *
 * Note: at levels above 2 we will generate the same joined relation in
 * multiple ways --- for example (a join b) join c is the same RelOptInfo as
 * (b join c) join a, though the second case will add a different set of Paths
 * to it.  This is the reason for using the join_rel_level mechanism, which
 * automatically ensures that each new joinrel is only added to the list once.
 *
 * 'old_rel' is the relation entry for the relation to be joined
 * 'other_rels': the first cell in a linked list containing the other
 * rels to be considered for joining
 *
 * Currently, this is only used with initial rels in other_rels, but it
 * will work for joining to joinrels too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_rels_by_clause_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                          <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>,
                          <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>other_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>for_each_cell</name><argument_list>(<argument>l</argument>, <argument>other_rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>other_rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>other_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><call><name>have_relevant_joinclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>other_rel</name></expr></argument>)</argument_list></call> <operator>||</operator>
             <call><name>have_join_order_restriction</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>other_rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>make_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>other_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * make_rels_by_clauseless_joins
 *      Given a relation 'old_rel' and a list of other relations
 *      'other_rels', create a join relation between 'old_rel' and each
 *      member of 'other_rels' that isn't already included in 'old_rel'.
 *      The join rels are returned in root-&gt;join_rel_level[join_cur_level].
 *
 * 'old_rel' is the relation entry for the relation to be joined
 * 'other_rels': the first cell of a linked list containing the
 * other rels to be considered for joining
 *
 * Currently, this is only used with initial rels in other_rels, but it would
 * work for joining to joinrels too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_rels_by_clauseless_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                              <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>,
                              <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>other_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>for_each_cell</name><argument_list>(<argument>l</argument>, <argument>other_rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>other_rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>other_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>make_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>other_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * join_is_legal
 *       Determine whether a proposed join is legal given the query's
 *       join order constraints; and if it is, determine the join type.
 *
 * Caller must supply not only the two rels, but the union of their relids.
 * (We could simplify the API by computing joinrelids locally, but this
 * would be redundant work in the normal path through make_join_rel.)
 *
 * On success, *sjinfo_p is set to NULL if this is to be a plain inner join,
 * else it's set to point to the associated SpecialJoinInfo node.  Also,
 * *reversed_p is set TRUE if the given relations need to be swapped to
 * match the SpecialJoinInfo node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>join_is_legal</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>,
			  <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>,
			  <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>sjinfo_p</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reversed_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>match_sjinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reversed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>unique_ified</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>must_be_leftjoin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure output params are set on failure return.  This is just to
	 * suppress uninitialized-variable warnings from overly anal compilers.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>sjinfo_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>reversed_p</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have any special joins, the proposed join might be illegal; and
	 * in any case we have to determine its join type.  Scan the join info
	 * list for matches and conflicts.
	 */</comment>
	<expr_stmt><expr><name>match_sjinfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reversed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>unique_ified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>must_be_leftjoin</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This special join is not relevant unless its RHS overlaps the
		 * proposed join.  (Check this first as a fast path for dismissing
		 * most irrelevant SJs quickly.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also, not relevant if proposed join is fully contained within RHS
		 * (ie, we're still building up the RHS).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also, not relevant if SJ is already done within either input.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's a semijoin and we already joined the RHS to any other rels
		 * within either input, then we must have unique-ified the RHS at that
		 * point (see below).  Therefore the semijoin is no longer relevant in
		 * this join path.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
			<name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT_SCALAR</name> <operator>||</operator>
			<name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT_SEMI</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If one input contains min_lefthand and the other contains
		 * min_righthand, then we can perform the SJ at this join.
		 *
		 * Reject if we get matches to more than one SJ; that implies we're
		 * considering something that's not really valid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>match_sjinfo</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* invalid join path */</comment>
			<expr_stmt><expr><name>match_sjinfo</name> <operator>=</operator> <name>sjinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reversed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>match_sjinfo</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* invalid join path */</comment>
			<expr_stmt><expr><name>match_sjinfo</name> <operator>=</operator> <name>sjinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reversed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>&amp;&amp;</operator>
				 <call><name>bms_equal</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>,
									<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*----------
			 * For a semijoin, we can join the RHS to anything else by
			 * unique-ifying the RHS (if the RHS can be unique-ified).
			 * We will only get here if we have the full RHS but less
			 * than min_lefthand on the LHS.
			 *
			 * The reason to consider such a join path is exemplified by
			 *	SELECT ... FROM a,b WHERE (a.x,b.y) IN (SELECT c1,c2 FROM c)
			 * If we insist on doing this as a semijoin we will first have
			 * to form the cartesian product of A*B.  But if we unique-ify
			 * C then the semijoin becomes a plain innerjoin and we can join
			 * in any order, eg C to A and then to B.  When C is much smaller
			 * than A and B this can be a huge win.  So we allow C to be
			 * joined to just A or just B here, and then make_join_rel has
			 * to handle the case properly.
			 *
			 * Note that actually we'll allow unique-ified C to be joined to
			 * some other relation D here, too.  That is legal, if usually not
			 * very sane, and this routine is only concerned with legality not
			 * with whether the join is good strategy.
			 *----------
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>match_sjinfo</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* invalid join path */</comment>
			<expr_stmt><expr><name>match_sjinfo</name> <operator>=</operator> <name>sjinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reversed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>unique_ified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>&amp;&amp;</operator>
				 <call><name>bms_equal</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>,
									<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Reversed semijoin case */</comment>
			<if_stmt><if>if <condition>(<expr><name>match_sjinfo</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* invalid join path */</comment>
			<expr_stmt><expr><name>match_sjinfo</name> <operator>=</operator> <name>sjinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reversed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>unique_ified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, the proposed join overlaps the RHS but isn't a valid
			 * implementation of this SJ.  But don't panic quite yet: the RHS
			 * violation might have occurred previously, in one or both input
			 * relations, in which case we must have previously decided that
			 * it was OK to commute some other SJ with this one.  If we need
			 * to perform this join to finish building up the RHS, rejecting
			 * it could lead to not finding any plan at all.  (This can occur
			 * because of the heuristics elsewhere in this file that postpone
			 * clauseless joins: we might not consider doing a clauseless join
			 * within the RHS until after we've performed other, validly
			 * commutable SJs with one or both sides of the clauseless join.)
			 * This consideration boils down to the rule that if both inputs
			 * overlap the RHS, we can allow the join --- they are either
			 * fully within the RHS, or represent previously-allowed joins to
			 * rels outside it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* assume valid previous violation of RHS */</comment>

			<comment type="block">/*
			 * The proposed join could still be legal, but only if we're
			 * allowed to associate it into the RHS of this SJ.  That means
			 * this SJ must be a LEFT join (not SEMI or ANTI, and certainly
			 * not FULL) and the proposed join must not overlap the LHS.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>||</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* invalid join path */</comment>

			<comment type="block">/*
			 * To be valid, the proposed join must be a LEFT join; otherwise
			 * it can't associate into this SJ's RHS.  But we may not yet have
			 * found the SpecialJoinInfo matching the proposed join, so we
			 * can't test that yet.  Remember the requirement for later.
			 */</comment>
			<expr_stmt><expr><name>must_be_leftjoin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Fail if violated any SJ's RHS and didn't match to a LEFT SJ: the
	 * proposed join can't associate into an SJ's RHS.
	 *
	 * Also, fail if the proposed join's predicate isn't strict; we're
	 * essentially checking to see if we can apply outer-join identity 3, and
	 * that's a requirement.  (This check may be redundant with checks in
	 * make_outerjoininfo, but I'm not quite sure, and it's cheap to test.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>must_be_leftjoin</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>match_sjinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		 <name><name>match_sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>||</operator>
		 <operator>!</operator><name><name>match_sjinfo</name><operator>-&gt;</operator><name>lhs_strict</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* invalid join path */</comment>

	<comment type="block">/*
	 * We also have to check for constraints imposed by LATERAL references.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lateral_fwd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lateral_rev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>join_lateral_rels</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The proposed rels could each contain lateral references to the
		 * other, in which case the join is impossible.  If there are lateral
		 * references in just one direction, then the join has to be done with
		 * a nestloop with the lateral referencer on the inside.  If the join
		 * matches an SJ that cannot be implemented by such a nestloop, the
		 * join is impossible.
		 *
		 * Also, if the lateral reference is only indirect, we should reject
		 * the join; whatever rel(s) the reference chain goes through must be
		 * joined to first.
		 *
		 * Another case that might keep us from building a valid plan is the
		 * implementation restriction described by have_dangerous_phv().
		 */</comment>
		<expr_stmt><expr><name>lateral_fwd</name> <operator>=</operator> <call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lateral_rev</name> <operator>=</operator> <call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lateral_fwd</name> <operator>&amp;&amp;</operator> <name>lateral_rev</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* have lateral refs in both directions */</comment>
		<if_stmt><if>if <condition>(<expr><name>lateral_fwd</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* has to be implemented as nestloop with rel1 on left */</comment>
			<if_stmt><if>if <condition>(<expr><name>match_sjinfo</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>reversed</name> <operator>||</operator>
				 <name>unique_ified</name> <operator>||</operator>
				 <name><name>match_sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not implementable as nestloop */</comment>
			<comment type="block">/* check there is a direct reference from rel2 to rel1 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* only indirect refs, so reject */</comment>
			<comment type="block">/* check we won't have a dangerous PHV */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>have_dangerous_phv</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* might be unable to handle required PHV */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>lateral_rev</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* has to be implemented as nestloop with rel2 on left */</comment>
			<if_stmt><if>if <condition>(<expr><name>match_sjinfo</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>!</operator><name>reversed</name> <operator>||</operator>
				 <name>unique_ified</name> <operator>||</operator>
				 <name><name>match_sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not implementable as nestloop */</comment>
			<comment type="block">/* check there is a direct reference from rel1 to rel2 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* only indirect refs, so reject */</comment>
			<comment type="block">/* check we won't have a dangerous PHV */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>have_dangerous_phv</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* might be unable to handle required PHV */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * LATERAL references could also cause problems later on if we accept
		 * this join: if the join's minimum parameterization includes any rels
		 * that would have to be on the inside of an outer join with this join
		 * rel, then it's never going to be possible to build the complete
		 * query using this join.  We should reject this join not only because
		 * it'll save work, but because if we don't, the clauseless-join
		 * heuristics might think that legality of this join means that some
		 * other join rel need not be formed, and that could lead to failure
		 * to find any plan at all.  We have to consider not only rels that
		 * are directly on the inner side of an OJ with the joinrel, but also
		 * ones that are indirectly so, so search to find all such rels.
		 */</comment>
		<expr_stmt><expr><name>join_lateral_rels</name> <operator>=</operator> <call><name>min_join_parameterization</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>,
													  <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>join_lateral_rels</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>join_plus_rhs</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>more</name></decl>;</decl_stmt>

			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>more</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name>join_plus_rhs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name>join_plus_rhs</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>join_plus_rhs</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>join_plus_rhs</name></expr></argument>,
														<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* full joins constrain both sides symmetrically */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
						<call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name>join_plus_rhs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name>join_plus_rhs</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>join_plus_rhs</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>join_plus_rhs</name></expr></argument>,
														<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block> while <condition>(<expr><name>more</name></expr>)</condition>;</do>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>join_plus_rhs</name></expr></argument>, <argument><expr><name>join_lateral_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* will not be able to join to some RHS rel */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise, it's a valid join */</comment>
	<expr_stmt><expr><operator>*</operator><name>sjinfo_p</name> <operator>=</operator> <name>match_sjinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>reversed_p</name> <operator>=</operator> <name>reversed</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * make_join_rel
 *       Find or create a join RelOptInfo that represents the join of
 *       the two given rels, and add to it path information for paths
 *       created with the two rels as outer and inner rel.
 *       (The join rel may already contain paths generated from other
 *       pairs of rels that add up to the same set of base rels.)
 *
 * NB: will return NULL if attempted join is not valid.  This can happen
 * when working with outer joins, or with IN or EXISTS clauses that have been
 * turned into joins.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>make_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>joinrelids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>reversed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SpecialJoinInfo</name></type> <name>sjinfo_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>restrictlist</name></decl>;</decl_stmt>

    <comment type="block">/* We should never try to join two overlapping sets of rels. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct Relids set that identifies the joinrel. */</comment>
    <expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check validity and determine join type. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_is_legal</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>sjinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reversed</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* invalid join path */</comment>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Swap rels if needed to match the join info. */</comment>
    <if_stmt><if>if <condition>(<expr><name>reversed</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>trel</name> <init>= <expr><name>rel1</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>rel1</name> <operator>=</operator> <name>rel2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rel2</name> <operator>=</operator> <name>trel</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If it's a plain inner join, then we won't have found anything in
     * join_info_list.  Make up a SpecialJoinInfo so that selectivity
     * estimation functions will know what's being joined.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>sjinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sjinfo</name> <operator>=</operator> <operator>&amp;</operator><name>sjinfo_data</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_SpecialJoinInfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name> <operator>=</operator> <name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name> <operator>=</operator> <name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name> <operator>=</operator> <name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name> <operator>=</operator> <name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
        <comment type="block">/* we don't bother trying to make the remaining fields valid */</comment>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>lhs_strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>delay_upper_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Find or build the join RelOptInfo, and compute the restrictlist that
     * goes with this particular joining.
     */</comment>
    <expr_stmt><expr><name>joinrel</name> <operator>=</operator> <call><name>build_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we've already proven this join is empty, we needn't consider any
     * more paths for it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinrel</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add paths to the join relation. */</comment>
    <expr_stmt><expr><call><name>populate_joinrel_with_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
                                <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>joinrel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * populate_joinrel_with_paths
 *      Add paths to the given joinrel for given pair of joining relations. The
 *      SpecialJoinInfo provides details about the join and the restrictlist
 *      contains the join clauses and the other clauses applicable for given pair
 *      of the joining relations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_joinrel_with_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Consider paths using each rel as both outer and inner.  Depending on
	 * the join type, a provably empty outer or inner rel might mean the join
	 * is provably empty too; in which case throw away any previously computed
	 * paths and mark the join as dummy.  (We do it this way since it's
	 * conceivable that dummy-ness of a multi-element join might only be
	 * noticeable for certain construction paths.)
	 *
	 * Also, a provably constant-false join restriction typically means that
	 * we can skip evaluating one or both sides of the join.  We do this by
	 * marking the appropriate rel as dummy.  For outer joins, a
	 * constant-false restriction that is pushed down still means the whole
	 * join is dummy, while a non-pushed-down one means that no inner rows
	 * will join so we can treat the inner rel as dummy.
	 *
	 * We need only consider the jointypes that appear in join_info_list, plus
	 * JOIN_INNER.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
								 <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_LEFT</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
								 <argument><expr><name>JOIN_RIGHT</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_FULL</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
								 <argument><expr><name>JOIN_FULL</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If there are join quals that aren't mergeable or hashable, we
			 * may not be able to build any valid plan.  Complain here so that
			 * we can give a somewhat-useful error message.  (Since we have no
			 * flexibility of planning for a full join, there's no chance of
			 * succeeding later with another pair of input rels.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FULL JOIN is only supported with merge-joinable or hash-joinable join conditions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>JOIN_LEFT_SCALAR</name></expr>:</case>
        <case>case <expr><name>JOIN_LEFT_SEMI</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/*
			 * We might have a normal semijoin, or a case where we don't have
			 * enough rels to do the semijoin but can unique-ify the RHS and
			 * then do an innerjoin (see comments in join_is_legal).  In the
			 * latter case we can't apply JOIN_SEMI joining.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
									 <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
									 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
									 <argument><expr><name>JOIN_SEMI</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
									 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we know how to unique-ify the RHS and one input rel is
			 * exactly the RHS (not a superset) we can consider unique-ifying
			 * it and then doing a regular join.  (The create_unique_path
			 * check here is probably redundant with what join_is_legal did,
			 * but if so the check is cheap because it's cached.  So test
			 * anyway to be sure.)
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>&amp;&amp;</operator> <call><name>bms_equal</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>,
								   <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>,
								   <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
									 <argument><expr><name>JOIN_UNIQUE_INNER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
									 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
									 <argument><expr><name>JOIN_UNIQUE_OUTER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
									 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_ANTI</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* other values not expected here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Apply partition-wise join technique, if possible. */</comment>
	<expr_stmt><expr><call><name>try_partition_wise_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * have_join_order_restriction
 *        Detect whether the two relations should be joined to satisfy
 *        a join-order restriction arising from special or lateral joins.
 *
 * In practice this is always used with have_relevant_joinclause(), and so
 * could be merged with that function, but it seems clearer to separate the
 * two concerns.  We need this test because there are degenerate cases where
 * a clauseless join must be performed to satisfy join-order restrictions.
 * Also, if one rel has a lateral reference to the other, or both are needed
 * to compute some PHV, we should consider joining them even if the join would
 * be clauseless.
 *
 * Note: this is only a problem if one side of a degenerate outer join
 * contains multiple rels, or a clauseless join is required within an
 * IN/EXISTS RHS; else we will find a join path via the "last ditch" case in
 * join_search_one_level().  We could dispense with this test if we were
 * willing to try bushy plans in the "last ditch" case, but that seems much
 * less efficient.
 */</comment>
<function><type><name>bool</name></type>
<name>have_join_order_restriction</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                            <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If either side has a direct lateral reference to the other, attempt the
     * join regardless of outer-join considerations.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Likewise, if both rels are needed to compute some PlaceHolderVar,
     * attempt the join regardless of outer-join considerations.  (This is not
     * very desirable, because a PHV with a large eval_at set will cause a lot
     * of probably-useless joins to be considered, but failing to do this can
     * cause us to fail to construct a plan at all.)
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * It's possible that the rels correspond to the left and right sides of a
     * degenerate outer join, that is, one with no joinclause mentioning the
     * non-nullable side; in which case we should force the join to occur.
     *
     * Also, the two rels could represent a clauseless join that has to be
     * completed to build up the LHS or RHS of an outer join.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* ignore full joins --- other mechanisms handle them */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Can we perform the SJ with these rels? */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Might we need to join these rels to complete the RHS?  We have to
         * use "overlap" tests since either rel might include a lower SJ that
         * has been proven to commute with this one.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Likewise for the LHS. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * We do not force the join to occur if either input rel can legally be
     * joined to anything else using joinclauses.  This essentially means that
     * clauseless bushy joins are put off as long as possible. The reason is
     * that when there is a join order restriction high up in the join tree
     * (that is, with many rels inside the LHS or RHS), we would otherwise
     * expend lots of effort considering very stupid join combinations within
     * its LHS or RHS.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>has_legal_joinclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>has_legal_joinclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * has_join_restriction
 *        Detect whether the specified relation has join-order restrictions,
 *        due to being inside an outer join or an IN (sub-SELECT),
 *        or participating in any LATERAL references or multi-rel PHVs.
 *
 * Essentially, this tests whether have_join_order_restriction() could
 * succeed with this rel and some other one.  It's OK if we sometimes
 * say "true" incorrectly.  (Therefore, we don't bother with the relatively
 * expensive has_legal_joinclause test.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_join_restriction</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* ignore full joins --- other mechanisms preserve their ordering */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* ignore if SJ is already contained in rel */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* restricted if it overlaps LHS or RHS, but doesn't contain SJ */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * has_legal_joinclause
 *        Detect whether the specified relation can legally be joined
 *        to any other rels using join clauses.
 *
 * We consider only joins to single other relations in the current
 * initial_rels list.  This is sufficient to get a "true" result in most real
 * queries, and an occasional erroneous "false" will only cost a bit more
 * planning time.  The reason for this limitation is that considering joins to
 * other joins would require proving that the other join rel can legally be
 * formed, which seems like too much trouble for something that's only a
 * heuristic to save planning time.  (Note: we must look at initial_rels
 * and not all of the query, since when we are planning a sub-joinlist we
 * may be forced to make clauseless joins within initial_rels even though
 * there are join clauses linking to other parts of the query.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_legal_joinclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;initial_rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* ignore rels that are already in "rel" */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>have_relevant_joinclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relids</name></type>        <name>joinrelids</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>reversed</name></decl>;</decl_stmt>

            <comment type="block">/* join_is_legal needs relids of the union */</comment>
            <expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>join_is_legal</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>sjinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reversed</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Yes, this will work */</comment>
                <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * There's a pitfall for creating parameterized nestloops: suppose the inner
 * rel (call it A) has a parameter that is a PlaceHolderVar, and that PHV's
 * minimum eval_at set includes the outer rel (B) and some third rel (C).
 * We might think we could create a B/A nestloop join that's parameterized by
 * C.  But we would end up with a plan in which the PHV's expression has to be
 * evaluated as a nestloop parameter at the B/A join; and the executor is only
 * set up to handle simple Vars as NestLoopParams.  Rather than add complexity
 * and overhead to the executor for such corner cases, it seems better to
 * forbid the join.  (Note that we can still make use of A's parameterized
 * path with pre-joined B+C as the outer rel.  have_join_order_restriction()
 * ensures that we will consider making such a join even if there are not
 * other reasons to do so.)
 *
 * So we check whether any PHVs used in the query could pose such a hazard.
 * We don't have any simple way of checking whether a risky PHV would actually
 * be used in the inner plan, and the case is so unusual that it doesn't seem
 * worth working very hard on it.
 *
 * This needs to be checked in two places.  If the inner rel's minimum
 * parameterization would trigger the restriction, then join_is_legal() should
 * reject the join altogether, because there will be no workable paths for it.
 * But joinpath.c has to check again for every proposed nestloop path, because
 * the inner path might have more than the minimum parameterization, causing
 * some PHV to be dangerous for it that otherwise wouldn't be.
 */</comment>
<function><type><name>bool</name></type>
<name>have_dangerous_phv</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                   <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>inner_params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name>inner_params</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* ignore, could not be a nestloop param */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* ignore, not relevant to this join */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* safe, it can be eval'd within outerrel */</comment>
        <comment type="block">/* Otherwise, it's potentially unsafe, so reject the join */</comment>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block>

    <comment type="block">/* OK to perform the join */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * is_dummy_rel --- has relation been proven empty?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_dummy_rel</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a relation as proven empty.
 *
 * During GEQO planning, this can get invoked more than once on the same
 * baserel struct, so it's worth checking to see if the rel is already marked
 * dummy.
 *
 * Also, when called during GEQO join planning, we are in a short-lived
 * memory context.  We must make sure that the dummy path attached to a
 * baserel survives the GEQO cycle, else the baserel is trashed for future
 * GEQO cycles.  On the other hand, when we are marking a joinrel during GEQO,
 * we don't want the dummy path to clutter the main planning context.  Upshot
 * is that the best solution is to explicitly make the dummy path in the same
 * context the given RelOptInfo is in.
 */</comment>
<function><type><name>void</name></type>
<name>mark_dummy_rel</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Already marked? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_dummy_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* No, so choose correct context to make the dummy path in */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set dummy size estimate */</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Evict any previously chosen paths */</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/* Set up the dummy path */</comment>
    <expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set or update cheapest_total_path and related fields */</comment>
    <expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * restriction_is_constant_false --- is a restrictlist just FALSE?
 *
 * In cases where a qual is provably constant FALSE, eval_const_expressions
 * will generally have thrown away anything that's ANDed with it.  In outer
 * join situations this will leave us computing cartesian products only to
 * decide there's no match for an outer row, which is pretty stupid.  So,
 * we need to detect the case.
 *
 * If only_pushed_down is TRUE, then consider only pushed-down quals.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>restriction_is_constant_false</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>only_pushed_down</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Despite the above comment, the restriction list we see here might
     * possibly have other members besides the FALSE constant, since other
     * quals could get "pushed down" to the outer join level.  So we check
     * each member of the list.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrictlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>only_pushed_down</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* constant NULL is as good as constant FALSE for our purposes */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assess whether join between given two partitioned relations can be broken
 * down into joins between matching partitions; a technique called
 * "partition-wise join"
 *
 * Partition-wise join is possible when a. Joining relations have same
 * partitioning scheme b. There exists an equi-join between the partition keys
 * of the two relations.
 *
 * Partition-wise join is planned as follows (details: optimizer/README.)
 *
 * 1. Create the RelOptInfos for joins between matching partitions i.e
 * child-joins and add paths to them.
 *
 * 2. Construct Append or MergeAppend paths across the set of child joins.
 * This second phase is implemented by generate_partition_wise_join_paths().
 *
 * The RelOptInfo, SpecialJoinInfo and restrictlist for each child join are
 * obtained by translating the respective parent join structures.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_partition_wise_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>parent_sjinfo</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt_parts</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly deep partition hierarchy. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do, if the join relation is not partitioned. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since this join relation is partitioned, all the base relations
	 * participating in this join must be partitioned and so are all the
	 * intermediate join relations.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>REL_HAS_ALL_PART_PROPS</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>REL_HAS_ALL_PART_PROPS</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The partition scheme of the join relation should match that of the
	 * joining relations.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>==</operator> <name><name>rel1</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>&amp;&amp;</operator>
		   <name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>==</operator> <name><name>rel2</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we allow partition-wise join only when the partition bounds of
	 * the joining relations exactly match, the partition bounds of the join
	 * should match those of the joining relations.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>partition_bounds_equal</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
								  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>,
								  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>,
								  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>partition_bounds_equal</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
								  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>,
								  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>,
								  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nparts</name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create child-join relations for this partitioned join, if those don't
	 * exist. Add paths to child-joins for a pair of child relations
	 * corresponding to the given pair of parent relations.
	 */</comment>
	<for>for <control>(<init><expr><name>cnt_parts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_parts</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>cnt_parts</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel1</name> <init>= <expr><name><name>rel1</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>cnt_parts</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel2</name> <init>= <expr><name><name>rel2</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>cnt_parts</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>child_sjinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_restrictlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_joinrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>child_joinrelids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>

		<comment type="block">/* We should never try to join two overlapping sets of rels. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>child_rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>child_rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>child_rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>child_rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_joinrelids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Construct SpecialJoinInfo from parent join relations's
		 * SpecialJoinInfo.
		 */</comment>
		<expr_stmt><expr><name>child_sjinfo</name> <operator>=</operator> <call><name>build_child_join_sjinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parent_sjinfo</name></expr></argument>,
											   <argument><expr><name><name>child_rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											   <argument><expr><name><name>child_rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Construct restrictions applicable to the child join from those
		 * applicable to the parent join.
		 */</comment>
		<expr_stmt><expr><name>child_restrictlist</name> <operator>=</operator>
			<operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parent_restrictlist</name></expr></argument>,
											<argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>child_joinrel</name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>cnt_parts</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>child_joinrel</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>child_joinrel</name> <operator>=</operator> <call><name>build_child_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_rel1</name></expr></argument>, <argument><expr><name>child_rel2</name></expr></argument>,
												 <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>child_restrictlist</name></expr></argument>,
												 <argument><expr><name>child_sjinfo</name></expr></argument>,
												 <argument><expr><name><name>child_sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>cnt_parts</name></expr>]</index></name> <operator>=</operator> <name>child_joinrel</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>child_joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>child_joinrelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>populate_joinrel_with_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_rel1</name></expr></argument>, <argument><expr><name>child_rel2</name></expr></argument>,
									<argument><expr><name>child_joinrel</name></expr></argument>, <argument><expr><name>child_sjinfo</name></expr></argument>,
									<argument><expr><name>child_restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if there exists an equi-join condition for each pair of
 * partition keys from given relations being joined.
 */</comment>
<function><type><name>bool</name></type>
<name>have_partkey_equi_join</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name> <init>= <expr><name><name>rel1</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt_pks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>pk_has_clause</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>strict_op</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This function should be called when the joining relations have same
	 * partitioning scheme.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>==</operator> <name><name>rel2</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>part_scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pk_has_clause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pk_has_clause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrictlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ipk1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ipk2</name></decl>;</decl_stmt>

		<comment type="block">/* If processing an outer join, only use its own join clauses. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Skip clauses which can not be used for a join. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>can_join</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Skip clauses which are not equality conditions. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>opexpr</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The equi-join between partition keys is strict if equi-join between
		 * at least one partition key is using a strict operator. See
		 * explanation about outer join reordering identity 3 in
		 * optimizer/README
		 */</comment>
		<expr_stmt><expr><name>strict_op</name> <operator>=</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Match the operands to the relation. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expr1</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr2</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expr1</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr2</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Only clauses referencing the partition keys are useful for
		 * partition-wise join.
		 */</comment>
		<expr_stmt><expr><name>ipk1</name> <operator>=</operator> <call><name>match_expr_to_partition_keys</name><argument_list>(<argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>strict_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ipk1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ipk2</name> <operator>=</operator> <call><name>match_expr_to_partition_keys</name><argument_list>(<argument><expr><name>expr2</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>strict_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ipk2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the clause refers to keys at different ordinal positions, it can
		 * not be used for partition-wise join.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ipk1</name> <operator>!=</operator> <name>ipk2</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The clause allows partition-wise join if only it uses the same
		 * operator family as that specified by the partition key.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel1</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name></expr></argument>,
								<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>ipk1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr></argument>,
							 <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>ipk1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Mark the partition key as having an equi-join clause. */</comment>
		<expr_stmt><expr><name><name>pk_has_clause</name><index>[<expr><name>ipk1</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Check whether every partition key has an equi-join condition. */</comment>
	<for>for <control>(<init><expr><name>cnt_pks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_pks</name> <operator>&lt;</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>cnt_pks</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pk_has_clause</name><index>[<expr><name>cnt_pks</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the partition key from the given relation matching the given
 * expression. If found, return the index of the partition key, else return -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>match_expr_to_partition_keys</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>strict_op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<comment type="block">/* This function should be called only for partitioned relations. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove any relabel decorations. */</comment>
	<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><call><name>castNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partexprs[cnt]</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>cnt</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strict_op</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's a strict equi-join a NULL partition key on one side will
		 * not join a NULL partition key on the other side. So, rows with NULL
		 * partition key from a partition on one side can not join with those
		 * from a non-matching partition on the other side. So, search the
		 * nullable partition keys as well.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;nullable_partexprs[cnt]</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>cnt</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
</unit>
